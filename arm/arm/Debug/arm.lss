
arm.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000040bc  00400000  00400000  00010000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  004040bc  004040bc  000140bc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     0000043c  20000000  004040c4  00020000  2**3
                  CONTENTS, ALLOC, LOAD, CODE
  3 .bss          0000011c  2000043c  00404500  0002043c  2**2
                  ALLOC
  4 .stack        00003000  20000558  0040461c  0002043c  2**0
                  ALLOC
  5 .ARM.attributes 0000002e  00000000  00000000  0002043c  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  0002046a  2**0
                  CONTENTS, READONLY
  7 .debug_info   0001638a  00000000  00000000  000204c3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00002f7f  00000000  00000000  0003684d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00006984  00000000  00000000  000397cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00000c70  00000000  00000000  00040150  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000b98  00000000  00000000  00040dc0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  0001c230  00000000  00000000  00041958  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0000fa58  00000000  00000000  0005db88  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0006b782  00000000  00000000  0006d5e0  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00003410  00000000  00000000  000d8d64  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <exception_table>:
  400000:	58 35 00 20 81 27 40 00 f1 26 40 00 f1 26 40 00     X5. .'@..&@..&@.
  400010:	f1 26 40 00 f1 26 40 00 f1 26 40 00 00 00 00 00     .&@..&@..&@.....
	...
  40002c:	f1 26 40 00 f1 26 40 00 00 00 00 00 f1 26 40 00     .&@..&@......&@.
  40003c:	f1 26 40 00 f1 26 40 00 f1 26 40 00 f1 26 40 00     .&@..&@..&@..&@.
  40004c:	f1 26 40 00 f1 26 40 00 f1 26 40 00 f1 26 40 00     .&@..&@..&@..&@.
  40005c:	f1 26 40 00 f1 26 40 00 4d 2e 40 00 65 2e 40 00     .&@..&@.M.@.e.@.
  40006c:	7d 2e 40 00 95 2e 40 00 ad 2e 40 00 f1 26 40 00     }.@...@...@..&@.
  40007c:	f1 26 40 00 f1 26 40 00 f1 26 40 00 f1 26 40 00     .&@..&@..&@..&@.
  40008c:	f1 26 40 00 f1 26 40 00 f1 26 40 00 f1 26 40 00     .&@..&@..&@..&@.
  40009c:	f1 26 40 00 f1 26 40 00 f1 26 40 00 f1 26 40 00     .&@..&@..&@..&@.
  4000ac:	f1 26 40 00 f1 26 40 00 f1 26 40 00 f1 26 40 00     .&@..&@..&@..&@.
  4000bc:	f1 26 40 00 f1 26 40 00 f1 26 40 00 f1 26 40 00     .&@..&@..&@..&@.
  4000cc:	f1 26 40 00 f1 26 40 00 f1 26 40 00 f1 26 40 00     .&@..&@..&@..&@.
  4000dc:	f1 26 40 00 f1 26 40 00 f1 26 40 00 f1 26 40 00     .&@..&@..&@..&@.
  4000ec:	f1 26 40 00 f1 26 40 00 f1 26 40 00                 .&@..&@..&@.

004000f8 <__do_global_dtors_aux>:
  4000f8:	b510      	push	{r4, lr}
  4000fa:	4c05      	ldr	r4, [pc, #20]	; (400110 <__do_global_dtors_aux+0x18>)
  4000fc:	7823      	ldrb	r3, [r4, #0]
  4000fe:	b933      	cbnz	r3, 40010e <__do_global_dtors_aux+0x16>
  400100:	4b04      	ldr	r3, [pc, #16]	; (400114 <__do_global_dtors_aux+0x1c>)
  400102:	b113      	cbz	r3, 40010a <__do_global_dtors_aux+0x12>
  400104:	4804      	ldr	r0, [pc, #16]	; (400118 <__do_global_dtors_aux+0x20>)
  400106:	f3af 8000 	nop.w
  40010a:	2301      	movs	r3, #1
  40010c:	7023      	strb	r3, [r4, #0]
  40010e:	bd10      	pop	{r4, pc}
  400110:	2000043c 	.word	0x2000043c
  400114:	00000000 	.word	0x00000000
  400118:	004040c4 	.word	0x004040c4

0040011c <frame_dummy>:
  40011c:	4b0c      	ldr	r3, [pc, #48]	; (400150 <frame_dummy+0x34>)
  40011e:	b143      	cbz	r3, 400132 <frame_dummy+0x16>
  400120:	480c      	ldr	r0, [pc, #48]	; (400154 <frame_dummy+0x38>)
  400122:	490d      	ldr	r1, [pc, #52]	; (400158 <frame_dummy+0x3c>)
  400124:	b510      	push	{r4, lr}
  400126:	f3af 8000 	nop.w
  40012a:	480c      	ldr	r0, [pc, #48]	; (40015c <frame_dummy+0x40>)
  40012c:	6803      	ldr	r3, [r0, #0]
  40012e:	b923      	cbnz	r3, 40013a <frame_dummy+0x1e>
  400130:	bd10      	pop	{r4, pc}
  400132:	480a      	ldr	r0, [pc, #40]	; (40015c <frame_dummy+0x40>)
  400134:	6803      	ldr	r3, [r0, #0]
  400136:	b933      	cbnz	r3, 400146 <frame_dummy+0x2a>
  400138:	4770      	bx	lr
  40013a:	4b09      	ldr	r3, [pc, #36]	; (400160 <frame_dummy+0x44>)
  40013c:	2b00      	cmp	r3, #0
  40013e:	d0f7      	beq.n	400130 <frame_dummy+0x14>
  400140:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  400144:	4718      	bx	r3
  400146:	4b06      	ldr	r3, [pc, #24]	; (400160 <frame_dummy+0x44>)
  400148:	2b00      	cmp	r3, #0
  40014a:	d0f5      	beq.n	400138 <frame_dummy+0x1c>
  40014c:	4718      	bx	r3
  40014e:	bf00      	nop
  400150:	00000000 	.word	0x00000000
  400154:	004040c4 	.word	0x004040c4
  400158:	20000440 	.word	0x20000440
  40015c:	004040c4 	.word	0x004040c4
  400160:	00000000 	.word	0x00000000

00400164 <osc_get_rate>:

	return 0;
}

static inline uint32_t osc_get_rate(uint32_t ul_id)
{
  400164:	b480      	push	{r7}
  400166:	b083      	sub	sp, #12
  400168:	af00      	add	r7, sp, #0
  40016a:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  40016c:	687b      	ldr	r3, [r7, #4]
  40016e:	2b07      	cmp	r3, #7
  400170:	d825      	bhi.n	4001be <osc_get_rate+0x5a>
  400172:	a201      	add	r2, pc, #4	; (adr r2, 400178 <osc_get_rate+0x14>)
  400174:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  400178:	00400199 	.word	0x00400199
  40017c:	0040019f 	.word	0x0040019f
  400180:	004001a5 	.word	0x004001a5
  400184:	004001ab 	.word	0x004001ab
  400188:	004001af 	.word	0x004001af
  40018c:	004001b3 	.word	0x004001b3
  400190:	004001b7 	.word	0x004001b7
  400194:	004001bb 	.word	0x004001bb
	case OSC_SLCK_32K_RC:
		return OSC_SLCK_32K_RC_HZ;
  400198:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  40019c:	e010      	b.n	4001c0 <osc_get_rate+0x5c>

	case OSC_SLCK_32K_XTAL:
		return BOARD_FREQ_SLCK_XTAL;
  40019e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  4001a2:	e00d      	b.n	4001c0 <osc_get_rate+0x5c>

	case OSC_SLCK_32K_BYPASS:
		return BOARD_FREQ_SLCK_BYPASS;
  4001a4:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  4001a8:	e00a      	b.n	4001c0 <osc_get_rate+0x5c>

	case OSC_MAINCK_4M_RC:
		return OSC_MAINCK_4M_RC_HZ;
  4001aa:	4b08      	ldr	r3, [pc, #32]	; (4001cc <osc_get_rate+0x68>)
  4001ac:	e008      	b.n	4001c0 <osc_get_rate+0x5c>

	case OSC_MAINCK_8M_RC:
		return OSC_MAINCK_8M_RC_HZ;
  4001ae:	4b08      	ldr	r3, [pc, #32]	; (4001d0 <osc_get_rate+0x6c>)
  4001b0:	e006      	b.n	4001c0 <osc_get_rate+0x5c>

	case OSC_MAINCK_12M_RC:
		return OSC_MAINCK_12M_RC_HZ;
  4001b2:	4b08      	ldr	r3, [pc, #32]	; (4001d4 <osc_get_rate+0x70>)
  4001b4:	e004      	b.n	4001c0 <osc_get_rate+0x5c>

	case OSC_MAINCK_XTAL:
		return BOARD_FREQ_MAINCK_XTAL;
  4001b6:	4b07      	ldr	r3, [pc, #28]	; (4001d4 <osc_get_rate+0x70>)
  4001b8:	e002      	b.n	4001c0 <osc_get_rate+0x5c>

	case OSC_MAINCK_BYPASS:
		return BOARD_FREQ_MAINCK_BYPASS;
  4001ba:	4b06      	ldr	r3, [pc, #24]	; (4001d4 <osc_get_rate+0x70>)
  4001bc:	e000      	b.n	4001c0 <osc_get_rate+0x5c>
	}

	return 0;
  4001be:	2300      	movs	r3, #0
}
  4001c0:	4618      	mov	r0, r3
  4001c2:	370c      	adds	r7, #12
  4001c4:	46bd      	mov	sp, r7
  4001c6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4001ca:	4770      	bx	lr
  4001cc:	003d0900 	.word	0x003d0900
  4001d0:	007a1200 	.word	0x007a1200
  4001d4:	00b71b00 	.word	0x00b71b00

004001d8 <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern uint32_t sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
  4001d8:	b580      	push	{r7, lr}
  4001da:	af00      	add	r7, sp, #0
	} else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_MAINCK_BYPASS) {
		return OSC_MAINCK_BYPASS_HZ;
	}
#ifdef CONFIG_PLL0_SOURCE
	else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_PLLACK) {
		return pll_get_default_rate(0);
  4001dc:	2006      	movs	r0, #6
  4001de:	4b03      	ldr	r3, [pc, #12]	; (4001ec <sysclk_get_main_hz+0x14>)
  4001e0:	4798      	blx	r3
  4001e2:	4603      	mov	r3, r0
  4001e4:	011b      	lsls	r3, r3, #4

	else {
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
  4001e6:	4618      	mov	r0, r3
  4001e8:	bd80      	pop	{r7, pc}
  4001ea:	bf00      	nop
  4001ec:	00400165 	.word	0x00400165

004001f0 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
  4001f0:	b580      	push	{r7, lr}
  4001f2:	af00      	add	r7, sp, #0
	/* CONFIG_SYSCLK_PRES is the register value for setting the expected */
	/* prescaler, not an immediate value. */
	return sysclk_get_main_hz() /
  4001f4:	4b02      	ldr	r3, [pc, #8]	; (400200 <sysclk_get_cpu_hz+0x10>)
  4001f6:	4798      	blx	r3
  4001f8:	4603      	mov	r3, r0
  4001fa:	085b      	lsrs	r3, r3, #1
		((CONFIG_SYSCLK_PRES == SYSCLK_PRES_3) ? 3 :
			(1 << (CONFIG_SYSCLK_PRES >> PMC_MCKR_PRES_Pos)));
}
  4001fc:	4618      	mov	r0, r3
  4001fe:	bd80      	pop	{r7, pc}
  400200:	004001d9 	.word	0x004001d9

00400204 <sysclk_get_peripheral_hz>:
 * \brief Retrieves the current rate in Hz of the peripheral clocks.
 *
 * \return Frequency of the peripheral clocks, in Hz.
 */
static inline uint32_t sysclk_get_peripheral_hz(void)
{
  400204:	b580      	push	{r7, lr}
  400206:	af00      	add	r7, sp, #0
	/* CONFIG_SYSCLK_PRES is the register value for setting the expected */
	/* prescaler, not an immediate value. */
	return sysclk_get_main_hz() /
  400208:	4b02      	ldr	r3, [pc, #8]	; (400214 <sysclk_get_peripheral_hz+0x10>)
  40020a:	4798      	blx	r3
  40020c:	4603      	mov	r3, r0
  40020e:	085b      	lsrs	r3, r3, #1
		((CONFIG_SYSCLK_PRES == SYSCLK_PRES_3) ? 3 :
			(1 << (CONFIG_SYSCLK_PRES >> PMC_MCKR_PRES_Pos)));
}
  400210:	4618      	mov	r0, r3
  400212:	bd80      	pop	{r7, pc}
  400214:	004001d9 	.word	0x004001d9

00400218 <sysclk_enable_peripheral_clock>:
 * \brief Enable a peripheral's clock.
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
  400218:	b580      	push	{r7, lr}
  40021a:	b082      	sub	sp, #8
  40021c:	af00      	add	r7, sp, #0
  40021e:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  400220:	6878      	ldr	r0, [r7, #4]
  400222:	4b03      	ldr	r3, [pc, #12]	; (400230 <sysclk_enable_peripheral_clock+0x18>)
  400224:	4798      	blx	r3
}
  400226:	bf00      	nop
  400228:	3708      	adds	r7, #8
  40022a:	46bd      	mov	sp, r7
  40022c:	bd80      	pop	{r7, pc}
  40022e:	bf00      	nop
  400230:	004036d5 	.word	0x004036d5

00400234 <twi_master_setup>:
typedef twi_options_t twi_master_options_t;
typedef twi_packet_t twi_package_t;

static inline uint32_t twi_master_setup(twi_master_t p_twi,
		twi_master_options_t *p_opt)
{
  400234:	b580      	push	{r7, lr}
  400236:	b082      	sub	sp, #8
  400238:	af00      	add	r7, sp, #0
  40023a:	6078      	str	r0, [r7, #4]
  40023c:	6039      	str	r1, [r7, #0]
	p_opt->master_clk = sysclk_get_peripheral_hz();
  40023e:	4b10      	ldr	r3, [pc, #64]	; (400280 <twi_master_setup+0x4c>)
  400240:	4798      	blx	r3
  400242:	4602      	mov	r2, r0
  400244:	683b      	ldr	r3, [r7, #0]
  400246:	601a      	str	r2, [r3, #0]
	p_opt->smbus      = 0;
  400248:	683b      	ldr	r3, [r7, #0]
  40024a:	2200      	movs	r2, #0
  40024c:	725a      	strb	r2, [r3, #9]
	} else {
		// Do Nothing
	}
#else
#if (!(SAMG51 || SAMG53 || SAMG54))
	if (p_twi == TWI0) {
  40024e:	687b      	ldr	r3, [r7, #4]
  400250:	4a0c      	ldr	r2, [pc, #48]	; (400284 <twi_master_setup+0x50>)
  400252:	4293      	cmp	r3, r2
  400254:	d103      	bne.n	40025e <twi_master_setup+0x2a>
		sysclk_enable_peripheral_clock(ID_TWI0);
  400256:	2011      	movs	r0, #17
  400258:	4b0b      	ldr	r3, [pc, #44]	; (400288 <twi_master_setup+0x54>)
  40025a:	4798      	blx	r3
  40025c:	e006      	b.n	40026c <twi_master_setup+0x38>
	} else
#endif
	if (p_twi == TWI1) {
  40025e:	687b      	ldr	r3, [r7, #4]
  400260:	4a0a      	ldr	r2, [pc, #40]	; (40028c <twi_master_setup+0x58>)
  400262:	4293      	cmp	r3, r2
  400264:	d102      	bne.n	40026c <twi_master_setup+0x38>
		sysclk_enable_peripheral_clock(ID_TWI1);
  400266:	2012      	movs	r0, #18
  400268:	4b07      	ldr	r3, [pc, #28]	; (400288 <twi_master_setup+0x54>)
  40026a:	4798      	blx	r3
	} else {
		// Do Nothing
	}
#endif

	return (twi_master_init(p_twi, p_opt));
  40026c:	6839      	ldr	r1, [r7, #0]
  40026e:	6878      	ldr	r0, [r7, #4]
  400270:	4b07      	ldr	r3, [pc, #28]	; (400290 <twi_master_setup+0x5c>)
  400272:	4798      	blx	r3
  400274:	4603      	mov	r3, r0
}
  400276:	4618      	mov	r0, r3
  400278:	3708      	adds	r7, #8
  40027a:	46bd      	mov	sp, r7
  40027c:	bd80      	pop	{r7, pc}
  40027e:	bf00      	nop
  400280:	00400205 	.word	0x00400205
  400284:	400a8000 	.word	0x400a8000
  400288:	00400219 	.word	0x00400219
  40028c:	400ac000 	.word	0x400ac000
  400290:	00403781 	.word	0x00403781

00400294 <bsp_hw_init>:
static void m_bsp_gpio_init(void);
static void m_bsp_sdcard_init(void);

/* Function definitions ----------------------------------------------- */
void bsp_hw_init(void)
{
  400294:	b580      	push	{r7, lr}
  400296:	af00      	add	r7, sp, #0
  m_bsp_i2c_init();
  400298:	4b03      	ldr	r3, [pc, #12]	; (4002a8 <bsp_hw_init+0x14>)
  40029a:	4798      	blx	r3
  m_bsp_gpio_init();
  40029c:	4b03      	ldr	r3, [pc, #12]	; (4002ac <bsp_hw_init+0x18>)
  40029e:	4798      	blx	r3
  m_bsp_sdcard_init();
  4002a0:	4b03      	ldr	r3, [pc, #12]	; (4002b0 <bsp_hw_init+0x1c>)
  4002a2:	4798      	blx	r3
}
  4002a4:	bf00      	nop
  4002a6:	bd80      	pop	{r7, pc}
  4002a8:	004003b1 	.word	0x004003b1
  4002ac:	004003e5 	.word	0x004003e5
  4002b0:	004003f5 	.word	0x004003f5

004002b4 <bsp_i2c_write>:

int bsp_i2c_write(uint8_t slave_addr, uint8_t reg_addr, uint8_t *p_data, uint32_t len)
{
  4002b4:	b580      	push	{r7, lr}
  4002b6:	b08a      	sub	sp, #40	; 0x28
  4002b8:	af00      	add	r7, sp, #0
  4002ba:	60ba      	str	r2, [r7, #8]
  4002bc:	607b      	str	r3, [r7, #4]
  4002be:	4603      	mov	r3, r0
  4002c0:	73fb      	strb	r3, [r7, #15]
  4002c2:	460b      	mov	r3, r1
  4002c4:	73bb      	strb	r3, [r7, #14]
  twi_package_t packet_write;

  packet_write.chip        = slave_addr;        // TWI slave bus address
  4002c6:	7bfb      	ldrb	r3, [r7, #15]
  4002c8:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
  packet_write.addr[0]     = reg_addr;          // TWI slave memory address data
  4002cc:	7bbb      	ldrb	r3, [r7, #14]
  4002ce:	753b      	strb	r3, [r7, #20]
  packet_write.addr_length = sizeof(reg_addr);  // TWI slave memory address data size
  4002d0:	2301      	movs	r3, #1
  4002d2:	61bb      	str	r3, [r7, #24]
  packet_write.buffer      = (void *)p_data;    // Transfer data source buffer
  4002d4:	68bb      	ldr	r3, [r7, #8]
  4002d6:	61fb      	str	r3, [r7, #28]
  packet_write.length      = len;               // Transfer data size (bytes)
  4002d8:	687b      	ldr	r3, [r7, #4]
  4002da:	623b      	str	r3, [r7, #32]

  return twi_master_write(TWI0, &packet_write);
  4002dc:	f107 0314 	add.w	r3, r7, #20
  4002e0:	4619      	mov	r1, r3
  4002e2:	4804      	ldr	r0, [pc, #16]	; (4002f4 <bsp_i2c_write+0x40>)
  4002e4:	4b04      	ldr	r3, [pc, #16]	; (4002f8 <bsp_i2c_write+0x44>)
  4002e6:	4798      	blx	r3
  4002e8:	4603      	mov	r3, r0
}
  4002ea:	4618      	mov	r0, r3
  4002ec:	3728      	adds	r7, #40	; 0x28
  4002ee:	46bd      	mov	sp, r7
  4002f0:	bd80      	pop	{r7, pc}
  4002f2:	bf00      	nop
  4002f4:	400a8000 	.word	0x400a8000
  4002f8:	00403935 	.word	0x00403935
  4002fc:	00000000 	.word	0x00000000

00400300 <bsp_delay>:

void bsp_delay(uint32_t ms)
{
  400300:	b5f0      	push	{r4, r5, r6, r7, lr}
  400302:	b083      	sub	sp, #12
  400304:	af00      	add	r7, sp, #0
  400306:	6078      	str	r0, [r7, #4]
  delay_ms(ms);
  400308:	687b      	ldr	r3, [r7, #4]
  40030a:	2b00      	cmp	r3, #0
  40030c:	d026      	beq.n	40035c <bsp_delay+0x5c>
  40030e:	687b      	ldr	r3, [r7, #4]
  400310:	461d      	mov	r5, r3
  400312:	f04f 0600 	mov.w	r6, #0
  400316:	4b22      	ldr	r3, [pc, #136]	; (4003a0 <bsp_delay+0xa0>)
  400318:	4798      	blx	r3
  40031a:	4603      	mov	r3, r0
  40031c:	f04f 0400 	mov.w	r4, #0
  400320:	fb03 f106 	mul.w	r1, r3, r6
  400324:	fb05 f204 	mul.w	r2, r5, r4
  400328:	440a      	add	r2, r1
  40032a:	fba5 3403 	umull	r3, r4, r5, r3
  40032e:	4422      	add	r2, r4
  400330:	4614      	mov	r4, r2
  400332:	f243 61af 	movw	r1, #13999	; 0x36af
  400336:	f04f 0200 	mov.w	r2, #0
  40033a:	185d      	adds	r5, r3, r1
  40033c:	eb44 0602 	adc.w	r6, r4, r2
  400340:	4628      	mov	r0, r5
  400342:	4631      	mov	r1, r6
  400344:	4c17      	ldr	r4, [pc, #92]	; (4003a4 <bsp_delay+0xa4>)
  400346:	f243 62b0 	movw	r2, #14000	; 0x36b0
  40034a:	f04f 0300 	mov.w	r3, #0
  40034e:	47a0      	blx	r4
  400350:	4603      	mov	r3, r0
  400352:	460c      	mov	r4, r1
  400354:	4618      	mov	r0, r3
  400356:	4b14      	ldr	r3, [pc, #80]	; (4003a8 <bsp_delay+0xa8>)
  400358:	4798      	blx	r3
}
  40035a:	e016      	b.n	40038a <bsp_delay+0x8a>
  delay_ms(ms);
  40035c:	4b10      	ldr	r3, [pc, #64]	; (4003a0 <bsp_delay+0xa0>)
  40035e:	4798      	blx	r3
  400360:	4603      	mov	r3, r0
  400362:	f04f 0400 	mov.w	r4, #0
  400366:	a20c      	add	r2, pc, #48	; (adr r2, 400398 <bsp_delay+0x98>)
  400368:	e9d2 1200 	ldrd	r1, r2, [r2]
  40036c:	185d      	adds	r5, r3, r1
  40036e:	eb44 0602 	adc.w	r6, r4, r2
  400372:	4628      	mov	r0, r5
  400374:	4631      	mov	r1, r6
  400376:	4c0b      	ldr	r4, [pc, #44]	; (4003a4 <bsp_delay+0xa4>)
  400378:	4a0c      	ldr	r2, [pc, #48]	; (4003ac <bsp_delay+0xac>)
  40037a:	f04f 0300 	mov.w	r3, #0
  40037e:	47a0      	blx	r4
  400380:	4603      	mov	r3, r0
  400382:	460c      	mov	r4, r1
  400384:	4618      	mov	r0, r3
  400386:	4b08      	ldr	r3, [pc, #32]	; (4003a8 <bsp_delay+0xa8>)
  400388:	4798      	blx	r3
}
  40038a:	bf00      	nop
  40038c:	370c      	adds	r7, #12
  40038e:	46bd      	mov	sp, r7
  400390:	bdf0      	pop	{r4, r5, r6, r7, pc}
  400392:	bf00      	nop
  400394:	f3af 8000 	nop.w
  400398:	00d59f7f 	.word	0x00d59f7f
  40039c:	00000000 	.word	0x00000000
  4003a0:	004001f1 	.word	0x004001f1
  4003a4:	00403a31 	.word	0x00403a31
  4003a8:	20000001 	.word	0x20000001
  4003ac:	00d59f80 	.word	0x00d59f80

004003b0 <m_bsp_i2c_init>:
/* Private function definitions ---------------------------------------- */
/**
 * @brief I2C init
 */
static void m_bsp_i2c_init(void)
{
  4003b0:	b580      	push	{r7, lr}
  4003b2:	b084      	sub	sp, #16
  4003b4:	af00      	add	r7, sp, #0
  twi_master_options_t opt = {
  4003b6:	1d3b      	adds	r3, r7, #4
  4003b8:	2200      	movs	r2, #0
  4003ba:	601a      	str	r2, [r3, #0]
  4003bc:	605a      	str	r2, [r3, #4]
  4003be:	609a      	str	r2, [r3, #8]
  4003c0:	4b05      	ldr	r3, [pc, #20]	; (4003d8 <m_bsp_i2c_init+0x28>)
  4003c2:	60bb      	str	r3, [r7, #8]
      .speed = 400000
  };

  twi_master_setup(TWI0, &opt);
  4003c4:	1d3b      	adds	r3, r7, #4
  4003c6:	4619      	mov	r1, r3
  4003c8:	4804      	ldr	r0, [pc, #16]	; (4003dc <m_bsp_i2c_init+0x2c>)
  4003ca:	4b05      	ldr	r3, [pc, #20]	; (4003e0 <m_bsp_i2c_init+0x30>)
  4003cc:	4798      	blx	r3
}
  4003ce:	bf00      	nop
  4003d0:	3710      	adds	r7, #16
  4003d2:	46bd      	mov	sp, r7
  4003d4:	bd80      	pop	{r7, pc}
  4003d6:	bf00      	nop
  4003d8:	00061a80 	.word	0x00061a80
  4003dc:	400a8000 	.word	0x400a8000
  4003e0:	00400235 	.word	0x00400235

004003e4 <m_bsp_gpio_init>:

/**
 * @brief Gpio init
 */
static void m_bsp_gpio_init(void)
{
  4003e4:	b480      	push	{r7}
  4003e6:	af00      	add	r7, sp, #0

}
  4003e8:	bf00      	nop
  4003ea:	46bd      	mov	sp, r7
  4003ec:	f85d 7b04 	ldr.w	r7, [sp], #4
  4003f0:	4770      	bx	lr
	...

004003f4 <m_bsp_sdcard_init>:

/**
 * @brief Gpio init
 */
static void m_bsp_sdcard_init(void)
{
  4003f4:	b580      	push	{r7, lr}
  4003f6:	b082      	sub	sp, #8
  4003f8:	af00      	add	r7, sp, #0
  Ctrl_status status;

  // Enable PIOA clock to detect Card Detect (CD) change
  sysclk_enable_peripheral_clock(ID_PIOA);
  4003fa:	2009      	movs	r0, #9
  4003fc:	4b10      	ldr	r3, [pc, #64]	; (400440 <m_bsp_sdcard_init+0x4c>)
  4003fe:	4798      	blx	r3

  // Configure SD card pins as per MCI peripheral (periph C)
  pio_set_peripheral(PIOA, PIO_PERIPH_C, PIO_PA30C_MCDA0 | // MCI Data 0
  400400:	f04f 427c 	mov.w	r2, #4227858432	; 0xfc000000
  400404:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  400408:	480e      	ldr	r0, [pc, #56]	; (400444 <m_bsp_sdcard_init+0x50>)
  40040a:	4b0f      	ldr	r3, [pc, #60]	; (400448 <m_bsp_sdcard_init+0x54>)
  40040c:	4798      	blx	r3
                                         PIO_PA27C_MCDA3 | // MCI Data 3
                                         PIO_PA28C_MCCDA | // MCI Command
                                         PIO_PA29C_MCCK);  // MCI Clock

  // Initialize SD MMC stack
  sd_mmc_init();
  40040e:	4b0f      	ldr	r3, [pc, #60]	; (40044c <m_bsp_sdcard_init+0x58>)
  400410:	4798      	blx	r3

  //  Wait until SD stack initialized and SD card inserted
  do
  {
    // Check if stack ready
    status = sd_mmc_test_unit_ready(0);
  400412:	2000      	movs	r0, #0
  400414:	4b0e      	ldr	r3, [pc, #56]	; (400450 <m_bsp_sdcard_init+0x5c>)
  400416:	4798      	blx	r3
  400418:	4603      	mov	r3, r0
  40041a:	71fb      	strb	r3, [r7, #7]
    if (status == CTRL_FAIL)
  40041c:	79fb      	ldrb	r3, [r7, #7]
  40041e:	2b01      	cmp	r3, #1
  400420:	d106      	bne.n	400430 <m_bsp_sdcard_init+0x3c>
    {
      // Wait for a card to be inserted
      while (sd_mmc_check(0) != CTRL_NO_PRESENT)
  400422:	bf00      	nop
  400424:	2000      	movs	r0, #0
  400426:	4b0b      	ldr	r3, [pc, #44]	; (400454 <m_bsp_sdcard_init+0x60>)
  400428:	4798      	blx	r3
  40042a:	4603      	mov	r3, r0
  40042c:	2b02      	cmp	r3, #2
  40042e:	d1f9      	bne.n	400424 <m_bsp_sdcard_init+0x30>
      {
        // Use a timeout here for real projects.
      }
    }
  } while (status != CTRL_GOOD);
  400430:	79fb      	ldrb	r3, [r7, #7]
  400432:	2b00      	cmp	r3, #0
  400434:	d1ed      	bne.n	400412 <m_bsp_sdcard_init+0x1e>
}
  400436:	bf00      	nop
  400438:	3708      	adds	r7, #8
  40043a:	46bd      	mov	sp, r7
  40043c:	bd80      	pop	{r7, pc}
  40043e:	bf00      	nop
  400440:	00400219 	.word	0x00400219
  400444:	400e0e00 	.word	0x400e0e00
  400448:	00403369 	.word	0x00403369
  40044c:	0040193d 	.word	0x0040193d
  400450:	00401a21 	.word	0x00401a21
  400454:	00401981 	.word	0x00401981

00400458 <osc_get_rate>:
{
  400458:	b480      	push	{r7}
  40045a:	b083      	sub	sp, #12
  40045c:	af00      	add	r7, sp, #0
  40045e:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  400460:	687b      	ldr	r3, [r7, #4]
  400462:	2b07      	cmp	r3, #7
  400464:	d825      	bhi.n	4004b2 <osc_get_rate+0x5a>
  400466:	a201      	add	r2, pc, #4	; (adr r2, 40046c <osc_get_rate+0x14>)
  400468:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40046c:	0040048d 	.word	0x0040048d
  400470:	00400493 	.word	0x00400493
  400474:	00400499 	.word	0x00400499
  400478:	0040049f 	.word	0x0040049f
  40047c:	004004a3 	.word	0x004004a3
  400480:	004004a7 	.word	0x004004a7
  400484:	004004ab 	.word	0x004004ab
  400488:	004004af 	.word	0x004004af
		return OSC_SLCK_32K_RC_HZ;
  40048c:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  400490:	e010      	b.n	4004b4 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_XTAL;
  400492:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  400496:	e00d      	b.n	4004b4 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_BYPASS;
  400498:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  40049c:	e00a      	b.n	4004b4 <osc_get_rate+0x5c>
		return OSC_MAINCK_4M_RC_HZ;
  40049e:	4b08      	ldr	r3, [pc, #32]	; (4004c0 <osc_get_rate+0x68>)
  4004a0:	e008      	b.n	4004b4 <osc_get_rate+0x5c>
		return OSC_MAINCK_8M_RC_HZ;
  4004a2:	4b08      	ldr	r3, [pc, #32]	; (4004c4 <osc_get_rate+0x6c>)
  4004a4:	e006      	b.n	4004b4 <osc_get_rate+0x5c>
		return OSC_MAINCK_12M_RC_HZ;
  4004a6:	4b08      	ldr	r3, [pc, #32]	; (4004c8 <osc_get_rate+0x70>)
  4004a8:	e004      	b.n	4004b4 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_XTAL;
  4004aa:	4b07      	ldr	r3, [pc, #28]	; (4004c8 <osc_get_rate+0x70>)
  4004ac:	e002      	b.n	4004b4 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_BYPASS;
  4004ae:	4b06      	ldr	r3, [pc, #24]	; (4004c8 <osc_get_rate+0x70>)
  4004b0:	e000      	b.n	4004b4 <osc_get_rate+0x5c>
	return 0;
  4004b2:	2300      	movs	r3, #0
}
  4004b4:	4618      	mov	r0, r3
  4004b6:	370c      	adds	r7, #12
  4004b8:	46bd      	mov	sp, r7
  4004ba:	f85d 7b04 	ldr.w	r7, [sp], #4
  4004be:	4770      	bx	lr
  4004c0:	003d0900 	.word	0x003d0900
  4004c4:	007a1200 	.word	0x007a1200
  4004c8:	00b71b00 	.word	0x00b71b00

004004cc <sysclk_get_main_hz>:
{
  4004cc:	b580      	push	{r7, lr}
  4004ce:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  4004d0:	2006      	movs	r0, #6
  4004d2:	4b03      	ldr	r3, [pc, #12]	; (4004e0 <sysclk_get_main_hz+0x14>)
  4004d4:	4798      	blx	r3
  4004d6:	4603      	mov	r3, r0
  4004d8:	011b      	lsls	r3, r3, #4
}
  4004da:	4618      	mov	r0, r3
  4004dc:	bd80      	pop	{r7, pc}
  4004de:	bf00      	nop
  4004e0:	00400459 	.word	0x00400459

004004e4 <sysclk_get_cpu_hz>:
{
  4004e4:	b580      	push	{r7, lr}
  4004e6:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  4004e8:	4b02      	ldr	r3, [pc, #8]	; (4004f4 <sysclk_get_cpu_hz+0x10>)
  4004ea:	4798      	blx	r3
  4004ec:	4603      	mov	r3, r0
  4004ee:	085b      	lsrs	r3, r3, #1
}
  4004f0:	4618      	mov	r0, r3
  4004f2:	bd80      	pop	{r7, pc}
  4004f4:	004004cd 	.word	0x004004cd

004004f8 <bsp_can_init>:
can_mb_conf_t m_can1_mailbox;

/* Private function prototypes ---------------------------------------- */
/* Function definitions ----------------------------------------------- */
void bsp_can_init(void)
{
  4004f8:	b580      	push	{r7, lr}
  4004fa:	b082      	sub	sp, #8
  4004fc:	af00      	add	r7, sp, #0
  uint32_t ul_sysclk = sysclk_get_cpu_hz();
  4004fe:	4b1b      	ldr	r3, [pc, #108]	; (40056c <bsp_can_init+0x74>)
  400500:	4798      	blx	r3
  400502:	6078      	str	r0, [r7, #4]

  pmc_enable_periph_clk(ID_CAN1);
  400504:	2026      	movs	r0, #38	; 0x26
  400506:	4b1a      	ldr	r3, [pc, #104]	; (400570 <bsp_can_init+0x78>)
  400508:	4798      	blx	r3

  can_init(CAN1, ul_sysclk, CAN_BPS_1000K);
  40050a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  40050e:	6879      	ldr	r1, [r7, #4]
  400510:	4818      	ldr	r0, [pc, #96]	; (400574 <bsp_can_init+0x7c>)
  400512:	4b19      	ldr	r3, [pc, #100]	; (400578 <bsp_can_init+0x80>)
  400514:	4798      	blx	r3
  can_reset_all_mailbox(CAN1);
  400516:	4817      	ldr	r0, [pc, #92]	; (400574 <bsp_can_init+0x7c>)
  400518:	4b18      	ldr	r3, [pc, #96]	; (40057c <bsp_can_init+0x84>)
  40051a:	4798      	blx	r3

  m_can1_mailbox.ul_mb_idx   = 0;
  40051c:	4b18      	ldr	r3, [pc, #96]	; (400580 <bsp_can_init+0x88>)
  40051e:	2200      	movs	r2, #0
  400520:	601a      	str	r2, [r3, #0]
  m_can1_mailbox.uc_obj_type = CAN_MB_TX_MODE;
  400522:	4b17      	ldr	r3, [pc, #92]	; (400580 <bsp_can_init+0x88>)
  400524:	2203      	movs	r2, #3
  400526:	711a      	strb	r2, [r3, #4]
  m_can1_mailbox.uc_tx_prio  = 15;
  400528:	4b15      	ldr	r3, [pc, #84]	; (400580 <bsp_can_init+0x88>)
  40052a:	220f      	movs	r2, #15
  40052c:	71da      	strb	r2, [r3, #7]
  m_can1_mailbox.uc_id_ver   = 0;
  40052e:	4b14      	ldr	r3, [pc, #80]	; (400580 <bsp_can_init+0x88>)
  400530:	2200      	movs	r2, #0
  400532:	715a      	strb	r2, [r3, #5]
  m_can1_mailbox.ul_id_msk   = 0;
  400534:	4b12      	ldr	r3, [pc, #72]	; (400580 <bsp_can_init+0x88>)
  400536:	2200      	movs	r2, #0
  400538:	60da      	str	r2, [r3, #12]
  can_mailbox_init(CAN1, &m_can1_mailbox);
  40053a:	4911      	ldr	r1, [pc, #68]	; (400580 <bsp_can_init+0x88>)
  40053c:	480d      	ldr	r0, [pc, #52]	; (400574 <bsp_can_init+0x7c>)
  40053e:	4b11      	ldr	r3, [pc, #68]	; (400584 <bsp_can_init+0x8c>)
  400540:	4798      	blx	r3
  
  m_can1_mailbox.ul_id     = CAN_MID_MIDvA(0x07);
  400542:	4b0f      	ldr	r3, [pc, #60]	; (400580 <bsp_can_init+0x88>)
  400544:	f44f 12e0 	mov.w	r2, #1835008	; 0x1c0000
  400548:	611a      	str	r2, [r3, #16]
  m_can1_mailbox.ul_datal  = 0x12345678;
  40054a:	4b0d      	ldr	r3, [pc, #52]	; (400580 <bsp_can_init+0x88>)
  40054c:	4a0e      	ldr	r2, [pc, #56]	; (400588 <bsp_can_init+0x90>)
  40054e:	619a      	str	r2, [r3, #24]
  m_can1_mailbox.ul_datah  = 0x87654321;
  400550:	4b0b      	ldr	r3, [pc, #44]	; (400580 <bsp_can_init+0x88>)
  400552:	4a0e      	ldr	r2, [pc, #56]	; (40058c <bsp_can_init+0x94>)
  400554:	61da      	str	r2, [r3, #28]
  m_can1_mailbox.uc_length = 8;
  400556:	4b0a      	ldr	r3, [pc, #40]	; (400580 <bsp_can_init+0x88>)
  400558:	2208      	movs	r2, #8
  40055a:	719a      	strb	r2, [r3, #6]
  can_mailbox_write(CAN1, &m_can1_mailbox);
  40055c:	4908      	ldr	r1, [pc, #32]	; (400580 <bsp_can_init+0x88>)
  40055e:	4805      	ldr	r0, [pc, #20]	; (400574 <bsp_can_init+0x7c>)
  400560:	4b0b      	ldr	r3, [pc, #44]	; (400590 <bsp_can_init+0x98>)
  400562:	4798      	blx	r3
}
  400564:	bf00      	nop
  400566:	3708      	adds	r7, #8
  400568:	46bd      	mov	sp, r7
  40056a:	bd80      	pop	{r7, pc}
  40056c:	004004e5 	.word	0x004004e5
  400570:	004036d5 	.word	0x004036d5
  400574:	40014000 	.word	0x40014000
  400578:	00403015 	.word	0x00403015
  40057c:	00403325 	.word	0x00403325
  400580:	20000500 	.word	0x20000500
  400584:	00403147 	.word	0x00403147
  400588:	12345678 	.word	0x12345678
  40058c:	87654321 	.word	0x87654321
  400590:	0040326d 	.word	0x0040326d

00400594 <bsp_can_send>:

void bsp_can_send(void)
{
  400594:	b580      	push	{r7, lr}
  400596:	af00      	add	r7, sp, #0
  can_global_send_transfer_cmd(CAN1, CAN_TCR_MB0);
  400598:	2101      	movs	r1, #1
  40059a:	4802      	ldr	r0, [pc, #8]	; (4005a4 <bsp_can_send+0x10>)
  40059c:	4b02      	ldr	r3, [pc, #8]	; (4005a8 <bsp_can_send+0x14>)
  40059e:	4798      	blx	r3
}
  4005a0:	bf00      	nop
  4005a2:	bd80      	pop	{r7, pc}
  4005a4:	40014000 	.word	0x40014000
  4005a8:	004030f5 	.word	0x004030f5

004005ac <bsp_lcd_init>:
/* Public variables --------------------------------------------------- */
/* Private variables -------------------------------------------------- */
/* Private function prototypes ---------------------------------------- */
/* Function definitions ----------------------------------------------- */
void bsp_lcd_init(void)
{
  4005ac:	b580      	push	{r7, lr}
  4005ae:	af00      	add	r7, sp, #0
  m_ssd1311.device_address = SSD1311_I2C_ADDRESS;
  4005b0:	4b06      	ldr	r3, [pc, #24]	; (4005cc <bsp_lcd_init+0x20>)
  4005b2:	223c      	movs	r2, #60	; 0x3c
  4005b4:	701a      	strb	r2, [r3, #0]
  m_ssd1311.i2c_write      = bsp_i2c_write;
  4005b6:	4b05      	ldr	r3, [pc, #20]	; (4005cc <bsp_lcd_init+0x20>)
  4005b8:	4a05      	ldr	r2, [pc, #20]	; (4005d0 <bsp_lcd_init+0x24>)
  4005ba:	605a      	str	r2, [r3, #4]
  m_ssd1311.delay          = bsp_delay;
  4005bc:	4b03      	ldr	r3, [pc, #12]	; (4005cc <bsp_lcd_init+0x20>)
  4005be:	4a05      	ldr	r2, [pc, #20]	; (4005d4 <bsp_lcd_init+0x28>)
  4005c0:	609a      	str	r2, [r3, #8]
  
  ssd1311_init(&m_ssd1311);
  4005c2:	4802      	ldr	r0, [pc, #8]	; (4005cc <bsp_lcd_init+0x20>)
  4005c4:	4b04      	ldr	r3, [pc, #16]	; (4005d8 <bsp_lcd_init+0x2c>)
  4005c6:	4798      	blx	r3
}
  4005c8:	bf00      	nop
  4005ca:	bd80      	pop	{r7, pc}
  4005cc:	20000520 	.word	0x20000520
  4005d0:	004002b5 	.word	0x004002b5
  4005d4:	00400301 	.word	0x00400301
  4005d8:	004005dd 	.word	0x004005dd

004005dc <ssd1311_init>:
/* Private function prototypes ---------------------------------------- */
static base_status_t m_ssd1311_run_cfg_script(ssd1311_t *me);

/* Function definitions ----------------------------------------------- */
base_status_t ssd1311_init(ssd1311_t *me)
{
  4005dc:	b580      	push	{r7, lr}
  4005de:	b082      	sub	sp, #8
  4005e0:	af00      	add	r7, sp, #0
  4005e2:	6078      	str	r0, [r7, #4]
  if ((me == NULL) || (me->i2c_write == NULL))
  4005e4:	687b      	ldr	r3, [r7, #4]
  4005e6:	2b00      	cmp	r3, #0
  4005e8:	d003      	beq.n	4005f2 <ssd1311_init+0x16>
  4005ea:	687b      	ldr	r3, [r7, #4]
  4005ec:	685b      	ldr	r3, [r3, #4]
  4005ee:	2b00      	cmp	r3, #0
  4005f0:	d101      	bne.n	4005f6 <ssd1311_init+0x1a>
    return BS_ERROR_PARAMS;
  4005f2:	2301      	movs	r3, #1
  4005f4:	e003      	b.n	4005fe <ssd1311_init+0x22>

  m_ssd1311_run_cfg_script(me);
  4005f6:	6878      	ldr	r0, [r7, #4]
  4005f8:	4b03      	ldr	r3, [pc, #12]	; (400608 <ssd1311_init+0x2c>)
  4005fa:	4798      	blx	r3

  return BS_OK;
  4005fc:	2300      	movs	r3, #0
}
  4005fe:	4618      	mov	r0, r3
  400600:	3708      	adds	r7, #8
  400602:	46bd      	mov	sp, r7
  400604:	bd80      	pop	{r7, pc}
  400606:	bf00      	nop
  400608:	0040066d 	.word	0x0040066d

0040060c <ssd1311_write_cmd>:

base_status_t ssd1311_write_cmd(ssd1311_t *me, uint8_t cmd)
{
  40060c:	b590      	push	{r4, r7, lr}
  40060e:	b083      	sub	sp, #12
  400610:	af00      	add	r7, sp, #0
  400612:	6078      	str	r0, [r7, #4]
  400614:	460b      	mov	r3, r1
  400616:	70fb      	strb	r3, [r7, #3]
  CHECK(BS_OK == me->i2c_write(me->device_address, SSD1311_CMD_MODE, &cmd, 1), BS_ERROR);
  400618:	687b      	ldr	r3, [r7, #4]
  40061a:	685c      	ldr	r4, [r3, #4]
  40061c:	687b      	ldr	r3, [r7, #4]
  40061e:	7818      	ldrb	r0, [r3, #0]
  400620:	1cfa      	adds	r2, r7, #3
  400622:	2301      	movs	r3, #1
  400624:	2180      	movs	r1, #128	; 0x80
  400626:	47a0      	blx	r4
  400628:	4603      	mov	r3, r0
  40062a:	2b00      	cmp	r3, #0
  40062c:	d001      	beq.n	400632 <ssd1311_write_cmd+0x26>
  40062e:	2302      	movs	r3, #2
  400630:	e000      	b.n	400634 <ssd1311_write_cmd+0x28>

  return BS_OK;
  400632:	2300      	movs	r3, #0
}
  400634:	4618      	mov	r0, r3
  400636:	370c      	adds	r7, #12
  400638:	46bd      	mov	sp, r7
  40063a:	bd90      	pop	{r4, r7, pc}

0040063c <ssd1311_write_data_byte>:

  return BS_OK;
}

base_status_t ssd1311_write_data_byte(ssd1311_t *me, uint8_t data)
{
  40063c:	b590      	push	{r4, r7, lr}
  40063e:	b083      	sub	sp, #12
  400640:	af00      	add	r7, sp, #0
  400642:	6078      	str	r0, [r7, #4]
  400644:	460b      	mov	r3, r1
  400646:	70fb      	strb	r3, [r7, #3]
  CHECK(BS_OK == me->i2c_write(me->device_address, SSD1311_DATA_MODE, &data, 1), BS_ERROR);
  400648:	687b      	ldr	r3, [r7, #4]
  40064a:	685c      	ldr	r4, [r3, #4]
  40064c:	687b      	ldr	r3, [r7, #4]
  40064e:	7818      	ldrb	r0, [r3, #0]
  400650:	1cfa      	adds	r2, r7, #3
  400652:	2301      	movs	r3, #1
  400654:	2140      	movs	r1, #64	; 0x40
  400656:	47a0      	blx	r4
  400658:	4603      	mov	r3, r0
  40065a:	2b00      	cmp	r3, #0
  40065c:	d001      	beq.n	400662 <ssd1311_write_data_byte+0x26>
  40065e:	2302      	movs	r3, #2
  400660:	e000      	b.n	400664 <ssd1311_write_data_byte+0x28>

  return BS_OK;
  400662:	2300      	movs	r3, #0
}
  400664:	4618      	mov	r0, r3
  400666:	370c      	adds	r7, #12
  400668:	46bd      	mov	sp, r7
  40066a:	bd90      	pop	{r4, r7, pc}

0040066c <m_ssd1311_run_cfg_script>:
 * @return
 * - BS_OK
 * - BS_ERROR
 */
static base_status_t m_ssd1311_run_cfg_script(ssd1311_t *me)
{
  40066c:	b580      	push	{r7, lr}
  40066e:	b084      	sub	sp, #16
  400670:	af00      	add	r7, sp, #0
  400672:	6078      	str	r0, [r7, #4]
  int i          = 0;
  400674:	2300      	movs	r3, #0
  400676:	60fb      	str	r3, [r7, #12]
  int end_script = 0;
  400678:	2300      	movs	r3, #0
  40067a:	60bb      	str	r3, [r7, #8]

  do
  {
    switch (SSD1311_CFG_SCRIPT[i].cmd)
  40067c:	4a20      	ldr	r2, [pc, #128]	; (400700 <m_ssd1311_run_cfg_script+0x94>)
  40067e:	68fb      	ldr	r3, [r7, #12]
  400680:	f812 3013 	ldrb.w	r3, [r2, r3, lsl #1]
  400684:	2b04      	cmp	r3, #4
  400686:	d82e      	bhi.n	4006e6 <m_ssd1311_run_cfg_script+0x7a>
  400688:	a201      	add	r2, pc, #4	; (adr r2, 400690 <m_ssd1311_run_cfg_script+0x24>)
  40068a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40068e:	bf00      	nop
  400690:	004006e7 	.word	0x004006e7
  400694:	004006e1 	.word	0x004006e1
  400698:	004006a5 	.word	0x004006a5
  40069c:	004006b9 	.word	0x004006b9
  4006a0:	004006cd 	.word	0x004006cd
    {
    case SSD1311_START:
      break;
    case SSD1311_CMD:
      ssd1311_write_cmd(me, SSD1311_CFG_SCRIPT[i].data & 0xFF);
  4006a4:	4a16      	ldr	r2, [pc, #88]	; (400700 <m_ssd1311_run_cfg_script+0x94>)
  4006a6:	68fb      	ldr	r3, [r7, #12]
  4006a8:	005b      	lsls	r3, r3, #1
  4006aa:	4413      	add	r3, r2
  4006ac:	785b      	ldrb	r3, [r3, #1]
  4006ae:	4619      	mov	r1, r3
  4006b0:	6878      	ldr	r0, [r7, #4]
  4006b2:	4b14      	ldr	r3, [pc, #80]	; (400704 <m_ssd1311_run_cfg_script+0x98>)
  4006b4:	4798      	blx	r3
      break;
  4006b6:	e017      	b.n	4006e8 <m_ssd1311_run_cfg_script+0x7c>
    case SSD1311_DATA:
      ssd1311_write_data_byte(me, SSD1311_CFG_SCRIPT[i].data & 0xFF);
  4006b8:	4a11      	ldr	r2, [pc, #68]	; (400700 <m_ssd1311_run_cfg_script+0x94>)
  4006ba:	68fb      	ldr	r3, [r7, #12]
  4006bc:	005b      	lsls	r3, r3, #1
  4006be:	4413      	add	r3, r2
  4006c0:	785b      	ldrb	r3, [r3, #1]
  4006c2:	4619      	mov	r1, r3
  4006c4:	6878      	ldr	r0, [r7, #4]
  4006c6:	4b10      	ldr	r3, [pc, #64]	; (400708 <m_ssd1311_run_cfg_script+0x9c>)
  4006c8:	4798      	blx	r3
      break;
  4006ca:	e00d      	b.n	4006e8 <m_ssd1311_run_cfg_script+0x7c>
    case SSD1311_DELAY:
      me->delay(SSD1311_CFG_SCRIPT[i].data);
  4006cc:	687b      	ldr	r3, [r7, #4]
  4006ce:	689a      	ldr	r2, [r3, #8]
  4006d0:	490b      	ldr	r1, [pc, #44]	; (400700 <m_ssd1311_run_cfg_script+0x94>)
  4006d2:	68fb      	ldr	r3, [r7, #12]
  4006d4:	005b      	lsls	r3, r3, #1
  4006d6:	440b      	add	r3, r1
  4006d8:	785b      	ldrb	r3, [r3, #1]
  4006da:	4618      	mov	r0, r3
  4006dc:	4790      	blx	r2
      break;
  4006de:	e003      	b.n	4006e8 <m_ssd1311_run_cfg_script+0x7c>
    case SSD1311_END:
      end_script = 1;
  4006e0:	2301      	movs	r3, #1
  4006e2:	60bb      	str	r3, [r7, #8]
      break;
  4006e4:	e000      	b.n	4006e8 <m_ssd1311_run_cfg_script+0x7c>
    default:
      break;
  4006e6:	bf00      	nop
    }
    i++;
  4006e8:	68fb      	ldr	r3, [r7, #12]
  4006ea:	3301      	adds	r3, #1
  4006ec:	60fb      	str	r3, [r7, #12]
  }
  while (!end_script);
  4006ee:	68bb      	ldr	r3, [r7, #8]
  4006f0:	2b00      	cmp	r3, #0
  4006f2:	d0c3      	beq.n	40067c <m_ssd1311_run_cfg_script+0x10>

  return BS_OK;
  4006f4:	2300      	movs	r3, #0
}
  4006f6:	4618      	mov	r0, r3
  4006f8:	3710      	adds	r7, #16
  4006fa:	46bd      	mov	sp, r7
  4006fc:	bd80      	pop	{r7, pc}
  4006fe:	bf00      	nop
  400700:	00403f4c 	.word	0x00403f4c
  400704:	0040060d 	.word	0x0040060d
  400708:	0040063d 	.word	0x0040063d

0040070c <sys_init>:
/* Private function prototypes ---------------------------------------- */
static void m_sys_sdcard_test(void);

/* Function definitions ----------------------------------------------- */
void sys_init(void)
{
  40070c:	b580      	push	{r7, lr}
  40070e:	af00      	add	r7, sp, #0
  sysclk_init();  // Initialize System Clock
  400710:	4b05      	ldr	r3, [pc, #20]	; (400728 <sys_init+0x1c>)
  400712:	4798      	blx	r3
  board_init();   // Board init
  400714:	4b05      	ldr	r3, [pc, #20]	; (40072c <sys_init+0x20>)
  400716:	4798      	blx	r3
  bsp_hw_init();  // Hardware init
  400718:	4b05      	ldr	r3, [pc, #20]	; (400730 <sys_init+0x24>)
  40071a:	4798      	blx	r3
  bsp_can_init(); // Can bus init
  40071c:	4b05      	ldr	r3, [pc, #20]	; (400734 <sys_init+0x28>)
  40071e:	4798      	blx	r3

  bsp_lcd_init();
  400720:	4b05      	ldr	r3, [pc, #20]	; (400738 <sys_init+0x2c>)
  400722:	4798      	blx	r3
}
  400724:	bf00      	nop
  400726:	bd80      	pop	{r7, pc}
  400728:	00402d09 	.word	0x00402d09
  40072c:	00401e05 	.word	0x00401e05
  400730:	00400295 	.word	0x00400295
  400734:	004004f9 	.word	0x004004f9
  400738:	004005ad 	.word	0x004005ad

0040073c <sys_run>:

void sys_run(void)
{
  40073c:	b580      	push	{r7, lr}
  40073e:	b082      	sub	sp, #8
  400740:	af00      	add	r7, sp, #0
  uint8_t data = 0x99;
  400742:	2399      	movs	r3, #153	; 0x99
  400744:	71fb      	strb	r3, [r7, #7]

  // bsp_i2c_write(0x77, 0x11, &data, 1);
  bsp_can_send();
  400746:	4b03      	ldr	r3, [pc, #12]	; (400754 <sys_run+0x18>)
  400748:	4798      	blx	r3
  // bsp_delay(1000);
}
  40074a:	bf00      	nop
  40074c:	3708      	adds	r7, #8
  40074e:	46bd      	mov	sp, r7
  400750:	bd80      	pop	{r7, pc}
  400752:	bf00      	nop
  400754:	00400595 	.word	0x00400595

00400758 <SDMMC_UNSTUFF_BITS>:
 * \brief Macro function to extract a bits field from a large SD MMC register
 * Used by : CSD, SCR, Switch status
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
  400758:	b480      	push	{r7}
  40075a:	b087      	sub	sp, #28
  40075c:	af00      	add	r7, sp, #0
  40075e:	60f8      	str	r0, [r7, #12]
  400760:	4608      	mov	r0, r1
  400762:	4611      	mov	r1, r2
  400764:	461a      	mov	r2, r3
  400766:	4603      	mov	r3, r0
  400768:	817b      	strh	r3, [r7, #10]
  40076a:	460b      	mov	r3, r1
  40076c:	813b      	strh	r3, [r7, #8]
  40076e:	4613      	mov	r3, r2
  400770:	71fb      	strb	r3, [r7, #7]
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400772:	897a      	ldrh	r2, [r7, #10]
  400774:	893b      	ldrh	r3, [r7, #8]
  400776:	1ad3      	subs	r3, r2, r3
  400778:	3307      	adds	r3, #7
  40077a:	2b00      	cmp	r3, #0
  40077c:	da00      	bge.n	400780 <SDMMC_UNSTUFF_BITS+0x28>
  40077e:	3307      	adds	r3, #7
  400780:	10db      	asrs	r3, r3, #3
  400782:	3b01      	subs	r3, #1
  400784:	68fa      	ldr	r2, [r7, #12]
  400786:	4413      	add	r3, r2
  400788:	781b      	ldrb	r3, [r3, #0]
  40078a:	461a      	mov	r2, r3
  40078c:	893b      	ldrh	r3, [r7, #8]
  40078e:	f003 0307 	and.w	r3, r3, #7
  400792:	fa42 f303 	asr.w	r3, r2, r3
  400796:	617b      	str	r3, [r7, #20]
	if (((pos % 8) + size) > 8) {
  400798:	893b      	ldrh	r3, [r7, #8]
  40079a:	f003 0207 	and.w	r2, r3, #7
  40079e:	79fb      	ldrb	r3, [r7, #7]
  4007a0:	4413      	add	r3, r2
  4007a2:	2b08      	cmp	r3, #8
  4007a4:	dd16      	ble.n	4007d4 <SDMMC_UNSTUFF_BITS+0x7c>
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  4007a6:	897a      	ldrh	r2, [r7, #10]
  4007a8:	893b      	ldrh	r3, [r7, #8]
  4007aa:	1ad3      	subs	r3, r2, r3
  4007ac:	3307      	adds	r3, #7
  4007ae:	2b00      	cmp	r3, #0
  4007b0:	da00      	bge.n	4007b4 <SDMMC_UNSTUFF_BITS+0x5c>
  4007b2:	3307      	adds	r3, #7
  4007b4:	10db      	asrs	r3, r3, #3
  4007b6:	3b02      	subs	r3, #2
  4007b8:	68fa      	ldr	r2, [r7, #12]
  4007ba:	4413      	add	r3, r2
  4007bc:	781b      	ldrb	r3, [r3, #0]
  4007be:	461a      	mov	r2, r3
  4007c0:	893b      	ldrh	r3, [r7, #8]
  4007c2:	f003 0307 	and.w	r3, r3, #7
  4007c6:	f1c3 0308 	rsb	r3, r3, #8
  4007ca:	fa02 f303 	lsl.w	r3, r2, r3
  4007ce:	697a      	ldr	r2, [r7, #20]
  4007d0:	4313      	orrs	r3, r2
  4007d2:	617b      	str	r3, [r7, #20]
	}
	if (((pos % 8) + size) > 16) {
  4007d4:	893b      	ldrh	r3, [r7, #8]
  4007d6:	f003 0207 	and.w	r2, r3, #7
  4007da:	79fb      	ldrb	r3, [r7, #7]
  4007dc:	4413      	add	r3, r2
  4007de:	2b10      	cmp	r3, #16
  4007e0:	dd16      	ble.n	400810 <SDMMC_UNSTUFF_BITS+0xb8>
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  4007e2:	897a      	ldrh	r2, [r7, #10]
  4007e4:	893b      	ldrh	r3, [r7, #8]
  4007e6:	1ad3      	subs	r3, r2, r3
  4007e8:	3307      	adds	r3, #7
  4007ea:	2b00      	cmp	r3, #0
  4007ec:	da00      	bge.n	4007f0 <SDMMC_UNSTUFF_BITS+0x98>
  4007ee:	3307      	adds	r3, #7
  4007f0:	10db      	asrs	r3, r3, #3
  4007f2:	3b03      	subs	r3, #3
  4007f4:	68fa      	ldr	r2, [r7, #12]
  4007f6:	4413      	add	r3, r2
  4007f8:	781b      	ldrb	r3, [r3, #0]
  4007fa:	461a      	mov	r2, r3
  4007fc:	893b      	ldrh	r3, [r7, #8]
  4007fe:	f003 0307 	and.w	r3, r3, #7
  400802:	f1c3 0310 	rsb	r3, r3, #16
  400806:	fa02 f303 	lsl.w	r3, r2, r3
  40080a:	697a      	ldr	r2, [r7, #20]
  40080c:	4313      	orrs	r3, r2
  40080e:	617b      	str	r3, [r7, #20]
	}
	if (((pos % 8) + size) > 16) {
  400810:	893b      	ldrh	r3, [r7, #8]
  400812:	f003 0207 	and.w	r2, r3, #7
  400816:	79fb      	ldrb	r3, [r7, #7]
  400818:	4413      	add	r3, r2
  40081a:	2b10      	cmp	r3, #16
  40081c:	dd16      	ble.n	40084c <SDMMC_UNSTUFF_BITS+0xf4>
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  40081e:	897a      	ldrh	r2, [r7, #10]
  400820:	893b      	ldrh	r3, [r7, #8]
  400822:	1ad3      	subs	r3, r2, r3
  400824:	3307      	adds	r3, #7
  400826:	2b00      	cmp	r3, #0
  400828:	da00      	bge.n	40082c <SDMMC_UNSTUFF_BITS+0xd4>
  40082a:	3307      	adds	r3, #7
  40082c:	10db      	asrs	r3, r3, #3
  40082e:	3b03      	subs	r3, #3
  400830:	68fa      	ldr	r2, [r7, #12]
  400832:	4413      	add	r3, r2
  400834:	781b      	ldrb	r3, [r3, #0]
  400836:	461a      	mov	r2, r3
  400838:	893b      	ldrh	r3, [r7, #8]
  40083a:	f003 0307 	and.w	r3, r3, #7
  40083e:	f1c3 0310 	rsb	r3, r3, #16
  400842:	fa02 f303 	lsl.w	r3, r2, r3
  400846:	697a      	ldr	r2, [r7, #20]
  400848:	4313      	orrs	r3, r2
  40084a:	617b      	str	r3, [r7, #20]
	}
	value &=  ((uint32_t)1 << size) - 1;
  40084c:	79fb      	ldrb	r3, [r7, #7]
  40084e:	2201      	movs	r2, #1
  400850:	fa02 f303 	lsl.w	r3, r2, r3
  400854:	3b01      	subs	r3, #1
  400856:	697a      	ldr	r2, [r7, #20]
  400858:	4013      	ands	r3, r2
  40085a:	617b      	str	r3, [r7, #20]
	return value;
  40085c:	697b      	ldr	r3, [r7, #20]
}
  40085e:	4618      	mov	r0, r3
  400860:	371c      	adds	r7, #28
  400862:	46bd      	mov	sp, r7
  400864:	f85d 7b04 	ldr.w	r7, [sp], #4
  400868:	4770      	bx	lr
	...

0040086c <mmc_mci_op_cond>:
 * - CMD1 reads OCR
 *
 * \return true if success, otherwise false
 */
static bool mmc_mci_op_cond(void)
{
  40086c:	b580      	push	{r7, lr}
  40086e:	b082      	sub	sp, #8
  400870:	af00      	add	r7, sp, #0
	/*
	 * Timeout 1s = 400KHz / ((6+6)*8) cylces = 4200 retry
	 * 6 = cmd byte size
	 * 6 = response byte size
	 */
	retry = 4200;
  400872:	f241 0368 	movw	r3, #4200	; 0x1068
  400876:	607b      	str	r3, [r7, #4]
	do {
		if (!driver_send_cmd(MMC_MCI_CMD1_SEND_OP_COND,
  400878:	4917      	ldr	r1, [pc, #92]	; (4008d8 <mmc_mci_op_cond+0x6c>)
  40087a:	f244 5001 	movw	r0, #17665	; 0x4501
  40087e:	4b17      	ldr	r3, [pc, #92]	; (4008dc <mmc_mci_op_cond+0x70>)
  400880:	4798      	blx	r3
  400882:	4603      	mov	r3, r0
  400884:	f083 0301 	eor.w	r3, r3, #1
  400888:	b2db      	uxtb	r3, r3
  40088a:	2b00      	cmp	r3, #0
  40088c:	d001      	beq.n	400892 <mmc_mci_op_cond+0x26>
				SD_MMC_VOLTAGE_SUPPORT | OCR_ACCESS_MODE_SECTOR)) {
			sd_mmc_debug("%s: CMD1 MCI Fail - Busy retry %d\n\r",
					__func__, (int)(4200 - retry));
			return false;
  40088e:	2300      	movs	r3, #0
  400890:	e01e      	b.n	4008d0 <mmc_mci_op_cond+0x64>
		}
		// Check busy flag
		resp = driver_get_response();
  400892:	4b13      	ldr	r3, [pc, #76]	; (4008e0 <mmc_mci_op_cond+0x74>)
  400894:	4798      	blx	r3
  400896:	6038      	str	r0, [r7, #0]
		if (resp & OCR_POWER_UP_BUSY) {
  400898:	683b      	ldr	r3, [r7, #0]
  40089a:	2b00      	cmp	r3, #0
  40089c:	da0f      	bge.n	4008be <mmc_mci_op_cond+0x52>
			// Check OCR value
			if ((resp & OCR_ACCESS_MODE_MASK)
  40089e:	683b      	ldr	r3, [r7, #0]
  4008a0:	f003 43c0 	and.w	r3, r3, #1610612736	; 0x60000000
  4008a4:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
  4008a8:	d110      	bne.n	4008cc <mmc_mci_op_cond+0x60>
					== OCR_ACCESS_MODE_SECTOR) {
				sd_mmc_card->type |= CARD_TYPE_HC;
  4008aa:	4b0e      	ldr	r3, [pc, #56]	; (4008e4 <mmc_mci_op_cond+0x78>)
  4008ac:	681b      	ldr	r3, [r3, #0]
  4008ae:	4a0d      	ldr	r2, [pc, #52]	; (4008e4 <mmc_mci_op_cond+0x78>)
  4008b0:	6812      	ldr	r2, [r2, #0]
  4008b2:	7ad2      	ldrb	r2, [r2, #11]
  4008b4:	f042 0208 	orr.w	r2, r2, #8
  4008b8:	b2d2      	uxtb	r2, r2
  4008ba:	72da      	strb	r2, [r3, #11]
			}
			break;
  4008bc:	e006      	b.n	4008cc <mmc_mci_op_cond+0x60>
		}
		if (retry-- == 0) {
  4008be:	687b      	ldr	r3, [r7, #4]
  4008c0:	1e5a      	subs	r2, r3, #1
  4008c2:	607a      	str	r2, [r7, #4]
  4008c4:	2b00      	cmp	r3, #0
  4008c6:	d1d7      	bne.n	400878 <mmc_mci_op_cond+0xc>
			sd_mmc_debug("%s: CMD1 Timeout on busy\n\r", __func__);
			return false;
  4008c8:	2300      	movs	r3, #0
  4008ca:	e001      	b.n	4008d0 <mmc_mci_op_cond+0x64>
			break;
  4008cc:	bf00      	nop
		}
	} while (1);
	return true;
  4008ce:	2301      	movs	r3, #1
}
  4008d0:	4618      	mov	r0, r3
  4008d2:	3708      	adds	r7, #8
  4008d4:	46bd      	mov	sp, r7
  4008d6:	bd80      	pop	{r7, pc}
  4008d8:	401f8000 	.word	0x401f8000
  4008dc:	00402331 	.word	0x00402331
  4008e0:	00402375 	.word	0x00402375
  4008e4:	2000047c 	.word	0x2000047c

004008e8 <sd_mci_op_cond>:
 * \param v2   Shall be 1 if it is a SD card V2
 *
 * \return true if success, otherwise false
 */
static bool sd_mci_op_cond(uint8_t v2)
{
  4008e8:	b580      	push	{r7, lr}
  4008ea:	b086      	sub	sp, #24
  4008ec:	af00      	add	r7, sp, #0
  4008ee:	4603      	mov	r3, r0
  4008f0:	71fb      	strb	r3, [r7, #7]
	 * 6 = cmd byte size
	 * 6 = response byte size
	 * 6 = cmd byte size
	 * 6 = response byte size
	 */
	retry = 2100;
  4008f2:	f640 0334 	movw	r3, #2100	; 0x834
  4008f6:	613b      	str	r3, [r7, #16]
	do {
		// CMD55 - Indicate to the card that the next command is an
		// application specific command rather than a standard command.
		if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, 0)) {
  4008f8:	2100      	movs	r1, #0
  4008fa:	f241 1037 	movw	r0, #4407	; 0x1137
  4008fe:	4b21      	ldr	r3, [pc, #132]	; (400984 <sd_mci_op_cond+0x9c>)
  400900:	4798      	blx	r3
  400902:	4603      	mov	r3, r0
  400904:	f083 0301 	eor.w	r3, r3, #1
  400908:	b2db      	uxtb	r3, r3
  40090a:	2b00      	cmp	r3, #0
  40090c:	d001      	beq.n	400912 <sd_mci_op_cond+0x2a>
			sd_mmc_debug("%s: CMD55 Fail\n\r", __func__);
			return false;
  40090e:	2300      	movs	r3, #0
  400910:	e034      	b.n	40097c <sd_mci_op_cond+0x94>
		}

		// (ACMD41) Sends host OCR register
		arg = SD_MMC_VOLTAGE_SUPPORT;
  400912:	f44f 13fc 	mov.w	r3, #2064384	; 0x1f8000
  400916:	617b      	str	r3, [r7, #20]
		if (v2) {
  400918:	79fb      	ldrb	r3, [r7, #7]
  40091a:	2b00      	cmp	r3, #0
  40091c:	d003      	beq.n	400926 <sd_mci_op_cond+0x3e>
			arg |= SD_ACMD41_HCS;
  40091e:	697b      	ldr	r3, [r7, #20]
  400920:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
  400924:	617b      	str	r3, [r7, #20]
		}
		// Check response
		if (!driver_send_cmd(SD_MCI_ACMD41_SD_SEND_OP_COND, arg)) {
  400926:	6979      	ldr	r1, [r7, #20]
  400928:	f244 5029 	movw	r0, #17705	; 0x4529
  40092c:	4b15      	ldr	r3, [pc, #84]	; (400984 <sd_mci_op_cond+0x9c>)
  40092e:	4798      	blx	r3
  400930:	4603      	mov	r3, r0
  400932:	f083 0301 	eor.w	r3, r3, #1
  400936:	b2db      	uxtb	r3, r3
  400938:	2b00      	cmp	r3, #0
  40093a:	d001      	beq.n	400940 <sd_mci_op_cond+0x58>
			sd_mmc_debug("%s: ACMD41 Fail\n\r", __func__);
			return false;
  40093c:	2300      	movs	r3, #0
  40093e:	e01d      	b.n	40097c <sd_mci_op_cond+0x94>
		}
		resp = driver_get_response();
  400940:	4b11      	ldr	r3, [pc, #68]	; (400988 <sd_mci_op_cond+0xa0>)
  400942:	4798      	blx	r3
  400944:	60f8      	str	r0, [r7, #12]
		if (resp & OCR_POWER_UP_BUSY) {
  400946:	68fb      	ldr	r3, [r7, #12]
  400948:	2b00      	cmp	r3, #0
  40094a:	da0e      	bge.n	40096a <sd_mci_op_cond+0x82>
			// Card is ready
			if ((resp & OCR_CCS) != 0) {
  40094c:	68fb      	ldr	r3, [r7, #12]
  40094e:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
  400952:	2b00      	cmp	r3, #0
  400954:	d010      	beq.n	400978 <sd_mci_op_cond+0x90>
				sd_mmc_card->type |= CARD_TYPE_HC;
  400956:	4b0d      	ldr	r3, [pc, #52]	; (40098c <sd_mci_op_cond+0xa4>)
  400958:	681b      	ldr	r3, [r3, #0]
  40095a:	4a0c      	ldr	r2, [pc, #48]	; (40098c <sd_mci_op_cond+0xa4>)
  40095c:	6812      	ldr	r2, [r2, #0]
  40095e:	7ad2      	ldrb	r2, [r2, #11]
  400960:	f042 0208 	orr.w	r2, r2, #8
  400964:	b2d2      	uxtb	r2, r2
  400966:	72da      	strb	r2, [r3, #11]
			}
			break;
  400968:	e006      	b.n	400978 <sd_mci_op_cond+0x90>
		}
		if (retry-- == 0) {
  40096a:	693b      	ldr	r3, [r7, #16]
  40096c:	1e5a      	subs	r2, r3, #1
  40096e:	613a      	str	r2, [r7, #16]
  400970:	2b00      	cmp	r3, #0
  400972:	d1c1      	bne.n	4008f8 <sd_mci_op_cond+0x10>
			sd_mmc_debug("%s: ACMD41 Timeout on busy, resp32 0x%08x \n\r",
					__func__, resp);
			return false;
  400974:	2300      	movs	r3, #0
  400976:	e001      	b.n	40097c <sd_mci_op_cond+0x94>
			break;
  400978:	bf00      	nop
		}
	} while (1);
	return true;
  40097a:	2301      	movs	r3, #1
}
  40097c:	4618      	mov	r0, r3
  40097e:	3718      	adds	r7, #24
  400980:	46bd      	mov	sp, r7
  400982:	bd80      	pop	{r7, pc}
  400984:	00402331 	.word	0x00402331
  400988:	00402375 	.word	0x00402375
  40098c:	2000047c 	.word	0x2000047c

00400990 <sdio_op_cond>:
 *   sd_mmc_card->type is updated
 *
 * \return true if success, otherwise false
 */
static bool sdio_op_cond(void)
{
  400990:	b580      	push	{r7, lr}
  400992:	b082      	sub	sp, #8
  400994:	af00      	add	r7, sp, #0
	uint32_t resp;

	// CMD5 - SDIO send operation condition (OCR) command.
	if (!driver_send_cmd(SDIO_CMD5_SEND_OP_COND, 0)) {
  400996:	2100      	movs	r1, #0
  400998:	f244 5005 	movw	r0, #17669	; 0x4505
  40099c:	4b23      	ldr	r3, [pc, #140]	; (400a2c <sdio_op_cond+0x9c>)
  40099e:	4798      	blx	r3
  4009a0:	4603      	mov	r3, r0
  4009a2:	f083 0301 	eor.w	r3, r3, #1
  4009a6:	b2db      	uxtb	r3, r3
  4009a8:	2b00      	cmp	r3, #0
  4009aa:	d001      	beq.n	4009b0 <sdio_op_cond+0x20>
		sd_mmc_debug("%s: CMD5 Fail\n\r", __func__);
		return true; // No error but card type not updated
  4009ac:	2301      	movs	r3, #1
  4009ae:	e039      	b.n	400a24 <sdio_op_cond+0x94>
	}
	resp = driver_get_response();
  4009b0:	4b1f      	ldr	r3, [pc, #124]	; (400a30 <sdio_op_cond+0xa0>)
  4009b2:	4798      	blx	r3
  4009b4:	6078      	str	r0, [r7, #4]
	if ((resp & OCR_SDIO_NF) == 0) {
  4009b6:	687b      	ldr	r3, [r7, #4]
  4009b8:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
  4009bc:	2b00      	cmp	r3, #0
  4009be:	d101      	bne.n	4009c4 <sdio_op_cond+0x34>
		return true; // No error but card type not updated
  4009c0:	2301      	movs	r3, #1
  4009c2:	e02f      	b.n	400a24 <sdio_op_cond+0x94>
	 * Wait card ready
	 * Timeout 1s = 400KHz / ((6+4)*8) cylces = 5000 retry
	 * 6 = cmd byte size
	 * 4(SPI) 6(MCI) = response byte size
	 */
	uint32_t cmd5_retry = 5000;
  4009c4:	f241 3388 	movw	r3, #5000	; 0x1388
  4009c8:	603b      	str	r3, [r7, #0]
	while (1) {
		// CMD5 - SDIO send operation condition (OCR) command.
		if (!driver_send_cmd(SDIO_CMD5_SEND_OP_COND,
  4009ca:	687b      	ldr	r3, [r7, #4]
  4009cc:	f403 13fc 	and.w	r3, r3, #2064384	; 0x1f8000
  4009d0:	4619      	mov	r1, r3
  4009d2:	f244 5005 	movw	r0, #17669	; 0x4505
  4009d6:	4b15      	ldr	r3, [pc, #84]	; (400a2c <sdio_op_cond+0x9c>)
  4009d8:	4798      	blx	r3
  4009da:	4603      	mov	r3, r0
  4009dc:	f083 0301 	eor.w	r3, r3, #1
  4009e0:	b2db      	uxtb	r3, r3
  4009e2:	2b00      	cmp	r3, #0
  4009e4:	d001      	beq.n	4009ea <sdio_op_cond+0x5a>
				resp & SD_MMC_VOLTAGE_SUPPORT)) {
			sd_mmc_debug("%s: CMD5 Fail\n\r", __func__);
			return false;
  4009e6:	2300      	movs	r3, #0
  4009e8:	e01c      	b.n	400a24 <sdio_op_cond+0x94>
		}
		resp = driver_get_response();
  4009ea:	4b11      	ldr	r3, [pc, #68]	; (400a30 <sdio_op_cond+0xa0>)
  4009ec:	4798      	blx	r3
  4009ee:	6078      	str	r0, [r7, #4]
		if ((resp & OCR_POWER_UP_BUSY) == OCR_POWER_UP_BUSY) {
  4009f0:	687b      	ldr	r3, [r7, #4]
  4009f2:	2b00      	cmp	r3, #0
  4009f4:	db06      	blt.n	400a04 <sdio_op_cond+0x74>
			break;
		}
		if (cmd5_retry-- == 0) {
  4009f6:	683b      	ldr	r3, [r7, #0]
  4009f8:	1e5a      	subs	r2, r3, #1
  4009fa:	603a      	str	r2, [r7, #0]
  4009fc:	2b00      	cmp	r3, #0
  4009fe:	d1e4      	bne.n	4009ca <sdio_op_cond+0x3a>
			sd_mmc_debug("%s: CMD5 Timeout on busy\n\r", __func__);
			return false;
  400a00:	2300      	movs	r3, #0
  400a02:	e00f      	b.n	400a24 <sdio_op_cond+0x94>
			break;
  400a04:	bf00      	nop
		}
	}
	// Update card type at the end of busy
	if ((resp & OCR_SDIO_MP) > 0) {
  400a06:	687b      	ldr	r3, [r7, #4]
  400a08:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
  400a0c:	2b00      	cmp	r3, #0
  400a0e:	d004      	beq.n	400a1a <sdio_op_cond+0x8a>
		sd_mmc_card->type = CARD_TYPE_SD_COMBO;
  400a10:	4b08      	ldr	r3, [pc, #32]	; (400a34 <sdio_op_cond+0xa4>)
  400a12:	681b      	ldr	r3, [r3, #0]
  400a14:	2205      	movs	r2, #5
  400a16:	72da      	strb	r2, [r3, #11]
  400a18:	e003      	b.n	400a22 <sdio_op_cond+0x92>
	} else {
		sd_mmc_card->type = CARD_TYPE_SDIO;
  400a1a:	4b06      	ldr	r3, [pc, #24]	; (400a34 <sdio_op_cond+0xa4>)
  400a1c:	681b      	ldr	r3, [r3, #0]
  400a1e:	2204      	movs	r2, #4
  400a20:	72da      	strb	r2, [r3, #11]
	}
	return true; // No error and card type updated with SDIO type
  400a22:	2301      	movs	r3, #1
}
  400a24:	4618      	mov	r0, r3
  400a26:	3708      	adds	r7, #8
  400a28:	46bd      	mov	sp, r7
  400a2a:	bd80      	pop	{r7, pc}
  400a2c:	00402331 	.word	0x00402331
  400a30:	00402375 	.word	0x00402375
  400a34:	2000047c 	.word	0x2000047c

00400a38 <sdio_get_max_speed>:
 *   and update sd_mmc_card->clock
 *
 * \return true if success, otherwise false
 */
static bool sdio_get_max_speed(void)
{
  400a38:	b590      	push	{r4, r7, lr}
  400a3a:	b08b      	sub	sp, #44	; 0x2c
  400a3c:	af02      	add	r7, sp, #8
	uint32_t mul;
	uint8_t tplfe_max_tran_speed, i;
	uint8_t addr_cis[4];

	/* Read CIS area address in CCCR area */
	addr_old = SDIO_CCCR_CIS_PTR;
  400a3e:	2309      	movs	r3, #9
  400a40:	61bb      	str	r3, [r7, #24]
	for(i = 0; i < 4; i++) {
  400a42:	2300      	movs	r3, #0
  400a44:	75bb      	strb	r3, [r7, #22]
  400a46:	e00f      	b.n	400a68 <sdio_get_max_speed+0x30>
		sdio_cmd52(SDIO_CMD52_READ_FLAG, SDIO_CIA, addr_old, 0, &addr_cis[i]);
  400a48:	7dbb      	ldrb	r3, [r7, #22]
  400a4a:	463a      	mov	r2, r7
  400a4c:	4413      	add	r3, r2
  400a4e:	9300      	str	r3, [sp, #0]
  400a50:	2300      	movs	r3, #0
  400a52:	69ba      	ldr	r2, [r7, #24]
  400a54:	2100      	movs	r1, #0
  400a56:	2000      	movs	r0, #0
  400a58:	4c46      	ldr	r4, [pc, #280]	; (400b74 <sdio_get_max_speed+0x13c>)
  400a5a:	47a0      	blx	r4
		addr_old++;
  400a5c:	69bb      	ldr	r3, [r7, #24]
  400a5e:	3301      	adds	r3, #1
  400a60:	61bb      	str	r3, [r7, #24]
	for(i = 0; i < 4; i++) {
  400a62:	7dbb      	ldrb	r3, [r7, #22]
  400a64:	3301      	adds	r3, #1
  400a66:	75bb      	strb	r3, [r7, #22]
  400a68:	7dbb      	ldrb	r3, [r7, #22]
  400a6a:	2b03      	cmp	r3, #3
  400a6c:	d9ec      	bls.n	400a48 <sdio_get_max_speed+0x10>
	}
	addr_old = addr_cis[0] + (addr_cis[1] << 8) + \
  400a6e:	783b      	ldrb	r3, [r7, #0]
  400a70:	461a      	mov	r2, r3
  400a72:	787b      	ldrb	r3, [r7, #1]
  400a74:	021b      	lsls	r3, r3, #8
  400a76:	441a      	add	r2, r3
				(addr_cis[2] << 16) + (addr_cis[3] << 24);
  400a78:	78bb      	ldrb	r3, [r7, #2]
  400a7a:	041b      	lsls	r3, r3, #16
	addr_old = addr_cis[0] + (addr_cis[1] << 8) + \
  400a7c:	441a      	add	r2, r3
				(addr_cis[2] << 16) + (addr_cis[3] << 24);
  400a7e:	78fb      	ldrb	r3, [r7, #3]
  400a80:	061b      	lsls	r3, r3, #24
  400a82:	4413      	add	r3, r2
	addr_old = addr_cis[0] + (addr_cis[1] << 8) + \
  400a84:	61bb      	str	r3, [r7, #24]
	addr_new = addr_old;
  400a86:	69bb      	ldr	r3, [r7, #24]
  400a88:	61fb      	str	r3, [r7, #28]

	while (1) {
		/* Read a sample of CIA area */
		for(i=0; i<3; i++) {
  400a8a:	2300      	movs	r3, #0
  400a8c:	75bb      	strb	r3, [r7, #22]
  400a8e:	e00f      	b.n	400ab0 <sdio_get_max_speed+0x78>
			sdio_cmd52(SDIO_CMD52_READ_FLAG, SDIO_CIA, addr_new, 0, &buf[i]);
  400a90:	7dbb      	ldrb	r3, [r7, #22]
  400a92:	1d3a      	adds	r2, r7, #4
  400a94:	4413      	add	r3, r2
  400a96:	9300      	str	r3, [sp, #0]
  400a98:	2300      	movs	r3, #0
  400a9a:	69fa      	ldr	r2, [r7, #28]
  400a9c:	2100      	movs	r1, #0
  400a9e:	2000      	movs	r0, #0
  400aa0:	4c34      	ldr	r4, [pc, #208]	; (400b74 <sdio_get_max_speed+0x13c>)
  400aa2:	47a0      	blx	r4
			addr_new++;
  400aa4:	69fb      	ldr	r3, [r7, #28]
  400aa6:	3301      	adds	r3, #1
  400aa8:	61fb      	str	r3, [r7, #28]
		for(i=0; i<3; i++) {
  400aaa:	7dbb      	ldrb	r3, [r7, #22]
  400aac:	3301      	adds	r3, #1
  400aae:	75bb      	strb	r3, [r7, #22]
  400ab0:	7dbb      	ldrb	r3, [r7, #22]
  400ab2:	2b02      	cmp	r3, #2
  400ab4:	d9ec      	bls.n	400a90 <sdio_get_max_speed+0x58>
		}
		if (buf[0] == SDIO_CISTPL_END) {
  400ab6:	793b      	ldrb	r3, [r7, #4]
  400ab8:	2bff      	cmp	r3, #255	; 0xff
  400aba:	d101      	bne.n	400ac0 <sdio_get_max_speed+0x88>
			return false; /* Tuple error */
  400abc:	2300      	movs	r3, #0
  400abe:	e055      	b.n	400b6c <sdio_get_max_speed+0x134>
		}
		if (buf[0] == SDIO_CISTPL_FUNCE && buf[2] == 0x00) {
  400ac0:	793b      	ldrb	r3, [r7, #4]
  400ac2:	2b22      	cmp	r3, #34	; 0x22
  400ac4:	d102      	bne.n	400acc <sdio_get_max_speed+0x94>
  400ac6:	79bb      	ldrb	r3, [r7, #6]
  400ac8:	2b00      	cmp	r3, #0
  400aca:	d012      	beq.n	400af2 <sdio_get_max_speed+0xba>
			break; /* Fun0 tuple found */
		}
		if (buf[1] == 0) {
  400acc:	797b      	ldrb	r3, [r7, #5]
  400ace:	2b00      	cmp	r3, #0
  400ad0:	d101      	bne.n	400ad6 <sdio_get_max_speed+0x9e>
			return false; /* Tuple error */
  400ad2:	2300      	movs	r3, #0
  400ad4:	e04a      	b.n	400b6c <sdio_get_max_speed+0x134>
		}
		/* Next address */
		addr_new += buf[1]-1;
  400ad6:	797b      	ldrb	r3, [r7, #5]
  400ad8:	461a      	mov	r2, r3
  400ada:	69fb      	ldr	r3, [r7, #28]
  400adc:	4413      	add	r3, r2
  400ade:	3b01      	subs	r3, #1
  400ae0:	61fb      	str	r3, [r7, #28]
		if (addr_new > (addr_old + 256)) {
  400ae2:	69bb      	ldr	r3, [r7, #24]
  400ae4:	f503 7280 	add.w	r2, r3, #256	; 0x100
  400ae8:	69fb      	ldr	r3, [r7, #28]
  400aea:	429a      	cmp	r2, r3
  400aec:	d2cd      	bcs.n	400a8a <sdio_get_max_speed+0x52>
			return false; /* Outoff CIS area */
  400aee:	2300      	movs	r3, #0
  400af0:	e03c      	b.n	400b6c <sdio_get_max_speed+0x134>
			break; /* Fun0 tuple found */
  400af2:	bf00      	nop
		}
	}

	/* Read all Fun0 tuple fields: fn0_blk_siz & max_tran_speed */
	addr_new -= 3;
  400af4:	69fb      	ldr	r3, [r7, #28]
  400af6:	3b03      	subs	r3, #3
  400af8:	61fb      	str	r3, [r7, #28]
	for(i = 0; i < 6; i++) {
  400afa:	2300      	movs	r3, #0
  400afc:	75bb      	strb	r3, [r7, #22]
  400afe:	e00f      	b.n	400b20 <sdio_get_max_speed+0xe8>
		sdio_cmd52(SDIO_CMD52_READ_FLAG, SDIO_CIA, addr_new, 0, &buf[i]);
  400b00:	7dbb      	ldrb	r3, [r7, #22]
  400b02:	1d3a      	adds	r2, r7, #4
  400b04:	4413      	add	r3, r2
  400b06:	9300      	str	r3, [sp, #0]
  400b08:	2300      	movs	r3, #0
  400b0a:	69fa      	ldr	r2, [r7, #28]
  400b0c:	2100      	movs	r1, #0
  400b0e:	2000      	movs	r0, #0
  400b10:	4c18      	ldr	r4, [pc, #96]	; (400b74 <sdio_get_max_speed+0x13c>)
  400b12:	47a0      	blx	r4
		addr_new++;
  400b14:	69fb      	ldr	r3, [r7, #28]
  400b16:	3301      	adds	r3, #1
  400b18:	61fb      	str	r3, [r7, #28]
	for(i = 0; i < 6; i++) {
  400b1a:	7dbb      	ldrb	r3, [r7, #22]
  400b1c:	3301      	adds	r3, #1
  400b1e:	75bb      	strb	r3, [r7, #22]
  400b20:	7dbb      	ldrb	r3, [r7, #22]
  400b22:	2b05      	cmp	r3, #5
  400b24:	d9ec      	bls.n	400b00 <sdio_get_max_speed+0xc8>
	}

	tplfe_max_tran_speed = buf[5];
  400b26:	7a7b      	ldrb	r3, [r7, #9]
  400b28:	75fb      	strb	r3, [r7, #23]
	if (tplfe_max_tran_speed > 0x32) {
  400b2a:	7dfb      	ldrb	r3, [r7, #23]
  400b2c:	2b32      	cmp	r3, #50	; 0x32
  400b2e:	d901      	bls.n	400b34 <sdio_get_max_speed+0xfc>
		/* Error on SDIO register, the high speed is not activated
		 * and the clock can not be more than 25MHz.
		 * This error is present on specific SDIO card
		 * (H&D wireless card - HDG104 WiFi SIP).
		 */
		tplfe_max_tran_speed = 0x32; /* 25Mhz */
  400b30:	2332      	movs	r3, #50	; 0x32
  400b32:	75fb      	strb	r3, [r7, #23]
	}

	/* Decode transfer speed in Hz.*/
	unit = sd_mmc_trans_units[tplfe_max_tran_speed & 0x7];
  400b34:	7dfb      	ldrb	r3, [r7, #23]
  400b36:	f003 0307 	and.w	r3, r3, #7
  400b3a:	4a0f      	ldr	r2, [pc, #60]	; (400b78 <sdio_get_max_speed+0x140>)
  400b3c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  400b40:	613b      	str	r3, [r7, #16]
	mul = sd_trans_multipliers[(tplfe_max_tran_speed >> 3) & 0xF];
  400b42:	7dfb      	ldrb	r3, [r7, #23]
  400b44:	08db      	lsrs	r3, r3, #3
  400b46:	b2db      	uxtb	r3, r3
  400b48:	f003 030f 	and.w	r3, r3, #15
  400b4c:	4a0b      	ldr	r2, [pc, #44]	; (400b7c <sdio_get_max_speed+0x144>)
  400b4e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  400b52:	60fb      	str	r3, [r7, #12]
	sd_mmc_card->clock = unit * mul * 1000;
  400b54:	4b0a      	ldr	r3, [pc, #40]	; (400b80 <sdio_get_max_speed+0x148>)
  400b56:	681b      	ldr	r3, [r3, #0]
  400b58:	693a      	ldr	r2, [r7, #16]
  400b5a:	68f9      	ldr	r1, [r7, #12]
  400b5c:	fb01 f202 	mul.w	r2, r1, r2
  400b60:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  400b64:	fb01 f202 	mul.w	r2, r1, r2
  400b68:	601a      	str	r2, [r3, #0]
	 * which supports upto 25MHz.
	 * A SDIO card alone can be:
	 * - a Low-Speed SDIO card which supports 400Khz minimum
	 * - a Full-Speed SDIO card which supports upto 25MHz
	 */
	return true;
  400b6a:	2301      	movs	r3, #1
}
  400b6c:	4618      	mov	r0, r3
  400b6e:	3724      	adds	r7, #36	; 0x24
  400b70:	46bd      	mov	sp, r7
  400b72:	bd90      	pop	{r4, r7, pc}
  400b74:	00401209 	.word	0x00401209
  400b78:	00403f8c 	.word	0x00403f8c
  400b7c:	00403fa8 	.word	0x00403fa8
  400b80:	2000047c 	.word	0x2000047c

00400b84 <sdio_cmd52_set_bus_width>:
 * \note sd_mmc_card->bus_width is updated.
 *
 * \return true if success, otherwise false
 */
static bool sdio_cmd52_set_bus_width(void)
{
  400b84:	b590      	push	{r4, r7, lr}
  400b86:	b085      	sub	sp, #20
  400b88:	af02      	add	r7, sp, #8
	 * A SDIO Low-Speed alone can supports 4bit (Optional)
	 */
	uint8_t u8_value;

	// Check 4bit support in 4BLS of "Card Capability" register
	if (!sdio_cmd52(SDIO_CMD52_READ_FLAG, SDIO_CIA, SDIO_CCCR_CAP,
  400b8a:	1dfb      	adds	r3, r7, #7
  400b8c:	9300      	str	r3, [sp, #0]
  400b8e:	2300      	movs	r3, #0
  400b90:	2208      	movs	r2, #8
  400b92:	2100      	movs	r1, #0
  400b94:	2000      	movs	r0, #0
  400b96:	4c15      	ldr	r4, [pc, #84]	; (400bec <sdio_cmd52_set_bus_width+0x68>)
  400b98:	47a0      	blx	r4
  400b9a:	4603      	mov	r3, r0
  400b9c:	f083 0301 	eor.w	r3, r3, #1
  400ba0:	b2db      	uxtb	r3, r3
  400ba2:	2b00      	cmp	r3, #0
  400ba4:	d001      	beq.n	400baa <sdio_cmd52_set_bus_width+0x26>
			0, &u8_value)) {
		return false;
  400ba6:	2300      	movs	r3, #0
  400ba8:	e01c      	b.n	400be4 <sdio_cmd52_set_bus_width+0x60>
	}
	if ((u8_value & SDIO_CAP_4BLS) != SDIO_CAP_4BLS) {
  400baa:	79fb      	ldrb	r3, [r7, #7]
  400bac:	b25b      	sxtb	r3, r3
  400bae:	2b00      	cmp	r3, #0
  400bb0:	db01      	blt.n	400bb6 <sdio_cmd52_set_bus_width+0x32>
		// No supported, it is not a protocol error
		return true;
  400bb2:	2301      	movs	r3, #1
  400bb4:	e016      	b.n	400be4 <sdio_cmd52_set_bus_width+0x60>
	}
	// HS mode possible, then enable
	u8_value = SDIO_BUSWIDTH_4B;
  400bb6:	2302      	movs	r3, #2
  400bb8:	71fb      	strb	r3, [r7, #7]
	if (!sdio_cmd52(SDIO_CMD52_WRITE_FLAG, SDIO_CIA, SDIO_CCCR_BUS_CTRL,
  400bba:	1dfb      	adds	r3, r7, #7
  400bbc:	9300      	str	r3, [sp, #0]
  400bbe:	2301      	movs	r3, #1
  400bc0:	2207      	movs	r2, #7
  400bc2:	2100      	movs	r1, #0
  400bc4:	2001      	movs	r0, #1
  400bc6:	4c09      	ldr	r4, [pc, #36]	; (400bec <sdio_cmd52_set_bus_width+0x68>)
  400bc8:	47a0      	blx	r4
  400bca:	4603      	mov	r3, r0
  400bcc:	f083 0301 	eor.w	r3, r3, #1
  400bd0:	b2db      	uxtb	r3, r3
  400bd2:	2b00      	cmp	r3, #0
  400bd4:	d001      	beq.n	400bda <sdio_cmd52_set_bus_width+0x56>
			1, &u8_value)) {
		return false;
  400bd6:	2300      	movs	r3, #0
  400bd8:	e004      	b.n	400be4 <sdio_cmd52_set_bus_width+0x60>
	}
	sd_mmc_card->bus_width = 4;
  400bda:	4b05      	ldr	r3, [pc, #20]	; (400bf0 <sdio_cmd52_set_bus_width+0x6c>)
  400bdc:	681b      	ldr	r3, [r3, #0]
  400bde:	2204      	movs	r2, #4
  400be0:	735a      	strb	r2, [r3, #13]
	sd_mmc_debug("%d-bit bus width enabled.\n\r", (int)sd_mmc_card->bus_width);
	return true;
  400be2:	2301      	movs	r3, #1
}
  400be4:	4618      	mov	r0, r3
  400be6:	370c      	adds	r7, #12
  400be8:	46bd      	mov	sp, r7
  400bea:	bd90      	pop	{r4, r7, pc}
  400bec:	00401209 	.word	0x00401209
  400bf0:	2000047c 	.word	0x2000047c

00400bf4 <sdio_cmd52_set_high_speed>:
 * \note sd_mmc_card->clock is updated.
 *
 * \return true if success, otherwise false
 */
static bool sdio_cmd52_set_high_speed(void)
{
  400bf4:	b590      	push	{r4, r7, lr}
  400bf6:	b085      	sub	sp, #20
  400bf8:	af02      	add	r7, sp, #8
	uint8_t u8_value;

	// Check CIA.HS
	if (!sdio_cmd52(SDIO_CMD52_READ_FLAG, SDIO_CIA, SDIO_CCCR_HS, 0, &u8_value)) {
  400bfa:	1dfb      	adds	r3, r7, #7
  400bfc:	9300      	str	r3, [sp, #0]
  400bfe:	2300      	movs	r3, #0
  400c00:	2213      	movs	r2, #19
  400c02:	2100      	movs	r1, #0
  400c04:	2000      	movs	r0, #0
  400c06:	4c19      	ldr	r4, [pc, #100]	; (400c6c <sdio_cmd52_set_high_speed+0x78>)
  400c08:	47a0      	blx	r4
  400c0a:	4603      	mov	r3, r0
  400c0c:	f083 0301 	eor.w	r3, r3, #1
  400c10:	b2db      	uxtb	r3, r3
  400c12:	2b00      	cmp	r3, #0
  400c14:	d001      	beq.n	400c1a <sdio_cmd52_set_high_speed+0x26>
		return false;
  400c16:	2300      	movs	r3, #0
  400c18:	e024      	b.n	400c64 <sdio_cmd52_set_high_speed+0x70>
	}
	if ((u8_value & SDIO_SHS) != SDIO_SHS) {
  400c1a:	79fb      	ldrb	r3, [r7, #7]
  400c1c:	f003 0301 	and.w	r3, r3, #1
  400c20:	2b00      	cmp	r3, #0
  400c22:	d101      	bne.n	400c28 <sdio_cmd52_set_high_speed+0x34>
		// No supported, it is not a protocol error
		return true;
  400c24:	2301      	movs	r3, #1
  400c26:	e01d      	b.n	400c64 <sdio_cmd52_set_high_speed+0x70>
	}
	// HS mode possible, then enable
	u8_value = SDIO_EHS;
  400c28:	2302      	movs	r3, #2
  400c2a:	71fb      	strb	r3, [r7, #7]
	if (!sdio_cmd52(SDIO_CMD52_WRITE_FLAG, SDIO_CIA, SDIO_CCCR_HS,
  400c2c:	1dfb      	adds	r3, r7, #7
  400c2e:	9300      	str	r3, [sp, #0]
  400c30:	2301      	movs	r3, #1
  400c32:	2213      	movs	r2, #19
  400c34:	2100      	movs	r1, #0
  400c36:	2001      	movs	r0, #1
  400c38:	4c0c      	ldr	r4, [pc, #48]	; (400c6c <sdio_cmd52_set_high_speed+0x78>)
  400c3a:	47a0      	blx	r4
  400c3c:	4603      	mov	r3, r0
  400c3e:	f083 0301 	eor.w	r3, r3, #1
  400c42:	b2db      	uxtb	r3, r3
  400c44:	2b00      	cmp	r3, #0
  400c46:	d001      	beq.n	400c4c <sdio_cmd52_set_high_speed+0x58>
			1, &u8_value)) {
		return false;
  400c48:	2300      	movs	r3, #0
  400c4a:	e00b      	b.n	400c64 <sdio_cmd52_set_high_speed+0x70>
	}
	sd_mmc_card->high_speed = 1;
  400c4c:	4b08      	ldr	r3, [pc, #32]	; (400c70 <sdio_cmd52_set_high_speed+0x7c>)
  400c4e:	681b      	ldr	r3, [r3, #0]
  400c50:	2201      	movs	r2, #1
  400c52:	779a      	strb	r2, [r3, #30]
	sd_mmc_card->clock *= 2;
  400c54:	4b06      	ldr	r3, [pc, #24]	; (400c70 <sdio_cmd52_set_high_speed+0x7c>)
  400c56:	681b      	ldr	r3, [r3, #0]
  400c58:	4a05      	ldr	r2, [pc, #20]	; (400c70 <sdio_cmd52_set_high_speed+0x7c>)
  400c5a:	6812      	ldr	r2, [r2, #0]
  400c5c:	6812      	ldr	r2, [r2, #0]
  400c5e:	0052      	lsls	r2, r2, #1
  400c60:	601a      	str	r2, [r3, #0]
	return true;
  400c62:	2301      	movs	r3, #1
}
  400c64:	4618      	mov	r0, r3
  400c66:	370c      	adds	r7, #12
  400c68:	46bd      	mov	sp, r7
  400c6a:	bd90      	pop	{r4, r7, pc}
  400c6c:	00401209 	.word	0x00401209
  400c70:	2000047c 	.word	0x2000047c

00400c74 <sd_cm6_set_high_speed>:
 * \note sd_mmc_card->clock is updated.
 *
 * \return true if success, otherwise false
 */
static bool sd_cm6_set_high_speed(void)
{
  400c74:	b590      	push	{r4, r7, lr}
  400c76:	b093      	sub	sp, #76	; 0x4c
  400c78:	af02      	add	r7, sp, #8
	uint8_t switch_status[SD_SW_STATUS_BSIZE] = {0};
  400c7a:	463b      	mov	r3, r7
  400c7c:	2240      	movs	r2, #64	; 0x40
  400c7e:	2100      	movs	r1, #0
  400c80:	4618      	mov	r0, r3
  400c82:	4b2f      	ldr	r3, [pc, #188]	; (400d40 <sd_cm6_set_high_speed+0xcc>)
  400c84:	4798      	blx	r3

	if (!driver_adtc_start(SD_CMD6_SWITCH_FUNC,
  400c86:	2301      	movs	r3, #1
  400c88:	9300      	str	r3, [sp, #0]
  400c8a:	2301      	movs	r3, #1
  400c8c:	2240      	movs	r2, #64	; 0x40
  400c8e:	492d      	ldr	r1, [pc, #180]	; (400d44 <sd_cm6_set_high_speed+0xd0>)
  400c90:	482d      	ldr	r0, [pc, #180]	; (400d48 <sd_cm6_set_high_speed+0xd4>)
  400c92:	4c2e      	ldr	r4, [pc, #184]	; (400d4c <sd_cm6_set_high_speed+0xd8>)
  400c94:	47a0      	blx	r4
  400c96:	4603      	mov	r3, r0
  400c98:	f083 0301 	eor.w	r3, r3, #1
  400c9c:	b2db      	uxtb	r3, r3
  400c9e:	2b00      	cmp	r3, #0
  400ca0:	d001      	beq.n	400ca6 <sd_cm6_set_high_speed+0x32>
			| SD_CMD6_GRP4_NO_INFLUENCE
			| SD_CMD6_GRP3_NO_INFLUENCE
			| SD_CMD6_GRP2_DEFAULT
			| SD_CMD6_GRP1_HIGH_SPEED,
			SD_SW_STATUS_BSIZE, 1, true)) {
		return false;
  400ca2:	2300      	movs	r3, #0
  400ca4:	e047      	b.n	400d36 <sd_cm6_set_high_speed+0xc2>
	}
	if (!driver_start_read_blocks(switch_status, 1)) {
  400ca6:	463b      	mov	r3, r7
  400ca8:	2101      	movs	r1, #1
  400caa:	4618      	mov	r0, r3
  400cac:	4b28      	ldr	r3, [pc, #160]	; (400d50 <sd_cm6_set_high_speed+0xdc>)
  400cae:	4798      	blx	r3
  400cb0:	4603      	mov	r3, r0
  400cb2:	f083 0301 	eor.w	r3, r3, #1
  400cb6:	b2db      	uxtb	r3, r3
  400cb8:	2b00      	cmp	r3, #0
  400cba:	d001      	beq.n	400cc0 <sd_cm6_set_high_speed+0x4c>
		return false;
  400cbc:	2300      	movs	r3, #0
  400cbe:	e03a      	b.n	400d36 <sd_cm6_set_high_speed+0xc2>
	}
	if (!driver_wait_end_of_read_blocks()) {
  400cc0:	4b24      	ldr	r3, [pc, #144]	; (400d54 <sd_cm6_set_high_speed+0xe0>)
  400cc2:	4798      	blx	r3
  400cc4:	4603      	mov	r3, r0
  400cc6:	f083 0301 	eor.w	r3, r3, #1
  400cca:	b2db      	uxtb	r3, r3
  400ccc:	2b00      	cmp	r3, #0
  400cce:	d001      	beq.n	400cd4 <sd_cm6_set_high_speed+0x60>
		return false;
  400cd0:	2300      	movs	r3, #0
  400cd2:	e030      	b.n	400d36 <sd_cm6_set_high_speed+0xc2>
	}

	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  400cd4:	4b20      	ldr	r3, [pc, #128]	; (400d58 <sd_cm6_set_high_speed+0xe4>)
  400cd6:	4798      	blx	r3
  400cd8:	4603      	mov	r3, r0
  400cda:	f003 0380 	and.w	r3, r3, #128	; 0x80
  400cde:	2b00      	cmp	r3, #0
  400ce0:	d001      	beq.n	400ce6 <sd_cm6_set_high_speed+0x72>
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
  400ce2:	2300      	movs	r3, #0
  400ce4:	e027      	b.n	400d36 <sd_cm6_set_high_speed+0xc2>
	}
	if (SD_SW_STATUS_FUN_GRP1_RC(switch_status)
  400ce6:	4638      	mov	r0, r7
  400ce8:	2304      	movs	r3, #4
  400cea:	f44f 72bc 	mov.w	r2, #376	; 0x178
  400cee:	f44f 7100 	mov.w	r1, #512	; 0x200
  400cf2:	4c1a      	ldr	r4, [pc, #104]	; (400d5c <sd_cm6_set_high_speed+0xe8>)
  400cf4:	47a0      	blx	r4
  400cf6:	4603      	mov	r3, r0
  400cf8:	2b0f      	cmp	r3, #15
  400cfa:	d101      	bne.n	400d00 <sd_cm6_set_high_speed+0x8c>
			== SD_SW_STATUS_FUN_GRP_RC_ERROR) {
		// No supported, it is not a protocol error
		return true;
  400cfc:	2301      	movs	r3, #1
  400cfe:	e01a      	b.n	400d36 <sd_cm6_set_high_speed+0xc2>
	}
	if (SD_SW_STATUS_FUN_GRP1_BUSY(switch_status)) {
  400d00:	4638      	mov	r0, r7
  400d02:	2310      	movs	r3, #16
  400d04:	f44f 7288 	mov.w	r2, #272	; 0x110
  400d08:	f44f 7100 	mov.w	r1, #512	; 0x200
  400d0c:	4c13      	ldr	r4, [pc, #76]	; (400d5c <sd_cm6_set_high_speed+0xe8>)
  400d0e:	47a0      	blx	r4
  400d10:	4603      	mov	r3, r0
  400d12:	2b00      	cmp	r3, #0
  400d14:	d001      	beq.n	400d1a <sd_cm6_set_high_speed+0xa6>
		sd_mmc_debug("%s: CMD6 SD_SW_STATUS_FUN_GRP1_BUSY\n\r", __func__);
		return false;
  400d16:	2300      	movs	r3, #0
  400d18:	e00d      	b.n	400d36 <sd_cm6_set_high_speed+0xc2>
	}
	// CMD6 function switching period is within 8 clocks
	// after the end bit of status data.
	driver_send_clock();
  400d1a:	4b11      	ldr	r3, [pc, #68]	; (400d60 <sd_cm6_set_high_speed+0xec>)
  400d1c:	4798      	blx	r3
	sd_mmc_card->high_speed = 1;
  400d1e:	4b11      	ldr	r3, [pc, #68]	; (400d64 <sd_cm6_set_high_speed+0xf0>)
  400d20:	681b      	ldr	r3, [r3, #0]
  400d22:	2201      	movs	r2, #1
  400d24:	779a      	strb	r2, [r3, #30]
	sd_mmc_card->clock *= 2;
  400d26:	4b0f      	ldr	r3, [pc, #60]	; (400d64 <sd_cm6_set_high_speed+0xf0>)
  400d28:	681b      	ldr	r3, [r3, #0]
  400d2a:	4a0e      	ldr	r2, [pc, #56]	; (400d64 <sd_cm6_set_high_speed+0xf0>)
  400d2c:	6812      	ldr	r2, [r2, #0]
  400d2e:	6812      	ldr	r2, [r2, #0]
  400d30:	0052      	lsls	r2, r2, #1
  400d32:	601a      	str	r2, [r3, #0]
	return true;
  400d34:	2301      	movs	r3, #1
}
  400d36:	4618      	mov	r0, r3
  400d38:	3744      	adds	r7, #68	; 0x44
  400d3a:	46bd      	mov	sp, r7
  400d3c:	bd90      	pop	{r4, r7, pc}
  400d3e:	bf00      	nop
  400d40:	00403d91 	.word	0x00403d91
  400d44:	80ffff01 	.word	0x80ffff01
  400d48:	00081106 	.word	0x00081106
  400d4c:	004023fd 	.word	0x004023fd
  400d50:	004025c1 	.word	0x004025c1
  400d54:	00402661 	.word	0x00402661
  400d58:	00402375 	.word	0x00402375
  400d5c:	00400759 	.word	0x00400759
  400d60:	004022f5 	.word	0x004022f5
  400d64:	2000047c 	.word	0x2000047c

00400d68 <mmc_cmd6_set_bus_width>:
 * \param bus_width   Bus width to set
 *
 * \return true if success, otherwise false
 */
static bool mmc_cmd6_set_bus_width(uint8_t bus_width)
{
  400d68:	b580      	push	{r7, lr}
  400d6a:	b084      	sub	sp, #16
  400d6c:	af00      	add	r7, sp, #0
  400d6e:	4603      	mov	r3, r0
  400d70:	71fb      	strb	r3, [r7, #7]
	uint32_t arg;

	switch (bus_width) {
  400d72:	79fb      	ldrb	r3, [r7, #7]
  400d74:	2b04      	cmp	r3, #4
  400d76:	d004      	beq.n	400d82 <mmc_cmd6_set_bus_width+0x1a>
  400d78:	2b08      	cmp	r3, #8
  400d7a:	d105      	bne.n	400d88 <mmc_cmd6_set_bus_width+0x20>
	case 8:
		arg = MMC_CMD6_ACCESS_SET_BITS
  400d7c:	4b13      	ldr	r3, [pc, #76]	; (400dcc <mmc_cmd6_set_bus_width+0x64>)
  400d7e:	60fb      	str	r3, [r7, #12]
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_8BIT;
		break;
  400d80:	e005      	b.n	400d8e <mmc_cmd6_set_bus_width+0x26>
	case 4:
		arg = MMC_CMD6_ACCESS_SET_BITS
  400d82:	4b13      	ldr	r3, [pc, #76]	; (400dd0 <mmc_cmd6_set_bus_width+0x68>)
  400d84:	60fb      	str	r3, [r7, #12]
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_4BIT;
		break;
  400d86:	e002      	b.n	400d8e <mmc_cmd6_set_bus_width+0x26>
	default:
		arg = MMC_CMD6_ACCESS_SET_BITS
  400d88:	4b12      	ldr	r3, [pc, #72]	; (400dd4 <mmc_cmd6_set_bus_width+0x6c>)
  400d8a:	60fb      	str	r3, [r7, #12]
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_1BIT;
		break;
  400d8c:	bf00      	nop
	}
	if (!driver_send_cmd(MMC_CMD6_SWITCH, arg)) {
  400d8e:	68f9      	ldr	r1, [r7, #12]
  400d90:	f243 1006 	movw	r0, #12550	; 0x3106
  400d94:	4b10      	ldr	r3, [pc, #64]	; (400dd8 <mmc_cmd6_set_bus_width+0x70>)
  400d96:	4798      	blx	r3
  400d98:	4603      	mov	r3, r0
  400d9a:	f083 0301 	eor.w	r3, r3, #1
  400d9e:	b2db      	uxtb	r3, r3
  400da0:	2b00      	cmp	r3, #0
  400da2:	d001      	beq.n	400da8 <mmc_cmd6_set_bus_width+0x40>
		return false;
  400da4:	2300      	movs	r3, #0
  400da6:	e00d      	b.n	400dc4 <mmc_cmd6_set_bus_width+0x5c>
	}
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  400da8:	4b0c      	ldr	r3, [pc, #48]	; (400ddc <mmc_cmd6_set_bus_width+0x74>)
  400daa:	4798      	blx	r3
  400dac:	4603      	mov	r3, r0
  400dae:	f003 0380 	and.w	r3, r3, #128	; 0x80
  400db2:	2b00      	cmp	r3, #0
  400db4:	d001      	beq.n	400dba <mmc_cmd6_set_bus_width+0x52>
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
  400db6:	2300      	movs	r3, #0
  400db8:	e004      	b.n	400dc4 <mmc_cmd6_set_bus_width+0x5c>
	}
	sd_mmc_card->bus_width = bus_width;
  400dba:	4b09      	ldr	r3, [pc, #36]	; (400de0 <mmc_cmd6_set_bus_width+0x78>)
  400dbc:	681b      	ldr	r3, [r3, #0]
  400dbe:	79fa      	ldrb	r2, [r7, #7]
  400dc0:	735a      	strb	r2, [r3, #13]
	sd_mmc_debug("%d-bit bus width enabled.\n\r", (int)sd_mmc_card->bus_width);
	return true;
  400dc2:	2301      	movs	r3, #1
}
  400dc4:	4618      	mov	r0, r3
  400dc6:	3710      	adds	r7, #16
  400dc8:	46bd      	mov	sp, r7
  400dca:	bd80      	pop	{r7, pc}
  400dcc:	01b70200 	.word	0x01b70200
  400dd0:	01b70100 	.word	0x01b70100
  400dd4:	01b70000 	.word	0x01b70000
  400dd8:	00402331 	.word	0x00402331
  400ddc:	00402375 	.word	0x00402375
  400de0:	2000047c 	.word	0x2000047c

00400de4 <mmc_cmd6_set_high_speed>:
 * \note sd_mmc_card->clock is updated.
 *
 * \return true if success, otherwise false
 */
static bool mmc_cmd6_set_high_speed(void)
{
  400de4:	b580      	push	{r7, lr}
  400de6:	af00      	add	r7, sp, #0
	if (!driver_send_cmd(MMC_CMD6_SWITCH,
  400de8:	4910      	ldr	r1, [pc, #64]	; (400e2c <mmc_cmd6_set_high_speed+0x48>)
  400dea:	f243 1006 	movw	r0, #12550	; 0x3106
  400dee:	4b10      	ldr	r3, [pc, #64]	; (400e30 <mmc_cmd6_set_high_speed+0x4c>)
  400df0:	4798      	blx	r3
  400df2:	4603      	mov	r3, r0
  400df4:	f083 0301 	eor.w	r3, r3, #1
  400df8:	b2db      	uxtb	r3, r3
  400dfa:	2b00      	cmp	r3, #0
  400dfc:	d001      	beq.n	400e02 <mmc_cmd6_set_high_speed+0x1e>
			MMC_CMD6_ACCESS_WRITE_BYTE
			| MMC_CMD6_INDEX_HS_TIMING
			| MMC_CMD6_VALUE_HS_TIMING_ENABLE)) {
		return false;
  400dfe:	2300      	movs	r3, #0
  400e00:	e011      	b.n	400e26 <mmc_cmd6_set_high_speed+0x42>
	}
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  400e02:	4b0c      	ldr	r3, [pc, #48]	; (400e34 <mmc_cmd6_set_high_speed+0x50>)
  400e04:	4798      	blx	r3
  400e06:	4603      	mov	r3, r0
  400e08:	f003 0380 	and.w	r3, r3, #128	; 0x80
  400e0c:	2b00      	cmp	r3, #0
  400e0e:	d001      	beq.n	400e14 <mmc_cmd6_set_high_speed+0x30>
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
  400e10:	2300      	movs	r3, #0
  400e12:	e008      	b.n	400e26 <mmc_cmd6_set_high_speed+0x42>
	}
	sd_mmc_card->high_speed = 1;
  400e14:	4b08      	ldr	r3, [pc, #32]	; (400e38 <mmc_cmd6_set_high_speed+0x54>)
  400e16:	681b      	ldr	r3, [r3, #0]
  400e18:	2201      	movs	r2, #1
  400e1a:	779a      	strb	r2, [r3, #30]
	sd_mmc_card->clock = 52000000lu;
  400e1c:	4b06      	ldr	r3, [pc, #24]	; (400e38 <mmc_cmd6_set_high_speed+0x54>)
  400e1e:	681b      	ldr	r3, [r3, #0]
  400e20:	4a06      	ldr	r2, [pc, #24]	; (400e3c <mmc_cmd6_set_high_speed+0x58>)
  400e22:	601a      	str	r2, [r3, #0]
	return true;
  400e24:	2301      	movs	r3, #1
}
  400e26:	4618      	mov	r0, r3
  400e28:	bd80      	pop	{r7, pc}
  400e2a:	bf00      	nop
  400e2c:	03b90100 	.word	0x03b90100
  400e30:	00402331 	.word	0x00402331
  400e34:	00402375 	.word	0x00402375
  400e38:	2000047c 	.word	0x2000047c
  400e3c:	03197500 	.word	0x03197500

00400e40 <sd_cmd8>:
 *
 * \return true if success, otherwise false
 *         with a update of \ref sd_mmc_err.
 */
static bool sd_cmd8(uint8_t * v2)
{
  400e40:	b580      	push	{r7, lr}
  400e42:	b084      	sub	sp, #16
  400e44:	af00      	add	r7, sp, #0
  400e46:	6078      	str	r0, [r7, #4]
	uint32_t resp;

	*v2 = 0;
  400e48:	687b      	ldr	r3, [r7, #4]
  400e4a:	2200      	movs	r2, #0
  400e4c:	701a      	strb	r2, [r3, #0]
	// Test for SD version 2
	if (!driver_send_cmd(SD_CMD8_SEND_IF_COND,
  400e4e:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
  400e52:	f245 5008 	movw	r0, #21768	; 0x5508
  400e56:	4b11      	ldr	r3, [pc, #68]	; (400e9c <sd_cmd8+0x5c>)
  400e58:	4798      	blx	r3
  400e5a:	4603      	mov	r3, r0
  400e5c:	f083 0301 	eor.w	r3, r3, #1
  400e60:	b2db      	uxtb	r3, r3
  400e62:	2b00      	cmp	r3, #0
  400e64:	d001      	beq.n	400e6a <sd_cmd8+0x2a>
			SD_CMD8_PATTERN | SD_CMD8_HIGH_VOLTAGE)) {
		return true; // It is not a V2
  400e66:	2301      	movs	r3, #1
  400e68:	e014      	b.n	400e94 <sd_cmd8+0x54>
	}
	// Check R7 response
	resp = driver_get_response();
  400e6a:	4b0d      	ldr	r3, [pc, #52]	; (400ea0 <sd_cmd8+0x60>)
  400e6c:	4798      	blx	r3
  400e6e:	60f8      	str	r0, [r7, #12]
	if (resp == 0xFFFFFFFF) {
  400e70:	68fb      	ldr	r3, [r7, #12]
  400e72:	f1b3 3fff 	cmp.w	r3, #4294967295
  400e76:	d101      	bne.n	400e7c <sd_cmd8+0x3c>
		// No compliance R7 value
		return true; // It is not a V2
  400e78:	2301      	movs	r3, #1
  400e7a:	e00b      	b.n	400e94 <sd_cmd8+0x54>
	}
	if ((resp & (SD_CMD8_MASK_PATTERN | SD_CMD8_MASK_VOLTAGE))
  400e7c:	68fb      	ldr	r3, [r7, #12]
  400e7e:	f3c3 030b 	ubfx	r3, r3, #0, #12
  400e82:	f5b3 7fd5 	cmp.w	r3, #426	; 0x1aa
  400e86:	d001      	beq.n	400e8c <sd_cmd8+0x4c>
				!= (SD_CMD8_PATTERN | SD_CMD8_HIGH_VOLTAGE)) {
		sd_mmc_debug("%s: CMD8 resp32 0x%08x UNUSABLE CARD\n\r",
				__func__, resp);
		return false;
  400e88:	2300      	movs	r3, #0
  400e8a:	e003      	b.n	400e94 <sd_cmd8+0x54>
	}
	sd_mmc_debug("SD card V2\n\r");
	*v2 = 1;
  400e8c:	687b      	ldr	r3, [r7, #4]
  400e8e:	2201      	movs	r2, #1
  400e90:	701a      	strb	r2, [r3, #0]
	return true;
  400e92:	2301      	movs	r3, #1
}
  400e94:	4618      	mov	r0, r3
  400e96:	3710      	adds	r7, #16
  400e98:	46bd      	mov	sp, r7
  400e9a:	bd80      	pop	{r7, pc}
  400e9c:	00402331 	.word	0x00402331
  400ea0:	00402375 	.word	0x00402375

00400ea4 <mmc_cmd8>:
 * support information
 *
 * \return true if success, otherwise false
 */
static bool mmc_cmd8(uint8_t *b_authorize_high_speed)
{
  400ea4:	b590      	push	{r4, r7, lr}
  400ea6:	b089      	sub	sp, #36	; 0x24
  400ea8:	af02      	add	r7, sp, #8
  400eaa:	6078      	str	r0, [r7, #4]
	uint16_t i;
	uint32_t ext_csd;
	uint32_t sec_count;

	if (!driver_adtc_start(MMC_CMD8_SEND_EXT_CSD, 0,
  400eac:	2300      	movs	r3, #0
  400eae:	9300      	str	r3, [sp, #0]
  400eb0:	2301      	movs	r3, #1
  400eb2:	f44f 7200 	mov.w	r2, #512	; 0x200
  400eb6:	2100      	movs	r1, #0
  400eb8:	4833      	ldr	r0, [pc, #204]	; (400f88 <mmc_cmd8+0xe4>)
  400eba:	4c34      	ldr	r4, [pc, #208]	; (400f8c <mmc_cmd8+0xe8>)
  400ebc:	47a0      	blx	r4
  400ebe:	4603      	mov	r3, r0
  400ec0:	f083 0301 	eor.w	r3, r3, #1
  400ec4:	b2db      	uxtb	r3, r3
  400ec6:	2b00      	cmp	r3, #0
  400ec8:	d001      	beq.n	400ece <mmc_cmd8+0x2a>
			EXT_CSD_BSIZE, 1, false)) {
		return false;
  400eca:	2300      	movs	r3, #0
  400ecc:	e058      	b.n	400f80 <mmc_cmd8+0xdc>
	//** Read and decode Extended Extended CSD
	// Note: The read access is done in byte to avoid a buffer
	// of EXT_CSD_BSIZE Byte in stack.

	// Read card type
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
  400ece:	2300      	movs	r3, #0
  400ed0:	82fb      	strh	r3, [r7, #22]
  400ed2:	e00f      	b.n	400ef4 <mmc_cmd8+0x50>
		if (!driver_read_word(&ext_csd)) {
  400ed4:	f107 0310 	add.w	r3, r7, #16
  400ed8:	4618      	mov	r0, r3
  400eda:	4b2d      	ldr	r3, [pc, #180]	; (400f90 <mmc_cmd8+0xec>)
  400edc:	4798      	blx	r3
  400ede:	4603      	mov	r3, r0
  400ee0:	f083 0301 	eor.w	r3, r3, #1
  400ee4:	b2db      	uxtb	r3, r3
  400ee6:	2b00      	cmp	r3, #0
  400ee8:	d001      	beq.n	400eee <mmc_cmd8+0x4a>
			return false;
  400eea:	2300      	movs	r3, #0
  400eec:	e048      	b.n	400f80 <mmc_cmd8+0xdc>
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
  400eee:	8afb      	ldrh	r3, [r7, #22]
  400ef0:	3301      	adds	r3, #1
  400ef2:	82fb      	strh	r3, [r7, #22]
  400ef4:	8afb      	ldrh	r3, [r7, #22]
  400ef6:	2b31      	cmp	r3, #49	; 0x31
  400ef8:	d9ec      	bls.n	400ed4 <mmc_cmd8+0x30>
		}
	}
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
			& MMC_CTYPE_52MHZ;
  400efa:	693b      	ldr	r3, [r7, #16]
  400efc:	b2db      	uxtb	r3, r3
  400efe:	f003 0302 	and.w	r3, r3, #2
  400f02:	b2da      	uxtb	r2, r3
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
  400f04:	687b      	ldr	r3, [r7, #4]
  400f06:	701a      	strb	r2, [r3, #0]

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
  400f08:	4b22      	ldr	r3, [pc, #136]	; (400f94 <mmc_cmd8+0xf0>)
  400f0a:	681b      	ldr	r3, [r3, #0]
  400f0c:	f103 000e 	add.w	r0, r3, #14
  400f10:	230c      	movs	r3, #12
  400f12:	223e      	movs	r2, #62	; 0x3e
  400f14:	2180      	movs	r1, #128	; 0x80
  400f16:	4c20      	ldr	r4, [pc, #128]	; (400f98 <mmc_cmd8+0xf4>)
  400f18:	47a0      	blx	r4
  400f1a:	4602      	mov	r2, r0
  400f1c:	f640 73ff 	movw	r3, #4095	; 0xfff
  400f20:	429a      	cmp	r2, r3
  400f22:	d129      	bne.n	400f78 <mmc_cmd8+0xd4>
		// For high capacity SD/MMC card,
		// memory capacity = SEC_COUNT * 512 byte
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
  400f24:	e00f      	b.n	400f46 <mmc_cmd8+0xa2>
			if (!driver_read_word(&sec_count)) {
  400f26:	f107 030c 	add.w	r3, r7, #12
  400f2a:	4618      	mov	r0, r3
  400f2c:	4b18      	ldr	r3, [pc, #96]	; (400f90 <mmc_cmd8+0xec>)
  400f2e:	4798      	blx	r3
  400f30:	4603      	mov	r3, r0
  400f32:	f083 0301 	eor.w	r3, r3, #1
  400f36:	b2db      	uxtb	r3, r3
  400f38:	2b00      	cmp	r3, #0
  400f3a:	d001      	beq.n	400f40 <mmc_cmd8+0x9c>
				return false;
  400f3c:	2300      	movs	r3, #0
  400f3e:	e01f      	b.n	400f80 <mmc_cmd8+0xdc>
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
  400f40:	8afb      	ldrh	r3, [r7, #22]
  400f42:	3301      	adds	r3, #1
  400f44:	82fb      	strh	r3, [r7, #22]
  400f46:	8afb      	ldrh	r3, [r7, #22]
  400f48:	2b35      	cmp	r3, #53	; 0x35
  400f4a:	d9ec      	bls.n	400f26 <mmc_cmd8+0x82>
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
  400f4c:	4b11      	ldr	r3, [pc, #68]	; (400f94 <mmc_cmd8+0xf0>)
  400f4e:	681b      	ldr	r3, [r3, #0]
  400f50:	68fa      	ldr	r2, [r7, #12]
  400f52:	0852      	lsrs	r2, r2, #1
  400f54:	605a      	str	r2, [r3, #4]
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
  400f56:	e00f      	b.n	400f78 <mmc_cmd8+0xd4>
		if (!driver_read_word(&sec_count)) {
  400f58:	f107 030c 	add.w	r3, r7, #12
  400f5c:	4618      	mov	r0, r3
  400f5e:	4b0c      	ldr	r3, [pc, #48]	; (400f90 <mmc_cmd8+0xec>)
  400f60:	4798      	blx	r3
  400f62:	4603      	mov	r3, r0
  400f64:	f083 0301 	eor.w	r3, r3, #1
  400f68:	b2db      	uxtb	r3, r3
  400f6a:	2b00      	cmp	r3, #0
  400f6c:	d001      	beq.n	400f72 <mmc_cmd8+0xce>
			return false;
  400f6e:	2300      	movs	r3, #0
  400f70:	e006      	b.n	400f80 <mmc_cmd8+0xdc>
	for (; i < EXT_CSD_BSIZE / 4; i++) {
  400f72:	8afb      	ldrh	r3, [r7, #22]
  400f74:	3301      	adds	r3, #1
  400f76:	82fb      	strh	r3, [r7, #22]
  400f78:	8afb      	ldrh	r3, [r7, #22]
  400f7a:	2b7f      	cmp	r3, #127	; 0x7f
  400f7c:	d9ec      	bls.n	400f58 <mmc_cmd8+0xb4>
		}
	}
	return true;
  400f7e:	2301      	movs	r3, #1
}
  400f80:	4618      	mov	r0, r3
  400f82:	371c      	adds	r7, #28
  400f84:	46bd      	mov	sp, r7
  400f86:	bd90      	pop	{r4, r7, pc}
  400f88:	00081108 	.word	0x00081108
  400f8c:	004023fd 	.word	0x004023fd
  400f90:	00402525 	.word	0x00402525
  400f94:	2000047c 	.word	0x2000047c
  400f98:	00400759 	.word	0x00400759

00400f9c <sd_mmc_cmd9_mci>:
 * data (CSD) on the CMD line mci.
 *
 * \return true if success, otherwise false
 */
static bool sd_mmc_cmd9_mci(void)
{
  400f9c:	b580      	push	{r7, lr}
  400f9e:	af00      	add	r7, sp, #0
	if (!driver_send_cmd(SDMMC_MCI_CMD9_SEND_CSD, (uint32_t)sd_mmc_card->rca << 16)) {
  400fa0:	4b0c      	ldr	r3, [pc, #48]	; (400fd4 <sd_mmc_cmd9_mci+0x38>)
  400fa2:	681b      	ldr	r3, [r3, #0]
  400fa4:	891b      	ldrh	r3, [r3, #8]
  400fa6:	041b      	lsls	r3, r3, #16
  400fa8:	4619      	mov	r1, r3
  400faa:	f641 3009 	movw	r0, #6921	; 0x1b09
  400fae:	4b0a      	ldr	r3, [pc, #40]	; (400fd8 <sd_mmc_cmd9_mci+0x3c>)
  400fb0:	4798      	blx	r3
  400fb2:	4603      	mov	r3, r0
  400fb4:	f083 0301 	eor.w	r3, r3, #1
  400fb8:	b2db      	uxtb	r3, r3
  400fba:	2b00      	cmp	r3, #0
  400fbc:	d001      	beq.n	400fc2 <sd_mmc_cmd9_mci+0x26>
		return false;
  400fbe:	2300      	movs	r3, #0
  400fc0:	e006      	b.n	400fd0 <sd_mmc_cmd9_mci+0x34>
	}
	driver_get_response_128(sd_mmc_card->csd);
  400fc2:	4b04      	ldr	r3, [pc, #16]	; (400fd4 <sd_mmc_cmd9_mci+0x38>)
  400fc4:	681b      	ldr	r3, [r3, #0]
  400fc6:	330e      	adds	r3, #14
  400fc8:	4618      	mov	r0, r3
  400fca:	4b04      	ldr	r3, [pc, #16]	; (400fdc <sd_mmc_cmd9_mci+0x40>)
  400fcc:	4798      	blx	r3
	return true;
  400fce:	2301      	movs	r3, #1
}
  400fd0:	4618      	mov	r0, r3
  400fd2:	bd80      	pop	{r7, pc}
  400fd4:	2000047c 	.word	0x2000047c
  400fd8:	00402331 	.word	0x00402331
  400fdc:	0040238d 	.word	0x0040238d

00400fe0 <mmc_decode_csd>:

/**
 * \brief Decodes MMC CSD register
 */
static void mmc_decode_csd(void)
{
  400fe0:	b5b0      	push	{r4, r5, r7, lr}
  400fe2:	b084      	sub	sp, #16
  400fe4:	af00      	add	r7, sp, #0
 	uint32_t unit;
	uint32_t mul;
	uint32_t tran_speed;

	// Get MMC System Specification version supported by the card
	switch (MMC_CSD_SPEC_VERS(sd_mmc_card->csd)) {
  400fe6:	4b48      	ldr	r3, [pc, #288]	; (401108 <mmc_decode_csd+0x128>)
  400fe8:	681b      	ldr	r3, [r3, #0]
  400fea:	f103 000e 	add.w	r0, r3, #14
  400fee:	2304      	movs	r3, #4
  400ff0:	227a      	movs	r2, #122	; 0x7a
  400ff2:	2180      	movs	r1, #128	; 0x80
  400ff4:	4c45      	ldr	r4, [pc, #276]	; (40110c <mmc_decode_csd+0x12c>)
  400ff6:	47a0      	blx	r4
  400ff8:	4603      	mov	r3, r0
  400ffa:	3b01      	subs	r3, #1
  400ffc:	2b03      	cmp	r3, #3
  400ffe:	d80b      	bhi.n	401018 <mmc_decode_csd+0x38>
  401000:	a201      	add	r2, pc, #4	; (adr r2, 401008 <mmc_decode_csd+0x28>)
  401002:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  401006:	bf00      	nop
  401008:	00401023 	.word	0x00401023
  40100c:	0040102d 	.word	0x0040102d
  401010:	00401037 	.word	0x00401037
  401014:	00401041 	.word	0x00401041
	default:
	case 0:
		sd_mmc_card->version = CARD_VER_MMC_1_2;
  401018:	4b3b      	ldr	r3, [pc, #236]	; (401108 <mmc_decode_csd+0x128>)
  40101a:	681b      	ldr	r3, [r3, #0]
  40101c:	2212      	movs	r2, #18
  40101e:	731a      	strb	r2, [r3, #12]
		break;
  401020:	e013      	b.n	40104a <mmc_decode_csd+0x6a>

	case 1:
		sd_mmc_card->version = CARD_VER_MMC_1_4;
  401022:	4b39      	ldr	r3, [pc, #228]	; (401108 <mmc_decode_csd+0x128>)
  401024:	681b      	ldr	r3, [r3, #0]
  401026:	2214      	movs	r2, #20
  401028:	731a      	strb	r2, [r3, #12]
		break;
  40102a:	e00e      	b.n	40104a <mmc_decode_csd+0x6a>

	case 2:
		sd_mmc_card->version = CARD_VER_MMC_2_2;
  40102c:	4b36      	ldr	r3, [pc, #216]	; (401108 <mmc_decode_csd+0x128>)
  40102e:	681b      	ldr	r3, [r3, #0]
  401030:	2222      	movs	r2, #34	; 0x22
  401032:	731a      	strb	r2, [r3, #12]
		break;
  401034:	e009      	b.n	40104a <mmc_decode_csd+0x6a>

	case 3:
		sd_mmc_card->version = CARD_VER_MMC_3;
  401036:	4b34      	ldr	r3, [pc, #208]	; (401108 <mmc_decode_csd+0x128>)
  401038:	681b      	ldr	r3, [r3, #0]
  40103a:	2230      	movs	r2, #48	; 0x30
  40103c:	731a      	strb	r2, [r3, #12]
		break;
  40103e:	e004      	b.n	40104a <mmc_decode_csd+0x6a>

	case 4:
		sd_mmc_card->version = CARD_VER_MMC_4;
  401040:	4b31      	ldr	r3, [pc, #196]	; (401108 <mmc_decode_csd+0x128>)
  401042:	681b      	ldr	r3, [r3, #0]
  401044:	2240      	movs	r2, #64	; 0x40
  401046:	731a      	strb	r2, [r3, #12]
		break;
  401048:	bf00      	nop
	}

	// Get MMC memory max transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
  40104a:	4b2f      	ldr	r3, [pc, #188]	; (401108 <mmc_decode_csd+0x128>)
  40104c:	681b      	ldr	r3, [r3, #0]
  40104e:	f103 000e 	add.w	r0, r3, #14
  401052:	2308      	movs	r3, #8
  401054:	2260      	movs	r2, #96	; 0x60
  401056:	2180      	movs	r1, #128	; 0x80
  401058:	4c2c      	ldr	r4, [pc, #176]	; (40110c <mmc_decode_csd+0x12c>)
  40105a:	47a0      	blx	r4
  40105c:	60f8      	str	r0, [r7, #12]
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  40105e:	68fb      	ldr	r3, [r7, #12]
  401060:	f003 0307 	and.w	r3, r3, #7
  401064:	4a2a      	ldr	r2, [pc, #168]	; (401110 <mmc_decode_csd+0x130>)
  401066:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40106a:	60bb      	str	r3, [r7, #8]
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
  40106c:	68fb      	ldr	r3, [r7, #12]
  40106e:	08db      	lsrs	r3, r3, #3
  401070:	f003 030f 	and.w	r3, r3, #15
  401074:	4a27      	ldr	r2, [pc, #156]	; (401114 <mmc_decode_csd+0x134>)
  401076:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40107a:	607b      	str	r3, [r7, #4]
	sd_mmc_card->clock = unit * mul * 1000;
  40107c:	4b22      	ldr	r3, [pc, #136]	; (401108 <mmc_decode_csd+0x128>)
  40107e:	681b      	ldr	r3, [r3, #0]
  401080:	68ba      	ldr	r2, [r7, #8]
  401082:	6879      	ldr	r1, [r7, #4]
  401084:	fb01 f202 	mul.w	r2, r1, r2
  401088:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  40108c:	fb01 f202 	mul.w	r2, r1, r2
  401090:	601a      	str	r2, [r3, #0]
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD/MMC card:
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
  401092:	4b1d      	ldr	r3, [pc, #116]	; (401108 <mmc_decode_csd+0x128>)
  401094:	681b      	ldr	r3, [r3, #0]
  401096:	f103 000e 	add.w	r0, r3, #14
  40109a:	230c      	movs	r3, #12
  40109c:	223e      	movs	r2, #62	; 0x3e
  40109e:	2180      	movs	r1, #128	; 0x80
  4010a0:	4c1a      	ldr	r4, [pc, #104]	; (40110c <mmc_decode_csd+0x12c>)
  4010a2:	47a0      	blx	r4
  4010a4:	4602      	mov	r2, r0
  4010a6:	f640 73ff 	movw	r3, #4095	; 0xfff
  4010aa:	429a      	cmp	r2, r3
  4010ac:	d028      	beq.n	401100 <mmc_decode_csd+0x120>
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
  4010ae:	4b16      	ldr	r3, [pc, #88]	; (401108 <mmc_decode_csd+0x128>)
  4010b0:	681b      	ldr	r3, [r3, #0]
  4010b2:	f103 000e 	add.w	r0, r3, #14
  4010b6:	230c      	movs	r3, #12
  4010b8:	223e      	movs	r2, #62	; 0x3e
  4010ba:	2180      	movs	r1, #128	; 0x80
  4010bc:	4c13      	ldr	r4, [pc, #76]	; (40110c <mmc_decode_csd+0x12c>)
  4010be:	47a0      	blx	r4
  4010c0:	4603      	mov	r3, r0
  4010c2:	1c5c      	adds	r4, r3, #1
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
  4010c4:	4b10      	ldr	r3, [pc, #64]	; (401108 <mmc_decode_csd+0x128>)
  4010c6:	681b      	ldr	r3, [r3, #0]
  4010c8:	f103 000e 	add.w	r0, r3, #14
  4010cc:	2303      	movs	r3, #3
  4010ce:	222f      	movs	r2, #47	; 0x2f
  4010d0:	2180      	movs	r1, #128	; 0x80
  4010d2:	4d0e      	ldr	r5, [pc, #56]	; (40110c <mmc_decode_csd+0x12c>)
  4010d4:	47a8      	blx	r5
  4010d6:	4603      	mov	r3, r0
  4010d8:	3302      	adds	r3, #2
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
  4010da:	fa04 f303 	lsl.w	r3, r4, r3
  4010de:	603b      	str	r3, [r7, #0]
		sd_mmc_card->capacity = blocknr *
  4010e0:	4b09      	ldr	r3, [pc, #36]	; (401108 <mmc_decode_csd+0x128>)
  4010e2:	681c      	ldr	r4, [r3, #0]
			(1 << MMC_CSD_READ_BL_LEN(sd_mmc_card->csd)) / 1024;
  4010e4:	4b08      	ldr	r3, [pc, #32]	; (401108 <mmc_decode_csd+0x128>)
  4010e6:	681b      	ldr	r3, [r3, #0]
  4010e8:	f103 000e 	add.w	r0, r3, #14
  4010ec:	2304      	movs	r3, #4
  4010ee:	2250      	movs	r2, #80	; 0x50
  4010f0:	2180      	movs	r1, #128	; 0x80
  4010f2:	4d06      	ldr	r5, [pc, #24]	; (40110c <mmc_decode_csd+0x12c>)
  4010f4:	47a8      	blx	r5
  4010f6:	4602      	mov	r2, r0
		sd_mmc_card->capacity = blocknr *
  4010f8:	683b      	ldr	r3, [r7, #0]
  4010fa:	4093      	lsls	r3, r2
			(1 << MMC_CSD_READ_BL_LEN(sd_mmc_card->csd)) / 1024;
  4010fc:	0a9b      	lsrs	r3, r3, #10
		sd_mmc_card->capacity = blocknr *
  4010fe:	6063      	str	r3, [r4, #4]
	}
}
  401100:	bf00      	nop
  401102:	3710      	adds	r7, #16
  401104:	46bd      	mov	sp, r7
  401106:	bdb0      	pop	{r4, r5, r7, pc}
  401108:	2000047c 	.word	0x2000047c
  40110c:	00400759 	.word	0x00400759
  401110:	00403f8c 	.word	0x00403f8c
  401114:	00403fe8 	.word	0x00403fe8

00401118 <sd_decode_csd>:

/**
 * \brief Decodes SD CSD register
 */
static void sd_decode_csd(void)
{
  401118:	b5b0      	push	{r4, r5, r7, lr}
  40111a:	b084      	sub	sp, #16
  40111c:	af00      	add	r7, sp, #0
 	uint32_t unit;
	uint32_t mul;
	uint32_t tran_speed;

	// Get SD memory maximum transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
  40111e:	4b36      	ldr	r3, [pc, #216]	; (4011f8 <sd_decode_csd+0xe0>)
  401120:	681b      	ldr	r3, [r3, #0]
  401122:	f103 000e 	add.w	r0, r3, #14
  401126:	2308      	movs	r3, #8
  401128:	2260      	movs	r2, #96	; 0x60
  40112a:	2180      	movs	r1, #128	; 0x80
  40112c:	4c33      	ldr	r4, [pc, #204]	; (4011fc <sd_decode_csd+0xe4>)
  40112e:	47a0      	blx	r4
  401130:	60f8      	str	r0, [r7, #12]
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  401132:	68fb      	ldr	r3, [r7, #12]
  401134:	f003 0307 	and.w	r3, r3, #7
  401138:	4a31      	ldr	r2, [pc, #196]	; (401200 <sd_decode_csd+0xe8>)
  40113a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40113e:	60bb      	str	r3, [r7, #8]
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
  401140:	68fb      	ldr	r3, [r7, #12]
  401142:	08db      	lsrs	r3, r3, #3
  401144:	f003 030f 	and.w	r3, r3, #15
  401148:	4a2e      	ldr	r2, [pc, #184]	; (401204 <sd_decode_csd+0xec>)
  40114a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40114e:	607b      	str	r3, [r7, #4]
	sd_mmc_card->clock = unit * mul * 1000;
  401150:	4b29      	ldr	r3, [pc, #164]	; (4011f8 <sd_decode_csd+0xe0>)
  401152:	681b      	ldr	r3, [r3, #0]
  401154:	68ba      	ldr	r2, [r7, #8]
  401156:	6879      	ldr	r1, [r7, #4]
  401158:	fb01 f202 	mul.w	r2, r1, r2
  40115c:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  401160:	fb01 f202 	mul.w	r2, r1, r2
  401164:	601a      	str	r2, [r3, #0]
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD card:
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
  401166:	4b24      	ldr	r3, [pc, #144]	; (4011f8 <sd_decode_csd+0xe0>)
  401168:	681b      	ldr	r3, [r3, #0]
  40116a:	f103 000e 	add.w	r0, r3, #14
  40116e:	2302      	movs	r3, #2
  401170:	227e      	movs	r2, #126	; 0x7e
  401172:	2180      	movs	r1, #128	; 0x80
  401174:	4c21      	ldr	r4, [pc, #132]	; (4011fc <sd_decode_csd+0xe4>)
  401176:	47a0      	blx	r4
  401178:	4603      	mov	r3, r0
  40117a:	2b00      	cmp	r3, #0
  40117c:	d00f      	beq.n	40119e <sd_decode_csd+0x86>
		sd_mmc_card->capacity =
  40117e:	4b1e      	ldr	r3, [pc, #120]	; (4011f8 <sd_decode_csd+0xe0>)
  401180:	681c      	ldr	r4, [r3, #0]
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
  401182:	4b1d      	ldr	r3, [pc, #116]	; (4011f8 <sd_decode_csd+0xe0>)
  401184:	681b      	ldr	r3, [r3, #0]
  401186:	f103 000e 	add.w	r0, r3, #14
  40118a:	2316      	movs	r3, #22
  40118c:	2230      	movs	r2, #48	; 0x30
  40118e:	2180      	movs	r1, #128	; 0x80
  401190:	4d1a      	ldr	r5, [pc, #104]	; (4011fc <sd_decode_csd+0xe4>)
  401192:	47a8      	blx	r5
  401194:	4603      	mov	r3, r0
				* 512;
  401196:	3301      	adds	r3, #1
  401198:	025b      	lsls	r3, r3, #9
		sd_mmc_card->capacity =
  40119a:	6063      	str	r3, [r4, #4]
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
				(1 << SD_CSD_1_0_READ_BL_LEN(sd_mmc_card->csd))
				/ 1024;
	}
}
  40119c:	e028      	b.n	4011f0 <sd_decode_csd+0xd8>
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
  40119e:	4b16      	ldr	r3, [pc, #88]	; (4011f8 <sd_decode_csd+0xe0>)
  4011a0:	681b      	ldr	r3, [r3, #0]
  4011a2:	f103 000e 	add.w	r0, r3, #14
  4011a6:	230c      	movs	r3, #12
  4011a8:	223e      	movs	r2, #62	; 0x3e
  4011aa:	2180      	movs	r1, #128	; 0x80
  4011ac:	4c13      	ldr	r4, [pc, #76]	; (4011fc <sd_decode_csd+0xe4>)
  4011ae:	47a0      	blx	r4
  4011b0:	4603      	mov	r3, r0
  4011b2:	1c5c      	adds	r4, r3, #1
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
  4011b4:	4b10      	ldr	r3, [pc, #64]	; (4011f8 <sd_decode_csd+0xe0>)
  4011b6:	681b      	ldr	r3, [r3, #0]
  4011b8:	f103 000e 	add.w	r0, r3, #14
  4011bc:	2303      	movs	r3, #3
  4011be:	222f      	movs	r2, #47	; 0x2f
  4011c0:	2180      	movs	r1, #128	; 0x80
  4011c2:	4d0e      	ldr	r5, [pc, #56]	; (4011fc <sd_decode_csd+0xe4>)
  4011c4:	47a8      	blx	r5
  4011c6:	4603      	mov	r3, r0
  4011c8:	3302      	adds	r3, #2
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
  4011ca:	fa04 f303 	lsl.w	r3, r4, r3
  4011ce:	603b      	str	r3, [r7, #0]
		sd_mmc_card->capacity = blocknr *
  4011d0:	4b09      	ldr	r3, [pc, #36]	; (4011f8 <sd_decode_csd+0xe0>)
  4011d2:	681c      	ldr	r4, [r3, #0]
				(1 << SD_CSD_1_0_READ_BL_LEN(sd_mmc_card->csd))
  4011d4:	4b08      	ldr	r3, [pc, #32]	; (4011f8 <sd_decode_csd+0xe0>)
  4011d6:	681b      	ldr	r3, [r3, #0]
  4011d8:	f103 000e 	add.w	r0, r3, #14
  4011dc:	2304      	movs	r3, #4
  4011de:	2250      	movs	r2, #80	; 0x50
  4011e0:	2180      	movs	r1, #128	; 0x80
  4011e2:	4d06      	ldr	r5, [pc, #24]	; (4011fc <sd_decode_csd+0xe4>)
  4011e4:	47a8      	blx	r5
  4011e6:	4602      	mov	r2, r0
		sd_mmc_card->capacity = blocknr *
  4011e8:	683b      	ldr	r3, [r7, #0]
  4011ea:	4093      	lsls	r3, r2
				/ 1024;
  4011ec:	0a9b      	lsrs	r3, r3, #10
		sd_mmc_card->capacity = blocknr *
  4011ee:	6063      	str	r3, [r4, #4]
}
  4011f0:	bf00      	nop
  4011f2:	3710      	adds	r7, #16
  4011f4:	46bd      	mov	sp, r7
  4011f6:	bdb0      	pop	{r4, r5, r7, pc}
  4011f8:	2000047c 	.word	0x2000047c
  4011fc:	00400759 	.word	0x00400759
  401200:	00403f8c 	.word	0x00403f8c
  401204:	00403fa8 	.word	0x00403fa8

00401208 <sdio_cmd52>:
 *
 * \return true if success, otherwise false
 */
static bool sdio_cmd52(uint8_t rw_flag, uint8_t func_nb,
		uint32_t reg_addr, uint8_t rd_after_wr, uint8_t *io_data)
{
  401208:	b580      	push	{r7, lr}
  40120a:	b082      	sub	sp, #8
  40120c:	af00      	add	r7, sp, #0
  40120e:	603a      	str	r2, [r7, #0]
  401210:	461a      	mov	r2, r3
  401212:	4603      	mov	r3, r0
  401214:	71fb      	strb	r3, [r7, #7]
  401216:	460b      	mov	r3, r1
  401218:	71bb      	strb	r3, [r7, #6]
  40121a:	4613      	mov	r3, r2
  40121c:	717b      	strb	r3, [r7, #5]
	Assert(io_data != NULL);
	if (!driver_send_cmd(SDIO_CMD52_IO_RW_DIRECT,
		((uint32_t)*io_data << SDIO_CMD52_WR_DATA)
  40121e:	693b      	ldr	r3, [r7, #16]
  401220:	781b      	ldrb	r3, [r3, #0]
  401222:	461a      	mov	r2, r3
		| ((uint32_t)rw_flag << SDIO_CMD52_RW_FLAG)
  401224:	79fb      	ldrb	r3, [r7, #7]
  401226:	07db      	lsls	r3, r3, #31
  401228:	431a      	orrs	r2, r3
		| ((uint32_t)func_nb << SDIO_CMD52_FUNCTION_NUM)
  40122a:	79bb      	ldrb	r3, [r7, #6]
  40122c:	071b      	lsls	r3, r3, #28
  40122e:	431a      	orrs	r2, r3
		| ((uint32_t)rd_after_wr << SDIO_CMD52_RAW_FLAG)
  401230:	797b      	ldrb	r3, [r7, #5]
  401232:	06db      	lsls	r3, r3, #27
  401234:	431a      	orrs	r2, r3
		| ((uint32_t)reg_addr << SDIO_CMD52_REG_ADRR))) {
  401236:	683b      	ldr	r3, [r7, #0]
  401238:	025b      	lsls	r3, r3, #9
	if (!driver_send_cmd(SDIO_CMD52_IO_RW_DIRECT,
  40123a:	4313      	orrs	r3, r2
  40123c:	4619      	mov	r1, r3
  40123e:	f241 3034 	movw	r0, #4916	; 0x1334
  401242:	4b0a      	ldr	r3, [pc, #40]	; (40126c <sdio_cmd52+0x64>)
  401244:	4798      	blx	r3
  401246:	4603      	mov	r3, r0
  401248:	f083 0301 	eor.w	r3, r3, #1
  40124c:	b2db      	uxtb	r3, r3
  40124e:	2b00      	cmp	r3, #0
  401250:	d001      	beq.n	401256 <sdio_cmd52+0x4e>
		return false;
  401252:	2300      	movs	r3, #0
  401254:	e006      	b.n	401264 <sdio_cmd52+0x5c>
	}
	*io_data = driver_get_response() & 0xFF;
  401256:	4b06      	ldr	r3, [pc, #24]	; (401270 <sdio_cmd52+0x68>)
  401258:	4798      	blx	r3
  40125a:	4603      	mov	r3, r0
  40125c:	b2da      	uxtb	r2, r3
  40125e:	693b      	ldr	r3, [r7, #16]
  401260:	701a      	strb	r2, [r3, #0]
	return true;
  401262:	2301      	movs	r3, #1
}
  401264:	4618      	mov	r0, r3
  401266:	3708      	adds	r7, #8
  401268:	46bd      	mov	sp, r7
  40126a:	bd80      	pop	{r7, pc}
  40126c:	00402331 	.word	0x00402331
  401270:	00402375 	.word	0x00402375

00401274 <sd_acmd6>:
 * \brief ACMD6 - Define the data bus width to 4 bits bus
 *
 * \return true if success, otherwise false
 */
static bool sd_acmd6(void)
{
  401274:	b580      	push	{r7, lr}
  401276:	af00      	add	r7, sp, #0
	// CMD55 - Indicate to the card that the next command is an
	// application specific command rather than a standard command.
	if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, (uint32_t)sd_mmc_card->rca << 16)) {
  401278:	4b12      	ldr	r3, [pc, #72]	; (4012c4 <sd_acmd6+0x50>)
  40127a:	681b      	ldr	r3, [r3, #0]
  40127c:	891b      	ldrh	r3, [r3, #8]
  40127e:	041b      	lsls	r3, r3, #16
  401280:	4619      	mov	r1, r3
  401282:	f241 1037 	movw	r0, #4407	; 0x1137
  401286:	4b10      	ldr	r3, [pc, #64]	; (4012c8 <sd_acmd6+0x54>)
  401288:	4798      	blx	r3
  40128a:	4603      	mov	r3, r0
  40128c:	f083 0301 	eor.w	r3, r3, #1
  401290:	b2db      	uxtb	r3, r3
  401292:	2b00      	cmp	r3, #0
  401294:	d001      	beq.n	40129a <sd_acmd6+0x26>
		return false;
  401296:	2300      	movs	r3, #0
  401298:	e011      	b.n	4012be <sd_acmd6+0x4a>
	}
	// 10b = 4 bits bus
	if (!driver_send_cmd(SD_ACMD6_SET_BUS_WIDTH, 0x2)) {
  40129a:	2102      	movs	r1, #2
  40129c:	f241 1006 	movw	r0, #4358	; 0x1106
  4012a0:	4b09      	ldr	r3, [pc, #36]	; (4012c8 <sd_acmd6+0x54>)
  4012a2:	4798      	blx	r3
  4012a4:	4603      	mov	r3, r0
  4012a6:	f083 0301 	eor.w	r3, r3, #1
  4012aa:	b2db      	uxtb	r3, r3
  4012ac:	2b00      	cmp	r3, #0
  4012ae:	d001      	beq.n	4012b4 <sd_acmd6+0x40>
		return false;
  4012b0:	2300      	movs	r3, #0
  4012b2:	e004      	b.n	4012be <sd_acmd6+0x4a>
	}
	sd_mmc_card->bus_width = 4;
  4012b4:	4b03      	ldr	r3, [pc, #12]	; (4012c4 <sd_acmd6+0x50>)
  4012b6:	681b      	ldr	r3, [r3, #0]
  4012b8:	2204      	movs	r2, #4
  4012ba:	735a      	strb	r2, [r3, #13]
	sd_mmc_debug("%d-bit bus width enabled.\n\r", (int)sd_mmc_card->bus_width);
	return true;
  4012bc:	2301      	movs	r3, #1
}
  4012be:	4618      	mov	r0, r3
  4012c0:	bd80      	pop	{r7, pc}
  4012c2:	bf00      	nop
  4012c4:	2000047c 	.word	0x2000047c
  4012c8:	00402331 	.word	0x00402331

004012cc <sd_acmd51>:
 *
 *
 * \return true if success, otherwise false
 */
static bool sd_acmd51(void)
{
  4012cc:	b590      	push	{r4, r7, lr}
  4012ce:	b085      	sub	sp, #20
  4012d0:	af02      	add	r7, sp, #8
	uint8_t scr[SD_SCR_REG_BSIZE];

	// CMD55 - Indicate to the card that the next command is an
	// application specific command rather than a standard command.
	if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, (uint32_t)sd_mmc_card->rca << 16)) {
  4012d2:	4b36      	ldr	r3, [pc, #216]	; (4013ac <sd_acmd51+0xe0>)
  4012d4:	681b      	ldr	r3, [r3, #0]
  4012d6:	891b      	ldrh	r3, [r3, #8]
  4012d8:	041b      	lsls	r3, r3, #16
  4012da:	4619      	mov	r1, r3
  4012dc:	f241 1037 	movw	r0, #4407	; 0x1137
  4012e0:	4b33      	ldr	r3, [pc, #204]	; (4013b0 <sd_acmd51+0xe4>)
  4012e2:	4798      	blx	r3
  4012e4:	4603      	mov	r3, r0
  4012e6:	f083 0301 	eor.w	r3, r3, #1
  4012ea:	b2db      	uxtb	r3, r3
  4012ec:	2b00      	cmp	r3, #0
  4012ee:	d001      	beq.n	4012f4 <sd_acmd51+0x28>
		return false;
  4012f0:	2300      	movs	r3, #0
  4012f2:	e057      	b.n	4013a4 <sd_acmd51+0xd8>
	}
	if (!driver_adtc_start(SD_ACMD51_SEND_SCR, 0,
  4012f4:	2301      	movs	r3, #1
  4012f6:	9300      	str	r3, [sp, #0]
  4012f8:	2301      	movs	r3, #1
  4012fa:	2208      	movs	r2, #8
  4012fc:	2100      	movs	r1, #0
  4012fe:	482d      	ldr	r0, [pc, #180]	; (4013b4 <sd_acmd51+0xe8>)
  401300:	4c2d      	ldr	r4, [pc, #180]	; (4013b8 <sd_acmd51+0xec>)
  401302:	47a0      	blx	r4
  401304:	4603      	mov	r3, r0
  401306:	f083 0301 	eor.w	r3, r3, #1
  40130a:	b2db      	uxtb	r3, r3
  40130c:	2b00      	cmp	r3, #0
  40130e:	d001      	beq.n	401314 <sd_acmd51+0x48>
			SD_SCR_REG_BSIZE, 1, true)) {
		return false;
  401310:	2300      	movs	r3, #0
  401312:	e047      	b.n	4013a4 <sd_acmd51+0xd8>
	}
	if (!driver_start_read_blocks(scr, 1)) {
  401314:	463b      	mov	r3, r7
  401316:	2101      	movs	r1, #1
  401318:	4618      	mov	r0, r3
  40131a:	4b28      	ldr	r3, [pc, #160]	; (4013bc <sd_acmd51+0xf0>)
  40131c:	4798      	blx	r3
  40131e:	4603      	mov	r3, r0
  401320:	f083 0301 	eor.w	r3, r3, #1
  401324:	b2db      	uxtb	r3, r3
  401326:	2b00      	cmp	r3, #0
  401328:	d001      	beq.n	40132e <sd_acmd51+0x62>
		return false;
  40132a:	2300      	movs	r3, #0
  40132c:	e03a      	b.n	4013a4 <sd_acmd51+0xd8>
	}
	if (!driver_wait_end_of_read_blocks()) {
  40132e:	4b24      	ldr	r3, [pc, #144]	; (4013c0 <sd_acmd51+0xf4>)
  401330:	4798      	blx	r3
  401332:	4603      	mov	r3, r0
  401334:	f083 0301 	eor.w	r3, r3, #1
  401338:	b2db      	uxtb	r3, r3
  40133a:	2b00      	cmp	r3, #0
  40133c:	d001      	beq.n	401342 <sd_acmd51+0x76>
		return false;
  40133e:	2300      	movs	r3, #0
  401340:	e030      	b.n	4013a4 <sd_acmd51+0xd8>
	}

	// Get SD Memory Card - Spec. Version
	switch (SD_SCR_SD_SPEC(scr)) {
  401342:	4638      	mov	r0, r7
  401344:	2304      	movs	r3, #4
  401346:	2238      	movs	r2, #56	; 0x38
  401348:	2140      	movs	r1, #64	; 0x40
  40134a:	4c1e      	ldr	r4, [pc, #120]	; (4013c4 <sd_acmd51+0xf8>)
  40134c:	47a0      	blx	r4
  40134e:	4603      	mov	r3, r0
  401350:	2b01      	cmp	r3, #1
  401352:	d009      	beq.n	401368 <sd_acmd51+0x9c>
  401354:	2b01      	cmp	r3, #1
  401356:	d302      	bcc.n	40135e <sd_acmd51+0x92>
  401358:	2b02      	cmp	r3, #2
  40135a:	d00a      	beq.n	401372 <sd_acmd51+0xa6>
  40135c:	e01c      	b.n	401398 <sd_acmd51+0xcc>
	case SD_SCR_SD_SPEC_1_0_01:
		sd_mmc_card->version = CARD_VER_SD_1_0;
  40135e:	4b13      	ldr	r3, [pc, #76]	; (4013ac <sd_acmd51+0xe0>)
  401360:	681b      	ldr	r3, [r3, #0]
  401362:	2210      	movs	r2, #16
  401364:	731a      	strb	r2, [r3, #12]
		break;
  401366:	e01c      	b.n	4013a2 <sd_acmd51+0xd6>

	case SD_SCR_SD_SPEC_1_10:
		sd_mmc_card->version = CARD_VER_SD_1_10;
  401368:	4b10      	ldr	r3, [pc, #64]	; (4013ac <sd_acmd51+0xe0>)
  40136a:	681b      	ldr	r3, [r3, #0]
  40136c:	221a      	movs	r2, #26
  40136e:	731a      	strb	r2, [r3, #12]
		break;
  401370:	e017      	b.n	4013a2 <sd_acmd51+0xd6>

	case SD_SCR_SD_SPEC_2_00:
		if (SD_SCR_SD_SPEC3(scr) == SD_SCR_SD_SPEC_3_00) {
  401372:	4638      	mov	r0, r7
  401374:	2301      	movs	r3, #1
  401376:	222f      	movs	r2, #47	; 0x2f
  401378:	2140      	movs	r1, #64	; 0x40
  40137a:	4c12      	ldr	r4, [pc, #72]	; (4013c4 <sd_acmd51+0xf8>)
  40137c:	47a0      	blx	r4
  40137e:	4603      	mov	r3, r0
  401380:	2b01      	cmp	r3, #1
  401382:	d104      	bne.n	40138e <sd_acmd51+0xc2>
			sd_mmc_card->version = CARD_VER_SD_3_0;
  401384:	4b09      	ldr	r3, [pc, #36]	; (4013ac <sd_acmd51+0xe0>)
  401386:	681b      	ldr	r3, [r3, #0]
  401388:	2230      	movs	r2, #48	; 0x30
  40138a:	731a      	strb	r2, [r3, #12]
		} else {
			sd_mmc_card->version = CARD_VER_SD_2_0;
		}
		break;
  40138c:	e009      	b.n	4013a2 <sd_acmd51+0xd6>
			sd_mmc_card->version = CARD_VER_SD_2_0;
  40138e:	4b07      	ldr	r3, [pc, #28]	; (4013ac <sd_acmd51+0xe0>)
  401390:	681b      	ldr	r3, [r3, #0]
  401392:	2220      	movs	r2, #32
  401394:	731a      	strb	r2, [r3, #12]
		break;
  401396:	e004      	b.n	4013a2 <sd_acmd51+0xd6>

	default:
		sd_mmc_card->version = CARD_VER_SD_1_0;
  401398:	4b04      	ldr	r3, [pc, #16]	; (4013ac <sd_acmd51+0xe0>)
  40139a:	681b      	ldr	r3, [r3, #0]
  40139c:	2210      	movs	r2, #16
  40139e:	731a      	strb	r2, [r3, #12]
		break;
  4013a0:	bf00      	nop
	}
	return true;
  4013a2:	2301      	movs	r3, #1
}
  4013a4:	4618      	mov	r0, r3
  4013a6:	370c      	adds	r7, #12
  4013a8:	46bd      	mov	sp, r7
  4013aa:	bd90      	pop	{r4, r7, pc}
  4013ac:	2000047c 	.word	0x2000047c
  4013b0:	00402331 	.word	0x00402331
  4013b4:	00081133 	.word	0x00081133
  4013b8:	004023fd 	.word	0x004023fd
  4013bc:	004025c1 	.word	0x004025c1
  4013c0:	00402661 	.word	0x00402661
  4013c4:	00400759 	.word	0x00400759

004013c8 <sd_mmc_select_slot>:
 * \retval SD_MMC_ERR_UNUSABLE Unusable card
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
  4013c8:	b580      	push	{r7, lr}
  4013ca:	b082      	sub	sp, #8
  4013cc:	af00      	add	r7, sp, #0
  4013ce:	4603      	mov	r3, r0
  4013d0:	71fb      	strb	r3, [r7, #7]
	if (slot >= SD_MMC_MEM_CNT) {
  4013d2:	79fb      	ldrb	r3, [r7, #7]
  4013d4:	2b00      	cmp	r3, #0
  4013d6:	d001      	beq.n	4013dc <sd_mmc_select_slot+0x14>
		return SD_MMC_ERR_SLOT;
  4013d8:	2304      	movs	r3, #4
  4013da:	e040      	b.n	40145e <sd_mmc_select_slot+0x96>
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_UNUSABLE) {
		return SD_MMC_ERR_UNUSABLE;
	}
#else
	// No pin card detection, then always try to install it
	if ((sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD)
  4013dc:	79fb      	ldrb	r3, [r7, #7]
  4013de:	4a22      	ldr	r2, [pc, #136]	; (401468 <sd_mmc_select_slot+0xa0>)
  4013e0:	015b      	lsls	r3, r3, #5
  4013e2:	4413      	add	r3, r2
  4013e4:	330a      	adds	r3, #10
  4013e6:	781b      	ldrb	r3, [r3, #0]
  4013e8:	2b04      	cmp	r3, #4
  4013ea:	d007      	beq.n	4013fc <sd_mmc_select_slot+0x34>
			|| (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_UNUSABLE)) {
  4013ec:	79fb      	ldrb	r3, [r7, #7]
  4013ee:	4a1e      	ldr	r2, [pc, #120]	; (401468 <sd_mmc_select_slot+0xa0>)
  4013f0:	015b      	lsls	r3, r3, #5
  4013f2:	4413      	add	r3, r2
  4013f4:	330a      	adds	r3, #10
  4013f6:	781b      	ldrb	r3, [r3, #0]
  4013f8:	2b03      	cmp	r3, #3
  4013fa:	d11a      	bne.n	401432 <sd_mmc_select_slot+0x6a>
		// Card is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_INIT;
  4013fc:	79fb      	ldrb	r3, [r7, #7]
  4013fe:	4a1a      	ldr	r2, [pc, #104]	; (401468 <sd_mmc_select_slot+0xa0>)
  401400:	015b      	lsls	r3, r3, #5
  401402:	4413      	add	r3, r2
  401404:	330a      	adds	r3, #10
  401406:	2202      	movs	r2, #2
  401408:	701a      	strb	r2, [r3, #0]
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
  40140a:	79fb      	ldrb	r3, [r7, #7]
  40140c:	4a16      	ldr	r2, [pc, #88]	; (401468 <sd_mmc_select_slot+0xa0>)
  40140e:	015b      	lsls	r3, r3, #5
  401410:	4413      	add	r3, r2
  401412:	4a16      	ldr	r2, [pc, #88]	; (40146c <sd_mmc_select_slot+0xa4>)
  401414:	601a      	str	r2, [r3, #0]
		sd_mmc_cards[slot].bus_width = 1;
  401416:	79fb      	ldrb	r3, [r7, #7]
  401418:	4a13      	ldr	r2, [pc, #76]	; (401468 <sd_mmc_select_slot+0xa0>)
  40141a:	015b      	lsls	r3, r3, #5
  40141c:	4413      	add	r3, r2
  40141e:	330d      	adds	r3, #13
  401420:	2201      	movs	r2, #1
  401422:	701a      	strb	r2, [r3, #0]
		sd_mmc_cards[slot].high_speed = 0;
  401424:	79fb      	ldrb	r3, [r7, #7]
  401426:	4a10      	ldr	r2, [pc, #64]	; (401468 <sd_mmc_select_slot+0xa0>)
  401428:	015b      	lsls	r3, r3, #5
  40142a:	4413      	add	r3, r2
  40142c:	331e      	adds	r3, #30
  40142e:	2200      	movs	r2, #0
  401430:	701a      	strb	r2, [r3, #0]
	}
#endif

	// Initialize interface
	sd_mmc_slot_sel = slot;
  401432:	4a0f      	ldr	r2, [pc, #60]	; (401470 <sd_mmc_select_slot+0xa8>)
  401434:	79fb      	ldrb	r3, [r7, #7]
  401436:	7013      	strb	r3, [r2, #0]
	sd_mmc_card = &sd_mmc_cards[slot];
  401438:	79fb      	ldrb	r3, [r7, #7]
  40143a:	015b      	lsls	r3, r3, #5
  40143c:	4a0a      	ldr	r2, [pc, #40]	; (401468 <sd_mmc_select_slot+0xa0>)
  40143e:	4413      	add	r3, r2
  401440:	4a0c      	ldr	r2, [pc, #48]	; (401474 <sd_mmc_select_slot+0xac>)
  401442:	6013      	str	r3, [r2, #0]
	sd_mmc_configure_slot();
  401444:	4b0c      	ldr	r3, [pc, #48]	; (401478 <sd_mmc_select_slot+0xb0>)
  401446:	4798      	blx	r3
	return (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_INIT) ?
  401448:	79fb      	ldrb	r3, [r7, #7]
  40144a:	4a07      	ldr	r2, [pc, #28]	; (401468 <sd_mmc_select_slot+0xa0>)
  40144c:	015b      	lsls	r3, r3, #5
  40144e:	4413      	add	r3, r2
  401450:	330a      	adds	r3, #10
  401452:	781b      	ldrb	r3, [r3, #0]
			SD_MMC_INIT_ONGOING : SD_MMC_OK;
  401454:	2b02      	cmp	r3, #2
  401456:	bf0c      	ite	eq
  401458:	2301      	moveq	r3, #1
  40145a:	2300      	movne	r3, #0
  40145c:	b2db      	uxtb	r3, r3
}
  40145e:	4618      	mov	r0, r3
  401460:	3708      	adds	r7, #8
  401462:	46bd      	mov	sp, r7
  401464:	bd80      	pop	{r7, pc}
  401466:	bf00      	nop
  401468:	20000458 	.word	0x20000458
  40146c:	00061a80 	.word	0x00061a80
  401470:	20000478 	.word	0x20000478
  401474:	2000047c 	.word	0x2000047c
  401478:	0040147d 	.word	0x0040147d

0040147c <sd_mmc_configure_slot>:

/**
 * \brief Configures the driver with the selected card configuration
 */
static void sd_mmc_configure_slot(void)
{
  40147c:	b598      	push	{r3, r4, r7, lr}
  40147e:	af00      	add	r7, sp, #0
	driver_select_device(sd_mmc_slot_sel, sd_mmc_card->clock,
  401480:	4b09      	ldr	r3, [pc, #36]	; (4014a8 <sd_mmc_configure_slot+0x2c>)
  401482:	7818      	ldrb	r0, [r3, #0]
  401484:	4b09      	ldr	r3, [pc, #36]	; (4014ac <sd_mmc_configure_slot+0x30>)
  401486:	681b      	ldr	r3, [r3, #0]
  401488:	6819      	ldr	r1, [r3, #0]
			sd_mmc_card->bus_width, sd_mmc_card->high_speed);
  40148a:	4b08      	ldr	r3, [pc, #32]	; (4014ac <sd_mmc_configure_slot+0x30>)
  40148c:	681b      	ldr	r3, [r3, #0]
	driver_select_device(sd_mmc_slot_sel, sd_mmc_card->clock,
  40148e:	7b5a      	ldrb	r2, [r3, #13]
			sd_mmc_card->bus_width, sd_mmc_card->high_speed);
  401490:	4b06      	ldr	r3, [pc, #24]	; (4014ac <sd_mmc_configure_slot+0x30>)
  401492:	681b      	ldr	r3, [r3, #0]
  401494:	7f9b      	ldrb	r3, [r3, #30]
	driver_select_device(sd_mmc_slot_sel, sd_mmc_card->clock,
  401496:	2b00      	cmp	r3, #0
  401498:	bf14      	ite	ne
  40149a:	2301      	movne	r3, #1
  40149c:	2300      	moveq	r3, #0
  40149e:	b2db      	uxtb	r3, r3
  4014a0:	4c03      	ldr	r4, [pc, #12]	; (4014b0 <sd_mmc_configure_slot+0x34>)
  4014a2:	47a0      	blx	r4
}
  4014a4:	bf00      	nop
  4014a6:	bd98      	pop	{r3, r4, r7, pc}
  4014a8:	20000478 	.word	0x20000478
  4014ac:	2000047c 	.word	0x2000047c
  4014b0:	00402245 	.word	0x00402245

004014b4 <sd_mmc_deselect_slot>:

/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
  4014b4:	b580      	push	{r7, lr}
  4014b6:	af00      	add	r7, sp, #0
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  4014b8:	4b05      	ldr	r3, [pc, #20]	; (4014d0 <sd_mmc_deselect_slot+0x1c>)
  4014ba:	781b      	ldrb	r3, [r3, #0]
  4014bc:	2b00      	cmp	r3, #0
  4014be:	d104      	bne.n	4014ca <sd_mmc_deselect_slot+0x16>
		driver_deselect_device(sd_mmc_slot_sel);
  4014c0:	4b03      	ldr	r3, [pc, #12]	; (4014d0 <sd_mmc_deselect_slot+0x1c>)
  4014c2:	781b      	ldrb	r3, [r3, #0]
  4014c4:	4618      	mov	r0, r3
  4014c6:	4b03      	ldr	r3, [pc, #12]	; (4014d4 <sd_mmc_deselect_slot+0x20>)
  4014c8:	4798      	blx	r3
	}
}
  4014ca:	bf00      	nop
  4014cc:	bd80      	pop	{r7, pc}
  4014ce:	bf00      	nop
  4014d0:	20000478 	.word	0x20000478
  4014d4:	004022dd 	.word	0x004022dd

004014d8 <sd_mmc_mci_card_init>:
 * At last, it will automaticly enable maximum bus width and transfer speed.
 *
 * \return true if success, otherwise false
 */
static bool sd_mmc_mci_card_init(void)
{
  4014d8:	b590      	push	{r4, r7, lr}
  4014da:	b085      	sub	sp, #20
  4014dc:	af02      	add	r7, sp, #8
	uint8_t v2 = 0;
  4014de:	2300      	movs	r3, #0
  4014e0:	71fb      	strb	r3, [r7, #7]
#ifdef SDIO_SUPPORT_ENABLE
	uint8_t data = 0x08;
  4014e2:	2308      	movs	r3, #8
  4014e4:	71bb      	strb	r3, [r7, #6]
#endif

	// In first, try to install SD/SDIO card
	sd_mmc_card->type = CARD_TYPE_SD;
  4014e6:	4b9a      	ldr	r3, [pc, #616]	; (401750 <sd_mmc_mci_card_init+0x278>)
  4014e8:	681b      	ldr	r3, [r3, #0]
  4014ea:	2201      	movs	r2, #1
  4014ec:	72da      	strb	r2, [r3, #11]
	sd_mmc_card->version = CARD_VER_UNKNOWN;
  4014ee:	4b98      	ldr	r3, [pc, #608]	; (401750 <sd_mmc_mci_card_init+0x278>)
  4014f0:	681b      	ldr	r3, [r3, #0]
  4014f2:	2200      	movs	r2, #0
  4014f4:	731a      	strb	r2, [r3, #12]
	sd_mmc_card->rca = 0;
  4014f6:	4b96      	ldr	r3, [pc, #600]	; (401750 <sd_mmc_mci_card_init+0x278>)
  4014f8:	681b      	ldr	r3, [r3, #0]
  4014fa:	2200      	movs	r2, #0
  4014fc:	811a      	strh	r2, [r3, #8]
	sd_mmc_debug("Start SD card install\n\r");

	// Card need of 74 cycles clock minimum to start
	driver_send_clock();
  4014fe:	4b95      	ldr	r3, [pc, #596]	; (401754 <sd_mmc_mci_card_init+0x27c>)
  401500:	4798      	blx	r3

#ifdef SDIO_SUPPORT_ENABLE
	/* CMD52 Reset SDIO */
	sdio_cmd52(SDIO_CMD52_WRITE_FLAG, SDIO_CIA,SDIO_CCCR_IOA, 0, &data);
  401502:	1dbb      	adds	r3, r7, #6
  401504:	9300      	str	r3, [sp, #0]
  401506:	2300      	movs	r3, #0
  401508:	2206      	movs	r2, #6
  40150a:	2100      	movs	r1, #0
  40150c:	2001      	movs	r0, #1
  40150e:	4c92      	ldr	r4, [pc, #584]	; (401758 <sd_mmc_mci_card_init+0x280>)
  401510:	47a0      	blx	r4
#endif

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  401512:	2100      	movs	r1, #0
  401514:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  401518:	4b90      	ldr	r3, [pc, #576]	; (40175c <sd_mmc_mci_card_init+0x284>)
  40151a:	4798      	blx	r3
  40151c:	4603      	mov	r3, r0
  40151e:	f083 0301 	eor.w	r3, r3, #1
  401522:	b2db      	uxtb	r3, r3
  401524:	2b00      	cmp	r3, #0
  401526:	d001      	beq.n	40152c <sd_mmc_mci_card_init+0x54>
		return false;
  401528:	2300      	movs	r3, #0
  40152a:	e10d      	b.n	401748 <sd_mmc_mci_card_init+0x270>
	}
	if (!sd_cmd8(&v2)) {
  40152c:	1dfb      	adds	r3, r7, #7
  40152e:	4618      	mov	r0, r3
  401530:	4b8b      	ldr	r3, [pc, #556]	; (401760 <sd_mmc_mci_card_init+0x288>)
  401532:	4798      	blx	r3
  401534:	4603      	mov	r3, r0
  401536:	f083 0301 	eor.w	r3, r3, #1
  40153a:	b2db      	uxtb	r3, r3
  40153c:	2b00      	cmp	r3, #0
  40153e:	d001      	beq.n	401544 <sd_mmc_mci_card_init+0x6c>
		return false;
  401540:	2300      	movs	r3, #0
  401542:	e101      	b.n	401748 <sd_mmc_mci_card_init+0x270>
	}
	// Try to get the SDIO card's operating condition
	if (!sdio_op_cond()) {
  401544:	4b87      	ldr	r3, [pc, #540]	; (401764 <sd_mmc_mci_card_init+0x28c>)
  401546:	4798      	blx	r3
  401548:	4603      	mov	r3, r0
  40154a:	f083 0301 	eor.w	r3, r3, #1
  40154e:	b2db      	uxtb	r3, r3
  401550:	2b00      	cmp	r3, #0
  401552:	d001      	beq.n	401558 <sd_mmc_mci_card_init+0x80>
		return false;
  401554:	2300      	movs	r3, #0
  401556:	e0f7      	b.n	401748 <sd_mmc_mci_card_init+0x270>
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
  401558:	4b7d      	ldr	r3, [pc, #500]	; (401750 <sd_mmc_mci_card_init+0x278>)
  40155a:	681b      	ldr	r3, [r3, #0]
  40155c:	7adb      	ldrb	r3, [r3, #11]
  40155e:	f003 0301 	and.w	r3, r3, #1
  401562:	2b00      	cmp	r3, #0
  401564:	d011      	beq.n	40158a <sd_mmc_mci_card_init+0xb2>
		// Try to get the SD card's operating condition
		if (!sd_mci_op_cond(v2)) {
  401566:	79fb      	ldrb	r3, [r7, #7]
  401568:	4618      	mov	r0, r3
  40156a:	4b7f      	ldr	r3, [pc, #508]	; (401768 <sd_mmc_mci_card_init+0x290>)
  40156c:	4798      	blx	r3
  40156e:	4603      	mov	r3, r0
  401570:	f083 0301 	eor.w	r3, r3, #1
  401574:	b2db      	uxtb	r3, r3
  401576:	2b00      	cmp	r3, #0
  401578:	d007      	beq.n	40158a <sd_mmc_mci_card_init+0xb2>
			// It is not a SD card
			sd_mmc_debug("Start MMC Install\n\r");
			sd_mmc_card->type = CARD_TYPE_MMC;
  40157a:	4b75      	ldr	r3, [pc, #468]	; (401750 <sd_mmc_mci_card_init+0x278>)
  40157c:	681b      	ldr	r3, [r3, #0]
  40157e:	2202      	movs	r2, #2
  401580:	72da      	strb	r2, [r3, #11]
			return sd_mmc_mci_install_mmc();
  401582:	4b7a      	ldr	r3, [pc, #488]	; (40176c <sd_mmc_mci_card_init+0x294>)
  401584:	4798      	blx	r3
  401586:	4603      	mov	r3, r0
  401588:	e0de      	b.n	401748 <sd_mmc_mci_card_init+0x270>
		}
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
  40158a:	4b71      	ldr	r3, [pc, #452]	; (401750 <sd_mmc_mci_card_init+0x278>)
  40158c:	681b      	ldr	r3, [r3, #0]
  40158e:	7adb      	ldrb	r3, [r3, #11]
  401590:	f003 0301 	and.w	r3, r3, #1
  401594:	2b00      	cmp	r3, #0
  401596:	d00c      	beq.n	4015b2 <sd_mmc_mci_card_init+0xda>
		// SD MEMORY, Put the Card in Identify Mode
		// Note: The CID is not used in this stack
		if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
  401598:	2100      	movs	r1, #0
  40159a:	f645 3002 	movw	r0, #23298	; 0x5b02
  40159e:	4b6f      	ldr	r3, [pc, #444]	; (40175c <sd_mmc_mci_card_init+0x284>)
  4015a0:	4798      	blx	r3
  4015a2:	4603      	mov	r3, r0
  4015a4:	f083 0301 	eor.w	r3, r3, #1
  4015a8:	b2db      	uxtb	r3, r3
  4015aa:	2b00      	cmp	r3, #0
  4015ac:	d001      	beq.n	4015b2 <sd_mmc_mci_card_init+0xda>
			return false;
  4015ae:	2300      	movs	r3, #0
  4015b0:	e0ca      	b.n	401748 <sd_mmc_mci_card_init+0x270>
		}
	}
	// Ask the card to publish a new relative address (RCA).
	if (!driver_send_cmd(SD_CMD3_SEND_RELATIVE_ADDR, 0)) {
  4015b2:	2100      	movs	r1, #0
  4015b4:	f245 1003 	movw	r0, #20739	; 0x5103
  4015b8:	4b68      	ldr	r3, [pc, #416]	; (40175c <sd_mmc_mci_card_init+0x284>)
  4015ba:	4798      	blx	r3
  4015bc:	4603      	mov	r3, r0
  4015be:	f083 0301 	eor.w	r3, r3, #1
  4015c2:	b2db      	uxtb	r3, r3
  4015c4:	2b00      	cmp	r3, #0
  4015c6:	d001      	beq.n	4015cc <sd_mmc_mci_card_init+0xf4>
		return false;
  4015c8:	2300      	movs	r3, #0
  4015ca:	e0bd      	b.n	401748 <sd_mmc_mci_card_init+0x270>
	}
	sd_mmc_card->rca = (driver_get_response() >> 16) & 0xFFFF;
  4015cc:	4b60      	ldr	r3, [pc, #384]	; (401750 <sd_mmc_mci_card_init+0x278>)
  4015ce:	681c      	ldr	r4, [r3, #0]
  4015d0:	4b67      	ldr	r3, [pc, #412]	; (401770 <sd_mmc_mci_card_init+0x298>)
  4015d2:	4798      	blx	r3
  4015d4:	4603      	mov	r3, r0
  4015d6:	0c1b      	lsrs	r3, r3, #16
  4015d8:	b29b      	uxth	r3, r3
  4015da:	8123      	strh	r3, [r4, #8]

	// SD MEMORY, Get the Card-Specific Data
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  4015dc:	4b5c      	ldr	r3, [pc, #368]	; (401750 <sd_mmc_mci_card_init+0x278>)
  4015de:	681b      	ldr	r3, [r3, #0]
  4015e0:	7adb      	ldrb	r3, [r3, #11]
  4015e2:	f003 0301 	and.w	r3, r3, #1
  4015e6:	2b00      	cmp	r3, #0
  4015e8:	d00b      	beq.n	401602 <sd_mmc_mci_card_init+0x12a>
		if (!sd_mmc_cmd9_mci()) {
  4015ea:	4b62      	ldr	r3, [pc, #392]	; (401774 <sd_mmc_mci_card_init+0x29c>)
  4015ec:	4798      	blx	r3
  4015ee:	4603      	mov	r3, r0
  4015f0:	f083 0301 	eor.w	r3, r3, #1
  4015f4:	b2db      	uxtb	r3, r3
  4015f6:	2b00      	cmp	r3, #0
  4015f8:	d001      	beq.n	4015fe <sd_mmc_mci_card_init+0x126>
			return false;
  4015fa:	2300      	movs	r3, #0
  4015fc:	e0a4      	b.n	401748 <sd_mmc_mci_card_init+0x270>
		}
		sd_decode_csd();
  4015fe:	4b5e      	ldr	r3, [pc, #376]	; (401778 <sd_mmc_mci_card_init+0x2a0>)
  401600:	4798      	blx	r3
	}
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
			(uint32_t)sd_mmc_card->rca << 16)) {
  401602:	4b53      	ldr	r3, [pc, #332]	; (401750 <sd_mmc_mci_card_init+0x278>)
  401604:	681b      	ldr	r3, [r3, #0]
  401606:	891b      	ldrh	r3, [r3, #8]
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
  401608:	041b      	lsls	r3, r3, #16
  40160a:	4619      	mov	r1, r3
  40160c:	f243 1007 	movw	r0, #12551	; 0x3107
  401610:	4b52      	ldr	r3, [pc, #328]	; (40175c <sd_mmc_mci_card_init+0x284>)
  401612:	4798      	blx	r3
  401614:	4603      	mov	r3, r0
  401616:	f083 0301 	eor.w	r3, r3, #1
  40161a:	b2db      	uxtb	r3, r3
  40161c:	2b00      	cmp	r3, #0
  40161e:	d001      	beq.n	401624 <sd_mmc_mci_card_init+0x14c>
		return false;
  401620:	2300      	movs	r3, #0
  401622:	e091      	b.n	401748 <sd_mmc_mci_card_init+0x270>
	}
	// SD MEMORY, Read the SCR to get card version
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  401624:	4b4a      	ldr	r3, [pc, #296]	; (401750 <sd_mmc_mci_card_init+0x278>)
  401626:	681b      	ldr	r3, [r3, #0]
  401628:	7adb      	ldrb	r3, [r3, #11]
  40162a:	f003 0301 	and.w	r3, r3, #1
  40162e:	2b00      	cmp	r3, #0
  401630:	d009      	beq.n	401646 <sd_mmc_mci_card_init+0x16e>
		if (!sd_acmd51()) {
  401632:	4b52      	ldr	r3, [pc, #328]	; (40177c <sd_mmc_mci_card_init+0x2a4>)
  401634:	4798      	blx	r3
  401636:	4603      	mov	r3, r0
  401638:	f083 0301 	eor.w	r3, r3, #1
  40163c:	b2db      	uxtb	r3, r3
  40163e:	2b00      	cmp	r3, #0
  401640:	d001      	beq.n	401646 <sd_mmc_mci_card_init+0x16e>
			return false;
  401642:	2300      	movs	r3, #0
  401644:	e080      	b.n	401748 <sd_mmc_mci_card_init+0x270>
		}
	}
	if (IS_SDIO()) {
  401646:	4b42      	ldr	r3, [pc, #264]	; (401750 <sd_mmc_mci_card_init+0x278>)
  401648:	681b      	ldr	r3, [r3, #0]
  40164a:	7adb      	ldrb	r3, [r3, #11]
  40164c:	f003 0304 	and.w	r3, r3, #4
  401650:	2b00      	cmp	r3, #0
  401652:	d009      	beq.n	401668 <sd_mmc_mci_card_init+0x190>
		if (!sdio_get_max_speed()) {
  401654:	4b4a      	ldr	r3, [pc, #296]	; (401780 <sd_mmc_mci_card_init+0x2a8>)
  401656:	4798      	blx	r3
  401658:	4603      	mov	r3, r0
  40165a:	f083 0301 	eor.w	r3, r3, #1
  40165e:	b2db      	uxtb	r3, r3
  401660:	2b00      	cmp	r3, #0
  401662:	d001      	beq.n	401668 <sd_mmc_mci_card_init+0x190>
			return false;
  401664:	2300      	movs	r3, #0
  401666:	e06f      	b.n	401748 <sd_mmc_mci_card_init+0x270>
		}
	}
	if ((4 <= driver_get_bus_width(sd_mmc_slot_sel))) {
  401668:	4b46      	ldr	r3, [pc, #280]	; (401784 <sd_mmc_mci_card_init+0x2ac>)
  40166a:	781b      	ldrb	r3, [r3, #0]
  40166c:	4618      	mov	r0, r3
  40166e:	4b46      	ldr	r3, [pc, #280]	; (401788 <sd_mmc_mci_card_init+0x2b0>)
  401670:	4798      	blx	r3
  401672:	4603      	mov	r3, r0
  401674:	2b03      	cmp	r3, #3
  401676:	d923      	bls.n	4016c0 <sd_mmc_mci_card_init+0x1e8>
		// TRY to enable 4-bit mode
		if (IS_SDIO()) {
  401678:	4b35      	ldr	r3, [pc, #212]	; (401750 <sd_mmc_mci_card_init+0x278>)
  40167a:	681b      	ldr	r3, [r3, #0]
  40167c:	7adb      	ldrb	r3, [r3, #11]
  40167e:	f003 0304 	and.w	r3, r3, #4
  401682:	2b00      	cmp	r3, #0
  401684:	d009      	beq.n	40169a <sd_mmc_mci_card_init+0x1c2>
			if (!sdio_cmd52_set_bus_width()) {
  401686:	4b41      	ldr	r3, [pc, #260]	; (40178c <sd_mmc_mci_card_init+0x2b4>)
  401688:	4798      	blx	r3
  40168a:	4603      	mov	r3, r0
  40168c:	f083 0301 	eor.w	r3, r3, #1
  401690:	b2db      	uxtb	r3, r3
  401692:	2b00      	cmp	r3, #0
  401694:	d001      	beq.n	40169a <sd_mmc_mci_card_init+0x1c2>
				return false;
  401696:	2300      	movs	r3, #0
  401698:	e056      	b.n	401748 <sd_mmc_mci_card_init+0x270>
			}
		}
		if (sd_mmc_card->type & CARD_TYPE_SD) {
  40169a:	4b2d      	ldr	r3, [pc, #180]	; (401750 <sd_mmc_mci_card_init+0x278>)
  40169c:	681b      	ldr	r3, [r3, #0]
  40169e:	7adb      	ldrb	r3, [r3, #11]
  4016a0:	f003 0301 	and.w	r3, r3, #1
  4016a4:	2b00      	cmp	r3, #0
  4016a6:	d009      	beq.n	4016bc <sd_mmc_mci_card_init+0x1e4>
			if (!sd_acmd6()) {
  4016a8:	4b39      	ldr	r3, [pc, #228]	; (401790 <sd_mmc_mci_card_init+0x2b8>)
  4016aa:	4798      	blx	r3
  4016ac:	4603      	mov	r3, r0
  4016ae:	f083 0301 	eor.w	r3, r3, #1
  4016b2:	b2db      	uxtb	r3, r3
  4016b4:	2b00      	cmp	r3, #0
  4016b6:	d001      	beq.n	4016bc <sd_mmc_mci_card_init+0x1e4>
				return false;
  4016b8:	2300      	movs	r3, #0
  4016ba:	e045      	b.n	401748 <sd_mmc_mci_card_init+0x270>
			}
		}
		// Switch to selected bus mode
		sd_mmc_configure_slot();
  4016bc:	4b35      	ldr	r3, [pc, #212]	; (401794 <sd_mmc_mci_card_init+0x2bc>)
  4016be:	4798      	blx	r3
	}
	if (driver_is_high_speed_capable()) {
  4016c0:	4b35      	ldr	r3, [pc, #212]	; (401798 <sd_mmc_mci_card_init+0x2c0>)
  4016c2:	4798      	blx	r3
  4016c4:	4603      	mov	r3, r0
  4016c6:	2b00      	cmp	r3, #0
  4016c8:	d028      	beq.n	40171c <sd_mmc_mci_card_init+0x244>
		// TRY to enable High-Speed Mode
		if (IS_SDIO()) {
  4016ca:	4b21      	ldr	r3, [pc, #132]	; (401750 <sd_mmc_mci_card_init+0x278>)
  4016cc:	681b      	ldr	r3, [r3, #0]
  4016ce:	7adb      	ldrb	r3, [r3, #11]
  4016d0:	f003 0304 	and.w	r3, r3, #4
  4016d4:	2b00      	cmp	r3, #0
  4016d6:	d009      	beq.n	4016ec <sd_mmc_mci_card_init+0x214>
			if (!sdio_cmd52_set_high_speed()) {
  4016d8:	4b30      	ldr	r3, [pc, #192]	; (40179c <sd_mmc_mci_card_init+0x2c4>)
  4016da:	4798      	blx	r3
  4016dc:	4603      	mov	r3, r0
  4016de:	f083 0301 	eor.w	r3, r3, #1
  4016e2:	b2db      	uxtb	r3, r3
  4016e4:	2b00      	cmp	r3, #0
  4016e6:	d001      	beq.n	4016ec <sd_mmc_mci_card_init+0x214>
				return false;
  4016e8:	2300      	movs	r3, #0
  4016ea:	e02d      	b.n	401748 <sd_mmc_mci_card_init+0x270>
			}
		}
		if (sd_mmc_card->type & CARD_TYPE_SD) {
  4016ec:	4b18      	ldr	r3, [pc, #96]	; (401750 <sd_mmc_mci_card_init+0x278>)
  4016ee:	681b      	ldr	r3, [r3, #0]
  4016f0:	7adb      	ldrb	r3, [r3, #11]
  4016f2:	f003 0301 	and.w	r3, r3, #1
  4016f6:	2b00      	cmp	r3, #0
  4016f8:	d00e      	beq.n	401718 <sd_mmc_mci_card_init+0x240>
			if (sd_mmc_card->version > CARD_VER_SD_1_0) {
  4016fa:	4b15      	ldr	r3, [pc, #84]	; (401750 <sd_mmc_mci_card_init+0x278>)
  4016fc:	681b      	ldr	r3, [r3, #0]
  4016fe:	7b1b      	ldrb	r3, [r3, #12]
  401700:	2b10      	cmp	r3, #16
  401702:	d909      	bls.n	401718 <sd_mmc_mci_card_init+0x240>
				if (!sd_cm6_set_high_speed()) {
  401704:	4b26      	ldr	r3, [pc, #152]	; (4017a0 <sd_mmc_mci_card_init+0x2c8>)
  401706:	4798      	blx	r3
  401708:	4603      	mov	r3, r0
  40170a:	f083 0301 	eor.w	r3, r3, #1
  40170e:	b2db      	uxtb	r3, r3
  401710:	2b00      	cmp	r3, #0
  401712:	d001      	beq.n	401718 <sd_mmc_mci_card_init+0x240>
					return false;
  401714:	2300      	movs	r3, #0
  401716:	e017      	b.n	401748 <sd_mmc_mci_card_init+0x270>
				}
			}
		}
		// Valid new configuration
		sd_mmc_configure_slot();
  401718:	4b1e      	ldr	r3, [pc, #120]	; (401794 <sd_mmc_mci_card_init+0x2bc>)
  40171a:	4798      	blx	r3
	}
	// SD MEMORY, Set default block size
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  40171c:	4b0c      	ldr	r3, [pc, #48]	; (401750 <sd_mmc_mci_card_init+0x278>)
  40171e:	681b      	ldr	r3, [r3, #0]
  401720:	7adb      	ldrb	r3, [r3, #11]
  401722:	f003 0301 	and.w	r3, r3, #1
  401726:	2b00      	cmp	r3, #0
  401728:	d00d      	beq.n	401746 <sd_mmc_mci_card_init+0x26e>
		if (!driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
  40172a:	f44f 7100 	mov.w	r1, #512	; 0x200
  40172e:	f241 1010 	movw	r0, #4368	; 0x1110
  401732:	4b0a      	ldr	r3, [pc, #40]	; (40175c <sd_mmc_mci_card_init+0x284>)
  401734:	4798      	blx	r3
  401736:	4603      	mov	r3, r0
  401738:	f083 0301 	eor.w	r3, r3, #1
  40173c:	b2db      	uxtb	r3, r3
  40173e:	2b00      	cmp	r3, #0
  401740:	d001      	beq.n	401746 <sd_mmc_mci_card_init+0x26e>
			return false;
  401742:	2300      	movs	r3, #0
  401744:	e000      	b.n	401748 <sd_mmc_mci_card_init+0x270>
		}
	}
	return true;
  401746:	2301      	movs	r3, #1
}
  401748:	4618      	mov	r0, r3
  40174a:	370c      	adds	r7, #12
  40174c:	46bd      	mov	sp, r7
  40174e:	bd90      	pop	{r4, r7, pc}
  401750:	2000047c 	.word	0x2000047c
  401754:	004022f5 	.word	0x004022f5
  401758:	00401209 	.word	0x00401209
  40175c:	00402331 	.word	0x00402331
  401760:	00400e41 	.word	0x00400e41
  401764:	00400991 	.word	0x00400991
  401768:	004008e9 	.word	0x004008e9
  40176c:	004017a5 	.word	0x004017a5
  401770:	00402375 	.word	0x00402375
  401774:	00400f9d 	.word	0x00400f9d
  401778:	00401119 	.word	0x00401119
  40177c:	004012cd 	.word	0x004012cd
  401780:	00400a39 	.word	0x00400a39
  401784:	20000478 	.word	0x20000478
  401788:	00402211 	.word	0x00402211
  40178c:	00400b85 	.word	0x00400b85
  401790:	00401275 	.word	0x00401275
  401794:	0040147d 	.word	0x0040147d
  401798:	00402233 	.word	0x00402233
  40179c:	00400bf5 	.word	0x00400bf5
  4017a0:	00400c75 	.word	0x00400c75

004017a4 <sd_mmc_mci_install_mmc>:
 * At last, it will automaticly enable maximum bus width and transfer speed.
 *
 * \return true if success, otherwise false
 */
static bool sd_mmc_mci_install_mmc(void)
{
  4017a4:	b580      	push	{r7, lr}
  4017a6:	b082      	sub	sp, #8
  4017a8:	af00      	add	r7, sp, #0
	uint8_t b_authorize_high_speed;

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  4017aa:	2100      	movs	r1, #0
  4017ac:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  4017b0:	4b56      	ldr	r3, [pc, #344]	; (40190c <sd_mmc_mci_install_mmc+0x168>)
  4017b2:	4798      	blx	r3
  4017b4:	4603      	mov	r3, r0
  4017b6:	f083 0301 	eor.w	r3, r3, #1
  4017ba:	b2db      	uxtb	r3, r3
  4017bc:	2b00      	cmp	r3, #0
  4017be:	d001      	beq.n	4017c4 <sd_mmc_mci_install_mmc+0x20>
		return false;
  4017c0:	2300      	movs	r3, #0
  4017c2:	e09f      	b.n	401904 <sd_mmc_mci_install_mmc+0x160>
	}

	if (!mmc_mci_op_cond()) {
  4017c4:	4b52      	ldr	r3, [pc, #328]	; (401910 <sd_mmc_mci_install_mmc+0x16c>)
  4017c6:	4798      	blx	r3
  4017c8:	4603      	mov	r3, r0
  4017ca:	f083 0301 	eor.w	r3, r3, #1
  4017ce:	b2db      	uxtb	r3, r3
  4017d0:	2b00      	cmp	r3, #0
  4017d2:	d001      	beq.n	4017d8 <sd_mmc_mci_install_mmc+0x34>
		return false;
  4017d4:	2300      	movs	r3, #0
  4017d6:	e095      	b.n	401904 <sd_mmc_mci_install_mmc+0x160>
	}

	// Put the Card in Identify Mode
	// Note: The CID is not used in this stack
	if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
  4017d8:	2100      	movs	r1, #0
  4017da:	f645 3002 	movw	r0, #23298	; 0x5b02
  4017de:	4b4b      	ldr	r3, [pc, #300]	; (40190c <sd_mmc_mci_install_mmc+0x168>)
  4017e0:	4798      	blx	r3
  4017e2:	4603      	mov	r3, r0
  4017e4:	f083 0301 	eor.w	r3, r3, #1
  4017e8:	b2db      	uxtb	r3, r3
  4017ea:	2b00      	cmp	r3, #0
  4017ec:	d001      	beq.n	4017f2 <sd_mmc_mci_install_mmc+0x4e>
		return false;
  4017ee:	2300      	movs	r3, #0
  4017f0:	e088      	b.n	401904 <sd_mmc_mci_install_mmc+0x160>
	}
	// Assign relative address to the card.
	sd_mmc_card->rca = 1;
  4017f2:	4b48      	ldr	r3, [pc, #288]	; (401914 <sd_mmc_mci_install_mmc+0x170>)
  4017f4:	681b      	ldr	r3, [r3, #0]
  4017f6:	2201      	movs	r2, #1
  4017f8:	811a      	strh	r2, [r3, #8]
	if (!driver_send_cmd(MMC_CMD3_SET_RELATIVE_ADDR,
			(uint32_t)sd_mmc_card->rca << 16)) {
  4017fa:	4b46      	ldr	r3, [pc, #280]	; (401914 <sd_mmc_mci_install_mmc+0x170>)
  4017fc:	681b      	ldr	r3, [r3, #0]
  4017fe:	891b      	ldrh	r3, [r3, #8]
	if (!driver_send_cmd(MMC_CMD3_SET_RELATIVE_ADDR,
  401800:	041b      	lsls	r3, r3, #16
  401802:	4619      	mov	r1, r3
  401804:	f241 1003 	movw	r0, #4355	; 0x1103
  401808:	4b40      	ldr	r3, [pc, #256]	; (40190c <sd_mmc_mci_install_mmc+0x168>)
  40180a:	4798      	blx	r3
  40180c:	4603      	mov	r3, r0
  40180e:	f083 0301 	eor.w	r3, r3, #1
  401812:	b2db      	uxtb	r3, r3
  401814:	2b00      	cmp	r3, #0
  401816:	d001      	beq.n	40181c <sd_mmc_mci_install_mmc+0x78>
		return false;
  401818:	2300      	movs	r3, #0
  40181a:	e073      	b.n	401904 <sd_mmc_mci_install_mmc+0x160>
	}
	// Get the Card-Specific Data
	if (!sd_mmc_cmd9_mci()) {
  40181c:	4b3e      	ldr	r3, [pc, #248]	; (401918 <sd_mmc_mci_install_mmc+0x174>)
  40181e:	4798      	blx	r3
  401820:	4603      	mov	r3, r0
  401822:	f083 0301 	eor.w	r3, r3, #1
  401826:	b2db      	uxtb	r3, r3
  401828:	2b00      	cmp	r3, #0
  40182a:	d001      	beq.n	401830 <sd_mmc_mci_install_mmc+0x8c>
		return false;
  40182c:	2300      	movs	r3, #0
  40182e:	e069      	b.n	401904 <sd_mmc_mci_install_mmc+0x160>
	}
	mmc_decode_csd();
  401830:	4b3a      	ldr	r3, [pc, #232]	; (40191c <sd_mmc_mci_install_mmc+0x178>)
  401832:	4798      	blx	r3
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
			(uint32_t)sd_mmc_card->rca << 16)) {
  401834:	4b37      	ldr	r3, [pc, #220]	; (401914 <sd_mmc_mci_install_mmc+0x170>)
  401836:	681b      	ldr	r3, [r3, #0]
  401838:	891b      	ldrh	r3, [r3, #8]
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
  40183a:	041b      	lsls	r3, r3, #16
  40183c:	4619      	mov	r1, r3
  40183e:	f243 1007 	movw	r0, #12551	; 0x3107
  401842:	4b32      	ldr	r3, [pc, #200]	; (40190c <sd_mmc_mci_install_mmc+0x168>)
  401844:	4798      	blx	r3
  401846:	4603      	mov	r3, r0
  401848:	f083 0301 	eor.w	r3, r3, #1
  40184c:	b2db      	uxtb	r3, r3
  40184e:	2b00      	cmp	r3, #0
  401850:	d001      	beq.n	401856 <sd_mmc_mci_install_mmc+0xb2>
		return false;
  401852:	2300      	movs	r3, #0
  401854:	e056      	b.n	401904 <sd_mmc_mci_install_mmc+0x160>
	}
	if (sd_mmc_card->version >= CARD_VER_MMC_4) {
  401856:	4b2f      	ldr	r3, [pc, #188]	; (401914 <sd_mmc_mci_install_mmc+0x170>)
  401858:	681b      	ldr	r3, [r3, #0]
  40185a:	7b1b      	ldrb	r3, [r3, #12]
  40185c:	2b3f      	cmp	r3, #63	; 0x3f
  40185e:	d93b      	bls.n	4018d8 <sd_mmc_mci_install_mmc+0x134>
		// For MMC 4.0 Higher version
		// Get EXT_CSD
		if (!mmc_cmd8(&b_authorize_high_speed)) {
  401860:	1dbb      	adds	r3, r7, #6
  401862:	4618      	mov	r0, r3
  401864:	4b2e      	ldr	r3, [pc, #184]	; (401920 <sd_mmc_mci_install_mmc+0x17c>)
  401866:	4798      	blx	r3
  401868:	4603      	mov	r3, r0
  40186a:	f083 0301 	eor.w	r3, r3, #1
  40186e:	b2db      	uxtb	r3, r3
  401870:	2b00      	cmp	r3, #0
  401872:	d001      	beq.n	401878 <sd_mmc_mci_install_mmc+0xd4>
			return false;
  401874:	2300      	movs	r3, #0
  401876:	e045      	b.n	401904 <sd_mmc_mci_install_mmc+0x160>
		}
		if (4 <= driver_get_bus_width(sd_mmc_slot_sel)) {
  401878:	4b2a      	ldr	r3, [pc, #168]	; (401924 <sd_mmc_mci_install_mmc+0x180>)
  40187a:	781b      	ldrb	r3, [r3, #0]
  40187c:	4618      	mov	r0, r3
  40187e:	4b2a      	ldr	r3, [pc, #168]	; (401928 <sd_mmc_mci_install_mmc+0x184>)
  401880:	4798      	blx	r3
  401882:	4603      	mov	r3, r0
  401884:	2b03      	cmp	r3, #3
  401886:	d912      	bls.n	4018ae <sd_mmc_mci_install_mmc+0x10a>
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
  401888:	4b26      	ldr	r3, [pc, #152]	; (401924 <sd_mmc_mci_install_mmc+0x180>)
  40188a:	781b      	ldrb	r3, [r3, #0]
  40188c:	4618      	mov	r0, r3
  40188e:	4b26      	ldr	r3, [pc, #152]	; (401928 <sd_mmc_mci_install_mmc+0x184>)
  401890:	4798      	blx	r3
  401892:	4603      	mov	r3, r0
  401894:	4618      	mov	r0, r3
  401896:	4b25      	ldr	r3, [pc, #148]	; (40192c <sd_mmc_mci_install_mmc+0x188>)
  401898:	4798      	blx	r3
  40189a:	4603      	mov	r3, r0
  40189c:	f083 0301 	eor.w	r3, r3, #1
  4018a0:	b2db      	uxtb	r3, r3
  4018a2:	2b00      	cmp	r3, #0
  4018a4:	d001      	beq.n	4018aa <sd_mmc_mci_install_mmc+0x106>
				return false;
  4018a6:	2300      	movs	r3, #0
  4018a8:	e02c      	b.n	401904 <sd_mmc_mci_install_mmc+0x160>
			}
			// Reinitialize the slot with the bus width
			sd_mmc_configure_slot();
  4018aa:	4b21      	ldr	r3, [pc, #132]	; (401930 <sd_mmc_mci_install_mmc+0x18c>)
  4018ac:	4798      	blx	r3
		}
		if (driver_is_high_speed_capable() && b_authorize_high_speed) {
  4018ae:	4b21      	ldr	r3, [pc, #132]	; (401934 <sd_mmc_mci_install_mmc+0x190>)
  4018b0:	4798      	blx	r3
  4018b2:	4603      	mov	r3, r0
  4018b4:	2b00      	cmp	r3, #0
  4018b6:	d011      	beq.n	4018dc <sd_mmc_mci_install_mmc+0x138>
  4018b8:	79bb      	ldrb	r3, [r7, #6]
  4018ba:	2b00      	cmp	r3, #0
  4018bc:	d00e      	beq.n	4018dc <sd_mmc_mci_install_mmc+0x138>
			// Enable HS
			if (!mmc_cmd6_set_high_speed()) {
  4018be:	4b1e      	ldr	r3, [pc, #120]	; (401938 <sd_mmc_mci_install_mmc+0x194>)
  4018c0:	4798      	blx	r3
  4018c2:	4603      	mov	r3, r0
  4018c4:	f083 0301 	eor.w	r3, r3, #1
  4018c8:	b2db      	uxtb	r3, r3
  4018ca:	2b00      	cmp	r3, #0
  4018cc:	d001      	beq.n	4018d2 <sd_mmc_mci_install_mmc+0x12e>
				return false;
  4018ce:	2300      	movs	r3, #0
  4018d0:	e018      	b.n	401904 <sd_mmc_mci_install_mmc+0x160>
			}
			// Reinitialize the slot with the new speed
			sd_mmc_configure_slot();
  4018d2:	4b17      	ldr	r3, [pc, #92]	; (401930 <sd_mmc_mci_install_mmc+0x18c>)
  4018d4:	4798      	blx	r3
  4018d6:	e001      	b.n	4018dc <sd_mmc_mci_install_mmc+0x138>
		}
	} else {
		// Reinitialize the slot with the new speed
		sd_mmc_configure_slot();
  4018d8:	4b15      	ldr	r3, [pc, #84]	; (401930 <sd_mmc_mci_install_mmc+0x18c>)
  4018da:	4798      	blx	r3
	}

	uint8_t retry = 10;
  4018dc:	230a      	movs	r3, #10
  4018de:	71fb      	strb	r3, [r7, #7]
	while (retry--) {
  4018e0:	e00a      	b.n	4018f8 <sd_mmc_mci_install_mmc+0x154>
		// Retry is a WORKAROUND for no compliance card (Atmel Internal ref. MMC19):
		// These cards seem not ready immediatly
		// after the end of busy of mmc_cmd6_set_high_speed()

		// Set default block size
		if (driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
  4018e2:	f44f 7100 	mov.w	r1, #512	; 0x200
  4018e6:	f241 1010 	movw	r0, #4368	; 0x1110
  4018ea:	4b08      	ldr	r3, [pc, #32]	; (40190c <sd_mmc_mci_install_mmc+0x168>)
  4018ec:	4798      	blx	r3
  4018ee:	4603      	mov	r3, r0
  4018f0:	2b00      	cmp	r3, #0
  4018f2:	d001      	beq.n	4018f8 <sd_mmc_mci_install_mmc+0x154>
			return true;
  4018f4:	2301      	movs	r3, #1
  4018f6:	e005      	b.n	401904 <sd_mmc_mci_install_mmc+0x160>
	while (retry--) {
  4018f8:	79fb      	ldrb	r3, [r7, #7]
  4018fa:	1e5a      	subs	r2, r3, #1
  4018fc:	71fa      	strb	r2, [r7, #7]
  4018fe:	2b00      	cmp	r3, #0
  401900:	d1ef      	bne.n	4018e2 <sd_mmc_mci_install_mmc+0x13e>
		}
	}
	return false;
  401902:	2300      	movs	r3, #0
}
  401904:	4618      	mov	r0, r3
  401906:	3708      	adds	r7, #8
  401908:	46bd      	mov	sp, r7
  40190a:	bd80      	pop	{r7, pc}
  40190c:	00402331 	.word	0x00402331
  401910:	0040086d 	.word	0x0040086d
  401914:	2000047c 	.word	0x2000047c
  401918:	00400f9d 	.word	0x00400f9d
  40191c:	00400fe1 	.word	0x00400fe1
  401920:	00400ea5 	.word	0x00400ea5
  401924:	20000478 	.word	0x20000478
  401928:	00402211 	.word	0x00402211
  40192c:	00400d69 	.word	0x00400d69
  401930:	0040147d 	.word	0x0040147d
  401934:	00402233 	.word	0x00402233
  401938:	00400de5 	.word	0x00400de5

0040193c <sd_mmc_init>:

//-------------------------------------------------------------------
//--------------------- PUBLIC FUNCTIONS ----------------------------

void sd_mmc_init(void)
{
  40193c:	b580      	push	{r7, lr}
  40193e:	b082      	sub	sp, #8
  401940:	af00      	add	r7, sp, #0
# define SD_MMC_ENABLE_WP_PIN(slot, unused) \
	pmc_enable_periph_clk(SD_MMC_##slot##_WP_PIO_ID);
	MREPEAT(SD_MMC_MEM_CNT, SD_MMC_ENABLE_WP_PIN, ~)
# undef SD_MMC_ENABLE_WP_PIN
#endif
	for (uint8_t slot = 0; slot < SD_MMC_MEM_CNT; slot++) {
  401942:	2300      	movs	r3, #0
  401944:	71fb      	strb	r3, [r7, #7]
  401946:	e009      	b.n	40195c <sd_mmc_init+0x20>
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
  401948:	79fb      	ldrb	r3, [r7, #7]
  40194a:	4a0a      	ldr	r2, [pc, #40]	; (401974 <sd_mmc_init+0x38>)
  40194c:	015b      	lsls	r3, r3, #5
  40194e:	4413      	add	r3, r2
  401950:	330a      	adds	r3, #10
  401952:	2204      	movs	r2, #4
  401954:	701a      	strb	r2, [r3, #0]
	for (uint8_t slot = 0; slot < SD_MMC_MEM_CNT; slot++) {
  401956:	79fb      	ldrb	r3, [r7, #7]
  401958:	3301      	adds	r3, #1
  40195a:	71fb      	strb	r3, [r7, #7]
  40195c:	79fb      	ldrb	r3, [r7, #7]
  40195e:	2b00      	cmp	r3, #0
  401960:	d0f2      	beq.n	401948 <sd_mmc_init+0xc>
	}
	sd_mmc_slot_sel = 0xFF; // No slot configurated
  401962:	4b05      	ldr	r3, [pc, #20]	; (401978 <sd_mmc_init+0x3c>)
  401964:	22ff      	movs	r2, #255	; 0xff
  401966:	701a      	strb	r2, [r3, #0]
	driver_init();
  401968:	4b04      	ldr	r3, [pc, #16]	; (40197c <sd_mmc_init+0x40>)
  40196a:	4798      	blx	r3
}
  40196c:	bf00      	nop
  40196e:	3708      	adds	r7, #8
  401970:	46bd      	mov	sp, r7
  401972:	bd80      	pop	{r7, pc}
  401974:	20000458 	.word	0x20000458
  401978:	20000478 	.word	0x20000478
  40197c:	004021d9 	.word	0x004021d9

00401980 <sd_mmc_check>:
{
	return SD_MMC_MEM_CNT;
}

sd_mmc_err_t sd_mmc_check(uint8_t slot)
{
  401980:	b580      	push	{r7, lr}
  401982:	b084      	sub	sp, #16
  401984:	af00      	add	r7, sp, #0
  401986:	4603      	mov	r3, r0
  401988:	71fb      	strb	r3, [r7, #7]
	sd_mmc_err_t sd_mmc_err;

	sd_mmc_err = sd_mmc_select_slot(slot);
  40198a:	79fb      	ldrb	r3, [r7, #7]
  40198c:	4618      	mov	r0, r3
  40198e:	4b11      	ldr	r3, [pc, #68]	; (4019d4 <sd_mmc_check+0x54>)
  401990:	4798      	blx	r3
  401992:	4603      	mov	r3, r0
  401994:	73fb      	strb	r3, [r7, #15]
	if (sd_mmc_err != SD_MMC_INIT_ONGOING) {
  401996:	7bfb      	ldrb	r3, [r7, #15]
  401998:	2b01      	cmp	r3, #1
  40199a:	d003      	beq.n	4019a4 <sd_mmc_check+0x24>
		sd_mmc_deselect_slot();
  40199c:	4b0e      	ldr	r3, [pc, #56]	; (4019d8 <sd_mmc_check+0x58>)
  40199e:	4798      	blx	r3
		return sd_mmc_err;
  4019a0:	7bfb      	ldrb	r3, [r7, #15]
  4019a2:	e013      	b.n	4019cc <sd_mmc_check+0x4c>
	}

	// Initialization of the card requested
	if (sd_mmc_is_spi()? sd_mmc_spi_card_init()
			: sd_mmc_mci_card_init()) {
  4019a4:	4b0d      	ldr	r3, [pc, #52]	; (4019dc <sd_mmc_check+0x5c>)
  4019a6:	4798      	blx	r3
  4019a8:	4603      	mov	r3, r0
	if (sd_mmc_is_spi()? sd_mmc_spi_card_init()
  4019aa:	2b00      	cmp	r3, #0
  4019ac:	d007      	beq.n	4019be <sd_mmc_check+0x3e>
		sd_mmc_debug("SD/MMC card ready\n\r");
		sd_mmc_card->state = SD_MMC_CARD_STATE_READY;
  4019ae:	4b0c      	ldr	r3, [pc, #48]	; (4019e0 <sd_mmc_check+0x60>)
  4019b0:	681b      	ldr	r3, [r3, #0]
  4019b2:	2200      	movs	r2, #0
  4019b4:	729a      	strb	r2, [r3, #10]
		sd_mmc_deselect_slot();
  4019b6:	4b08      	ldr	r3, [pc, #32]	; (4019d8 <sd_mmc_check+0x58>)
  4019b8:	4798      	blx	r3
		// To notify that the card has been just initialized
		// It is necessary for USB Device MSC
		return SD_MMC_INIT_ONGOING;
  4019ba:	2301      	movs	r3, #1
  4019bc:	e006      	b.n	4019cc <sd_mmc_check+0x4c>
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
  4019be:	4b08      	ldr	r3, [pc, #32]	; (4019e0 <sd_mmc_check+0x60>)
  4019c0:	681b      	ldr	r3, [r3, #0]
  4019c2:	2203      	movs	r2, #3
  4019c4:	729a      	strb	r2, [r3, #10]
	sd_mmc_deselect_slot();
  4019c6:	4b04      	ldr	r3, [pc, #16]	; (4019d8 <sd_mmc_check+0x58>)
  4019c8:	4798      	blx	r3
	return SD_MMC_ERR_UNUSABLE;
  4019ca:	2303      	movs	r3, #3
}
  4019cc:	4618      	mov	r0, r3
  4019ce:	3710      	adds	r7, #16
  4019d0:	46bd      	mov	sp, r7
  4019d2:	bd80      	pop	{r7, pc}
  4019d4:	004013c9 	.word	0x004013c9
  4019d8:	004014b5 	.word	0x004014b5
  4019dc:	004014d9 	.word	0x004014d9
  4019e0:	2000047c 	.word	0x2000047c

004019e4 <sd_mmc_get_type>:

card_type_t sd_mmc_get_type(uint8_t slot)
{
  4019e4:	b580      	push	{r7, lr}
  4019e6:	b082      	sub	sp, #8
  4019e8:	af00      	add	r7, sp, #0
  4019ea:	4603      	mov	r3, r0
  4019ec:	71fb      	strb	r3, [r7, #7]
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
  4019ee:	79fb      	ldrb	r3, [r7, #7]
  4019f0:	4618      	mov	r0, r3
  4019f2:	4b08      	ldr	r3, [pc, #32]	; (401a14 <sd_mmc_get_type+0x30>)
  4019f4:	4798      	blx	r3
  4019f6:	4603      	mov	r3, r0
  4019f8:	2b00      	cmp	r3, #0
  4019fa:	d001      	beq.n	401a00 <sd_mmc_get_type+0x1c>
		return CARD_TYPE_UNKNOWN;
  4019fc:	2300      	movs	r3, #0
  4019fe:	e004      	b.n	401a0a <sd_mmc_get_type+0x26>
	}
	sd_mmc_deselect_slot();
  401a00:	4b05      	ldr	r3, [pc, #20]	; (401a18 <sd_mmc_get_type+0x34>)
  401a02:	4798      	blx	r3
	return sd_mmc_card->type;
  401a04:	4b05      	ldr	r3, [pc, #20]	; (401a1c <sd_mmc_get_type+0x38>)
  401a06:	681b      	ldr	r3, [r3, #0]
  401a08:	7adb      	ldrb	r3, [r3, #11]
}
  401a0a:	4618      	mov	r0, r3
  401a0c:	3708      	adds	r7, #8
  401a0e:	46bd      	mov	sp, r7
  401a10:	bd80      	pop	{r7, pc}
  401a12:	bf00      	nop
  401a14:	004013c9 	.word	0x004013c9
  401a18:	004014b5 	.word	0x004014b5
  401a1c:	2000047c 	.word	0x2000047c

00401a20 <sd_mmc_test_unit_ready>:
 */

static bool sd_mmc_ejected[2] = {false, false};

Ctrl_status sd_mmc_test_unit_ready(uint8_t slot)
{
  401a20:	b580      	push	{r7, lr}
  401a22:	b082      	sub	sp, #8
  401a24:	af00      	add	r7, sp, #0
  401a26:	4603      	mov	r3, r0
  401a28:	71fb      	strb	r3, [r7, #7]
	switch (sd_mmc_check(slot))
  401a2a:	79fb      	ldrb	r3, [r7, #7]
  401a2c:	4618      	mov	r0, r3
  401a2e:	4b15      	ldr	r3, [pc, #84]	; (401a84 <sd_mmc_test_unit_ready+0x64>)
  401a30:	4798      	blx	r3
  401a32:	4603      	mov	r3, r0
  401a34:	2b01      	cmp	r3, #1
  401a36:	d017      	beq.n	401a68 <sd_mmc_test_unit_ready+0x48>
  401a38:	2b02      	cmp	r3, #2
  401a3a:	d017      	beq.n	401a6c <sd_mmc_test_unit_ready+0x4c>
  401a3c:	2b00      	cmp	r3, #0
  401a3e:	d11b      	bne.n	401a78 <sd_mmc_test_unit_ready+0x58>
	{
	case SD_MMC_OK:
		if (sd_mmc_ejected[slot]) {
  401a40:	79fb      	ldrb	r3, [r7, #7]
  401a42:	4a11      	ldr	r2, [pc, #68]	; (401a88 <sd_mmc_test_unit_ready+0x68>)
  401a44:	5cd3      	ldrb	r3, [r2, r3]
  401a46:	2b00      	cmp	r3, #0
  401a48:	d001      	beq.n	401a4e <sd_mmc_test_unit_ready+0x2e>
			return CTRL_NO_PRESENT;
  401a4a:	2302      	movs	r3, #2
  401a4c:	e015      	b.n	401a7a <sd_mmc_test_unit_ready+0x5a>
		}
		if (sd_mmc_get_type(slot) & (CARD_TYPE_SD | CARD_TYPE_MMC)) {
  401a4e:	79fb      	ldrb	r3, [r7, #7]
  401a50:	4618      	mov	r0, r3
  401a52:	4b0e      	ldr	r3, [pc, #56]	; (401a8c <sd_mmc_test_unit_ready+0x6c>)
  401a54:	4798      	blx	r3
  401a56:	4603      	mov	r3, r0
  401a58:	f003 0303 	and.w	r3, r3, #3
  401a5c:	2b00      	cmp	r3, #0
  401a5e:	d001      	beq.n	401a64 <sd_mmc_test_unit_ready+0x44>
			return CTRL_GOOD;
  401a60:	2300      	movs	r3, #0
  401a62:	e00a      	b.n	401a7a <sd_mmc_test_unit_ready+0x5a>
		}
		// It is not a memory card
		return CTRL_NO_PRESENT;
  401a64:	2302      	movs	r3, #2
  401a66:	e008      	b.n	401a7a <sd_mmc_test_unit_ready+0x5a>

	case SD_MMC_INIT_ONGOING:
		return CTRL_BUSY;
  401a68:	2303      	movs	r3, #3
  401a6a:	e006      	b.n	401a7a <sd_mmc_test_unit_ready+0x5a>

	case SD_MMC_ERR_NO_CARD:
		sd_mmc_ejected[slot] = false;
  401a6c:	79fb      	ldrb	r3, [r7, #7]
  401a6e:	4a06      	ldr	r2, [pc, #24]	; (401a88 <sd_mmc_test_unit_ready+0x68>)
  401a70:	2100      	movs	r1, #0
  401a72:	54d1      	strb	r1, [r2, r3]
		return CTRL_NO_PRESENT;
  401a74:	2302      	movs	r3, #2
  401a76:	e000      	b.n	401a7a <sd_mmc_test_unit_ready+0x5a>

	default:
		return CTRL_FAIL;
  401a78:	2301      	movs	r3, #1
	}
}
  401a7a:	4618      	mov	r0, r3
  401a7c:	3708      	adds	r7, #8
  401a7e:	46bd      	mov	sp, r7
  401a80:	bd80      	pop	{r7, pc}
  401a82:	bf00      	nop
  401a84:	00401981 	.word	0x00401981
  401a88:	20000480 	.word	0x20000480
  401a8c:	004019e5 	.word	0x004019e5

00401a90 <sysclk_enable_peripheral_clock>:
{
  401a90:	b580      	push	{r7, lr}
  401a92:	b082      	sub	sp, #8
  401a94:	af00      	add	r7, sp, #0
  401a96:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  401a98:	6878      	ldr	r0, [r7, #4]
  401a9a:	4b03      	ldr	r3, [pc, #12]	; (401aa8 <sysclk_enable_peripheral_clock+0x18>)
  401a9c:	4798      	blx	r3
}
  401a9e:	bf00      	nop
  401aa0:	3708      	adds	r7, #8
  401aa2:	46bd      	mov	sp, r7
  401aa4:	bd80      	pop	{r7, pc}
  401aa6:	bf00      	nop
  401aa8:	004036d5 	.word	0x004036d5

00401aac <ioport_init>:
 *
 * This function must be called before using any other functions in the IOPORT
 * service.
 */
static inline void ioport_init(void)
{
  401aac:	b580      	push	{r7, lr}
  401aae:	af00      	add	r7, sp, #0
}

__always_inline static void arch_ioport_init(void)
{
#ifdef ID_PIOA
	sysclk_enable_peripheral_clock(ID_PIOA);
  401ab0:	2009      	movs	r0, #9
  401ab2:	4b08      	ldr	r3, [pc, #32]	; (401ad4 <ioport_init+0x28>)
  401ab4:	4798      	blx	r3
#endif
#ifdef ID_PIOB
	sysclk_enable_peripheral_clock(ID_PIOB);
  401ab6:	200a      	movs	r0, #10
  401ab8:	4b06      	ldr	r3, [pc, #24]	; (401ad4 <ioport_init+0x28>)
  401aba:	4798      	blx	r3
#endif
#ifdef ID_PIOC
	sysclk_enable_peripheral_clock(ID_PIOC);
  401abc:	200b      	movs	r0, #11
  401abe:	4b05      	ldr	r3, [pc, #20]	; (401ad4 <ioport_init+0x28>)
  401ac0:	4798      	blx	r3
#endif
#ifdef ID_PIOD
	sysclk_enable_peripheral_clock(ID_PIOD);
  401ac2:	200c      	movs	r0, #12
  401ac4:	4b03      	ldr	r3, [pc, #12]	; (401ad4 <ioport_init+0x28>)
  401ac6:	4798      	blx	r3
#endif
#ifdef ID_PIOE
	sysclk_enable_peripheral_clock(ID_PIOE);
  401ac8:	200d      	movs	r0, #13
  401aca:	4b02      	ldr	r3, [pc, #8]	; (401ad4 <ioport_init+0x28>)
  401acc:	4798      	blx	r3
	arch_ioport_init();
}
  401ace:	bf00      	nop
  401ad0:	bd80      	pop	{r7, pc}
  401ad2:	bf00      	nop
  401ad4:	00401a91 	.word	0x00401a91

00401ad8 <ioport_disable_pin>:
 *        IOPORT_CREATE_PIN().
 *
 * \param pin IOPORT pin to disable
 */
static inline void ioport_disable_pin(ioport_pin_t pin)
{
  401ad8:	b480      	push	{r7}
  401ada:	b089      	sub	sp, #36	; 0x24
  401adc:	af00      	add	r7, sp, #0
  401ade:	6078      	str	r0, [r7, #4]
  401ae0:	687b      	ldr	r3, [r7, #4]
  401ae2:	61fb      	str	r3, [r7, #28]
  401ae4:	69fb      	ldr	r3, [r7, #28]
  401ae6:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  401ae8:	69bb      	ldr	r3, [r7, #24]
  401aea:	095a      	lsrs	r2, r3, #5
  401aec:	69fb      	ldr	r3, [r7, #28]
  401aee:	617b      	str	r3, [r7, #20]
	return 1U << (pin & 0x1F);
  401af0:	697b      	ldr	r3, [r7, #20]
  401af2:	f003 031f 	and.w	r3, r3, #31
  401af6:	2101      	movs	r1, #1
  401af8:	fa01 f303 	lsl.w	r3, r1, r3
  401afc:	613a      	str	r2, [r7, #16]
  401afe:	60fb      	str	r3, [r7, #12]
  401b00:	693b      	ldr	r3, [r7, #16]
  401b02:	60bb      	str	r3, [r7, #8]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  401b04:	68bb      	ldr	r3, [r7, #8]
  401b06:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401b0a:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401b0e:	025b      	lsls	r3, r3, #9
  401b10:	461a      	mov	r2, r3
}

__always_inline static void arch_ioport_disable_port(ioport_port_t port,
		ioport_port_mask_t mask)
{
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  401b12:	68fb      	ldr	r3, [r7, #12]
  401b14:	6053      	str	r3, [r2, #4]
	arch_ioport_disable_pin(pin);
}
  401b16:	bf00      	nop
  401b18:	3724      	adds	r7, #36	; 0x24
  401b1a:	46bd      	mov	sp, r7
  401b1c:	f85d 7b04 	ldr.w	r7, [sp], #4
  401b20:	4770      	bx	lr

00401b22 <ioport_set_pin_mode>:
 *
 * \param pin IOPORT pin to configure
 * \param mode Mode masks to configure for the specified pin (\ref ioport_modes)
 */
static inline void ioport_set_pin_mode(ioport_pin_t pin, ioport_mode_t mode)
{
  401b22:	b480      	push	{r7}
  401b24:	b08d      	sub	sp, #52	; 0x34
  401b26:	af00      	add	r7, sp, #0
  401b28:	6078      	str	r0, [r7, #4]
  401b2a:	6039      	str	r1, [r7, #0]
  401b2c:	687b      	ldr	r3, [r7, #4]
  401b2e:	62fb      	str	r3, [r7, #44]	; 0x2c
  401b30:	683b      	ldr	r3, [r7, #0]
  401b32:	62bb      	str	r3, [r7, #40]	; 0x28
  401b34:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401b36:	627b      	str	r3, [r7, #36]	; 0x24
	return pin >> 5;
  401b38:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401b3a:	095a      	lsrs	r2, r3, #5
  401b3c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401b3e:	623b      	str	r3, [r7, #32]
	return 1U << (pin & 0x1F);
  401b40:	6a3b      	ldr	r3, [r7, #32]
  401b42:	f003 031f 	and.w	r3, r3, #31
  401b46:	2101      	movs	r1, #1
  401b48:	fa01 f303 	lsl.w	r3, r1, r3
  401b4c:	61fa      	str	r2, [r7, #28]
  401b4e:	61bb      	str	r3, [r7, #24]
  401b50:	6abb      	ldr	r3, [r7, #40]	; 0x28
  401b52:	617b      	str	r3, [r7, #20]
  401b54:	69fb      	ldr	r3, [r7, #28]
  401b56:	613b      	str	r3, [r7, #16]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  401b58:	693b      	ldr	r3, [r7, #16]
  401b5a:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401b5e:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401b62:	025b      	lsls	r3, r3, #9
}

__always_inline static void arch_ioport_set_port_mode(ioport_port_t port,
		ioport_port_mask_t mask, ioport_mode_t mode)
{
	Pio *base = arch_ioport_port_to_base(port);
  401b64:	60fb      	str	r3, [r7, #12]

	if (mode & IOPORT_MODE_PULLUP) {
  401b66:	697b      	ldr	r3, [r7, #20]
  401b68:	f003 0308 	and.w	r3, r3, #8
  401b6c:	2b00      	cmp	r3, #0
  401b6e:	d003      	beq.n	401b78 <ioport_set_pin_mode+0x56>
		base->PIO_PUER = mask;
  401b70:	68fb      	ldr	r3, [r7, #12]
  401b72:	69ba      	ldr	r2, [r7, #24]
  401b74:	665a      	str	r2, [r3, #100]	; 0x64
  401b76:	e002      	b.n	401b7e <ioport_set_pin_mode+0x5c>
	} else {
		base->PIO_PUDR = mask;
  401b78:	68fb      	ldr	r3, [r7, #12]
  401b7a:	69ba      	ldr	r2, [r7, #24]
  401b7c:	661a      	str	r2, [r3, #96]	; 0x60
	}

#if defined(IOPORT_MODE_PULLDOWN)
	if (mode & IOPORT_MODE_PULLDOWN) {
  401b7e:	697b      	ldr	r3, [r7, #20]
  401b80:	f003 0310 	and.w	r3, r3, #16
  401b84:	2b00      	cmp	r3, #0
  401b86:	d004      	beq.n	401b92 <ioport_set_pin_mode+0x70>
		base->PIO_PPDER = mask;
  401b88:	68fb      	ldr	r3, [r7, #12]
  401b8a:	69ba      	ldr	r2, [r7, #24]
  401b8c:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  401b90:	e003      	b.n	401b9a <ioport_set_pin_mode+0x78>
	} else {
		base->PIO_PPDDR = mask;
  401b92:	68fb      	ldr	r3, [r7, #12]
  401b94:	69ba      	ldr	r2, [r7, #24]
  401b96:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	}
#endif

	if (mode & IOPORT_MODE_OPEN_DRAIN) {
  401b9a:	697b      	ldr	r3, [r7, #20]
  401b9c:	f003 0320 	and.w	r3, r3, #32
  401ba0:	2b00      	cmp	r3, #0
  401ba2:	d003      	beq.n	401bac <ioport_set_pin_mode+0x8a>
		base->PIO_MDER = mask;
  401ba4:	68fb      	ldr	r3, [r7, #12]
  401ba6:	69ba      	ldr	r2, [r7, #24]
  401ba8:	651a      	str	r2, [r3, #80]	; 0x50
  401baa:	e002      	b.n	401bb2 <ioport_set_pin_mode+0x90>
	} else {
		base->PIO_MDDR = mask;
  401bac:	68fb      	ldr	r3, [r7, #12]
  401bae:	69ba      	ldr	r2, [r7, #24]
  401bb0:	655a      	str	r2, [r3, #84]	; 0x54
	}

	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
  401bb2:	697b      	ldr	r3, [r7, #20]
  401bb4:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
  401bb8:	2b00      	cmp	r3, #0
  401bba:	d003      	beq.n	401bc4 <ioport_set_pin_mode+0xa2>
		base->PIO_IFER = mask;
  401bbc:	68fb      	ldr	r3, [r7, #12]
  401bbe:	69ba      	ldr	r2, [r7, #24]
  401bc0:	621a      	str	r2, [r3, #32]
  401bc2:	e002      	b.n	401bca <ioport_set_pin_mode+0xa8>
	} else {
		base->PIO_IFDR = mask;
  401bc4:	68fb      	ldr	r3, [r7, #12]
  401bc6:	69ba      	ldr	r2, [r7, #24]
  401bc8:	625a      	str	r2, [r3, #36]	; 0x24
	}

	if (mode & IOPORT_MODE_DEBOUNCE) {
  401bca:	697b      	ldr	r3, [r7, #20]
  401bcc:	f003 0380 	and.w	r3, r3, #128	; 0x80
  401bd0:	2b00      	cmp	r3, #0
  401bd2:	d004      	beq.n	401bde <ioport_set_pin_mode+0xbc>
#if SAM3U || SAM3XA
		base->PIO_DIFSR = mask;
#else
		base->PIO_IFSCER = mask;
  401bd4:	68fb      	ldr	r3, [r7, #12]
  401bd6:	69ba      	ldr	r2, [r7, #24]
  401bd8:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  401bdc:	e003      	b.n	401be6 <ioport_set_pin_mode+0xc4>
#endif
	} else {
#if SAM3U || SAM3XA
		base->PIO_SCIFSR = mask;
#else
		base->PIO_IFSCDR = mask;
  401bde:	68fb      	ldr	r3, [r7, #12]
  401be0:	69ba      	ldr	r2, [r7, #24]
  401be2:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
		base->PIO_ABSR |= mask;
	} else {
		base->PIO_ABSR &= ~mask;
	}
#else
	if (mode & IOPORT_MODE_MUX_BIT0) {
  401be6:	697b      	ldr	r3, [r7, #20]
  401be8:	f003 0301 	and.w	r3, r3, #1
  401bec:	2b00      	cmp	r3, #0
  401bee:	d006      	beq.n	401bfe <ioport_set_pin_mode+0xdc>
		base->PIO_ABCDSR[0] |= mask;
  401bf0:	68fb      	ldr	r3, [r7, #12]
  401bf2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  401bf4:	69bb      	ldr	r3, [r7, #24]
  401bf6:	431a      	orrs	r2, r3
  401bf8:	68fb      	ldr	r3, [r7, #12]
  401bfa:	671a      	str	r2, [r3, #112]	; 0x70
  401bfc:	e006      	b.n	401c0c <ioport_set_pin_mode+0xea>
	} else {
		base->PIO_ABCDSR[0] &= ~mask;
  401bfe:	68fb      	ldr	r3, [r7, #12]
  401c00:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  401c02:	69bb      	ldr	r3, [r7, #24]
  401c04:	43db      	mvns	r3, r3
  401c06:	401a      	ands	r2, r3
  401c08:	68fb      	ldr	r3, [r7, #12]
  401c0a:	671a      	str	r2, [r3, #112]	; 0x70
	}

	if (mode & IOPORT_MODE_MUX_BIT1) {
  401c0c:	697b      	ldr	r3, [r7, #20]
  401c0e:	f003 0302 	and.w	r3, r3, #2
  401c12:	2b00      	cmp	r3, #0
  401c14:	d006      	beq.n	401c24 <ioport_set_pin_mode+0x102>
		base->PIO_ABCDSR[1] |= mask;
  401c16:	68fb      	ldr	r3, [r7, #12]
  401c18:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  401c1a:	69bb      	ldr	r3, [r7, #24]
  401c1c:	431a      	orrs	r2, r3
  401c1e:	68fb      	ldr	r3, [r7, #12]
  401c20:	675a      	str	r2, [r3, #116]	; 0x74
	arch_ioport_set_pin_mode(pin, mode);
}
  401c22:	e006      	b.n	401c32 <ioport_set_pin_mode+0x110>
	} else {
		base->PIO_ABCDSR[1] &= ~mask;
  401c24:	68fb      	ldr	r3, [r7, #12]
  401c26:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  401c28:	69bb      	ldr	r3, [r7, #24]
  401c2a:	43db      	mvns	r3, r3
  401c2c:	401a      	ands	r2, r3
  401c2e:	68fb      	ldr	r3, [r7, #12]
  401c30:	675a      	str	r2, [r3, #116]	; 0x74
  401c32:	bf00      	nop
  401c34:	3734      	adds	r7, #52	; 0x34
  401c36:	46bd      	mov	sp, r7
  401c38:	f85d 7b04 	ldr.w	r7, [sp], #4
  401c3c:	4770      	bx	lr

00401c3e <ioport_set_pin_dir>:
 * \param pin IOPORT pin to configure
 * \param dir Direction to set for the specified pin (\ref ioport_direction)
 */
static inline void ioport_set_pin_dir(ioport_pin_t pin,
		enum ioport_direction dir)
{
  401c3e:	b480      	push	{r7}
  401c40:	b08d      	sub	sp, #52	; 0x34
  401c42:	af00      	add	r7, sp, #0
  401c44:	6078      	str	r0, [r7, #4]
  401c46:	460b      	mov	r3, r1
  401c48:	70fb      	strb	r3, [r7, #3]
  401c4a:	687b      	ldr	r3, [r7, #4]
  401c4c:	62fb      	str	r3, [r7, #44]	; 0x2c
  401c4e:	78fb      	ldrb	r3, [r7, #3]
  401c50:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  401c54:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401c56:	627b      	str	r3, [r7, #36]	; 0x24
  401c58:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401c5a:	623b      	str	r3, [r7, #32]
	return pin >> 5;
  401c5c:	6a3b      	ldr	r3, [r7, #32]
  401c5e:	095b      	lsrs	r3, r3, #5
  401c60:	61fb      	str	r3, [r7, #28]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  401c62:	69fb      	ldr	r3, [r7, #28]
  401c64:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401c68:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401c6c:	025b      	lsls	r3, r3, #9
}

__always_inline static void arch_ioport_set_pin_dir(ioport_pin_t pin,
		enum ioport_direction dir)
{
	Pio *base = arch_ioport_pin_to_base(pin);
  401c6e:	61bb      	str	r3, [r7, #24]

	if (dir == IOPORT_DIR_OUTPUT) {
  401c70:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  401c74:	2b01      	cmp	r3, #1
  401c76:	d109      	bne.n	401c8c <ioport_set_pin_dir+0x4e>
  401c78:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401c7a:	617b      	str	r3, [r7, #20]
	return 1U << (pin & 0x1F);
  401c7c:	697b      	ldr	r3, [r7, #20]
  401c7e:	f003 031f 	and.w	r3, r3, #31
  401c82:	2201      	movs	r2, #1
  401c84:	409a      	lsls	r2, r3
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  401c86:	69bb      	ldr	r3, [r7, #24]
  401c88:	611a      	str	r2, [r3, #16]
  401c8a:	e00c      	b.n	401ca6 <ioport_set_pin_dir+0x68>
	} else if (dir == IOPORT_DIR_INPUT) {
  401c8c:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  401c90:	2b00      	cmp	r3, #0
  401c92:	d108      	bne.n	401ca6 <ioport_set_pin_dir+0x68>
  401c94:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401c96:	613b      	str	r3, [r7, #16]
	return 1U << (pin & 0x1F);
  401c98:	693b      	ldr	r3, [r7, #16]
  401c9a:	f003 031f 	and.w	r3, r3, #31
  401c9e:	2201      	movs	r2, #1
  401ca0:	409a      	lsls	r2, r3
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
  401ca2:	69bb      	ldr	r3, [r7, #24]
  401ca4:	615a      	str	r2, [r3, #20]
  401ca6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401ca8:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  401caa:	68fb      	ldr	r3, [r7, #12]
  401cac:	f003 031f 	and.w	r3, r3, #31
  401cb0:	2201      	movs	r2, #1
  401cb2:	409a      	lsls	r2, r3
	}

	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  401cb4:	69bb      	ldr	r3, [r7, #24]
  401cb6:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
	arch_ioport_set_pin_dir(pin, dir);
}
  401cba:	bf00      	nop
  401cbc:	3734      	adds	r7, #52	; 0x34
  401cbe:	46bd      	mov	sp, r7
  401cc0:	f85d 7b04 	ldr.w	r7, [sp], #4
  401cc4:	4770      	bx	lr

00401cc6 <ioport_set_pin_level>:
 *
 * \param pin IOPORT pin to configure
 * \param level Logical value of the pin
 */
static inline void ioport_set_pin_level(ioport_pin_t pin, bool level)
{
  401cc6:	b480      	push	{r7}
  401cc8:	b08b      	sub	sp, #44	; 0x2c
  401cca:	af00      	add	r7, sp, #0
  401ccc:	6078      	str	r0, [r7, #4]
  401cce:	460b      	mov	r3, r1
  401cd0:	70fb      	strb	r3, [r7, #3]
  401cd2:	687b      	ldr	r3, [r7, #4]
  401cd4:	627b      	str	r3, [r7, #36]	; 0x24
  401cd6:	78fb      	ldrb	r3, [r7, #3]
  401cd8:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  401cdc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401cde:	61fb      	str	r3, [r7, #28]
  401ce0:	69fb      	ldr	r3, [r7, #28]
  401ce2:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  401ce4:	69bb      	ldr	r3, [r7, #24]
  401ce6:	095b      	lsrs	r3, r3, #5
  401ce8:	617b      	str	r3, [r7, #20]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  401cea:	697b      	ldr	r3, [r7, #20]
  401cec:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401cf0:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401cf4:	025b      	lsls	r3, r3, #9
}

__always_inline static void arch_ioport_set_pin_level(ioport_pin_t pin,
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);
  401cf6:	613b      	str	r3, [r7, #16]

	if (level) {
  401cf8:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  401cfc:	2b00      	cmp	r3, #0
  401cfe:	d009      	beq.n	401d14 <ioport_set_pin_level+0x4e>
  401d00:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401d02:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  401d04:	68fb      	ldr	r3, [r7, #12]
  401d06:	f003 031f 	and.w	r3, r3, #31
  401d0a:	2201      	movs	r2, #1
  401d0c:	409a      	lsls	r2, r3
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  401d0e:	693b      	ldr	r3, [r7, #16]
  401d10:	631a      	str	r2, [r3, #48]	; 0x30
	arch_ioport_set_pin_level(pin, level);
}
  401d12:	e008      	b.n	401d26 <ioport_set_pin_level+0x60>
  401d14:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401d16:	60bb      	str	r3, [r7, #8]
	return 1U << (pin & 0x1F);
  401d18:	68bb      	ldr	r3, [r7, #8]
  401d1a:	f003 031f 	and.w	r3, r3, #31
  401d1e:	2201      	movs	r2, #1
  401d20:	409a      	lsls	r2, r3
	} else {
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  401d22:	693b      	ldr	r3, [r7, #16]
  401d24:	635a      	str	r2, [r3, #52]	; 0x34
  401d26:	bf00      	nop
  401d28:	372c      	adds	r7, #44	; 0x2c
  401d2a:	46bd      	mov	sp, r7
  401d2c:	f85d 7b04 	ldr.w	r7, [sp], #4
  401d30:	4770      	bx	lr
	...

00401d34 <ioport_set_pin_sense_mode>:
 * \param pin IOPORT pin to configure
 * \param pin_sense Edge to sense for the pin (\ref ioport_sense)
 */
static inline void ioport_set_pin_sense_mode(ioport_pin_t pin,
		enum ioport_sense pin_sense)
{
  401d34:	b480      	push	{r7}
  401d36:	b08d      	sub	sp, #52	; 0x34
  401d38:	af00      	add	r7, sp, #0
  401d3a:	6078      	str	r0, [r7, #4]
  401d3c:	460b      	mov	r3, r1
  401d3e:	70fb      	strb	r3, [r7, #3]
  401d40:	687b      	ldr	r3, [r7, #4]
  401d42:	62fb      	str	r3, [r7, #44]	; 0x2c
  401d44:	78fb      	ldrb	r3, [r7, #3]
  401d46:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  401d4a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401d4c:	627b      	str	r3, [r7, #36]	; 0x24
	return pin >> 5;
  401d4e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401d50:	095a      	lsrs	r2, r3, #5
  401d52:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401d54:	623b      	str	r3, [r7, #32]
	return 1U << (pin & 0x1F);
  401d56:	6a3b      	ldr	r3, [r7, #32]
  401d58:	f003 031f 	and.w	r3, r3, #31
  401d5c:	2101      	movs	r1, #1
  401d5e:	fa01 f303 	lsl.w	r3, r1, r3
  401d62:	61fa      	str	r2, [r7, #28]
  401d64:	61bb      	str	r3, [r7, #24]
  401d66:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  401d6a:	75fb      	strb	r3, [r7, #23]
  401d6c:	69fb      	ldr	r3, [r7, #28]
  401d6e:	613b      	str	r3, [r7, #16]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  401d70:	693b      	ldr	r3, [r7, #16]
  401d72:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401d76:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401d7a:	025b      	lsls	r3, r3, #9
}

__always_inline static void arch_ioport_set_port_sense_mode(ioport_port_t port,
		ioport_port_mask_t mask, enum ioport_sense pin_sense)
{
	Pio *base = arch_ioport_port_to_base(port);
  401d7c:	60fb      	str	r3, [r7, #12]
	 *       1       0         0    IOPORT_SENSE_FALLING
	 *       1       0         1    IOPORT_SENSE_RISING
	 *       1       1         0    IOPORT_SENSE_LEVEL_LOW
	 *       1       1         1    IOPORT_SENSE_LEVEL_HIGH
	 */
	switch(pin_sense) {
  401d7e:	7dfb      	ldrb	r3, [r7, #23]
  401d80:	3b01      	subs	r3, #1
  401d82:	2b03      	cmp	r3, #3
  401d84:	d82e      	bhi.n	401de4 <ioport_set_pin_sense_mode+0xb0>
  401d86:	a201      	add	r2, pc, #4	; (adr r2, 401d8c <ioport_set_pin_sense_mode+0x58>)
  401d88:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  401d8c:	00401dc1 	.word	0x00401dc1
  401d90:	00401dd3 	.word	0x00401dd3
  401d94:	00401d9d 	.word	0x00401d9d
  401d98:	00401daf 	.word	0x00401daf
	case IOPORT_SENSE_LEVEL_LOW:
		base->PIO_LSR = mask;
  401d9c:	68fb      	ldr	r3, [r7, #12]
  401d9e:	69ba      	ldr	r2, [r7, #24]
  401da0:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
		base->PIO_FELLSR = mask;
  401da4:	68fb      	ldr	r3, [r7, #12]
  401da6:	69ba      	ldr	r2, [r7, #24]
  401da8:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
  401dac:	e01f      	b.n	401dee <ioport_set_pin_sense_mode+0xba>
		break;
	case IOPORT_SENSE_LEVEL_HIGH:
		base->PIO_LSR = mask;
  401dae:	68fb      	ldr	r3, [r7, #12]
  401db0:	69ba      	ldr	r2, [r7, #24]
  401db2:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
		base->PIO_REHLSR = mask;
  401db6:	68fb      	ldr	r3, [r7, #12]
  401db8:	69ba      	ldr	r2, [r7, #24]
  401dba:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
  401dbe:	e016      	b.n	401dee <ioport_set_pin_sense_mode+0xba>
		break;
	case IOPORT_SENSE_FALLING:
		base->PIO_ESR = mask;
  401dc0:	68fb      	ldr	r3, [r7, #12]
  401dc2:	69ba      	ldr	r2, [r7, #24]
  401dc4:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
		base->PIO_FELLSR = mask;
  401dc8:	68fb      	ldr	r3, [r7, #12]
  401dca:	69ba      	ldr	r2, [r7, #24]
  401dcc:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
  401dd0:	e00d      	b.n	401dee <ioport_set_pin_sense_mode+0xba>
		break;
	case IOPORT_SENSE_RISING:
		base->PIO_ESR = mask;
  401dd2:	68fb      	ldr	r3, [r7, #12]
  401dd4:	69ba      	ldr	r2, [r7, #24]
  401dd6:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
		base->PIO_REHLSR = mask;
  401dda:	68fb      	ldr	r3, [r7, #12]
  401ddc:	69ba      	ldr	r2, [r7, #24]
  401dde:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
  401de2:	e004      	b.n	401dee <ioport_set_pin_sense_mode+0xba>
		break;
	default:
		base->PIO_AIMDR = mask;
  401de4:	68fb      	ldr	r3, [r7, #12]
  401de6:	69ba      	ldr	r2, [r7, #24]
  401de8:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
	arch_ioport_set_pin_sense_mode(pin, pin_sense);
}
  401dec:	e003      	b.n	401df6 <ioport_set_pin_sense_mode+0xc2>
		return;
	}
	base->PIO_AIMER = mask;
  401dee:	68fb      	ldr	r3, [r7, #12]
  401df0:	69ba      	ldr	r2, [r7, #24]
  401df2:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
  401df6:	bf00      	nop
  401df8:	3734      	adds	r7, #52	; 0x34
  401dfa:	46bd      	mov	sp, r7
  401dfc:	f85d 7b04 	ldr.w	r7, [sp], #4
  401e00:	4770      	bx	lr
  401e02:	bf00      	nop

00401e04 <board_init>:
		ioport_set_pin_mode(pin, mode);\
		ioport_set_pin_sense_mode(pin, sense);\
	} while (0)

void board_init(void)
{
  401e04:	b580      	push	{r7, lr}
  401e06:	af00      	add	r7, sp, #0
#ifndef CONF_BOARD_KEEP_WATCHDOG_AT_INIT
	/* Disable the watchdog */
	WDT->WDT_MR = WDT_MR_WDDIS;
  401e08:	4b34      	ldr	r3, [pc, #208]	; (401edc <board_init+0xd8>)
  401e0a:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  401e0e:	605a      	str	r2, [r3, #4]
#endif

	/* Initialize IOPORTs */
	ioport_init();
  401e10:	4b33      	ldr	r3, [pc, #204]	; (401ee0 <board_init+0xdc>)
  401e12:	4798      	blx	r3

	/* Configure the pins connected to LED as output and set their
	 * default initial state to high (LED off).
	 */
	ioport_set_pin_dir(LED0_GPIO, IOPORT_DIR_OUTPUT);
  401e14:	2101      	movs	r1, #1
  401e16:	2076      	movs	r0, #118	; 0x76
  401e18:	4b32      	ldr	r3, [pc, #200]	; (401ee4 <board_init+0xe0>)
  401e1a:	4798      	blx	r3
	ioport_set_pin_level(LED0_GPIO, LED0_INACTIVE_LEVEL);
  401e1c:	2101      	movs	r1, #1
  401e1e:	2076      	movs	r0, #118	; 0x76
  401e20:	4b31      	ldr	r3, [pc, #196]	; (401ee8 <board_init+0xe4>)
  401e22:	4798      	blx	r3

	/* Configure Push Button pins */
	ioport_set_pin_input_mode(GPIO_PUSH_BUTTON_1, GPIO_PUSH_BUTTON_1_FLAGS,
  401e24:	2100      	movs	r1, #0
  401e26:	2002      	movs	r0, #2
  401e28:	4b2e      	ldr	r3, [pc, #184]	; (401ee4 <board_init+0xe0>)
  401e2a:	4798      	blx	r3
  401e2c:	2188      	movs	r1, #136	; 0x88
  401e2e:	2002      	movs	r0, #2
  401e30:	4b2e      	ldr	r3, [pc, #184]	; (401eec <board_init+0xe8>)
  401e32:	4798      	blx	r3
  401e34:	2102      	movs	r1, #2
  401e36:	2002      	movs	r0, #2
  401e38:	4b2d      	ldr	r3, [pc, #180]	; (401ef0 <board_init+0xec>)
  401e3a:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_PWM_LED0_GPIO, PIN_PWM_LED0_FLAGS);
#endif

#ifdef CONF_BOARD_CAN
	/* Configure the CAN1 TX and RX pin. */
	ioport_set_pin_peripheral_mode(PIN_CAN1_RX_IDX, PIN_CAN1_RX_FLAGS);
  401e3c:	2102      	movs	r1, #2
  401e3e:	204c      	movs	r0, #76	; 0x4c
  401e40:	4b2a      	ldr	r3, [pc, #168]	; (401eec <board_init+0xe8>)
  401e42:	4798      	blx	r3
  401e44:	204c      	movs	r0, #76	; 0x4c
  401e46:	4b2b      	ldr	r3, [pc, #172]	; (401ef4 <board_init+0xf0>)
  401e48:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_CAN1_TX_IDX, PIN_CAN1_TX_FLAGS);
  401e4a:	2102      	movs	r1, #2
  401e4c:	204f      	movs	r0, #79	; 0x4f
  401e4e:	4b27      	ldr	r3, [pc, #156]	; (401eec <board_init+0xe8>)
  401e50:	4798      	blx	r3
  401e52:	204f      	movs	r0, #79	; 0x4f
  401e54:	4b27      	ldr	r3, [pc, #156]	; (401ef4 <board_init+0xf0>)
  401e56:	4798      	blx	r3
	/* Configure the transiver1 RS & EN pins. */
	ioport_set_pin_dir(PIN_CAN1_TR_RS_IDX, IOPORT_DIR_OUTPUT);
  401e58:	2101      	movs	r1, #1
  401e5a:	2082      	movs	r0, #130	; 0x82
  401e5c:	4b21      	ldr	r3, [pc, #132]	; (401ee4 <board_init+0xe0>)
  401e5e:	4798      	blx	r3
	ioport_set_pin_dir(PIN_CAN1_TR_EN_IDX, IOPORT_DIR_OUTPUT);
  401e60:	2101      	movs	r1, #1
  401e62:	2083      	movs	r0, #131	; 0x83
  401e64:	4b1f      	ldr	r3, [pc, #124]	; (401ee4 <board_init+0xe0>)
  401e66:	4798      	blx	r3
#  endif
#endif

#if defined (CONF_BOARD_SD_MMC_HSMCI)
	/* Configure HSMCI pins */
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCCDA_GPIO, PIN_HSMCI_MCCDA_FLAGS);
  401e68:	2102      	movs	r1, #2
  401e6a:	201c      	movs	r0, #28
  401e6c:	4b1f      	ldr	r3, [pc, #124]	; (401eec <board_init+0xe8>)
  401e6e:	4798      	blx	r3
  401e70:	201c      	movs	r0, #28
  401e72:	4b20      	ldr	r3, [pc, #128]	; (401ef4 <board_init+0xf0>)
  401e74:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCCK_GPIO, PIN_HSMCI_MCCK_FLAGS);
  401e76:	2102      	movs	r1, #2
  401e78:	201d      	movs	r0, #29
  401e7a:	4b1c      	ldr	r3, [pc, #112]	; (401eec <board_init+0xe8>)
  401e7c:	4798      	blx	r3
  401e7e:	201d      	movs	r0, #29
  401e80:	4b1c      	ldr	r3, [pc, #112]	; (401ef4 <board_init+0xf0>)
  401e82:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCDA0_GPIO, PIN_HSMCI_MCDA0_FLAGS);
  401e84:	2102      	movs	r1, #2
  401e86:	201e      	movs	r0, #30
  401e88:	4b18      	ldr	r3, [pc, #96]	; (401eec <board_init+0xe8>)
  401e8a:	4798      	blx	r3
  401e8c:	201e      	movs	r0, #30
  401e8e:	4b19      	ldr	r3, [pc, #100]	; (401ef4 <board_init+0xf0>)
  401e90:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCDA1_GPIO, PIN_HSMCI_MCDA1_FLAGS);
  401e92:	2102      	movs	r1, #2
  401e94:	201f      	movs	r0, #31
  401e96:	4b15      	ldr	r3, [pc, #84]	; (401eec <board_init+0xe8>)
  401e98:	4798      	blx	r3
  401e9a:	201f      	movs	r0, #31
  401e9c:	4b15      	ldr	r3, [pc, #84]	; (401ef4 <board_init+0xf0>)
  401e9e:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCDA2_GPIO, PIN_HSMCI_MCDA2_FLAGS);
  401ea0:	2102      	movs	r1, #2
  401ea2:	201a      	movs	r0, #26
  401ea4:	4b11      	ldr	r3, [pc, #68]	; (401eec <board_init+0xe8>)
  401ea6:	4798      	blx	r3
  401ea8:	201a      	movs	r0, #26
  401eaa:	4b12      	ldr	r3, [pc, #72]	; (401ef4 <board_init+0xf0>)
  401eac:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCDA3_GPIO, PIN_HSMCI_MCDA3_FLAGS);
  401eae:	2102      	movs	r1, #2
  401eb0:	201b      	movs	r0, #27
  401eb2:	4b0e      	ldr	r3, [pc, #56]	; (401eec <board_init+0xe8>)
  401eb4:	4798      	blx	r3
  401eb6:	201b      	movs	r0, #27
  401eb8:	4b0e      	ldr	r3, [pc, #56]	; (401ef4 <board_init+0xf0>)
  401eba:	4798      	blx	r3
	ioport_set_pin_dir(AT86RFX_SLP_PIN, IOPORT_DIR_OUTPUT);
	ioport_set_pin_level(AT86RFX_SLP_PIN, IOPORT_PIN_LEVEL_HIGH);
#endif  

#if (defined(CONF_BOARD_TWI0) || defined(CONF_BOARD_EDBG_TWI))
	ioport_set_pin_peripheral_mode(TWI0_DATA_GPIO, TWI0_DATA_FLAGS);
  401ebc:	2100      	movs	r1, #0
  401ebe:	2003      	movs	r0, #3
  401ec0:	4b0a      	ldr	r3, [pc, #40]	; (401eec <board_init+0xe8>)
  401ec2:	4798      	blx	r3
  401ec4:	2003      	movs	r0, #3
  401ec6:	4b0b      	ldr	r3, [pc, #44]	; (401ef4 <board_init+0xf0>)
  401ec8:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(TWI0_CLK_GPIO, TWI0_CLK_FLAGS);
  401eca:	2100      	movs	r1, #0
  401ecc:	2004      	movs	r0, #4
  401ece:	4b07      	ldr	r3, [pc, #28]	; (401eec <board_init+0xe8>)
  401ed0:	4798      	blx	r3
  401ed2:	2004      	movs	r0, #4
  401ed4:	4b07      	ldr	r3, [pc, #28]	; (401ef4 <board_init+0xf0>)
  401ed6:	4798      	blx	r3
#endif

}
  401ed8:	bf00      	nop
  401eda:	bd80      	pop	{r7, pc}
  401edc:	400e1850 	.word	0x400e1850
  401ee0:	00401aad 	.word	0x00401aad
  401ee4:	00401c3f 	.word	0x00401c3f
  401ee8:	00401cc7 	.word	0x00401cc7
  401eec:	00401b23 	.word	0x00401b23
  401ef0:	00401d35 	.word	0x00401d35
  401ef4:	00401ad9 	.word	0x00401ad9

00401ef8 <osc_get_rate>:
{
  401ef8:	b480      	push	{r7}
  401efa:	b083      	sub	sp, #12
  401efc:	af00      	add	r7, sp, #0
  401efe:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  401f00:	687b      	ldr	r3, [r7, #4]
  401f02:	2b07      	cmp	r3, #7
  401f04:	d825      	bhi.n	401f52 <osc_get_rate+0x5a>
  401f06:	a201      	add	r2, pc, #4	; (adr r2, 401f0c <osc_get_rate+0x14>)
  401f08:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  401f0c:	00401f2d 	.word	0x00401f2d
  401f10:	00401f33 	.word	0x00401f33
  401f14:	00401f39 	.word	0x00401f39
  401f18:	00401f3f 	.word	0x00401f3f
  401f1c:	00401f43 	.word	0x00401f43
  401f20:	00401f47 	.word	0x00401f47
  401f24:	00401f4b 	.word	0x00401f4b
  401f28:	00401f4f 	.word	0x00401f4f
		return OSC_SLCK_32K_RC_HZ;
  401f2c:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  401f30:	e010      	b.n	401f54 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_XTAL;
  401f32:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  401f36:	e00d      	b.n	401f54 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_BYPASS;
  401f38:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  401f3c:	e00a      	b.n	401f54 <osc_get_rate+0x5c>
		return OSC_MAINCK_4M_RC_HZ;
  401f3e:	4b08      	ldr	r3, [pc, #32]	; (401f60 <osc_get_rate+0x68>)
  401f40:	e008      	b.n	401f54 <osc_get_rate+0x5c>
		return OSC_MAINCK_8M_RC_HZ;
  401f42:	4b08      	ldr	r3, [pc, #32]	; (401f64 <osc_get_rate+0x6c>)
  401f44:	e006      	b.n	401f54 <osc_get_rate+0x5c>
		return OSC_MAINCK_12M_RC_HZ;
  401f46:	4b08      	ldr	r3, [pc, #32]	; (401f68 <osc_get_rate+0x70>)
  401f48:	e004      	b.n	401f54 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_XTAL;
  401f4a:	4b07      	ldr	r3, [pc, #28]	; (401f68 <osc_get_rate+0x70>)
  401f4c:	e002      	b.n	401f54 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_BYPASS;
  401f4e:	4b06      	ldr	r3, [pc, #24]	; (401f68 <osc_get_rate+0x70>)
  401f50:	e000      	b.n	401f54 <osc_get_rate+0x5c>
	return 0;
  401f52:	2300      	movs	r3, #0
}
  401f54:	4618      	mov	r0, r3
  401f56:	370c      	adds	r7, #12
  401f58:	46bd      	mov	sp, r7
  401f5a:	f85d 7b04 	ldr.w	r7, [sp], #4
  401f5e:	4770      	bx	lr
  401f60:	003d0900 	.word	0x003d0900
  401f64:	007a1200 	.word	0x007a1200
  401f68:	00b71b00 	.word	0x00b71b00

00401f6c <sysclk_get_main_hz>:
{
  401f6c:	b580      	push	{r7, lr}
  401f6e:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  401f70:	2006      	movs	r0, #6
  401f72:	4b03      	ldr	r3, [pc, #12]	; (401f80 <sysclk_get_main_hz+0x14>)
  401f74:	4798      	blx	r3
  401f76:	4603      	mov	r3, r0
  401f78:	011b      	lsls	r3, r3, #4
}
  401f7a:	4618      	mov	r0, r3
  401f7c:	bd80      	pop	{r7, pc}
  401f7e:	bf00      	nop
  401f80:	00401ef9 	.word	0x00401ef9

00401f84 <sysclk_get_peripheral_hz>:
{
  401f84:	b580      	push	{r7, lr}
  401f86:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  401f88:	4b02      	ldr	r3, [pc, #8]	; (401f94 <sysclk_get_peripheral_hz+0x10>)
  401f8a:	4798      	blx	r3
  401f8c:	4603      	mov	r3, r0
  401f8e:	085b      	lsrs	r3, r3, #1
}
  401f90:	4618      	mov	r0, r3
  401f92:	bd80      	pop	{r7, pc}
  401f94:	00401f6d 	.word	0x00401f6d

00401f98 <hsmci_reset>:

/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
  401f98:	b480      	push	{r7}
  401f9a:	b087      	sub	sp, #28
  401f9c:	af00      	add	r7, sp, #0
	uint32_t mr = HSMCI->HSMCI_MR;
  401f9e:	4b15      	ldr	r3, [pc, #84]	; (401ff4 <hsmci_reset+0x5c>)
  401fa0:	685b      	ldr	r3, [r3, #4]
  401fa2:	617b      	str	r3, [r7, #20]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  401fa4:	4b13      	ldr	r3, [pc, #76]	; (401ff4 <hsmci_reset+0x5c>)
  401fa6:	689b      	ldr	r3, [r3, #8]
  401fa8:	613b      	str	r3, [r7, #16]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  401faa:	4b12      	ldr	r3, [pc, #72]	; (401ff4 <hsmci_reset+0x5c>)
  401fac:	68db      	ldr	r3, [r3, #12]
  401fae:	60fb      	str	r3, [r7, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  401fb0:	4b10      	ldr	r3, [pc, #64]	; (401ff4 <hsmci_reset+0x5c>)
  401fb2:	69db      	ldr	r3, [r3, #28]
  401fb4:	60bb      	str	r3, [r7, #8]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  401fb6:	4b0f      	ldr	r3, [pc, #60]	; (401ff4 <hsmci_reset+0x5c>)
  401fb8:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  401fba:	607b      	str	r3, [r7, #4]
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401fbc:	4b0d      	ldr	r3, [pc, #52]	; (401ff4 <hsmci_reset+0x5c>)
  401fbe:	2280      	movs	r2, #128	; 0x80
  401fc0:	601a      	str	r2, [r3, #0]
	HSMCI->HSMCI_MR = mr;
  401fc2:	4a0c      	ldr	r2, [pc, #48]	; (401ff4 <hsmci_reset+0x5c>)
  401fc4:	697b      	ldr	r3, [r7, #20]
  401fc6:	6053      	str	r3, [r2, #4]
	HSMCI->HSMCI_DTOR = dtor;
  401fc8:	4a0a      	ldr	r2, [pc, #40]	; (401ff4 <hsmci_reset+0x5c>)
  401fca:	693b      	ldr	r3, [r7, #16]
  401fcc:	6093      	str	r3, [r2, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  401fce:	4a09      	ldr	r2, [pc, #36]	; (401ff4 <hsmci_reset+0x5c>)
  401fd0:	68fb      	ldr	r3, [r7, #12]
  401fd2:	60d3      	str	r3, [r2, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  401fd4:	4a07      	ldr	r2, [pc, #28]	; (401ff4 <hsmci_reset+0x5c>)
  401fd6:	68bb      	ldr	r3, [r7, #8]
  401fd8:	61d3      	str	r3, [r2, #28]
	HSMCI->HSMCI_CFG = cfg;
  401fda:	4a06      	ldr	r2, [pc, #24]	; (401ff4 <hsmci_reset+0x5c>)
  401fdc:	687b      	ldr	r3, [r7, #4]
  401fde:	6553      	str	r3, [r2, #84]	; 0x54
#ifdef HSMCI_DMA_DMAEN
	HSMCI->HSMCI_DMA = 0;
#endif
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401fe0:	4b04      	ldr	r3, [pc, #16]	; (401ff4 <hsmci_reset+0x5c>)
  401fe2:	2205      	movs	r2, #5
  401fe4:	601a      	str	r2, [r3, #0]
}
  401fe6:	bf00      	nop
  401fe8:	371c      	adds	r7, #28
  401fea:	46bd      	mov	sp, r7
  401fec:	f85d 7b04 	ldr.w	r7, [sp], #4
  401ff0:	4770      	bx	lr
  401ff2:	bf00      	nop
  401ff4:	40080000 	.word	0x40080000

00401ff8 <hsmci_set_speed>:
 *
 * \param speed    HSMCI clock speed in Hz.
 * \param mck      MCK clock speed in Hz.
 */
static void hsmci_set_speed(uint32_t speed, uint32_t mck)
{
  401ff8:	b480      	push	{r7}
  401ffa:	b087      	sub	sp, #28
  401ffc:	af00      	add	r7, sp, #0
  401ffe:	6078      	str	r0, [r7, #4]
  402000:	6039      	str	r1, [r7, #0]
#if (SAM4E || SAMV70 || SAMV71 || SAME70 || SAMS70)
	uint32_t clkdiv = 0;
  402002:	2300      	movs	r3, #0
  402004:	617b      	str	r3, [r7, #20]
	uint32_t clkodd = 0;
  402006:	2300      	movs	r3, #0
  402008:	613b      	str	r3, [r7, #16]
	// clock divider, represent (((clkdiv << 1) + clkodd) + 2)
	uint32_t div = 0;
  40200a:	2300      	movs	r3, #0
  40200c:	60fb      	str	r3, [r7, #12]

	// Speed = MCK clock / (((clkdiv << 1) + clkodd) + 2)
	if ((speed * 2) < mck) {
  40200e:	687b      	ldr	r3, [r7, #4]
  402010:	005a      	lsls	r2, r3, #1
  402012:	683b      	ldr	r3, [r7, #0]
  402014:	429a      	cmp	r2, r3
  402016:	d21a      	bcs.n	40204e <hsmci_set_speed+0x56>
		div = (mck / speed) - 2;
  402018:	683a      	ldr	r2, [r7, #0]
  40201a:	687b      	ldr	r3, [r7, #4]
  40201c:	fbb2 f3f3 	udiv	r3, r2, r3
  402020:	3b02      	subs	r3, #2
  402022:	60fb      	str	r3, [r7, #12]
		if (mck % speed) {
  402024:	683b      	ldr	r3, [r7, #0]
  402026:	687a      	ldr	r2, [r7, #4]
  402028:	fbb3 f2f2 	udiv	r2, r3, r2
  40202c:	6879      	ldr	r1, [r7, #4]
  40202e:	fb01 f202 	mul.w	r2, r1, r2
  402032:	1a9b      	subs	r3, r3, r2
  402034:	2b00      	cmp	r3, #0
  402036:	d002      	beq.n	40203e <hsmci_set_speed+0x46>
			// Ensure that the card speed not be higher than expected.
			div++;
  402038:	68fb      	ldr	r3, [r7, #12]
  40203a:	3301      	adds	r3, #1
  40203c:	60fb      	str	r3, [r7, #12]
		}
		clkdiv = div >> 1;
  40203e:	68fb      	ldr	r3, [r7, #12]
  402040:	085b      	lsrs	r3, r3, #1
  402042:	617b      	str	r3, [r7, #20]
		// clkodd is the last significant bit of the clock divider (div).
		clkodd = div % 2;
  402044:	68fb      	ldr	r3, [r7, #12]
  402046:	f003 0301 	and.w	r3, r3, #1
  40204a:	613b      	str	r3, [r7, #16]
  40204c:	e003      	b.n	402056 <hsmci_set_speed+0x5e>
	} else {
		clkdiv = 0;
  40204e:	2300      	movs	r3, #0
  402050:	617b      	str	r3, [r7, #20]
		clkodd = 0;
  402052:	2300      	movs	r3, #0
  402054:	613b      	str	r3, [r7, #16]
	}

	HSMCI->HSMCI_MR &= ~HSMCI_MR_CLKDIV_Msk;
  402056:	4a11      	ldr	r2, [pc, #68]	; (40209c <hsmci_set_speed+0xa4>)
  402058:	4b10      	ldr	r3, [pc, #64]	; (40209c <hsmci_set_speed+0xa4>)
  40205a:	685b      	ldr	r3, [r3, #4]
  40205c:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
  402060:	6053      	str	r3, [r2, #4]
	HSMCI->HSMCI_MR |= HSMCI_MR_CLKDIV(clkdiv);
  402062:	490e      	ldr	r1, [pc, #56]	; (40209c <hsmci_set_speed+0xa4>)
  402064:	4b0d      	ldr	r3, [pc, #52]	; (40209c <hsmci_set_speed+0xa4>)
  402066:	685a      	ldr	r2, [r3, #4]
  402068:	697b      	ldr	r3, [r7, #20]
  40206a:	b2db      	uxtb	r3, r3
  40206c:	4313      	orrs	r3, r2
  40206e:	604b      	str	r3, [r1, #4]
	if (clkodd) {
  402070:	693b      	ldr	r3, [r7, #16]
  402072:	2b00      	cmp	r3, #0
  402074:	d006      	beq.n	402084 <hsmci_set_speed+0x8c>
		HSMCI->HSMCI_MR |= HSMCI_MR_CLKODD;
  402076:	4a09      	ldr	r2, [pc, #36]	; (40209c <hsmci_set_speed+0xa4>)
  402078:	4b08      	ldr	r3, [pc, #32]	; (40209c <hsmci_set_speed+0xa4>)
  40207a:	685b      	ldr	r3, [r3, #4]
  40207c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  402080:	6053      	str	r3, [r2, #4]
	}
	HSMCI->HSMCI_MR &= ~HSMCI_MR_CLKDIV_Msk;
	HSMCI->HSMCI_MR |= HSMCI_MR_CLKDIV(clkdiv);
#endif

}
  402082:	e005      	b.n	402090 <hsmci_set_speed+0x98>
		HSMCI->HSMCI_MR &= ~HSMCI_MR_CLKODD;
  402084:	4a05      	ldr	r2, [pc, #20]	; (40209c <hsmci_set_speed+0xa4>)
  402086:	4b05      	ldr	r3, [pc, #20]	; (40209c <hsmci_set_speed+0xa4>)
  402088:	685b      	ldr	r3, [r3, #4]
  40208a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  40208e:	6053      	str	r3, [r2, #4]
}
  402090:	bf00      	nop
  402092:	371c      	adds	r7, #28
  402094:	46bd      	mov	sp, r7
  402096:	f85d 7b04 	ldr.w	r7, [sp], #4
  40209a:	4770      	bx	lr
  40209c:	40080000 	.word	0x40080000

004020a0 <hsmci_wait_busy>:
/** \brief Wait the end of busy signal on data line
 *
 * \return true if success, otherwise false
 */
static bool hsmci_wait_busy(void)
{
  4020a0:	b580      	push	{r7, lr}
  4020a2:	b082      	sub	sp, #8
  4020a4:	af00      	add	r7, sp, #0
	uint32_t busy_wait = 0xFFFFFFFF;
  4020a6:	f04f 33ff 	mov.w	r3, #4294967295
  4020aa:	607b      	str	r3, [r7, #4]
	uint32_t sr;

	do {
		sr = HSMCI->HSMCI_SR;
  4020ac:	4b0d      	ldr	r3, [pc, #52]	; (4020e4 <hsmci_wait_busy+0x44>)
  4020ae:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4020b0:	603b      	str	r3, [r7, #0]
		if (busy_wait-- == 0) {
  4020b2:	687b      	ldr	r3, [r7, #4]
  4020b4:	1e5a      	subs	r2, r3, #1
  4020b6:	607a      	str	r2, [r7, #4]
  4020b8:	2b00      	cmp	r3, #0
  4020ba:	d103      	bne.n	4020c4 <hsmci_wait_busy+0x24>
			hsmci_debug("%s: timeout\n\r", __func__);
			hsmci_reset();
  4020bc:	4b0a      	ldr	r3, [pc, #40]	; (4020e8 <hsmci_wait_busy+0x48>)
  4020be:	4798      	blx	r3
			return false;
  4020c0:	2300      	movs	r3, #0
  4020c2:	e00a      	b.n	4020da <hsmci_wait_busy+0x3a>
		}
	} while (!((sr & HSMCI_SR_NOTBUSY) && ((sr & HSMCI_SR_DTIP) == 0)));
  4020c4:	683b      	ldr	r3, [r7, #0]
  4020c6:	f003 0320 	and.w	r3, r3, #32
  4020ca:	2b00      	cmp	r3, #0
  4020cc:	d0ee      	beq.n	4020ac <hsmci_wait_busy+0xc>
  4020ce:	683b      	ldr	r3, [r7, #0]
  4020d0:	f003 0310 	and.w	r3, r3, #16
  4020d4:	2b00      	cmp	r3, #0
  4020d6:	d1e9      	bne.n	4020ac <hsmci_wait_busy+0xc>
	return true;
  4020d8:	2301      	movs	r3, #1
}
  4020da:	4618      	mov	r0, r3
  4020dc:	3708      	adds	r7, #8
  4020de:	46bd      	mov	sp, r7
  4020e0:	bd80      	pop	{r7, pc}
  4020e2:	bf00      	nop
  4020e4:	40080000 	.word	0x40080000
  4020e8:	00401f99 	.word	0x00401f99

004020ec <hsmci_send_cmd_execute>:
 *
 * \return true if success, otherwise false
 */
static bool hsmci_send_cmd_execute(uint32_t cmdr, sdmmc_cmd_def_t cmd,
		uint32_t arg)
{
  4020ec:	b580      	push	{r7, lr}
  4020ee:	b086      	sub	sp, #24
  4020f0:	af00      	add	r7, sp, #0
  4020f2:	60f8      	str	r0, [r7, #12]
  4020f4:	60b9      	str	r1, [r7, #8]
  4020f6:	607a      	str	r2, [r7, #4]
	uint32_t sr;

	cmdr |= HSMCI_CMDR_CMDNB(cmd) | HSMCI_CMDR_SPCMD_STD;
  4020f8:	68bb      	ldr	r3, [r7, #8]
  4020fa:	f003 033f 	and.w	r3, r3, #63	; 0x3f
  4020fe:	68fa      	ldr	r2, [r7, #12]
  402100:	4313      	orrs	r3, r2
  402102:	60fb      	str	r3, [r7, #12]
	if (cmd & SDMMC_RESP_PRESENT) {
  402104:	68bb      	ldr	r3, [r7, #8]
  402106:	f403 7380 	and.w	r3, r3, #256	; 0x100
  40210a:	2b00      	cmp	r3, #0
  40210c:	d01b      	beq.n	402146 <hsmci_send_cmd_execute+0x5a>
		cmdr |= HSMCI_CMDR_MAXLAT;
  40210e:	68fb      	ldr	r3, [r7, #12]
  402110:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
  402114:	60fb      	str	r3, [r7, #12]
		if (cmd & SDMMC_RESP_136) {
  402116:	68bb      	ldr	r3, [r7, #8]
  402118:	f403 6300 	and.w	r3, r3, #2048	; 0x800
  40211c:	2b00      	cmp	r3, #0
  40211e:	d004      	beq.n	40212a <hsmci_send_cmd_execute+0x3e>
			cmdr |= HSMCI_CMDR_RSPTYP_136_BIT;
  402120:	68fb      	ldr	r3, [r7, #12]
  402122:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  402126:	60fb      	str	r3, [r7, #12]
  402128:	e00d      	b.n	402146 <hsmci_send_cmd_execute+0x5a>
		} else if (cmd & SDMMC_RESP_BUSY) {
  40212a:	68bb      	ldr	r3, [r7, #8]
  40212c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  402130:	2b00      	cmp	r3, #0
  402132:	d004      	beq.n	40213e <hsmci_send_cmd_execute+0x52>
			cmdr |= HSMCI_CMDR_RSPTYP_R1B;
  402134:	68fb      	ldr	r3, [r7, #12]
  402136:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
  40213a:	60fb      	str	r3, [r7, #12]
  40213c:	e003      	b.n	402146 <hsmci_send_cmd_execute+0x5a>
		} else {
			cmdr |= HSMCI_CMDR_RSPTYP_48_BIT;
  40213e:	68fb      	ldr	r3, [r7, #12]
  402140:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  402144:	60fb      	str	r3, [r7, #12]
		}
	}
	if (cmd & SDMMC_CMD_OPENDRAIN) {
  402146:	68bb      	ldr	r3, [r7, #8]
  402148:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
  40214c:	2b00      	cmp	r3, #0
  40214e:	d003      	beq.n	402158 <hsmci_send_cmd_execute+0x6c>
		cmdr |= HSMCI_CMDR_OPDCMD_OPENDRAIN;
  402150:	68fb      	ldr	r3, [r7, #12]
  402152:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  402156:	60fb      	str	r3, [r7, #12]
	}

	// Write argument
	HSMCI->HSMCI_ARGR = arg;
  402158:	4a1c      	ldr	r2, [pc, #112]	; (4021cc <hsmci_send_cmd_execute+0xe0>)
  40215a:	687b      	ldr	r3, [r7, #4]
  40215c:	6113      	str	r3, [r2, #16]
	// Write and start command
	HSMCI->HSMCI_CMDR = cmdr;
  40215e:	4a1b      	ldr	r2, [pc, #108]	; (4021cc <hsmci_send_cmd_execute+0xe0>)
  402160:	68fb      	ldr	r3, [r7, #12]
  402162:	6153      	str	r3, [r2, #20]

	// Wait end of command
	do {
		sr = HSMCI->HSMCI_SR;
  402164:	4b19      	ldr	r3, [pc, #100]	; (4021cc <hsmci_send_cmd_execute+0xe0>)
  402166:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  402168:	617b      	str	r3, [r7, #20]
		if (cmd & SDMMC_RESP_CRC) {
  40216a:	68bb      	ldr	r3, [r7, #8]
  40216c:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  402170:	2b00      	cmp	r3, #0
  402172:	d008      	beq.n	402186 <hsmci_send_cmd_execute+0x9a>
			if (sr & (HSMCI_SR_CSTOE | HSMCI_SR_RTOE
  402174:	697b      	ldr	r3, [r7, #20]
  402176:	f403 031f 	and.w	r3, r3, #10420224	; 0x9f0000
  40217a:	2b00      	cmp	r3, #0
  40217c:	d00c      	beq.n	402198 <hsmci_send_cmd_execute+0xac>
					| HSMCI_SR_RENDE | HSMCI_SR_RCRCE
					| HSMCI_SR_RDIRE | HSMCI_SR_RINDE)) {
				hsmci_debug("%s: CMD 0x%08x sr 0x%08x error\n\r",
						__func__, cmd, sr);
				hsmci_reset();
  40217e:	4b14      	ldr	r3, [pc, #80]	; (4021d0 <hsmci_send_cmd_execute+0xe4>)
  402180:	4798      	blx	r3
				return false;
  402182:	2300      	movs	r3, #0
  402184:	e01d      	b.n	4021c2 <hsmci_send_cmd_execute+0xd6>
			}
		} else {
			if (sr & (HSMCI_SR_CSTOE | HSMCI_SR_RTOE
  402186:	697b      	ldr	r3, [r7, #20]
  402188:	f403 031b 	and.w	r3, r3, #10158080	; 0x9b0000
  40218c:	2b00      	cmp	r3, #0
  40218e:	d003      	beq.n	402198 <hsmci_send_cmd_execute+0xac>
					| HSMCI_SR_RENDE
					| HSMCI_SR_RDIRE | HSMCI_SR_RINDE)) {
				hsmci_debug("%s: CMD 0x%08x sr 0x%08x error\n\r",
						__func__, cmd, sr);
				hsmci_reset();
  402190:	4b0f      	ldr	r3, [pc, #60]	; (4021d0 <hsmci_send_cmd_execute+0xe4>)
  402192:	4798      	blx	r3
				return false;
  402194:	2300      	movs	r3, #0
  402196:	e014      	b.n	4021c2 <hsmci_send_cmd_execute+0xd6>
			}
		}
	} while (!(sr & HSMCI_SR_CMDRDY));
  402198:	697b      	ldr	r3, [r7, #20]
  40219a:	f003 0301 	and.w	r3, r3, #1
  40219e:	2b00      	cmp	r3, #0
  4021a0:	d0e0      	beq.n	402164 <hsmci_send_cmd_execute+0x78>

	if (cmd & SDMMC_RESP_BUSY) {
  4021a2:	68bb      	ldr	r3, [r7, #8]
  4021a4:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  4021a8:	2b00      	cmp	r3, #0
  4021aa:	d009      	beq.n	4021c0 <hsmci_send_cmd_execute+0xd4>
		if (!hsmci_wait_busy()) {
  4021ac:	4b09      	ldr	r3, [pc, #36]	; (4021d4 <hsmci_send_cmd_execute+0xe8>)
  4021ae:	4798      	blx	r3
  4021b0:	4603      	mov	r3, r0
  4021b2:	f083 0301 	eor.w	r3, r3, #1
  4021b6:	b2db      	uxtb	r3, r3
  4021b8:	2b00      	cmp	r3, #0
  4021ba:	d001      	beq.n	4021c0 <hsmci_send_cmd_execute+0xd4>
			return false;
  4021bc:	2300      	movs	r3, #0
  4021be:	e000      	b.n	4021c2 <hsmci_send_cmd_execute+0xd6>
		}
	}
	return true;
  4021c0:	2301      	movs	r3, #1
}
  4021c2:	4618      	mov	r0, r3
  4021c4:	3718      	adds	r7, #24
  4021c6:	46bd      	mov	sp, r7
  4021c8:	bd80      	pop	{r7, pc}
  4021ca:	bf00      	nop
  4021cc:	40080000 	.word	0x40080000
  4021d0:	00401f99 	.word	0x00401f99
  4021d4:	004020a1 	.word	0x004020a1

004021d8 <hsmci_init>:

//-------------------------------------------------------------------
//--------------------- PUBLIC FUNCTIONS ----------------------------

void hsmci_init(void)
{
  4021d8:	b580      	push	{r7, lr}
  4021da:	af00      	add	r7, sp, #0
	pmc_enable_periph_clk(ID_HSMCI);
  4021dc:	2010      	movs	r0, #16
  4021de:	4b0a      	ldr	r3, [pc, #40]	; (402208 <hsmci_init+0x30>)
  4021e0:	4798      	blx	r3
	pmc_enable_periph_clk(ID_XDMAC);
#endif
#endif

	// Set the Data Timeout Register to 2 Mega Cycles
	HSMCI->HSMCI_DTOR = HSMCI_DTOR_DTOMUL_1048576 | HSMCI_DTOR_DTOCYC(2);
  4021e2:	4b0a      	ldr	r3, [pc, #40]	; (40220c <hsmci_init+0x34>)
  4021e4:	2272      	movs	r2, #114	; 0x72
  4021e6:	609a      	str	r2, [r3, #8]
	// Set Completion Signal Timeout to 2 Mega Cycles
	HSMCI->HSMCI_CSTOR = HSMCI_CSTOR_CSTOMUL_1048576 | HSMCI_CSTOR_CSTOCYC(2);
  4021e8:	4b08      	ldr	r3, [pc, #32]	; (40220c <hsmci_init+0x34>)
  4021ea:	2272      	movs	r2, #114	; 0x72
  4021ec:	61da      	str	r2, [r3, #28]
	// Set Configuration Register
	HSMCI->HSMCI_CFG = HSMCI_CFG_FIFOMODE | HSMCI_CFG_FERRCTRL;
  4021ee:	4b07      	ldr	r3, [pc, #28]	; (40220c <hsmci_init+0x34>)
  4021f0:	2211      	movs	r2, #17
  4021f2:	655a      	str	r2, [r3, #84]	; 0x54
	// Set power saving to maximum value
	HSMCI->HSMCI_MR = HSMCI_MR_PWSDIV_Msk;
  4021f4:	4b05      	ldr	r3, [pc, #20]	; (40220c <hsmci_init+0x34>)
  4021f6:	f44f 62e0 	mov.w	r2, #1792	; 0x700
  4021fa:	605a      	str	r2, [r3, #4]

	// Enable the HSMCI and the Power Saving
	HSMCI->HSMCI_CR = HSMCI_CR_MCIEN | HSMCI_CR_PWSEN;
  4021fc:	4b03      	ldr	r3, [pc, #12]	; (40220c <hsmci_init+0x34>)
  4021fe:	2205      	movs	r2, #5
  402200:	601a      	str	r2, [r3, #0]
}
  402202:	bf00      	nop
  402204:	bd80      	pop	{r7, pc}
  402206:	bf00      	nop
  402208:	004036d5 	.word	0x004036d5
  40220c:	40080000 	.word	0x40080000

00402210 <hsmci_get_bus_width>:

uint8_t hsmci_get_bus_width(uint8_t slot)
{
  402210:	b480      	push	{r7}
  402212:	b083      	sub	sp, #12
  402214:	af00      	add	r7, sp, #0
  402216:	4603      	mov	r3, r0
  402218:	71fb      	strb	r3, [r7, #7]
	switch (slot) {
  40221a:	79fb      	ldrb	r3, [r7, #7]
  40221c:	2b00      	cmp	r3, #0
  40221e:	d101      	bne.n	402224 <hsmci_get_bus_width+0x14>
	case 0:
		return SD_MMC_HSMCI_SLOT_0_SIZE;
  402220:	2304      	movs	r3, #4
  402222:	e000      	b.n	402226 <hsmci_get_bus_width+0x16>
#if (SD_MMC_HSMCI_MEM_CNT == 2)
	case 1:
		return SD_MMC_HSMCI_SLOT_1_SIZE;
#endif
	default:
		return 0; // Slot number wrong
  402224:	2300      	movs	r3, #0
	}
}
  402226:	4618      	mov	r0, r3
  402228:	370c      	adds	r7, #12
  40222a:	46bd      	mov	sp, r7
  40222c:	f85d 7b04 	ldr.w	r7, [sp], #4
  402230:	4770      	bx	lr

00402232 <hsmci_is_high_speed_capable>:

bool hsmci_is_high_speed_capable(void)
{
  402232:	b480      	push	{r7}
  402234:	af00      	add	r7, sp, #0
	return true;
  402236:	2301      	movs	r3, #1
}
  402238:	4618      	mov	r0, r3
  40223a:	46bd      	mov	sp, r7
  40223c:	f85d 7b04 	ldr.w	r7, [sp], #4
  402240:	4770      	bx	lr
	...

00402244 <hsmci_select_device>:

void hsmci_select_device(uint8_t slot, uint32_t clock, uint8_t bus_width, bool high_speed)
{
  402244:	b580      	push	{r7, lr}
  402246:	b084      	sub	sp, #16
  402248:	af00      	add	r7, sp, #0
  40224a:	6039      	str	r1, [r7, #0]
  40224c:	4611      	mov	r1, r2
  40224e:	461a      	mov	r2, r3
  402250:	4603      	mov	r3, r0
  402252:	71fb      	strb	r3, [r7, #7]
  402254:	460b      	mov	r3, r1
  402256:	71bb      	strb	r3, [r7, #6]
  402258:	4613      	mov	r3, r2
  40225a:	717b      	strb	r3, [r7, #5]
	uint32_t hsmci_slot = HSMCI_SDCR_SDCSEL_SLOTA;
  40225c:	2300      	movs	r3, #0
  40225e:	60fb      	str	r3, [r7, #12]
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;
  402260:	2300      	movs	r3, #0
  402262:	60bb      	str	r3, [r7, #8]

	if (high_speed) {
  402264:	797b      	ldrb	r3, [r7, #5]
  402266:	2b00      	cmp	r3, #0
  402268:	d006      	beq.n	402278 <hsmci_select_device+0x34>
		HSMCI->HSMCI_CFG |= HSMCI_CFG_HSMODE;
  40226a:	4a19      	ldr	r2, [pc, #100]	; (4022d0 <hsmci_select_device+0x8c>)
  40226c:	4b18      	ldr	r3, [pc, #96]	; (4022d0 <hsmci_select_device+0x8c>)
  40226e:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  402270:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  402274:	6553      	str	r3, [r2, #84]	; 0x54
  402276:	e005      	b.n	402284 <hsmci_select_device+0x40>
	} else {
		HSMCI->HSMCI_CFG &= ~HSMCI_CFG_HSMODE;
  402278:	4a15      	ldr	r2, [pc, #84]	; (4022d0 <hsmci_select_device+0x8c>)
  40227a:	4b15      	ldr	r3, [pc, #84]	; (4022d0 <hsmci_select_device+0x8c>)
  40227c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  40227e:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  402282:	6553      	str	r3, [r2, #84]	; 0x54
	}

	hsmci_set_speed(clock, sysclk_get_peripheral_hz());
  402284:	4b13      	ldr	r3, [pc, #76]	; (4022d4 <hsmci_select_device+0x90>)
  402286:	4798      	blx	r3
  402288:	4603      	mov	r3, r0
  40228a:	4619      	mov	r1, r3
  40228c:	6838      	ldr	r0, [r7, #0]
  40228e:	4b12      	ldr	r3, [pc, #72]	; (4022d8 <hsmci_select_device+0x94>)
  402290:	4798      	blx	r3

	switch (slot) {
  402292:	79fb      	ldrb	r3, [r7, #7]
  402294:	2b00      	cmp	r3, #0
  402296:	d102      	bne.n	40229e <hsmci_select_device+0x5a>
	case 0:
		hsmci_slot = HSMCI_SDCR_SDCSEL_SLOTA;
  402298:	2300      	movs	r3, #0
  40229a:	60fb      	str	r3, [r7, #12]
		break;
  40229c:	bf00      	nop
#endif
	default:
		Assert(false); // Slot number wrong
	}

	switch (bus_width) {
  40229e:	79bb      	ldrb	r3, [r7, #6]
  4022a0:	2b04      	cmp	r3, #4
  4022a2:	d006      	beq.n	4022b2 <hsmci_select_device+0x6e>
  4022a4:	2b08      	cmp	r3, #8
  4022a6:	d007      	beq.n	4022b8 <hsmci_select_device+0x74>
  4022a8:	2b01      	cmp	r3, #1
  4022aa:	d108      	bne.n	4022be <hsmci_select_device+0x7a>
	case 1:
		hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;
  4022ac:	2300      	movs	r3, #0
  4022ae:	60bb      	str	r3, [r7, #8]
		break;
  4022b0:	e005      	b.n	4022be <hsmci_select_device+0x7a>

	case 4:
		hsmci_bus_width = HSMCI_SDCR_SDCBUS_4;
  4022b2:	2380      	movs	r3, #128	; 0x80
  4022b4:	60bb      	str	r3, [r7, #8]
		break;
  4022b6:	e002      	b.n	4022be <hsmci_select_device+0x7a>

	case 8:
		hsmci_bus_width = HSMCI_SDCR_SDCBUS_8;
  4022b8:	23c0      	movs	r3, #192	; 0xc0
  4022ba:	60bb      	str	r3, [r7, #8]
		break;
  4022bc:	bf00      	nop

	default:
		Assert(false); // Bus width wrong
	}
	HSMCI->HSMCI_SDCR = hsmci_slot | hsmci_bus_width;
  4022be:	4904      	ldr	r1, [pc, #16]	; (4022d0 <hsmci_select_device+0x8c>)
  4022c0:	68fa      	ldr	r2, [r7, #12]
  4022c2:	68bb      	ldr	r3, [r7, #8]
  4022c4:	4313      	orrs	r3, r2
  4022c6:	60cb      	str	r3, [r1, #12]
}
  4022c8:	bf00      	nop
  4022ca:	3710      	adds	r7, #16
  4022cc:	46bd      	mov	sp, r7
  4022ce:	bd80      	pop	{r7, pc}
  4022d0:	40080000 	.word	0x40080000
  4022d4:	00401f85 	.word	0x00401f85
  4022d8:	00401ff9 	.word	0x00401ff9

004022dc <hsmci_deselect_device>:

void hsmci_deselect_device(uint8_t slot)
{
  4022dc:	b480      	push	{r7}
  4022de:	b083      	sub	sp, #12
  4022e0:	af00      	add	r7, sp, #0
  4022e2:	4603      	mov	r3, r0
  4022e4:	71fb      	strb	r3, [r7, #7]
	UNUSED(slot);
	// Nothing to do
}
  4022e6:	bf00      	nop
  4022e8:	370c      	adds	r7, #12
  4022ea:	46bd      	mov	sp, r7
  4022ec:	f85d 7b04 	ldr.w	r7, [sp], #4
  4022f0:	4770      	bx	lr
	...

004022f4 <hsmci_send_clock>:

void hsmci_send_clock(void)
{
  4022f4:	b480      	push	{r7}
  4022f6:	af00      	add	r7, sp, #0
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  4022f8:	4a0c      	ldr	r2, [pc, #48]	; (40232c <hsmci_send_clock+0x38>)
  4022fa:	4b0c      	ldr	r3, [pc, #48]	; (40232c <hsmci_send_clock+0x38>)
  4022fc:	685b      	ldr	r3, [r3, #4]
  4022fe:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
  402302:	6053      	str	r3, [r2, #4]
	// Write argument
	HSMCI->HSMCI_ARGR = 0;
  402304:	4b09      	ldr	r3, [pc, #36]	; (40232c <hsmci_send_clock+0x38>)
  402306:	2200      	movs	r2, #0
  402308:	611a      	str	r2, [r3, #16]
	// Write and start initialization command
	HSMCI->HSMCI_CMDR = HSMCI_CMDR_RSPTYP_NORESP
  40230a:	4b08      	ldr	r3, [pc, #32]	; (40232c <hsmci_send_clock+0x38>)
  40230c:	f44f 6210 	mov.w	r2, #2304	; 0x900
  402310:	615a      	str	r2, [r3, #20]
			| HSMCI_CMDR_SPCMD_INIT
			| HSMCI_CMDR_OPDCMD_OPENDRAIN;
	// Wait end of initialization command
	while (!(HSMCI->HSMCI_SR & HSMCI_SR_CMDRDY));
  402312:	bf00      	nop
  402314:	4b05      	ldr	r3, [pc, #20]	; (40232c <hsmci_send_clock+0x38>)
  402316:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  402318:	f003 0301 	and.w	r3, r3, #1
  40231c:	2b00      	cmp	r3, #0
  40231e:	d0f9      	beq.n	402314 <hsmci_send_clock+0x20>
}
  402320:	bf00      	nop
  402322:	46bd      	mov	sp, r7
  402324:	f85d 7b04 	ldr.w	r7, [sp], #4
  402328:	4770      	bx	lr
  40232a:	bf00      	nop
  40232c:	40080000 	.word	0x40080000

00402330 <hsmci_send_cmd>:

bool hsmci_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
  402330:	b580      	push	{r7, lr}
  402332:	b082      	sub	sp, #8
  402334:	af00      	add	r7, sp, #0
  402336:	6078      	str	r0, [r7, #4]
  402338:	6039      	str	r1, [r7, #0]
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  40233a:	4a0c      	ldr	r2, [pc, #48]	; (40236c <hsmci_send_cmd+0x3c>)
  40233c:	4b0b      	ldr	r3, [pc, #44]	; (40236c <hsmci_send_cmd+0x3c>)
  40233e:	685b      	ldr	r3, [r3, #4]
  402340:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
  402344:	6053      	str	r3, [r2, #4]
	// Disable DMA for HSMCI
	HSMCI->HSMCI_DMA = 0;
#endif
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
  402346:	4a09      	ldr	r2, [pc, #36]	; (40236c <hsmci_send_cmd+0x3c>)
  402348:	4b08      	ldr	r3, [pc, #32]	; (40236c <hsmci_send_cmd+0x3c>)
  40234a:	685b      	ldr	r3, [r3, #4]
  40234c:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
  402350:	6053      	str	r3, [r2, #4]
#ifdef HSMCI_DMA_DMAEN
	// Disable DMA for HSMCI
	HSMCI->HSMCI_DMA = 0;
#endif
#endif
	HSMCI->HSMCI_BLKR = 0;
  402352:	4b06      	ldr	r3, [pc, #24]	; (40236c <hsmci_send_cmd+0x3c>)
  402354:	2200      	movs	r2, #0
  402356:	619a      	str	r2, [r3, #24]
	return hsmci_send_cmd_execute(0, cmd, arg);
  402358:	683a      	ldr	r2, [r7, #0]
  40235a:	6879      	ldr	r1, [r7, #4]
  40235c:	2000      	movs	r0, #0
  40235e:	4b04      	ldr	r3, [pc, #16]	; (402370 <hsmci_send_cmd+0x40>)
  402360:	4798      	blx	r3
  402362:	4603      	mov	r3, r0
}
  402364:	4618      	mov	r0, r3
  402366:	3708      	adds	r7, #8
  402368:	46bd      	mov	sp, r7
  40236a:	bd80      	pop	{r7, pc}
  40236c:	40080000 	.word	0x40080000
  402370:	004020ed 	.word	0x004020ed

00402374 <hsmci_get_response>:

uint32_t hsmci_get_response(void)
{
  402374:	b480      	push	{r7}
  402376:	af00      	add	r7, sp, #0
	return HSMCI->HSMCI_RSPR[0];
  402378:	4b03      	ldr	r3, [pc, #12]	; (402388 <hsmci_get_response+0x14>)
  40237a:	6a1b      	ldr	r3, [r3, #32]
}
  40237c:	4618      	mov	r0, r3
  40237e:	46bd      	mov	sp, r7
  402380:	f85d 7b04 	ldr.w	r7, [sp], #4
  402384:	4770      	bx	lr
  402386:	bf00      	nop
  402388:	40080000 	.word	0x40080000

0040238c <hsmci_get_response_128>:

void hsmci_get_response_128(uint8_t* response)
{
  40238c:	b480      	push	{r7}
  40238e:	b085      	sub	sp, #20
  402390:	af00      	add	r7, sp, #0
  402392:	6078      	str	r0, [r7, #4]
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
  402394:	2300      	movs	r3, #0
  402396:	73fb      	strb	r3, [r7, #15]
  402398:	e024      	b.n	4023e4 <hsmci_get_response_128+0x58>
		response_32 = HSMCI->HSMCI_RSPR[0];
  40239a:	4b17      	ldr	r3, [pc, #92]	; (4023f8 <hsmci_get_response_128+0x6c>)
  40239c:	6a1b      	ldr	r3, [r3, #32]
  40239e:	60bb      	str	r3, [r7, #8]
		*response = (response_32 >> 24) & 0xFF;
  4023a0:	68bb      	ldr	r3, [r7, #8]
  4023a2:	0e1b      	lsrs	r3, r3, #24
  4023a4:	b2da      	uxtb	r2, r3
  4023a6:	687b      	ldr	r3, [r7, #4]
  4023a8:	701a      	strb	r2, [r3, #0]
		response++;
  4023aa:	687b      	ldr	r3, [r7, #4]
  4023ac:	3301      	adds	r3, #1
  4023ae:	607b      	str	r3, [r7, #4]
		*response = (response_32 >> 16) & 0xFF;
  4023b0:	68bb      	ldr	r3, [r7, #8]
  4023b2:	0c1b      	lsrs	r3, r3, #16
  4023b4:	b2da      	uxtb	r2, r3
  4023b6:	687b      	ldr	r3, [r7, #4]
  4023b8:	701a      	strb	r2, [r3, #0]
		response++;
  4023ba:	687b      	ldr	r3, [r7, #4]
  4023bc:	3301      	adds	r3, #1
  4023be:	607b      	str	r3, [r7, #4]
		*response = (response_32 >>  8) & 0xFF;
  4023c0:	68bb      	ldr	r3, [r7, #8]
  4023c2:	0a1b      	lsrs	r3, r3, #8
  4023c4:	b2da      	uxtb	r2, r3
  4023c6:	687b      	ldr	r3, [r7, #4]
  4023c8:	701a      	strb	r2, [r3, #0]
		response++;
  4023ca:	687b      	ldr	r3, [r7, #4]
  4023cc:	3301      	adds	r3, #1
  4023ce:	607b      	str	r3, [r7, #4]
		*response = (response_32 >>  0) & 0xFF;
  4023d0:	68bb      	ldr	r3, [r7, #8]
  4023d2:	b2da      	uxtb	r2, r3
  4023d4:	687b      	ldr	r3, [r7, #4]
  4023d6:	701a      	strb	r2, [r3, #0]
		response++;
  4023d8:	687b      	ldr	r3, [r7, #4]
  4023da:	3301      	adds	r3, #1
  4023dc:	607b      	str	r3, [r7, #4]
	for (uint8_t i = 0; i < 4; i++) {
  4023de:	7bfb      	ldrb	r3, [r7, #15]
  4023e0:	3301      	adds	r3, #1
  4023e2:	73fb      	strb	r3, [r7, #15]
  4023e4:	7bfb      	ldrb	r3, [r7, #15]
  4023e6:	2b03      	cmp	r3, #3
  4023e8:	d9d7      	bls.n	40239a <hsmci_get_response_128+0xe>
	}
}
  4023ea:	bf00      	nop
  4023ec:	3714      	adds	r7, #20
  4023ee:	46bd      	mov	sp, r7
  4023f0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4023f4:	4770      	bx	lr
  4023f6:	bf00      	nop
  4023f8:	40080000 	.word	0x40080000

004023fc <hsmci_adtc_start>:

bool hsmci_adtc_start(sdmmc_cmd_def_t cmd, uint32_t arg, uint16_t block_size, uint16_t nb_block, bool access_block)
{
  4023fc:	b580      	push	{r7, lr}
  4023fe:	b086      	sub	sp, #24
  402400:	af00      	add	r7, sp, #0
  402402:	60f8      	str	r0, [r7, #12]
  402404:	60b9      	str	r1, [r7, #8]
  402406:	4611      	mov	r1, r2
  402408:	461a      	mov	r2, r3
  40240a:	460b      	mov	r3, r1
  40240c:	80fb      	strh	r3, [r7, #6]
  40240e:	4613      	mov	r3, r2
  402410:	80bb      	strh	r3, [r7, #4]
		HSMCI->HSMCI_DMA = 0;
	}
#endif

#ifdef HSMCI_MR_PDCMODE
	if (access_block) {
  402412:	f897 3020 	ldrb.w	r3, [r7, #32]
  402416:	2b00      	cmp	r3, #0
  402418:	d006      	beq.n	402428 <hsmci_adtc_start+0x2c>
		// Enable PDC for HSMCI
		HSMCI->HSMCI_MR |= HSMCI_MR_PDCMODE;
  40241a:	4a3d      	ldr	r2, [pc, #244]	; (402510 <hsmci_adtc_start+0x114>)
  40241c:	4b3c      	ldr	r3, [pc, #240]	; (402510 <hsmci_adtc_start+0x114>)
  40241e:	685b      	ldr	r3, [r3, #4]
  402420:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  402424:	6053      	str	r3, [r2, #4]
  402426:	e005      	b.n	402434 <hsmci_adtc_start+0x38>
	} else {
		// Disable PDC for HSMCI
		HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
  402428:	4a39      	ldr	r2, [pc, #228]	; (402510 <hsmci_adtc_start+0x114>)
  40242a:	4b39      	ldr	r3, [pc, #228]	; (402510 <hsmci_adtc_start+0x114>)
  40242c:	685b      	ldr	r3, [r3, #4]
  40242e:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
  402432:	6053      	str	r3, [r2, #4]
#endif
#endif
	// Enabling Read/Write Proof allows to stop the HSMCI Clock during
	// read/write  access if the internal FIFO is full.
	// This will guarantee data integrity, not bandwidth.
	HSMCI->HSMCI_MR |= HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF;
  402434:	4a36      	ldr	r2, [pc, #216]	; (402510 <hsmci_adtc_start+0x114>)
  402436:	4b36      	ldr	r3, [pc, #216]	; (402510 <hsmci_adtc_start+0x114>)
  402438:	685b      	ldr	r3, [r3, #4]
  40243a:	f443 53c0 	orr.w	r3, r3, #6144	; 0x1800
  40243e:	6053      	str	r3, [r2, #4]
	// Force byte transfer if needed
	if (block_size & 0x3) {
  402440:	88fb      	ldrh	r3, [r7, #6]
  402442:	f003 0303 	and.w	r3, r3, #3
  402446:	2b00      	cmp	r3, #0
  402448:	d006      	beq.n	402458 <hsmci_adtc_start+0x5c>
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
  40244a:	4a31      	ldr	r2, [pc, #196]	; (402510 <hsmci_adtc_start+0x114>)
  40244c:	4b30      	ldr	r3, [pc, #192]	; (402510 <hsmci_adtc_start+0x114>)
  40244e:	685b      	ldr	r3, [r3, #4]
  402450:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
  402454:	6053      	str	r3, [r2, #4]
  402456:	e005      	b.n	402464 <hsmci_adtc_start+0x68>
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  402458:	4a2d      	ldr	r2, [pc, #180]	; (402510 <hsmci_adtc_start+0x114>)
  40245a:	4b2d      	ldr	r3, [pc, #180]	; (402510 <hsmci_adtc_start+0x114>)
  40245c:	685b      	ldr	r3, [r3, #4]
  40245e:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  402462:	6053      	str	r3, [r2, #4]
	}

	if (cmd & SDMMC_CMD_WRITE) {
  402464:	68fb      	ldr	r3, [r7, #12]
  402466:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
  40246a:	2b00      	cmp	r3, #0
  40246c:	d003      	beq.n	402476 <hsmci_adtc_start+0x7a>
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_WRITE;
  40246e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
  402472:	617b      	str	r3, [r7, #20]
  402474:	e002      	b.n	40247c <hsmci_adtc_start+0x80>
	} else {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_READ;
  402476:	f44f 23a0 	mov.w	r3, #327680	; 0x50000
  40247a:	617b      	str	r3, [r7, #20]
	}

	if (cmd & SDMMC_CMD_SDIO_BYTE) {
  40247c:	68fb      	ldr	r3, [r7, #12]
  40247e:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
  402482:	2b00      	cmp	r3, #0
  402484:	d009      	beq.n	40249a <hsmci_adtc_start+0x9e>
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
  402486:	697b      	ldr	r3, [r7, #20]
  402488:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
  40248c:	617b      	str	r3, [r7, #20]
			// Value 0 corresponds to a 512-byte transfer
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
  40248e:	4a20      	ldr	r2, [pc, #128]	; (402510 <hsmci_adtc_start+0x114>)
  402490:	88fb      	ldrh	r3, [r7, #6]
  402492:	f3c3 0308 	ubfx	r3, r3, #0, #9
  402496:	6193      	str	r3, [r2, #24]
  402498:	e027      	b.n	4024ea <hsmci_adtc_start+0xee>
	} else {
		HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BLKLEN_Pos) |
  40249a:	491d      	ldr	r1, [pc, #116]	; (402510 <hsmci_adtc_start+0x114>)
  40249c:	88fb      	ldrh	r3, [r7, #6]
  40249e:	041a      	lsls	r2, r3, #16
				(nb_block << HSMCI_BLKR_BCNT_Pos);
  4024a0:	88bb      	ldrh	r3, [r7, #4]
		HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BLKLEN_Pos) |
  4024a2:	4313      	orrs	r3, r2
  4024a4:	618b      	str	r3, [r1, #24]
		if (cmd & SDMMC_CMD_SDIO_BLOCK) {
  4024a6:	68fb      	ldr	r3, [r7, #12]
  4024a8:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  4024ac:	2b00      	cmp	r3, #0
  4024ae:	d004      	beq.n	4024ba <hsmci_adtc_start+0xbe>
			cmdr |= HSMCI_CMDR_TRTYP_BLOCK;
  4024b0:	697b      	ldr	r3, [r7, #20]
  4024b2:	f443 1320 	orr.w	r3, r3, #2621440	; 0x280000
  4024b6:	617b      	str	r3, [r7, #20]
  4024b8:	e017      	b.n	4024ea <hsmci_adtc_start+0xee>
		} else if (cmd & SDMMC_CMD_STREAM) {
  4024ba:	68fb      	ldr	r3, [r7, #12]
  4024bc:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
  4024c0:	2b00      	cmp	r3, #0
  4024c2:	d004      	beq.n	4024ce <hsmci_adtc_start+0xd2>
			cmdr |= HSMCI_CMDR_TRTYP_STREAM;
  4024c4:	697b      	ldr	r3, [r7, #20]
  4024c6:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  4024ca:	617b      	str	r3, [r7, #20]
  4024cc:	e00d      	b.n	4024ea <hsmci_adtc_start+0xee>
		} else if (cmd & SDMMC_CMD_SINGLE_BLOCK) {
  4024ce:	68fb      	ldr	r3, [r7, #12]
  4024d0:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
  4024d4:	2b00      	cmp	r3, #0
  4024d6:	d108      	bne.n	4024ea <hsmci_adtc_start+0xee>
			cmdr |= HSMCI_CMDR_TRTYP_SINGLE;
		} else if (cmd & SDMMC_CMD_MULTI_BLOCK) {
  4024d8:	68fb      	ldr	r3, [r7, #12]
  4024da:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
  4024de:	2b00      	cmp	r3, #0
  4024e0:	d003      	beq.n	4024ea <hsmci_adtc_start+0xee>
			cmdr |= HSMCI_CMDR_TRTYP_MULTIPLE;
  4024e2:	697b      	ldr	r3, [r7, #20]
  4024e4:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
  4024e8:	617b      	str	r3, [r7, #20]
		} else {
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
  4024ea:	4b0a      	ldr	r3, [pc, #40]	; (402514 <hsmci_adtc_start+0x118>)
  4024ec:	2200      	movs	r2, #0
  4024ee:	601a      	str	r2, [r3, #0]
	hsmci_block_size = block_size;
  4024f0:	4a09      	ldr	r2, [pc, #36]	; (402518 <hsmci_adtc_start+0x11c>)
  4024f2:	88fb      	ldrh	r3, [r7, #6]
  4024f4:	8013      	strh	r3, [r2, #0]
	hsmci_nb_block = nb_block;
  4024f6:	4a09      	ldr	r2, [pc, #36]	; (40251c <hsmci_adtc_start+0x120>)
  4024f8:	88bb      	ldrh	r3, [r7, #4]
  4024fa:	8013      	strh	r3, [r2, #0]

	return hsmci_send_cmd_execute(cmdr, cmd, arg);
  4024fc:	68ba      	ldr	r2, [r7, #8]
  4024fe:	68f9      	ldr	r1, [r7, #12]
  402500:	6978      	ldr	r0, [r7, #20]
  402502:	4b07      	ldr	r3, [pc, #28]	; (402520 <hsmci_adtc_start+0x124>)
  402504:	4798      	blx	r3
  402506:	4603      	mov	r3, r0
}
  402508:	4618      	mov	r0, r3
  40250a:	3718      	adds	r7, #24
  40250c:	46bd      	mov	sp, r7
  40250e:	bd80      	pop	{r7, pc}
  402510:	40080000 	.word	0x40080000
  402514:	20000484 	.word	0x20000484
  402518:	20000488 	.word	0x20000488
  40251c:	2000048a 	.word	0x2000048a
  402520:	004020ed 	.word	0x004020ed

00402524 <hsmci_read_word>:
{
	return hsmci_send_cmd_execute(HSMCI_CMDR_TRCMD_STOP_DATA, cmd, arg);
}

bool hsmci_read_word(uint32_t* value)
{
  402524:	b580      	push	{r7, lr}
  402526:	b084      	sub	sp, #16
  402528:	af00      	add	r7, sp, #0
  40252a:	6078      	str	r0, [r7, #4]

	Assert(((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos);

	// Wait data available
	do {
		sr = HSMCI->HSMCI_SR;
  40252c:	4b1e      	ldr	r3, [pc, #120]	; (4025a8 <hsmci_read_word+0x84>)
  40252e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  402530:	60fb      	str	r3, [r7, #12]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  402532:	68fa      	ldr	r2, [r7, #12]
  402534:	4b1d      	ldr	r3, [pc, #116]	; (4025ac <hsmci_read_word+0x88>)
  402536:	4013      	ands	r3, r2
  402538:	2b00      	cmp	r3, #0
  40253a:	d003      	beq.n	402544 <hsmci_read_word+0x20>
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
  40253c:	4b1c      	ldr	r3, [pc, #112]	; (4025b0 <hsmci_read_word+0x8c>)
  40253e:	4798      	blx	r3
			return false;
  402540:	2300      	movs	r3, #0
  402542:	e02c      	b.n	40259e <hsmci_read_word+0x7a>
		}
	} while (!(sr & HSMCI_SR_RXRDY));
  402544:	68fb      	ldr	r3, [r7, #12]
  402546:	f003 0302 	and.w	r3, r3, #2
  40254a:	2b00      	cmp	r3, #0
  40254c:	d0ee      	beq.n	40252c <hsmci_read_word+0x8>

	// Read data
	*value = HSMCI->HSMCI_RDR;
  40254e:	4b16      	ldr	r3, [pc, #88]	; (4025a8 <hsmci_read_word+0x84>)
  402550:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  402552:	687b      	ldr	r3, [r7, #4]
  402554:	601a      	str	r2, [r3, #0]
	hsmci_transfert_pos += 4;
  402556:	4b17      	ldr	r3, [pc, #92]	; (4025b4 <hsmci_read_word+0x90>)
  402558:	681b      	ldr	r3, [r3, #0]
  40255a:	3304      	adds	r3, #4
  40255c:	4a15      	ldr	r2, [pc, #84]	; (4025b4 <hsmci_read_word+0x90>)
  40255e:	6013      	str	r3, [r2, #0]
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
  402560:	4b15      	ldr	r3, [pc, #84]	; (4025b8 <hsmci_read_word+0x94>)
  402562:	881b      	ldrh	r3, [r3, #0]
  402564:	461a      	mov	r2, r3
  402566:	4b15      	ldr	r3, [pc, #84]	; (4025bc <hsmci_read_word+0x98>)
  402568:	881b      	ldrh	r3, [r3, #0]
  40256a:	fb03 f202 	mul.w	r2, r3, r2
  40256e:	4b11      	ldr	r3, [pc, #68]	; (4025b4 <hsmci_read_word+0x90>)
  402570:	681b      	ldr	r3, [r3, #0]
  402572:	429a      	cmp	r2, r3
  402574:	d901      	bls.n	40257a <hsmci_read_word+0x56>
		return true;
  402576:	2301      	movs	r3, #1
  402578:	e011      	b.n	40259e <hsmci_read_word+0x7a>
	}

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI
	do {
		sr = HSMCI->HSMCI_SR;
  40257a:	4b0b      	ldr	r3, [pc, #44]	; (4025a8 <hsmci_read_word+0x84>)
  40257c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  40257e:	60fb      	str	r3, [r7, #12]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  402580:	68fa      	ldr	r2, [r7, #12]
  402582:	4b0a      	ldr	r3, [pc, #40]	; (4025ac <hsmci_read_word+0x88>)
  402584:	4013      	ands	r3, r2
  402586:	2b00      	cmp	r3, #0
  402588:	d003      	beq.n	402592 <hsmci_read_word+0x6e>
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
  40258a:	4b09      	ldr	r3, [pc, #36]	; (4025b0 <hsmci_read_word+0x8c>)
  40258c:	4798      	blx	r3
			return false;
  40258e:	2300      	movs	r3, #0
  402590:	e005      	b.n	40259e <hsmci_read_word+0x7a>
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
  402592:	68fb      	ldr	r3, [r7, #12]
  402594:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
  402598:	2b00      	cmp	r3, #0
  40259a:	d0ee      	beq.n	40257a <hsmci_read_word+0x56>
	return true;
  40259c:	2301      	movs	r3, #1
}
  40259e:	4618      	mov	r0, r3
  4025a0:	3710      	adds	r7, #16
  4025a2:	46bd      	mov	sp, r7
  4025a4:	bd80      	pop	{r7, pc}
  4025a6:	bf00      	nop
  4025a8:	40080000 	.word	0x40080000
  4025ac:	c0600000 	.word	0xc0600000
  4025b0:	00401f99 	.word	0x00401f99
  4025b4:	20000484 	.word	0x20000484
  4025b8:	20000488 	.word	0x20000488
  4025bc:	2000048a 	.word	0x2000048a

004025c0 <hsmci_start_read_blocks>:
}
#endif // HSMCI_SR_DMADONE

#ifdef HSMCI_MR_PDCMODE
bool hsmci_start_read_blocks(void *dest, uint16_t nb_block)
{
  4025c0:	b480      	push	{r7}
  4025c2:	b085      	sub	sp, #20
  4025c4:	af00      	add	r7, sp, #0
  4025c6:	6078      	str	r0, [r7, #4]
  4025c8:	460b      	mov	r3, r1
  4025ca:	807b      	strh	r3, [r7, #2]
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  4025cc:	887b      	ldrh	r3, [r7, #2]
  4025ce:	4a21      	ldr	r2, [pc, #132]	; (402654 <hsmci_start_read_blocks+0x94>)
  4025d0:	8812      	ldrh	r2, [r2, #0]
  4025d2:	fb02 f303 	mul.w	r3, r2, r3
  4025d6:	60fb      	str	r3, [r7, #12]
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_RCR_RXCTR_Msk >> PERIPH_RCR_RXCTR_Pos));

	// Handle unaligned memory address
	if (((uint32_t)dest & 0x3) || (hsmci_block_size & 0x3)) {
  4025d8:	687b      	ldr	r3, [r7, #4]
  4025da:	f003 0303 	and.w	r3, r3, #3
  4025de:	2b00      	cmp	r3, #0
  4025e0:	d105      	bne.n	4025ee <hsmci_start_read_blocks+0x2e>
  4025e2:	4b1c      	ldr	r3, [pc, #112]	; (402654 <hsmci_start_read_blocks+0x94>)
  4025e4:	881b      	ldrh	r3, [r3, #0]
  4025e6:	f003 0303 	and.w	r3, r3, #3
  4025ea:	2b00      	cmp	r3, #0
  4025ec:	d006      	beq.n	4025fc <hsmci_start_read_blocks+0x3c>
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
  4025ee:	4a1a      	ldr	r2, [pc, #104]	; (402658 <hsmci_start_read_blocks+0x98>)
  4025f0:	4b19      	ldr	r3, [pc, #100]	; (402658 <hsmci_start_read_blocks+0x98>)
  4025f2:	685b      	ldr	r3, [r3, #4]
  4025f4:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
  4025f8:	6053      	str	r3, [r2, #4]
  4025fa:	e005      	b.n	402608 <hsmci_start_read_blocks+0x48>
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  4025fc:	4a16      	ldr	r2, [pc, #88]	; (402658 <hsmci_start_read_blocks+0x98>)
  4025fe:	4b16      	ldr	r3, [pc, #88]	; (402658 <hsmci_start_read_blocks+0x98>)
  402600:	685b      	ldr	r3, [r3, #4]
  402602:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  402606:	6053      	str	r3, [r2, #4]
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
  402608:	4a13      	ldr	r2, [pc, #76]	; (402658 <hsmci_start_read_blocks+0x98>)
  40260a:	687b      	ldr	r3, [r7, #4]
  40260c:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  402610:	4a11      	ldr	r2, [pc, #68]	; (402658 <hsmci_start_read_blocks+0x98>)
  402612:	4b11      	ldr	r3, [pc, #68]	; (402658 <hsmci_start_read_blocks+0x98>)
  402614:	685b      	ldr	r3, [r3, #4]
  402616:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
			nb_data : nb_data / 4;
  40261a:	2b00      	cmp	r3, #0
  40261c:	d102      	bne.n	402624 <hsmci_start_read_blocks+0x64>
  40261e:	68fb      	ldr	r3, [r7, #12]
  402620:	089b      	lsrs	r3, r3, #2
  402622:	e000      	b.n	402626 <hsmci_start_read_blocks+0x66>
  402624:	68fb      	ldr	r3, [r7, #12]
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  402626:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
	HSMCI->HSMCI_RNCR = 0;
  40262a:	4b0b      	ldr	r3, [pc, #44]	; (402658 <hsmci_start_read_blocks+0x98>)
  40262c:	2200      	movs	r2, #0
  40262e:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTEN;
  402632:	4b09      	ldr	r3, [pc, #36]	; (402658 <hsmci_start_read_blocks+0x98>)
  402634:	2201      	movs	r2, #1
  402636:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
	hsmci_transfert_pos += nb_data;
  40263a:	4b08      	ldr	r3, [pc, #32]	; (40265c <hsmci_start_read_blocks+0x9c>)
  40263c:	681a      	ldr	r2, [r3, #0]
  40263e:	68fb      	ldr	r3, [r7, #12]
  402640:	4413      	add	r3, r2
  402642:	4a06      	ldr	r2, [pc, #24]	; (40265c <hsmci_start_read_blocks+0x9c>)
  402644:	6013      	str	r3, [r2, #0]
	return true;
  402646:	2301      	movs	r3, #1
}
  402648:	4618      	mov	r0, r3
  40264a:	3714      	adds	r7, #20
  40264c:	46bd      	mov	sp, r7
  40264e:	f85d 7b04 	ldr.w	r7, [sp], #4
  402652:	4770      	bx	lr
  402654:	20000488 	.word	0x20000488
  402658:	40080000 	.word	0x40080000
  40265c:	20000484 	.word	0x20000484

00402660 <hsmci_wait_end_of_read_blocks>:

bool hsmci_wait_end_of_read_blocks(void)
{
  402660:	b580      	push	{r7, lr}
  402662:	b082      	sub	sp, #8
  402664:	af00      	add	r7, sp, #0
	uint32_t sr;
	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  402666:	4b1c      	ldr	r3, [pc, #112]	; (4026d8 <hsmci_wait_end_of_read_blocks+0x78>)
  402668:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  40266a:	607b      	str	r3, [r7, #4]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  40266c:	687a      	ldr	r2, [r7, #4]
  40266e:	4b1b      	ldr	r3, [pc, #108]	; (4026dc <hsmci_wait_end_of_read_blocks+0x7c>)
  402670:	4013      	ands	r3, r2
  402672:	2b00      	cmp	r3, #0
  402674:	d008      	beq.n	402688 <hsmci_wait_end_of_read_blocks+0x28>
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x error\n\r",
					__func__, sr);
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
  402676:	4b18      	ldr	r3, [pc, #96]	; (4026d8 <hsmci_wait_end_of_read_blocks+0x78>)
  402678:	f240 2202 	movw	r2, #514	; 0x202
  40267c:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
			hsmci_reset();
  402680:	4b17      	ldr	r3, [pc, #92]	; (4026e0 <hsmci_wait_end_of_read_blocks+0x80>)
  402682:	4798      	blx	r3
			return false;
  402684:	2300      	movs	r3, #0
  402686:	e023      	b.n	4026d0 <hsmci_wait_end_of_read_blocks+0x70>
		}

	} while (!(sr & HSMCI_SR_RXBUFF));
  402688:	687b      	ldr	r3, [r7, #4]
  40268a:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
  40268e:	2b00      	cmp	r3, #0
  402690:	d0e9      	beq.n	402666 <hsmci_wait_end_of_read_blocks+0x6>

	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
  402692:	4b14      	ldr	r3, [pc, #80]	; (4026e4 <hsmci_wait_end_of_read_blocks+0x84>)
  402694:	881b      	ldrh	r3, [r3, #0]
  402696:	461a      	mov	r2, r3
  402698:	4b13      	ldr	r3, [pc, #76]	; (4026e8 <hsmci_wait_end_of_read_blocks+0x88>)
  40269a:	881b      	ldrh	r3, [r3, #0]
  40269c:	fb03 f202 	mul.w	r2, r3, r2
  4026a0:	4b12      	ldr	r3, [pc, #72]	; (4026ec <hsmci_wait_end_of_read_blocks+0x8c>)
  4026a2:	681b      	ldr	r3, [r3, #0]
  4026a4:	429a      	cmp	r2, r3
  4026a6:	d901      	bls.n	4026ac <hsmci_wait_end_of_read_blocks+0x4c>
		return true;
  4026a8:	2301      	movs	r3, #1
  4026aa:	e011      	b.n	4026d0 <hsmci_wait_end_of_read_blocks+0x70>
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  4026ac:	4b0a      	ldr	r3, [pc, #40]	; (4026d8 <hsmci_wait_end_of_read_blocks+0x78>)
  4026ae:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4026b0:	607b      	str	r3, [r7, #4]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  4026b2:	687a      	ldr	r2, [r7, #4]
  4026b4:	4b09      	ldr	r3, [pc, #36]	; (4026dc <hsmci_wait_end_of_read_blocks+0x7c>)
  4026b6:	4013      	ands	r3, r2
  4026b8:	2b00      	cmp	r3, #0
  4026ba:	d003      	beq.n	4026c4 <hsmci_wait_end_of_read_blocks+0x64>
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
  4026bc:	4b08      	ldr	r3, [pc, #32]	; (4026e0 <hsmci_wait_end_of_read_blocks+0x80>)
  4026be:	4798      	blx	r3
			return false;
  4026c0:	2300      	movs	r3, #0
  4026c2:	e005      	b.n	4026d0 <hsmci_wait_end_of_read_blocks+0x70>
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
  4026c4:	687b      	ldr	r3, [r7, #4]
  4026c6:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
  4026ca:	2b00      	cmp	r3, #0
  4026cc:	d0ee      	beq.n	4026ac <hsmci_wait_end_of_read_blocks+0x4c>
	return true;
  4026ce:	2301      	movs	r3, #1
}
  4026d0:	4618      	mov	r0, r3
  4026d2:	3708      	adds	r7, #8
  4026d4:	46bd      	mov	sp, r7
  4026d6:	bd80      	pop	{r7, pc}
  4026d8:	40080000 	.word	0x40080000
  4026dc:	c0600000 	.word	0xc0600000
  4026e0:	00401f99 	.word	0x00401f99
  4026e4:	20000488 	.word	0x20000488
  4026e8:	2000048a 	.word	0x2000048a
  4026ec:	20000484 	.word	0x20000484

004026f0 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  4026f0:	b480      	push	{r7}
  4026f2:	af00      	add	r7, sp, #0
	while (1) {
  4026f4:	e7fe      	b.n	4026f4 <Dummy_Handler+0x4>
	...

004026f8 <cpu_irq_save>:

static volatile uint32_t cpu_irq_critical_section_counter;
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
  4026f8:	b480      	push	{r7}
  4026fa:	b083      	sub	sp, #12
  4026fc:	af00      	add	r7, sp, #0
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
  4026fe:	f3ef 8310 	mrs	r3, PRIMASK
  402702:	607b      	str	r3, [r7, #4]
  return(result);
  402704:	687b      	ldr	r3, [r7, #4]
	volatile irqflags_t flags = cpu_irq_is_enabled();
  402706:	2b00      	cmp	r3, #0
  402708:	bf0c      	ite	eq
  40270a:	2301      	moveq	r3, #1
  40270c:	2300      	movne	r3, #0
  40270e:	b2db      	uxtb	r3, r3
  402710:	603b      	str	r3, [r7, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  402712:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
  402714:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
  402718:	4b04      	ldr	r3, [pc, #16]	; (40272c <cpu_irq_save+0x34>)
  40271a:	2200      	movs	r2, #0
  40271c:	701a      	strb	r2, [r3, #0]
	return flags;
  40271e:	683b      	ldr	r3, [r7, #0]
}
  402720:	4618      	mov	r0, r3
  402722:	370c      	adds	r7, #12
  402724:	46bd      	mov	sp, r7
  402726:	f85d 7b04 	ldr.w	r7, [sp], #4
  40272a:	4770      	bx	lr
  40272c:	2000000a 	.word	0x2000000a

00402730 <cpu_irq_is_enabled_flags>:

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
  402730:	b480      	push	{r7}
  402732:	b083      	sub	sp, #12
  402734:	af00      	add	r7, sp, #0
  402736:	6078      	str	r0, [r7, #4]
	return (flags);
  402738:	687b      	ldr	r3, [r7, #4]
  40273a:	2b00      	cmp	r3, #0
  40273c:	bf14      	ite	ne
  40273e:	2301      	movne	r3, #1
  402740:	2300      	moveq	r3, #0
  402742:	b2db      	uxtb	r3, r3
}
  402744:	4618      	mov	r0, r3
  402746:	370c      	adds	r7, #12
  402748:	46bd      	mov	sp, r7
  40274a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40274e:	4770      	bx	lr

00402750 <cpu_irq_restore>:

static inline void cpu_irq_restore(irqflags_t flags)
{
  402750:	b580      	push	{r7, lr}
  402752:	b082      	sub	sp, #8
  402754:	af00      	add	r7, sp, #0
  402756:	6078      	str	r0, [r7, #4]
	if (cpu_irq_is_enabled_flags(flags))
  402758:	6878      	ldr	r0, [r7, #4]
  40275a:	4b07      	ldr	r3, [pc, #28]	; (402778 <cpu_irq_restore+0x28>)
  40275c:	4798      	blx	r3
  40275e:	4603      	mov	r3, r0
  402760:	2b00      	cmp	r3, #0
  402762:	d005      	beq.n	402770 <cpu_irq_restore+0x20>
		cpu_irq_enable();
  402764:	4b05      	ldr	r3, [pc, #20]	; (40277c <cpu_irq_restore+0x2c>)
  402766:	2201      	movs	r2, #1
  402768:	701a      	strb	r2, [r3, #0]
  40276a:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  40276e:	b662      	cpsie	i
}
  402770:	bf00      	nop
  402772:	3708      	adds	r7, #8
  402774:	46bd      	mov	sp, r7
  402776:	bd80      	pop	{r7, pc}
  402778:	00402731 	.word	0x00402731
  40277c:	2000000a 	.word	0x2000000a

00402780 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  402780:	b580      	push	{r7, lr}
  402782:	b084      	sub	sp, #16
  402784:	af00      	add	r7, sp, #0
	uint32_t *pSrc, *pDest;

	/* Initialize the relocate segment */
	pSrc = &_etext;
  402786:	4b1e      	ldr	r3, [pc, #120]	; (402800 <Reset_Handler+0x80>)
  402788:	60fb      	str	r3, [r7, #12]
	pDest = &_srelocate;
  40278a:	4b1e      	ldr	r3, [pc, #120]	; (402804 <Reset_Handler+0x84>)
  40278c:	60bb      	str	r3, [r7, #8]

	if (pSrc != pDest) {
  40278e:	68fa      	ldr	r2, [r7, #12]
  402790:	68bb      	ldr	r3, [r7, #8]
  402792:	429a      	cmp	r2, r3
  402794:	d00c      	beq.n	4027b0 <Reset_Handler+0x30>
		for (; pDest < &_erelocate;) {
  402796:	e007      	b.n	4027a8 <Reset_Handler+0x28>
			*pDest++ = *pSrc++;
  402798:	68bb      	ldr	r3, [r7, #8]
  40279a:	1d1a      	adds	r2, r3, #4
  40279c:	60ba      	str	r2, [r7, #8]
  40279e:	68fa      	ldr	r2, [r7, #12]
  4027a0:	1d11      	adds	r1, r2, #4
  4027a2:	60f9      	str	r1, [r7, #12]
  4027a4:	6812      	ldr	r2, [r2, #0]
  4027a6:	601a      	str	r2, [r3, #0]
		for (; pDest < &_erelocate;) {
  4027a8:	68bb      	ldr	r3, [r7, #8]
  4027aa:	4a17      	ldr	r2, [pc, #92]	; (402808 <Reset_Handler+0x88>)
  4027ac:	4293      	cmp	r3, r2
  4027ae:	d3f3      	bcc.n	402798 <Reset_Handler+0x18>
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  4027b0:	4b16      	ldr	r3, [pc, #88]	; (40280c <Reset_Handler+0x8c>)
  4027b2:	60bb      	str	r3, [r7, #8]
  4027b4:	e004      	b.n	4027c0 <Reset_Handler+0x40>
		*pDest++ = 0;
  4027b6:	68bb      	ldr	r3, [r7, #8]
  4027b8:	1d1a      	adds	r2, r3, #4
  4027ba:	60ba      	str	r2, [r7, #8]
  4027bc:	2200      	movs	r2, #0
  4027be:	601a      	str	r2, [r3, #0]
	for (pDest = &_szero; pDest < &_ezero;) {
  4027c0:	68bb      	ldr	r3, [r7, #8]
  4027c2:	4a13      	ldr	r2, [pc, #76]	; (402810 <Reset_Handler+0x90>)
  4027c4:	4293      	cmp	r3, r2
  4027c6:	d3f6      	bcc.n	4027b6 <Reset_Handler+0x36>
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) & _sfixed;
  4027c8:	4b12      	ldr	r3, [pc, #72]	; (402814 <Reset_Handler+0x94>)
  4027ca:	60fb      	str	r3, [r7, #12]
	SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  4027cc:	4a12      	ldr	r2, [pc, #72]	; (402818 <Reset_Handler+0x98>)
  4027ce:	68fb      	ldr	r3, [r7, #12]
  4027d0:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  4027d4:	6093      	str	r3, [r2, #8]
 * \brief Enable FPU
 */
__always_inline static void fpu_enable(void)
{
	irqflags_t flags;
	flags = cpu_irq_save();
  4027d6:	4b11      	ldr	r3, [pc, #68]	; (40281c <Reset_Handler+0x9c>)
  4027d8:	4798      	blx	r3
  4027da:	6078      	str	r0, [r7, #4]
	REG_CPACR |=  (0xFu << 20);
  4027dc:	4a10      	ldr	r2, [pc, #64]	; (402820 <Reset_Handler+0xa0>)
  4027de:	4b10      	ldr	r3, [pc, #64]	; (402820 <Reset_Handler+0xa0>)
  4027e0:	681b      	ldr	r3, [r3, #0]
  4027e2:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
  4027e6:	6013      	str	r3, [r2, #0]
  __ASM volatile ("dsb 0xF":::"memory");
  4027e8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  4027ec:	f3bf 8f6f 	isb	sy
	__DSB();
	__ISB();
	cpu_irq_restore(flags);
  4027f0:	6878      	ldr	r0, [r7, #4]
  4027f2:	4b0c      	ldr	r3, [pc, #48]	; (402824 <Reset_Handler+0xa4>)
  4027f4:	4798      	blx	r3
#if __FPU_USED
	fpu_enable();
#endif

	/* Initialize the C library */
	__libc_init_array();
  4027f6:	4b0c      	ldr	r3, [pc, #48]	; (402828 <Reset_Handler+0xa8>)
  4027f8:	4798      	blx	r3

	/* Branch to main function */
	main();
  4027fa:	4b0c      	ldr	r3, [pc, #48]	; (40282c <Reset_Handler+0xac>)
  4027fc:	4798      	blx	r3

	/* Infinite loop */
	while (1);
  4027fe:	e7fe      	b.n	4027fe <Reset_Handler+0x7e>
  402800:	004040c4 	.word	0x004040c4
  402804:	20000000 	.word	0x20000000
  402808:	2000043c 	.word	0x2000043c
  40280c:	2000043c 	.word	0x2000043c
  402810:	20000558 	.word	0x20000558
  402814:	00400000 	.word	0x00400000
  402818:	e000ed00 	.word	0xe000ed00
  40281c:	004026f9 	.word	0x004026f9
  402820:	e000ed88 	.word	0xe000ed88
  402824:	00402751 	.word	0x00402751
  402828:	00403d41 	.word	0x00403d41
  40282c:	00402a31 	.word	0x00402a31

00402830 <SystemCoreClockUpdate>:

	SystemCoreClock = CHIP_FREQ_CPU_MAX;
}

void SystemCoreClockUpdate( void )
{
  402830:	b480      	push	{r7}
  402832:	af00      	add	r7, sp, #0
	/* Determine clock frequency according to clock register values */
	switch (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) {
  402834:	4b52      	ldr	r3, [pc, #328]	; (402980 <SystemCoreClockUpdate+0x150>)
  402836:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  402838:	f003 0303 	and.w	r3, r3, #3
  40283c:	2b01      	cmp	r3, #1
  40283e:	d014      	beq.n	40286a <SystemCoreClockUpdate+0x3a>
  402840:	2b01      	cmp	r3, #1
  402842:	d302      	bcc.n	40284a <SystemCoreClockUpdate+0x1a>
  402844:	2b02      	cmp	r3, #2
  402846:	d038      	beq.n	4028ba <SystemCoreClockUpdate+0x8a>
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos));
		}
		break;

	default:
		break;
  402848:	e07a      	b.n	402940 <SystemCoreClockUpdate+0x110>
		if ( SUPC->SUPC_SR & SUPC_SR_OSCSEL ) {
  40284a:	4b4e      	ldr	r3, [pc, #312]	; (402984 <SystemCoreClockUpdate+0x154>)
  40284c:	695b      	ldr	r3, [r3, #20]
  40284e:	f003 0380 	and.w	r3, r3, #128	; 0x80
  402852:	2b00      	cmp	r3, #0
  402854:	d004      	beq.n	402860 <SystemCoreClockUpdate+0x30>
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
  402856:	4b4c      	ldr	r3, [pc, #304]	; (402988 <SystemCoreClockUpdate+0x158>)
  402858:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  40285c:	601a      	str	r2, [r3, #0]
		break;
  40285e:	e06f      	b.n	402940 <SystemCoreClockUpdate+0x110>
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
  402860:	4b49      	ldr	r3, [pc, #292]	; (402988 <SystemCoreClockUpdate+0x158>)
  402862:	f44f 42fa 	mov.w	r2, #32000	; 0x7d00
  402866:	601a      	str	r2, [r3, #0]
		break;
  402868:	e06a      	b.n	402940 <SystemCoreClockUpdate+0x110>
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  40286a:	4b45      	ldr	r3, [pc, #276]	; (402980 <SystemCoreClockUpdate+0x150>)
  40286c:	6a1b      	ldr	r3, [r3, #32]
  40286e:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  402872:	2b00      	cmp	r3, #0
  402874:	d003      	beq.n	40287e <SystemCoreClockUpdate+0x4e>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
  402876:	4b44      	ldr	r3, [pc, #272]	; (402988 <SystemCoreClockUpdate+0x158>)
  402878:	4a44      	ldr	r2, [pc, #272]	; (40298c <SystemCoreClockUpdate+0x15c>)
  40287a:	601a      	str	r2, [r3, #0]
		break;
  40287c:	e060      	b.n	402940 <SystemCoreClockUpdate+0x110>
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  40287e:	4b42      	ldr	r3, [pc, #264]	; (402988 <SystemCoreClockUpdate+0x158>)
  402880:	4a43      	ldr	r2, [pc, #268]	; (402990 <SystemCoreClockUpdate+0x160>)
  402882:	601a      	str	r2, [r3, #0]
			switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  402884:	4b3e      	ldr	r3, [pc, #248]	; (402980 <SystemCoreClockUpdate+0x150>)
  402886:	6a1b      	ldr	r3, [r3, #32]
  402888:	f003 0370 	and.w	r3, r3, #112	; 0x70
  40288c:	2b10      	cmp	r3, #16
  40288e:	d004      	beq.n	40289a <SystemCoreClockUpdate+0x6a>
  402890:	2b20      	cmp	r3, #32
  402892:	d008      	beq.n	4028a6 <SystemCoreClockUpdate+0x76>
  402894:	2b00      	cmp	r3, #0
  402896:	d00e      	beq.n	4028b6 <SystemCoreClockUpdate+0x86>
				break;
  402898:	e00e      	b.n	4028b8 <SystemCoreClockUpdate+0x88>
				SystemCoreClock *= 2U;
  40289a:	4b3b      	ldr	r3, [pc, #236]	; (402988 <SystemCoreClockUpdate+0x158>)
  40289c:	681b      	ldr	r3, [r3, #0]
  40289e:	005b      	lsls	r3, r3, #1
  4028a0:	4a39      	ldr	r2, [pc, #228]	; (402988 <SystemCoreClockUpdate+0x158>)
  4028a2:	6013      	str	r3, [r2, #0]
				break;
  4028a4:	e008      	b.n	4028b8 <SystemCoreClockUpdate+0x88>
				SystemCoreClock *= 3U;
  4028a6:	4b38      	ldr	r3, [pc, #224]	; (402988 <SystemCoreClockUpdate+0x158>)
  4028a8:	681a      	ldr	r2, [r3, #0]
  4028aa:	4613      	mov	r3, r2
  4028ac:	005b      	lsls	r3, r3, #1
  4028ae:	4413      	add	r3, r2
  4028b0:	4a35      	ldr	r2, [pc, #212]	; (402988 <SystemCoreClockUpdate+0x158>)
  4028b2:	6013      	str	r3, [r2, #0]
				break;
  4028b4:	e000      	b.n	4028b8 <SystemCoreClockUpdate+0x88>
				break;
  4028b6:	bf00      	nop
		break;
  4028b8:	e042      	b.n	402940 <SystemCoreClockUpdate+0x110>
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  4028ba:	4b31      	ldr	r3, [pc, #196]	; (402980 <SystemCoreClockUpdate+0x150>)
  4028bc:	6a1b      	ldr	r3, [r3, #32]
  4028be:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  4028c2:	2b00      	cmp	r3, #0
  4028c4:	d003      	beq.n	4028ce <SystemCoreClockUpdate+0x9e>
			SystemCoreClock = CHIP_FREQ_XTAL_12M ;
  4028c6:	4b30      	ldr	r3, [pc, #192]	; (402988 <SystemCoreClockUpdate+0x158>)
  4028c8:	4a30      	ldr	r2, [pc, #192]	; (40298c <SystemCoreClockUpdate+0x15c>)
  4028ca:	601a      	str	r2, [r3, #0]
  4028cc:	e01c      	b.n	402908 <SystemCoreClockUpdate+0xd8>
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  4028ce:	4b2e      	ldr	r3, [pc, #184]	; (402988 <SystemCoreClockUpdate+0x158>)
  4028d0:	4a2f      	ldr	r2, [pc, #188]	; (402990 <SystemCoreClockUpdate+0x160>)
  4028d2:	601a      	str	r2, [r3, #0]
			switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  4028d4:	4b2a      	ldr	r3, [pc, #168]	; (402980 <SystemCoreClockUpdate+0x150>)
  4028d6:	6a1b      	ldr	r3, [r3, #32]
  4028d8:	f003 0370 	and.w	r3, r3, #112	; 0x70
  4028dc:	2b10      	cmp	r3, #16
  4028de:	d004      	beq.n	4028ea <SystemCoreClockUpdate+0xba>
  4028e0:	2b20      	cmp	r3, #32
  4028e2:	d008      	beq.n	4028f6 <SystemCoreClockUpdate+0xc6>
  4028e4:	2b00      	cmp	r3, #0
  4028e6:	d00e      	beq.n	402906 <SystemCoreClockUpdate+0xd6>
				break;
  4028e8:	e00e      	b.n	402908 <SystemCoreClockUpdate+0xd8>
				SystemCoreClock *= 2U;
  4028ea:	4b27      	ldr	r3, [pc, #156]	; (402988 <SystemCoreClockUpdate+0x158>)
  4028ec:	681b      	ldr	r3, [r3, #0]
  4028ee:	005b      	lsls	r3, r3, #1
  4028f0:	4a25      	ldr	r2, [pc, #148]	; (402988 <SystemCoreClockUpdate+0x158>)
  4028f2:	6013      	str	r3, [r2, #0]
				break;
  4028f4:	e008      	b.n	402908 <SystemCoreClockUpdate+0xd8>
				SystemCoreClock *= 3U;
  4028f6:	4b24      	ldr	r3, [pc, #144]	; (402988 <SystemCoreClockUpdate+0x158>)
  4028f8:	681a      	ldr	r2, [r3, #0]
  4028fa:	4613      	mov	r3, r2
  4028fc:	005b      	lsls	r3, r3, #1
  4028fe:	4413      	add	r3, r2
  402900:	4a21      	ldr	r2, [pc, #132]	; (402988 <SystemCoreClockUpdate+0x158>)
  402902:	6013      	str	r3, [r2, #0]
				break;
  402904:	e000      	b.n	402908 <SystemCoreClockUpdate+0xd8>
				break;
  402906:	bf00      	nop
		if ((uint32_t) (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK)
  402908:	4b1d      	ldr	r3, [pc, #116]	; (402980 <SystemCoreClockUpdate+0x150>)
  40290a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40290c:	f003 0303 	and.w	r3, r3, #3
  402910:	2b02      	cmp	r3, #2
  402912:	d114      	bne.n	40293e <SystemCoreClockUpdate+0x10e>
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> CKGR_PLLAR_MULA_Pos) + 1U);
  402914:	4b1a      	ldr	r3, [pc, #104]	; (402980 <SystemCoreClockUpdate+0x150>)
  402916:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  402918:	0c1b      	lsrs	r3, r3, #16
  40291a:	f3c3 030a 	ubfx	r3, r3, #0, #11
  40291e:	3301      	adds	r3, #1
  402920:	4a19      	ldr	r2, [pc, #100]	; (402988 <SystemCoreClockUpdate+0x158>)
  402922:	6812      	ldr	r2, [r2, #0]
  402924:	fb02 f303 	mul.w	r3, r2, r3
  402928:	4a17      	ldr	r2, [pc, #92]	; (402988 <SystemCoreClockUpdate+0x158>)
  40292a:	6013      	str	r3, [r2, #0]
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos));
  40292c:	4b14      	ldr	r3, [pc, #80]	; (402980 <SystemCoreClockUpdate+0x150>)
  40292e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  402930:	b2db      	uxtb	r3, r3
  402932:	4a15      	ldr	r2, [pc, #84]	; (402988 <SystemCoreClockUpdate+0x158>)
  402934:	6812      	ldr	r2, [r2, #0]
  402936:	fbb2 f3f3 	udiv	r3, r2, r3
  40293a:	4a13      	ldr	r2, [pc, #76]	; (402988 <SystemCoreClockUpdate+0x158>)
  40293c:	6013      	str	r3, [r2, #0]
		break;
  40293e:	bf00      	nop
	}

	if ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3) {
  402940:	4b0f      	ldr	r3, [pc, #60]	; (402980 <SystemCoreClockUpdate+0x150>)
  402942:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  402944:	f003 0370 	and.w	r3, r3, #112	; 0x70
  402948:	2b70      	cmp	r3, #112	; 0x70
  40294a:	d108      	bne.n	40295e <SystemCoreClockUpdate+0x12e>
		SystemCoreClock /= 3U;
  40294c:	4b0e      	ldr	r3, [pc, #56]	; (402988 <SystemCoreClockUpdate+0x158>)
  40294e:	681b      	ldr	r3, [r3, #0]
  402950:	4a10      	ldr	r2, [pc, #64]	; (402994 <SystemCoreClockUpdate+0x164>)
  402952:	fba2 2303 	umull	r2, r3, r2, r3
  402956:	085b      	lsrs	r3, r3, #1
  402958:	4a0b      	ldr	r2, [pc, #44]	; (402988 <SystemCoreClockUpdate+0x158>)
  40295a:	6013      	str	r3, [r2, #0]
	} else {
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >>
				PMC_MCKR_PRES_Pos);
	}
}
  40295c:	e00a      	b.n	402974 <SystemCoreClockUpdate+0x144>
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >>
  40295e:	4b08      	ldr	r3, [pc, #32]	; (402980 <SystemCoreClockUpdate+0x150>)
  402960:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  402962:	091b      	lsrs	r3, r3, #4
  402964:	f003 0307 	and.w	r3, r3, #7
  402968:	4a07      	ldr	r2, [pc, #28]	; (402988 <SystemCoreClockUpdate+0x158>)
  40296a:	6812      	ldr	r2, [r2, #0]
  40296c:	fa22 f303 	lsr.w	r3, r2, r3
  402970:	4a05      	ldr	r2, [pc, #20]	; (402988 <SystemCoreClockUpdate+0x158>)
  402972:	6013      	str	r3, [r2, #0]
}
  402974:	bf00      	nop
  402976:	46bd      	mov	sp, r7
  402978:	f85d 7b04 	ldr.w	r7, [sp], #4
  40297c:	4770      	bx	lr
  40297e:	bf00      	nop
  402980:	400e0400 	.word	0x400e0400
  402984:	400e1810 	.word	0x400e1810
  402988:	2000000c 	.word	0x2000000c
  40298c:	00b71b00 	.word	0x00b71b00
  402990:	003d0900 	.word	0x003d0900
  402994:	aaaaaaab 	.word	0xaaaaaaab

00402998 <system_init_flash>:

/**
 * Initialize flash.
 */
void system_init_flash( uint32_t ul_clk )
{
  402998:	b480      	push	{r7}
  40299a:	b083      	sub	sp, #12
  40299c:	af00      	add	r7, sp, #0
  40299e:	6078      	str	r0, [r7, #4]
	/* Set FWS for embedded Flash access according to operating frequency */
	if ( ul_clk < CHIP_FREQ_FWS_0 ) {
  4029a0:	687b      	ldr	r3, [r7, #4]
  4029a2:	4a19      	ldr	r2, [pc, #100]	; (402a08 <system_init_flash+0x70>)
  4029a4:	4293      	cmp	r3, r2
  4029a6:	d804      	bhi.n	4029b2 <system_init_flash+0x1a>
		EFC->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  4029a8:	4b18      	ldr	r3, [pc, #96]	; (402a0c <system_init_flash+0x74>)
  4029aa:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
  4029ae:	601a      	str	r2, [r3, #0]
					}
				}
			}
		}
	}
}
  4029b0:	e023      	b.n	4029fa <system_init_flash+0x62>
		if (ul_clk < CHIP_FREQ_FWS_1) {
  4029b2:	687b      	ldr	r3, [r7, #4]
  4029b4:	4a16      	ldr	r2, [pc, #88]	; (402a10 <system_init_flash+0x78>)
  4029b6:	4293      	cmp	r3, r2
  4029b8:	d803      	bhi.n	4029c2 <system_init_flash+0x2a>
			EFC->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
  4029ba:	4b14      	ldr	r3, [pc, #80]	; (402a0c <system_init_flash+0x74>)
  4029bc:	4a15      	ldr	r2, [pc, #84]	; (402a14 <system_init_flash+0x7c>)
  4029be:	601a      	str	r2, [r3, #0]
}
  4029c0:	e01b      	b.n	4029fa <system_init_flash+0x62>
			if (ul_clk < CHIP_FREQ_FWS_2) {
  4029c2:	687b      	ldr	r3, [r7, #4]
  4029c4:	4a14      	ldr	r2, [pc, #80]	; (402a18 <system_init_flash+0x80>)
  4029c6:	4293      	cmp	r3, r2
  4029c8:	d803      	bhi.n	4029d2 <system_init_flash+0x3a>
				EFC->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
  4029ca:	4b10      	ldr	r3, [pc, #64]	; (402a0c <system_init_flash+0x74>)
  4029cc:	4a13      	ldr	r2, [pc, #76]	; (402a1c <system_init_flash+0x84>)
  4029ce:	601a      	str	r2, [r3, #0]
}
  4029d0:	e013      	b.n	4029fa <system_init_flash+0x62>
				if ( ul_clk < CHIP_FREQ_FWS_3 ) {
  4029d2:	687b      	ldr	r3, [r7, #4]
  4029d4:	4a12      	ldr	r2, [pc, #72]	; (402a20 <system_init_flash+0x88>)
  4029d6:	4293      	cmp	r3, r2
  4029d8:	d803      	bhi.n	4029e2 <system_init_flash+0x4a>
					EFC->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
  4029da:	4b0c      	ldr	r3, [pc, #48]	; (402a0c <system_init_flash+0x74>)
  4029dc:	4a11      	ldr	r2, [pc, #68]	; (402a24 <system_init_flash+0x8c>)
  4029de:	601a      	str	r2, [r3, #0]
}
  4029e0:	e00b      	b.n	4029fa <system_init_flash+0x62>
					if ( ul_clk < CHIP_FREQ_FWS_4 ) {
  4029e2:	687b      	ldr	r3, [r7, #4]
  4029e4:	4a10      	ldr	r2, [pc, #64]	; (402a28 <system_init_flash+0x90>)
  4029e6:	4293      	cmp	r3, r2
  4029e8:	d804      	bhi.n	4029f4 <system_init_flash+0x5c>
						EFC->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  4029ea:	4b08      	ldr	r3, [pc, #32]	; (402a0c <system_init_flash+0x74>)
  4029ec:	f04f 2204 	mov.w	r2, #67109888	; 0x4000400
  4029f0:	601a      	str	r2, [r3, #0]
}
  4029f2:	e002      	b.n	4029fa <system_init_flash+0x62>
						EFC->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  4029f4:	4b05      	ldr	r3, [pc, #20]	; (402a0c <system_init_flash+0x74>)
  4029f6:	4a0d      	ldr	r2, [pc, #52]	; (402a2c <system_init_flash+0x94>)
  4029f8:	601a      	str	r2, [r3, #0]
}
  4029fa:	bf00      	nop
  4029fc:	370c      	adds	r7, #12
  4029fe:	46bd      	mov	sp, r7
  402a00:	f85d 7b04 	ldr.w	r7, [sp], #4
  402a04:	4770      	bx	lr
  402a06:	bf00      	nop
  402a08:	01312cff 	.word	0x01312cff
  402a0c:	400e0a00 	.word	0x400e0a00
  402a10:	026259ff 	.word	0x026259ff
  402a14:	04000100 	.word	0x04000100
  402a18:	039386ff 	.word	0x039386ff
  402a1c:	04000200 	.word	0x04000200
  402a20:	04c4b3ff 	.word	0x04c4b3ff
  402a24:	04000300 	.word	0x04000300
  402a28:	05f5e0ff 	.word	0x05f5e0ff
  402a2c:	04000500 	.word	0x04000500

00402a30 <main>:
/* Function definitions ----------------------------------------------- */
/**
 * @brief Entry
 */
int main(void)
{
  402a30:	b580      	push	{r7, lr}
  402a32:	af00      	add	r7, sp, #0
  sys_init();
  402a34:	4b02      	ldr	r3, [pc, #8]	; (402a40 <main+0x10>)
  402a36:	4798      	blx	r3

  while (1)
  {
    sys_run();
  402a38:	4b02      	ldr	r3, [pc, #8]	; (402a44 <main+0x14>)
  402a3a:	4798      	blx	r3
  402a3c:	e7fc      	b.n	402a38 <main+0x8>
  402a3e:	bf00      	nop
  402a40:	0040070d 	.word	0x0040070d
  402a44:	0040073d 	.word	0x0040073d

00402a48 <osc_enable>:
{
  402a48:	b580      	push	{r7, lr}
  402a4a:	b082      	sub	sp, #8
  402a4c:	af00      	add	r7, sp, #0
  402a4e:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  402a50:	687b      	ldr	r3, [r7, #4]
  402a52:	2b07      	cmp	r3, #7
  402a54:	d831      	bhi.n	402aba <osc_enable+0x72>
  402a56:	a201      	add	r2, pc, #4	; (adr r2, 402a5c <osc_enable+0x14>)
  402a58:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  402a5c:	00402ab9 	.word	0x00402ab9
  402a60:	00402a7d 	.word	0x00402a7d
  402a64:	00402a85 	.word	0x00402a85
  402a68:	00402a8d 	.word	0x00402a8d
  402a6c:	00402a95 	.word	0x00402a95
  402a70:	00402a9d 	.word	0x00402a9d
  402a74:	00402aa5 	.word	0x00402aa5
  402a78:	00402aaf 	.word	0x00402aaf
		pmc_switch_sclk_to_32kxtal(PMC_OSC_XTAL);
  402a7c:	2000      	movs	r0, #0
  402a7e:	4b11      	ldr	r3, [pc, #68]	; (402ac4 <osc_enable+0x7c>)
  402a80:	4798      	blx	r3
		break;
  402a82:	e01a      	b.n	402aba <osc_enable+0x72>
		pmc_switch_sclk_to_32kxtal(PMC_OSC_BYPASS);
  402a84:	2001      	movs	r0, #1
  402a86:	4b0f      	ldr	r3, [pc, #60]	; (402ac4 <osc_enable+0x7c>)
  402a88:	4798      	blx	r3
		break;
  402a8a:	e016      	b.n	402aba <osc_enable+0x72>
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_4_MHz);
  402a8c:	2000      	movs	r0, #0
  402a8e:	4b0e      	ldr	r3, [pc, #56]	; (402ac8 <osc_enable+0x80>)
  402a90:	4798      	blx	r3
		break;
  402a92:	e012      	b.n	402aba <osc_enable+0x72>
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_8_MHz);
  402a94:	2010      	movs	r0, #16
  402a96:	4b0c      	ldr	r3, [pc, #48]	; (402ac8 <osc_enable+0x80>)
  402a98:	4798      	blx	r3
		break;
  402a9a:	e00e      	b.n	402aba <osc_enable+0x72>
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_12_MHz);
  402a9c:	2020      	movs	r0, #32
  402a9e:	4b0a      	ldr	r3, [pc, #40]	; (402ac8 <osc_enable+0x80>)
  402aa0:	4798      	blx	r3
		break;
  402aa2:	e00a      	b.n	402aba <osc_enable+0x72>
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL,
  402aa4:	213e      	movs	r1, #62	; 0x3e
  402aa6:	2000      	movs	r0, #0
  402aa8:	4b08      	ldr	r3, [pc, #32]	; (402acc <osc_enable+0x84>)
  402aaa:	4798      	blx	r3
		break;
  402aac:	e005      	b.n	402aba <osc_enable+0x72>
		pmc_switch_mainck_to_xtal(PMC_OSC_BYPASS,
  402aae:	213e      	movs	r1, #62	; 0x3e
  402ab0:	2001      	movs	r0, #1
  402ab2:	4b06      	ldr	r3, [pc, #24]	; (402acc <osc_enable+0x84>)
  402ab4:	4798      	blx	r3
		break;
  402ab6:	e000      	b.n	402aba <osc_enable+0x72>
		break;
  402ab8:	bf00      	nop
}
  402aba:	bf00      	nop
  402abc:	3708      	adds	r7, #8
  402abe:	46bd      	mov	sp, r7
  402ac0:	bd80      	pop	{r7, pc}
  402ac2:	bf00      	nop
  402ac4:	0040352d 	.word	0x0040352d
  402ac8:	00403599 	.word	0x00403599
  402acc:	00403609 	.word	0x00403609

00402ad0 <osc_is_ready>:
{
  402ad0:	b580      	push	{r7, lr}
  402ad2:	b082      	sub	sp, #8
  402ad4:	af00      	add	r7, sp, #0
  402ad6:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  402ad8:	687b      	ldr	r3, [r7, #4]
  402ada:	2b07      	cmp	r3, #7
  402adc:	d826      	bhi.n	402b2c <osc_is_ready+0x5c>
  402ade:	a201      	add	r2, pc, #4	; (adr r2, 402ae4 <osc_is_ready+0x14>)
  402ae0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  402ae4:	00402b05 	.word	0x00402b05
  402ae8:	00402b09 	.word	0x00402b09
  402aec:	00402b09 	.word	0x00402b09
  402af0:	00402b1b 	.word	0x00402b1b
  402af4:	00402b1b 	.word	0x00402b1b
  402af8:	00402b1b 	.word	0x00402b1b
  402afc:	00402b1b 	.word	0x00402b1b
  402b00:	00402b1b 	.word	0x00402b1b
		return 1;
  402b04:	2301      	movs	r3, #1
  402b06:	e012      	b.n	402b2e <osc_is_ready+0x5e>
		return pmc_osc_is_ready_32kxtal();
  402b08:	4b0b      	ldr	r3, [pc, #44]	; (402b38 <osc_is_ready+0x68>)
  402b0a:	4798      	blx	r3
  402b0c:	4603      	mov	r3, r0
  402b0e:	2b00      	cmp	r3, #0
  402b10:	bf14      	ite	ne
  402b12:	2301      	movne	r3, #1
  402b14:	2300      	moveq	r3, #0
  402b16:	b2db      	uxtb	r3, r3
  402b18:	e009      	b.n	402b2e <osc_is_ready+0x5e>
		return pmc_osc_is_ready_mainck();
  402b1a:	4b08      	ldr	r3, [pc, #32]	; (402b3c <osc_is_ready+0x6c>)
  402b1c:	4798      	blx	r3
  402b1e:	4603      	mov	r3, r0
  402b20:	2b00      	cmp	r3, #0
  402b22:	bf14      	ite	ne
  402b24:	2301      	movne	r3, #1
  402b26:	2300      	moveq	r3, #0
  402b28:	b2db      	uxtb	r3, r3
  402b2a:	e000      	b.n	402b2e <osc_is_ready+0x5e>
	return 0;
  402b2c:	2300      	movs	r3, #0
}
  402b2e:	4618      	mov	r0, r3
  402b30:	3708      	adds	r7, #8
  402b32:	46bd      	mov	sp, r7
  402b34:	bd80      	pop	{r7, pc}
  402b36:	bf00      	nop
  402b38:	00403565 	.word	0x00403565
  402b3c:	00403681 	.word	0x00403681

00402b40 <osc_get_rate>:
{
  402b40:	b480      	push	{r7}
  402b42:	b083      	sub	sp, #12
  402b44:	af00      	add	r7, sp, #0
  402b46:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  402b48:	687b      	ldr	r3, [r7, #4]
  402b4a:	2b07      	cmp	r3, #7
  402b4c:	d825      	bhi.n	402b9a <osc_get_rate+0x5a>
  402b4e:	a201      	add	r2, pc, #4	; (adr r2, 402b54 <osc_get_rate+0x14>)
  402b50:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  402b54:	00402b75 	.word	0x00402b75
  402b58:	00402b7b 	.word	0x00402b7b
  402b5c:	00402b81 	.word	0x00402b81
  402b60:	00402b87 	.word	0x00402b87
  402b64:	00402b8b 	.word	0x00402b8b
  402b68:	00402b8f 	.word	0x00402b8f
  402b6c:	00402b93 	.word	0x00402b93
  402b70:	00402b97 	.word	0x00402b97
		return OSC_SLCK_32K_RC_HZ;
  402b74:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  402b78:	e010      	b.n	402b9c <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_XTAL;
  402b7a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  402b7e:	e00d      	b.n	402b9c <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_BYPASS;
  402b80:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  402b84:	e00a      	b.n	402b9c <osc_get_rate+0x5c>
		return OSC_MAINCK_4M_RC_HZ;
  402b86:	4b08      	ldr	r3, [pc, #32]	; (402ba8 <osc_get_rate+0x68>)
  402b88:	e008      	b.n	402b9c <osc_get_rate+0x5c>
		return OSC_MAINCK_8M_RC_HZ;
  402b8a:	4b08      	ldr	r3, [pc, #32]	; (402bac <osc_get_rate+0x6c>)
  402b8c:	e006      	b.n	402b9c <osc_get_rate+0x5c>
		return OSC_MAINCK_12M_RC_HZ;
  402b8e:	4b08      	ldr	r3, [pc, #32]	; (402bb0 <osc_get_rate+0x70>)
  402b90:	e004      	b.n	402b9c <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_XTAL;
  402b92:	4b07      	ldr	r3, [pc, #28]	; (402bb0 <osc_get_rate+0x70>)
  402b94:	e002      	b.n	402b9c <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_BYPASS;
  402b96:	4b06      	ldr	r3, [pc, #24]	; (402bb0 <osc_get_rate+0x70>)
  402b98:	e000      	b.n	402b9c <osc_get_rate+0x5c>
	return 0;
  402b9a:	2300      	movs	r3, #0
}
  402b9c:	4618      	mov	r0, r3
  402b9e:	370c      	adds	r7, #12
  402ba0:	46bd      	mov	sp, r7
  402ba2:	f85d 7b04 	ldr.w	r7, [sp], #4
  402ba6:	4770      	bx	lr
  402ba8:	003d0900 	.word	0x003d0900
  402bac:	007a1200 	.word	0x007a1200
  402bb0:	00b71b00 	.word	0x00b71b00

00402bb4 <osc_wait_ready>:
 * to become stable and ready to use as a clock source.
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
  402bb4:	b580      	push	{r7, lr}
  402bb6:	b082      	sub	sp, #8
  402bb8:	af00      	add	r7, sp, #0
  402bba:	4603      	mov	r3, r0
  402bbc:	71fb      	strb	r3, [r7, #7]
	while (!osc_is_ready(id)) {
  402bbe:	bf00      	nop
  402bc0:	79fb      	ldrb	r3, [r7, #7]
  402bc2:	4618      	mov	r0, r3
  402bc4:	4b05      	ldr	r3, [pc, #20]	; (402bdc <osc_wait_ready+0x28>)
  402bc6:	4798      	blx	r3
  402bc8:	4603      	mov	r3, r0
  402bca:	f083 0301 	eor.w	r3, r3, #1
  402bce:	b2db      	uxtb	r3, r3
  402bd0:	2b00      	cmp	r3, #0
  402bd2:	d1f5      	bne.n	402bc0 <osc_wait_ready+0xc>
		/* Do nothing */
	}
}
  402bd4:	bf00      	nop
  402bd6:	3708      	adds	r7, #8
  402bd8:	46bd      	mov	sp, r7
  402bda:	bd80      	pop	{r7, pc}
  402bdc:	00402ad1 	.word	0x00402ad1

00402be0 <pll_config_init>:
 * hardware mul+1 is hidden in this implementation. Use mul as mul effective
 * value.
 */
static inline void pll_config_init(struct pll_config *p_cfg,
		enum pll_source e_src, uint32_t ul_div, uint32_t ul_mul)
{
  402be0:	b580      	push	{r7, lr}
  402be2:	b086      	sub	sp, #24
  402be4:	af00      	add	r7, sp, #0
  402be6:	60f8      	str	r0, [r7, #12]
  402be8:	607a      	str	r2, [r7, #4]
  402bea:	603b      	str	r3, [r7, #0]
  402bec:	460b      	mov	r3, r1
  402bee:	72fb      	strb	r3, [r7, #11]
	uint32_t vco_hz;

	Assert(e_src < PLL_NR_SOURCES);

	/* Calculate internal VCO frequency */
	vco_hz = osc_get_rate(e_src) / ul_div;
  402bf0:	7afb      	ldrb	r3, [r7, #11]
  402bf2:	4618      	mov	r0, r3
  402bf4:	4b0d      	ldr	r3, [pc, #52]	; (402c2c <pll_config_init+0x4c>)
  402bf6:	4798      	blx	r3
  402bf8:	4602      	mov	r2, r0
  402bfa:	687b      	ldr	r3, [r7, #4]
  402bfc:	fbb2 f3f3 	udiv	r3, r2, r3
  402c00:	617b      	str	r3, [r7, #20]
	Assert(vco_hz >= PLL_INPUT_MIN_HZ);
	Assert(vco_hz <= PLL_INPUT_MAX_HZ);

	vco_hz *= ul_mul;
  402c02:	697b      	ldr	r3, [r7, #20]
  402c04:	683a      	ldr	r2, [r7, #0]
  402c06:	fb02 f303 	mul.w	r3, r2, r3
  402c0a:	617b      	str	r3, [r7, #20]
	Assert(vco_hz >= PLL_OUTPUT_MIN_HZ);
	Assert(vco_hz <= PLL_OUTPUT_MAX_HZ);

	/* PMC hardware will automatically make it mul+1 */
	p_cfg->ctrl = CKGR_PLLAR_MULA(ul_mul - 1) | CKGR_PLLAR_DIVA(ul_div) | \
  402c0c:	683b      	ldr	r3, [r7, #0]
  402c0e:	3b01      	subs	r3, #1
  402c10:	041a      	lsls	r2, r3, #16
  402c12:	4b07      	ldr	r3, [pc, #28]	; (402c30 <pll_config_init+0x50>)
  402c14:	4013      	ands	r3, r2
  402c16:	687a      	ldr	r2, [r7, #4]
  402c18:	b2d2      	uxtb	r2, r2
  402c1a:	4313      	orrs	r3, r2
  402c1c:	f443 527c 	orr.w	r2, r3, #16128	; 0x3f00
  402c20:	68fb      	ldr	r3, [r7, #12]
  402c22:	601a      	str	r2, [r3, #0]
			CKGR_PLLAR_PLLACOUNT(PLL_COUNT);
}
  402c24:	bf00      	nop
  402c26:	3718      	adds	r7, #24
  402c28:	46bd      	mov	sp, r7
  402c2a:	bd80      	pop	{r7, pc}
  402c2c:	00402b41 	.word	0x00402b41
  402c30:	07ff0000 	.word	0x07ff0000

00402c34 <pll_enable>:
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
	}
}

static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
  402c34:	b580      	push	{r7, lr}
  402c36:	b082      	sub	sp, #8
  402c38:	af00      	add	r7, sp, #0
  402c3a:	6078      	str	r0, [r7, #4]
  402c3c:	6039      	str	r1, [r7, #0]
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
  402c3e:	683b      	ldr	r3, [r7, #0]
  402c40:	2b00      	cmp	r3, #0
  402c42:	d107      	bne.n	402c54 <pll_enable+0x20>
		pmc_disable_pllack(); // Always stop PLL first!
  402c44:	4b05      	ldr	r3, [pc, #20]	; (402c5c <pll_enable+0x28>)
  402c46:	4798      	blx	r3
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
  402c48:	4a05      	ldr	r2, [pc, #20]	; (402c60 <pll_enable+0x2c>)
  402c4a:	687b      	ldr	r3, [r7, #4]
  402c4c:	681b      	ldr	r3, [r3, #0]
  402c4e:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
  402c52:	6293      	str	r3, [r2, #40]	; 0x28
	}
}
  402c54:	bf00      	nop
  402c56:	3708      	adds	r7, #8
  402c58:	46bd      	mov	sp, r7
  402c5a:	bd80      	pop	{r7, pc}
  402c5c:	0040369d 	.word	0x0040369d
  402c60:	400e0400 	.word	0x400e0400

00402c64 <pll_is_locked>:
		pmc_disable_pllack();
	}
}

static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
  402c64:	b580      	push	{r7, lr}
  402c66:	b082      	sub	sp, #8
  402c68:	af00      	add	r7, sp, #0
  402c6a:	6078      	str	r0, [r7, #4]
	Assert(ul_pll_id < NR_PLLS);

	UNUSED(ul_pll_id);
	return pmc_is_locked_pllack();
  402c6c:	4b03      	ldr	r3, [pc, #12]	; (402c7c <pll_is_locked+0x18>)
  402c6e:	4798      	blx	r3
  402c70:	4603      	mov	r3, r0
}
  402c72:	4618      	mov	r0, r3
  402c74:	3708      	adds	r7, #8
  402c76:	46bd      	mov	sp, r7
  402c78:	bd80      	pop	{r7, pc}
  402c7a:	bf00      	nop
  402c7c:	004036b9 	.word	0x004036b9

00402c80 <pll_enable_source>:

static inline void pll_enable_source(enum pll_source e_src)
{
  402c80:	b580      	push	{r7, lr}
  402c82:	b082      	sub	sp, #8
  402c84:	af00      	add	r7, sp, #0
  402c86:	4603      	mov	r3, r0
  402c88:	71fb      	strb	r3, [r7, #7]
	switch (e_src) {
  402c8a:	79fb      	ldrb	r3, [r7, #7]
  402c8c:	3b03      	subs	r3, #3
  402c8e:	2b04      	cmp	r3, #4
  402c90:	d808      	bhi.n	402ca4 <pll_enable_source+0x24>
	case PLL_SRC_MAINCK_4M_RC:
	case PLL_SRC_MAINCK_8M_RC:
	case PLL_SRC_MAINCK_12M_RC:
	case PLL_SRC_MAINCK_XTAL:
	case PLL_SRC_MAINCK_BYPASS:
		osc_enable(e_src);
  402c92:	79fb      	ldrb	r3, [r7, #7]
  402c94:	4618      	mov	r0, r3
  402c96:	4b06      	ldr	r3, [pc, #24]	; (402cb0 <pll_enable_source+0x30>)
  402c98:	4798      	blx	r3
		osc_wait_ready(e_src);
  402c9a:	79fb      	ldrb	r3, [r7, #7]
  402c9c:	4618      	mov	r0, r3
  402c9e:	4b05      	ldr	r3, [pc, #20]	; (402cb4 <pll_enable_source+0x34>)
  402ca0:	4798      	blx	r3
		break;
  402ca2:	e000      	b.n	402ca6 <pll_enable_source+0x26>

	default:
		Assert(false);
		break;
  402ca4:	bf00      	nop
	}
}
  402ca6:	bf00      	nop
  402ca8:	3708      	adds	r7, #8
  402caa:	46bd      	mov	sp, r7
  402cac:	bd80      	pop	{r7, pc}
  402cae:	bf00      	nop
  402cb0:	00402a49 	.word	0x00402a49
  402cb4:	00402bb5 	.word	0x00402bb5

00402cb8 <pll_wait_for_lock>:
 *
 * \retval STATUS_OK The PLL is now locked.
 * \retval ERR_TIMEOUT Timed out waiting for PLL to become locked.
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
  402cb8:	b580      	push	{r7, lr}
  402cba:	b082      	sub	sp, #8
  402cbc:	af00      	add	r7, sp, #0
  402cbe:	6078      	str	r0, [r7, #4]
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  402cc0:	bf00      	nop
  402cc2:	6878      	ldr	r0, [r7, #4]
  402cc4:	4b04      	ldr	r3, [pc, #16]	; (402cd8 <pll_wait_for_lock+0x20>)
  402cc6:	4798      	blx	r3
  402cc8:	4603      	mov	r3, r0
  402cca:	2b00      	cmp	r3, #0
  402ccc:	d0f9      	beq.n	402cc2 <pll_wait_for_lock+0xa>
		/* Do nothing */
	}

	return 0;
  402cce:	2300      	movs	r3, #0
}
  402cd0:	4618      	mov	r0, r3
  402cd2:	3708      	adds	r7, #8
  402cd4:	46bd      	mov	sp, r7
  402cd6:	bd80      	pop	{r7, pc}
  402cd8:	00402c65 	.word	0x00402c65

00402cdc <sysclk_get_main_hz>:
{
  402cdc:	b580      	push	{r7, lr}
  402cde:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  402ce0:	2006      	movs	r0, #6
  402ce2:	4b03      	ldr	r3, [pc, #12]	; (402cf0 <sysclk_get_main_hz+0x14>)
  402ce4:	4798      	blx	r3
  402ce6:	4603      	mov	r3, r0
  402ce8:	011b      	lsls	r3, r3, #4
}
  402cea:	4618      	mov	r0, r3
  402cec:	bd80      	pop	{r7, pc}
  402cee:	bf00      	nop
  402cf0:	00402b41 	.word	0x00402b41

00402cf4 <sysclk_get_cpu_hz>:
{
  402cf4:	b580      	push	{r7, lr}
  402cf6:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  402cf8:	4b02      	ldr	r3, [pc, #8]	; (402d04 <sysclk_get_cpu_hz+0x10>)
  402cfa:	4798      	blx	r3
  402cfc:	4603      	mov	r3, r0
  402cfe:	085b      	lsrs	r3, r3, #1
}
  402d00:	4618      	mov	r0, r3
  402d02:	bd80      	pop	{r7, pc}
  402d04:	00402cdd 	.word	0x00402cdd

00402d08 <sysclk_init>:
	pmc_disable_udpck();
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
  402d08:	b590      	push	{r4, r7, lr}
  402d0a:	b083      	sub	sp, #12
  402d0c:	af00      	add	r7, sp, #0
	/* Set flash wait state to max in case the below clock switching. */
	system_init_flash(CHIP_FREQ_CPU_MAX);
  402d0e:	4811      	ldr	r0, [pc, #68]	; (402d54 <sysclk_init+0x4c>)
  402d10:	4b11      	ldr	r3, [pc, #68]	; (402d58 <sysclk_init+0x50>)
  402d12:	4798      	blx	r3

#ifdef CONFIG_PLL0_SOURCE
	else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_PLLACK) {
		struct pll_config pllcfg;

		pll_enable_source(CONFIG_PLL0_SOURCE);
  402d14:	2006      	movs	r0, #6
  402d16:	4b11      	ldr	r3, [pc, #68]	; (402d5c <sysclk_init+0x54>)
  402d18:	4798      	blx	r3
		pll_config_defaults(&pllcfg, 0);
  402d1a:	1d38      	adds	r0, r7, #4
  402d1c:	2310      	movs	r3, #16
  402d1e:	2201      	movs	r2, #1
  402d20:	2106      	movs	r1, #6
  402d22:	4c0f      	ldr	r4, [pc, #60]	; (402d60 <sysclk_init+0x58>)
  402d24:	47a0      	blx	r4
		pll_enable(&pllcfg, 0);
  402d26:	1d3b      	adds	r3, r7, #4
  402d28:	2100      	movs	r1, #0
  402d2a:	4618      	mov	r0, r3
  402d2c:	4b0d      	ldr	r3, [pc, #52]	; (402d64 <sysclk_init+0x5c>)
  402d2e:	4798      	blx	r3
		pll_wait_for_lock(0);
  402d30:	2000      	movs	r0, #0
  402d32:	4b0d      	ldr	r3, [pc, #52]	; (402d68 <sysclk_init+0x60>)
  402d34:	4798      	blx	r3
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  402d36:	2010      	movs	r0, #16
  402d38:	4b0c      	ldr	r3, [pc, #48]	; (402d6c <sysclk_init+0x64>)
  402d3a:	4798      	blx	r3
	}
#endif

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  402d3c:	4b0c      	ldr	r3, [pc, #48]	; (402d70 <sysclk_init+0x68>)
  402d3e:	4798      	blx	r3

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  402d40:	4b0c      	ldr	r3, [pc, #48]	; (402d74 <sysclk_init+0x6c>)
  402d42:	4798      	blx	r3
  402d44:	4603      	mov	r3, r0
  402d46:	4618      	mov	r0, r3
  402d48:	4b03      	ldr	r3, [pc, #12]	; (402d58 <sysclk_init+0x50>)
  402d4a:	4798      	blx	r3

#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
	/* Signal that the internal frequencies are setup */
	sysclk_initialized = 1;
#endif
}
  402d4c:	bf00      	nop
  402d4e:	370c      	adds	r7, #12
  402d50:	46bd      	mov	sp, r7
  402d52:	bd90      	pop	{r4, r7, pc}
  402d54:	07270e00 	.word	0x07270e00
  402d58:	00402999 	.word	0x00402999
  402d5c:	00402c81 	.word	0x00402c81
  402d60:	00402be1 	.word	0x00402be1
  402d64:	00402c35 	.word	0x00402c35
  402d68:	00402cb9 	.word	0x00402cb9
  402d6c:	004034a9 	.word	0x004034a9
  402d70:	00402831 	.word	0x00402831
  402d74:	00402cf5 	.word	0x00402cf5

00402d78 <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  402d78:	b580      	push	{r7, lr}
  402d7a:	b084      	sub	sp, #16
  402d7c:	af00      	add	r7, sp, #0
  402d7e:	6078      	str	r0, [r7, #4]
  402d80:	6039      	str	r1, [r7, #0]
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  402d82:	6878      	ldr	r0, [r7, #4]
  402d84:	4b2c      	ldr	r3, [pc, #176]	; (402e38 <pio_handler_process+0xc0>)
  402d86:	4798      	blx	r3
  402d88:	60f8      	str	r0, [r7, #12]
	status &= pio_get_interrupt_mask(p_pio);
  402d8a:	6878      	ldr	r0, [r7, #4]
  402d8c:	4b2b      	ldr	r3, [pc, #172]	; (402e3c <pio_handler_process+0xc4>)
  402d8e:	4798      	blx	r3
  402d90:	4602      	mov	r2, r0
  402d92:	68fb      	ldr	r3, [r7, #12]
  402d94:	4013      	ands	r3, r2
  402d96:	60fb      	str	r3, [r7, #12]

	/* Check pending events */
	if (status != 0) {
  402d98:	68fb      	ldr	r3, [r7, #12]
  402d9a:	2b00      	cmp	r3, #0
  402d9c:	d03c      	beq.n	402e18 <pio_handler_process+0xa0>
		/* Find triggering source */
		i = 0;
  402d9e:	2300      	movs	r3, #0
  402da0:	60bb      	str	r3, [r7, #8]
		while (status != 0) {
  402da2:	e034      	b.n	402e0e <pio_handler_process+0x96>
			/* Source is configured on the same controller */
			if (gs_interrupt_sources[i].id == ul_id) {
  402da4:	4a26      	ldr	r2, [pc, #152]	; (402e40 <pio_handler_process+0xc8>)
  402da6:	68bb      	ldr	r3, [r7, #8]
  402da8:	011b      	lsls	r3, r3, #4
  402daa:	4413      	add	r3, r2
  402dac:	681a      	ldr	r2, [r3, #0]
  402dae:	683b      	ldr	r3, [r7, #0]
  402db0:	429a      	cmp	r2, r3
  402db2:	d126      	bne.n	402e02 <pio_handler_process+0x8a>
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
  402db4:	4a22      	ldr	r2, [pc, #136]	; (402e40 <pio_handler_process+0xc8>)
  402db6:	68bb      	ldr	r3, [r7, #8]
  402db8:	011b      	lsls	r3, r3, #4
  402dba:	4413      	add	r3, r2
  402dbc:	3304      	adds	r3, #4
  402dbe:	681a      	ldr	r2, [r3, #0]
  402dc0:	68fb      	ldr	r3, [r7, #12]
  402dc2:	4013      	ands	r3, r2
  402dc4:	2b00      	cmp	r3, #0
  402dc6:	d01c      	beq.n	402e02 <pio_handler_process+0x8a>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
  402dc8:	4a1d      	ldr	r2, [pc, #116]	; (402e40 <pio_handler_process+0xc8>)
  402dca:	68bb      	ldr	r3, [r7, #8]
  402dcc:	011b      	lsls	r3, r3, #4
  402dce:	4413      	add	r3, r2
  402dd0:	330c      	adds	r3, #12
  402dd2:	681b      	ldr	r3, [r3, #0]
  402dd4:	491a      	ldr	r1, [pc, #104]	; (402e40 <pio_handler_process+0xc8>)
  402dd6:	68ba      	ldr	r2, [r7, #8]
  402dd8:	0112      	lsls	r2, r2, #4
  402dda:	440a      	add	r2, r1
  402ddc:	6810      	ldr	r0, [r2, #0]
  402dde:	4918      	ldr	r1, [pc, #96]	; (402e40 <pio_handler_process+0xc8>)
  402de0:	68ba      	ldr	r2, [r7, #8]
  402de2:	0112      	lsls	r2, r2, #4
  402de4:	440a      	add	r2, r1
  402de6:	3204      	adds	r2, #4
  402de8:	6812      	ldr	r2, [r2, #0]
  402dea:	4611      	mov	r1, r2
  402dec:	4798      	blx	r3
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
  402dee:	4a14      	ldr	r2, [pc, #80]	; (402e40 <pio_handler_process+0xc8>)
  402df0:	68bb      	ldr	r3, [r7, #8]
  402df2:	011b      	lsls	r3, r3, #4
  402df4:	4413      	add	r3, r2
  402df6:	3304      	adds	r3, #4
  402df8:	681b      	ldr	r3, [r3, #0]
  402dfa:	43db      	mvns	r3, r3
  402dfc:	68fa      	ldr	r2, [r7, #12]
  402dfe:	4013      	ands	r3, r2
  402e00:	60fb      	str	r3, [r7, #12]
				}
			}
			i++;
  402e02:	68bb      	ldr	r3, [r7, #8]
  402e04:	3301      	adds	r3, #1
  402e06:	60bb      	str	r3, [r7, #8]
			if (i >= MAX_INTERRUPT_SOURCES) {
  402e08:	68bb      	ldr	r3, [r7, #8]
  402e0a:	2b06      	cmp	r3, #6
  402e0c:	d803      	bhi.n	402e16 <pio_handler_process+0x9e>
		while (status != 0) {
  402e0e:	68fb      	ldr	r3, [r7, #12]
  402e10:	2b00      	cmp	r3, #0
  402e12:	d1c7      	bne.n	402da4 <pio_handler_process+0x2c>
  402e14:	e000      	b.n	402e18 <pio_handler_process+0xa0>
				break;
  402e16:	bf00      	nop
		}
	}

	/* Check capture events */
#if (SAM3S || SAM4S || SAM4E)
	if (pio_capture_enable_flag) {
  402e18:	4b0a      	ldr	r3, [pc, #40]	; (402e44 <pio_handler_process+0xcc>)
  402e1a:	681b      	ldr	r3, [r3, #0]
  402e1c:	2b00      	cmp	r3, #0
  402e1e:	d007      	beq.n	402e30 <pio_handler_process+0xb8>
		if (pio_capture_handler) {
  402e20:	4b09      	ldr	r3, [pc, #36]	; (402e48 <pio_handler_process+0xd0>)
  402e22:	681b      	ldr	r3, [r3, #0]
  402e24:	2b00      	cmp	r3, #0
  402e26:	d003      	beq.n	402e30 <pio_handler_process+0xb8>
			pio_capture_handler(p_pio);
  402e28:	4b07      	ldr	r3, [pc, #28]	; (402e48 <pio_handler_process+0xd0>)
  402e2a:	681b      	ldr	r3, [r3, #0]
  402e2c:	6878      	ldr	r0, [r7, #4]
  402e2e:	4798      	blx	r3
		}
	}
#endif
}
  402e30:	bf00      	nop
  402e32:	3710      	adds	r7, #16
  402e34:	46bd      	mov	sp, r7
  402e36:	bd80      	pop	{r7, pc}
  402e38:	00403479 	.word	0x00403479
  402e3c:	00403491 	.word	0x00403491
  402e40:	2000048c 	.word	0x2000048c
  402e44:	20000530 	.word	0x20000530
  402e48:	200004fc 	.word	0x200004fc

00402e4c <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
  402e4c:	b580      	push	{r7, lr}
  402e4e:	af00      	add	r7, sp, #0
	pio_handler_process(PIOA, ID_PIOA);
  402e50:	2109      	movs	r1, #9
  402e52:	4802      	ldr	r0, [pc, #8]	; (402e5c <PIOA_Handler+0x10>)
  402e54:	4b02      	ldr	r3, [pc, #8]	; (402e60 <PIOA_Handler+0x14>)
  402e56:	4798      	blx	r3
}
  402e58:	bf00      	nop
  402e5a:	bd80      	pop	{r7, pc}
  402e5c:	400e0e00 	.word	0x400e0e00
  402e60:	00402d79 	.word	0x00402d79

00402e64 <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
  402e64:	b580      	push	{r7, lr}
  402e66:	af00      	add	r7, sp, #0
    pio_handler_process(PIOB, ID_PIOB);
  402e68:	210a      	movs	r1, #10
  402e6a:	4802      	ldr	r0, [pc, #8]	; (402e74 <PIOB_Handler+0x10>)
  402e6c:	4b02      	ldr	r3, [pc, #8]	; (402e78 <PIOB_Handler+0x14>)
  402e6e:	4798      	blx	r3
}
  402e70:	bf00      	nop
  402e72:	bd80      	pop	{r7, pc}
  402e74:	400e1000 	.word	0x400e1000
  402e78:	00402d79 	.word	0x00402d79

00402e7c <PIOC_Handler>:
/**
 * \brief Parallel IO Controller C interrupt handler.
 * Redefined PIOC interrupt handler for NVIC interrupt table.
 */
void PIOC_Handler(void)
{
  402e7c:	b580      	push	{r7, lr}
  402e7e:	af00      	add	r7, sp, #0
	pio_handler_process(PIOC, ID_PIOC);
  402e80:	210b      	movs	r1, #11
  402e82:	4802      	ldr	r0, [pc, #8]	; (402e8c <PIOC_Handler+0x10>)
  402e84:	4b02      	ldr	r3, [pc, #8]	; (402e90 <PIOC_Handler+0x14>)
  402e86:	4798      	blx	r3
}
  402e88:	bf00      	nop
  402e8a:	bd80      	pop	{r7, pc}
  402e8c:	400e1200 	.word	0x400e1200
  402e90:	00402d79 	.word	0x00402d79

00402e94 <PIOD_Handler>:
/**
 * \brief Parallel IO Controller D interrupt handler.
 * Redefined PIOD interrupt handler for NVIC interrupt table.
 */
void PIOD_Handler(void)
{
  402e94:	b580      	push	{r7, lr}
  402e96:	af00      	add	r7, sp, #0
	pio_handler_process(PIOD, ID_PIOD);
  402e98:	210c      	movs	r1, #12
  402e9a:	4802      	ldr	r0, [pc, #8]	; (402ea4 <PIOD_Handler+0x10>)
  402e9c:	4b02      	ldr	r3, [pc, #8]	; (402ea8 <PIOD_Handler+0x14>)
  402e9e:	4798      	blx	r3
}
  402ea0:	bf00      	nop
  402ea2:	bd80      	pop	{r7, pc}
  402ea4:	400e1400 	.word	0x400e1400
  402ea8:	00402d79 	.word	0x00402d79

00402eac <PIOE_Handler>:
/**
 * \brief Parallel IO Controller E interrupt handler.
 * Redefined PIOE interrupt handler for NVIC interrupt table.
 */
void PIOE_Handler(void)
{
  402eac:	b580      	push	{r7, lr}
  402eae:	af00      	add	r7, sp, #0
	pio_handler_process(PIOE, ID_PIOE);
  402eb0:	210d      	movs	r1, #13
  402eb2:	4802      	ldr	r0, [pc, #8]	; (402ebc <PIOE_Handler+0x10>)
  402eb4:	4b02      	ldr	r3, [pc, #8]	; (402ec0 <PIOE_Handler+0x14>)
  402eb6:	4798      	blx	r3
}
  402eb8:	bf00      	nop
  402eba:	bd80      	pop	{r7, pc}
  402ebc:	400e1600 	.word	0x400e1600
  402ec0:	00402d79 	.word	0x00402d79

00402ec4 <can_set_baudrate>:
 *
 * \retval Set the baudrate successfully or not.
 */
static uint32_t can_set_baudrate(Can *p_can, uint32_t ul_mck,
		uint32_t ul_baudrate)
{
  402ec4:	b580      	push	{r7, lr}
  402ec6:	b08a      	sub	sp, #40	; 0x28
  402ec8:	af00      	add	r7, sp, #0
  402eca:	60f8      	str	r0, [r7, #12]
  402ecc:	60b9      	str	r1, [r7, #8]
  402ece:	607a      	str	r2, [r7, #4]
	uint32_t ul_cur_mod;
	can_bit_timing_t *p_bit_time;

	/* Check whether the baudrate prescale will be greater than the max
	 * divide value. */
	if (((ul_mck + (ul_baudrate * CAN_MAX_TQ_NUM * 1000 - 1)) /
  402ed0:	687b      	ldr	r3, [r7, #4]
  402ed2:	f246 12a8 	movw	r2, #25000	; 0x61a8
  402ed6:	fb02 f203 	mul.w	r2, r2, r3
  402eda:	68bb      	ldr	r3, [r7, #8]
  402edc:	4413      	add	r3, r2
  402ede:	1e5a      	subs	r2, r3, #1
			(ul_baudrate * CAN_MAX_TQ_NUM * 1000)) >
  402ee0:	687b      	ldr	r3, [r7, #4]
  402ee2:	f246 11a8 	movw	r1, #25000	; 0x61a8
  402ee6:	fb01 f303 	mul.w	r3, r1, r3
	if (((ul_mck + (ul_baudrate * CAN_MAX_TQ_NUM * 1000 - 1)) /
  402eea:	fbb2 f3f3 	udiv	r3, r2, r3
  402eee:	2b80      	cmp	r3, #128	; 0x80
  402ef0:	d901      	bls.n	402ef6 <can_set_baudrate+0x32>
			CAN_BAUDRATE_MAX_DIV) {
		return 0;
  402ef2:	2300      	movs	r3, #0
  402ef4:	e086      	b.n	403004 <can_set_baudrate+0x140>
	}

	/* Check whether the input MCK is too small. */
	if ((ul_mck / 2)  < ul_baudrate * CAN_MIN_TQ_NUM * 1000) {
  402ef6:	68bb      	ldr	r3, [r7, #8]
  402ef8:	085a      	lsrs	r2, r3, #1
  402efa:	687b      	ldr	r3, [r7, #4]
  402efc:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
  402f00:	fb01 f303 	mul.w	r3, r1, r3
  402f04:	429a      	cmp	r2, r3
  402f06:	d201      	bcs.n	402f0c <can_set_baudrate+0x48>
		return 0;
  402f08:	2300      	movs	r3, #0
  402f0a:	e07b      	b.n	403004 <can_set_baudrate+0x140>
	}

	/* Initialize it as the minimum Time Quantum. */
	uc_tq = CAN_MIN_TQ_NUM;
  402f0c:	2308      	movs	r3, #8
  402f0e:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

	/* Initialize the remainder as the max value. When the remainder is 0,
	 *get the right TQ number. */
	ul_mod = 0xffffffff;
  402f12:	f04f 33ff 	mov.w	r3, #4294967295
  402f16:	623b      	str	r3, [r7, #32]
	/* Find out the approximate Time Quantum according to the baudrate. */
	for (uint8_t i = CAN_MIN_TQ_NUM; i <= CAN_MAX_TQ_NUM; i++) {
  402f18:	2308      	movs	r3, #8
  402f1a:	77fb      	strb	r3, [r7, #31]
  402f1c:	e02a      	b.n	402f74 <can_set_baudrate+0xb0>
		if ((ul_mck / (ul_baudrate * i * 1000)) <=
  402f1e:	7ffb      	ldrb	r3, [r7, #31]
  402f20:	687a      	ldr	r2, [r7, #4]
  402f22:	fb02 f303 	mul.w	r3, r2, r3
  402f26:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  402f2a:	fb02 f303 	mul.w	r3, r2, r3
  402f2e:	68ba      	ldr	r2, [r7, #8]
  402f30:	fbb2 f3f3 	udiv	r3, r2, r3
  402f34:	2b80      	cmp	r3, #128	; 0x80
  402f36:	d81a      	bhi.n	402f6e <can_set_baudrate+0xaa>
				CAN_BAUDRATE_MAX_DIV) {
			ul_cur_mod = ul_mck % (ul_baudrate * i * 1000);
  402f38:	7ffb      	ldrb	r3, [r7, #31]
  402f3a:	687a      	ldr	r2, [r7, #4]
  402f3c:	fb02 f303 	mul.w	r3, r2, r3
  402f40:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  402f44:	fb02 f203 	mul.w	r2, r2, r3
  402f48:	68bb      	ldr	r3, [r7, #8]
  402f4a:	fbb3 f1f2 	udiv	r1, r3, r2
  402f4e:	fb02 f201 	mul.w	r2, r2, r1
  402f52:	1a9b      	subs	r3, r3, r2
  402f54:	61bb      	str	r3, [r7, #24]
			if (ul_cur_mod < ul_mod) {
  402f56:	69ba      	ldr	r2, [r7, #24]
  402f58:	6a3b      	ldr	r3, [r7, #32]
  402f5a:	429a      	cmp	r2, r3
  402f5c:	d207      	bcs.n	402f6e <can_set_baudrate+0xaa>
				ul_mod = ul_cur_mod;
  402f5e:	69bb      	ldr	r3, [r7, #24]
  402f60:	623b      	str	r3, [r7, #32]
				uc_tq = i;
  402f62:	7ffb      	ldrb	r3, [r7, #31]
  402f64:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
				if (!ul_mod) {
  402f68:	6a3b      	ldr	r3, [r7, #32]
  402f6a:	2b00      	cmp	r3, #0
  402f6c:	d006      	beq.n	402f7c <can_set_baudrate+0xb8>
	for (uint8_t i = CAN_MIN_TQ_NUM; i <= CAN_MAX_TQ_NUM; i++) {
  402f6e:	7ffb      	ldrb	r3, [r7, #31]
  402f70:	3301      	adds	r3, #1
  402f72:	77fb      	strb	r3, [r7, #31]
  402f74:	7ffb      	ldrb	r3, [r7, #31]
  402f76:	2b19      	cmp	r3, #25
  402f78:	d9d1      	bls.n	402f1e <can_set_baudrate+0x5a>
  402f7a:	e000      	b.n	402f7e <can_set_baudrate+0xba>
					break;
  402f7c:	bf00      	nop
			}
		}
	}

	/* Calculate the baudrate prescale value. */
	uc_prescale = ul_mck / (ul_baudrate * uc_tq * 1000);
  402f7e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  402f82:	687a      	ldr	r2, [r7, #4]
  402f84:	fb02 f303 	mul.w	r3, r2, r3
  402f88:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  402f8c:	fb02 f303 	mul.w	r3, r2, r3
  402f90:	68ba      	ldr	r2, [r7, #8]
  402f92:	fbb2 f3f3 	udiv	r3, r2, r3
  402f96:	75fb      	strb	r3, [r7, #23]
	if (uc_prescale < 2) {
  402f98:	7dfb      	ldrb	r3, [r7, #23]
  402f9a:	2b01      	cmp	r3, #1
  402f9c:	d801      	bhi.n	402fa2 <can_set_baudrate+0xde>
		return 0;
  402f9e:	2300      	movs	r3, #0
  402fa0:	e030      	b.n	403004 <can_set_baudrate+0x140>
	}

	/* Get the right CAN BIT Timing group. */
	p_bit_time = (can_bit_timing_t *)&can_bit_time[uc_tq - CAN_MIN_TQ_NUM];
  402fa2:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  402fa6:	f1a3 0208 	sub.w	r2, r3, #8
  402faa:	4613      	mov	r3, r2
  402fac:	005b      	lsls	r3, r3, #1
  402fae:	4413      	add	r3, r2
  402fb0:	005b      	lsls	r3, r3, #1
  402fb2:	4a16      	ldr	r2, [pc, #88]	; (40300c <can_set_baudrate+0x148>)
  402fb4:	4413      	add	r3, r2
  402fb6:	613b      	str	r3, [r7, #16]

	/* Before modifying the CANBR register, disable the CAN controller. */
	can_disable(p_can);
  402fb8:	68f8      	ldr	r0, [r7, #12]
  402fba:	4b15      	ldr	r3, [pc, #84]	; (403010 <can_set_baudrate+0x14c>)
  402fbc:	4798      	blx	r3

	/* Write into the CAN baudrate register. */
	p_can->CAN_BR = CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
  402fbe:	693b      	ldr	r3, [r7, #16]
  402fc0:	78db      	ldrb	r3, [r3, #3]
  402fc2:	3b01      	subs	r3, #1
  402fc4:	f003 0207 	and.w	r2, r3, #7
			CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
  402fc8:	693b      	ldr	r3, [r7, #16]
  402fca:	789b      	ldrb	r3, [r3, #2]
  402fcc:	3b01      	subs	r3, #1
  402fce:	011b      	lsls	r3, r3, #4
  402fd0:	f003 0370 	and.w	r3, r3, #112	; 0x70
	p_can->CAN_BR = CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
  402fd4:	431a      	orrs	r2, r3
			CAN_BR_PROPAG(p_bit_time->uc_prog - 1) |
  402fd6:	693b      	ldr	r3, [r7, #16]
  402fd8:	785b      	ldrb	r3, [r3, #1]
  402fda:	3b01      	subs	r3, #1
  402fdc:	021b      	lsls	r3, r3, #8
  402fde:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
			CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
  402fe2:	431a      	orrs	r2, r3
			CAN_BR_SJW(p_bit_time->uc_sjw - 1) |
  402fe4:	693b      	ldr	r3, [r7, #16]
  402fe6:	791b      	ldrb	r3, [r3, #4]
  402fe8:	3b01      	subs	r3, #1
  402fea:	031b      	lsls	r3, r3, #12
  402fec:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
			CAN_BR_PROPAG(p_bit_time->uc_prog - 1) |
  402ff0:	431a      	orrs	r2, r3
			CAN_BR_BRP(uc_prescale - 1);
  402ff2:	7dfb      	ldrb	r3, [r7, #23]
  402ff4:	3b01      	subs	r3, #1
  402ff6:	041b      	lsls	r3, r3, #16
  402ff8:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
			CAN_BR_SJW(p_bit_time->uc_sjw - 1) |
  402ffc:	431a      	orrs	r2, r3
	p_can->CAN_BR = CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
  402ffe:	68fb      	ldr	r3, [r7, #12]
  403000:	615a      	str	r2, [r3, #20]
	return 1;
  403002:	2301      	movs	r3, #1
}
  403004:	4618      	mov	r0, r3
  403006:	3728      	adds	r7, #40	; 0x28
  403008:	46bd      	mov	sp, r7
  40300a:	bd80      	pop	{r7, pc}
  40300c:	00404028 	.word	0x00404028
  403010:	004030bd 	.word	0x004030bd

00403014 <can_init>:
 *
 * \note PMC clock for CAN peripheral should be enabled before calling this
 *function.
 */
uint32_t can_init(Can *p_can, uint32_t ul_mck, uint32_t ul_baudrate)
{
  403014:	b580      	push	{r7, lr}
  403016:	b086      	sub	sp, #24
  403018:	af00      	add	r7, sp, #0
  40301a:	60f8      	str	r0, [r7, #12]
  40301c:	60b9      	str	r1, [r7, #8]
  40301e:	607a      	str	r2, [r7, #4]
	uint32_t ul_flag;
	uint32_t ul_tick;

	/* Initialize the baudrate for CAN module. */
	ul_flag = can_set_baudrate(p_can, ul_mck, ul_baudrate);
  403020:	687a      	ldr	r2, [r7, #4]
  403022:	68b9      	ldr	r1, [r7, #8]
  403024:	68f8      	ldr	r0, [r7, #12]
  403026:	4b17      	ldr	r3, [pc, #92]	; (403084 <can_init+0x70>)
  403028:	4798      	blx	r3
  40302a:	6178      	str	r0, [r7, #20]
	if (ul_flag == 0) {
  40302c:	697b      	ldr	r3, [r7, #20]
  40302e:	2b00      	cmp	r3, #0
  403030:	d101      	bne.n	403036 <can_init+0x22>
		return 0;
  403032:	2300      	movs	r3, #0
  403034:	e021      	b.n	40307a <can_init+0x66>
	}

	/* Reset the CAN eight message mailbox. */
	can_reset_all_mailbox(p_can);
  403036:	68f8      	ldr	r0, [r7, #12]
  403038:	4b13      	ldr	r3, [pc, #76]	; (403088 <can_init+0x74>)
  40303a:	4798      	blx	r3

	/* Enable the CAN controller. */
	can_enable(p_can);
  40303c:	68f8      	ldr	r0, [r7, #12]
  40303e:	4b13      	ldr	r3, [pc, #76]	; (40308c <can_init+0x78>)
  403040:	4798      	blx	r3

	/* Wait until the CAN is synchronized with the bus activity. */
	ul_flag = 0;
  403042:	2300      	movs	r3, #0
  403044:	617b      	str	r3, [r7, #20]
	ul_tick = 0;
  403046:	2300      	movs	r3, #0
  403048:	613b      	str	r3, [r7, #16]
	while (!(ul_flag & CAN_SR_WAKEUP) && (ul_tick < CAN_TIMEOUT)) {
  40304a:	e006      	b.n	40305a <can_init+0x46>
		ul_flag = can_get_status(p_can);
  40304c:	68f8      	ldr	r0, [r7, #12]
  40304e:	4b10      	ldr	r3, [pc, #64]	; (403090 <can_init+0x7c>)
  403050:	4798      	blx	r3
  403052:	6178      	str	r0, [r7, #20]
		ul_tick++;
  403054:	693b      	ldr	r3, [r7, #16]
  403056:	3301      	adds	r3, #1
  403058:	613b      	str	r3, [r7, #16]
	while (!(ul_flag & CAN_SR_WAKEUP) && (ul_tick < CAN_TIMEOUT)) {
  40305a:	697b      	ldr	r3, [r7, #20]
  40305c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
  403060:	2b00      	cmp	r3, #0
  403062:	d103      	bne.n	40306c <can_init+0x58>
  403064:	693b      	ldr	r3, [r7, #16]
  403066:	4a0b      	ldr	r2, [pc, #44]	; (403094 <can_init+0x80>)
  403068:	4293      	cmp	r3, r2
  40306a:	d9ef      	bls.n	40304c <can_init+0x38>
	}

	/* Timeout or the CAN module has been synchronized with the bus. */
	if (CAN_TIMEOUT == ul_tick) {
  40306c:	693b      	ldr	r3, [r7, #16]
  40306e:	4a0a      	ldr	r2, [pc, #40]	; (403098 <can_init+0x84>)
  403070:	4293      	cmp	r3, r2
  403072:	d101      	bne.n	403078 <can_init+0x64>
		return 0;
  403074:	2300      	movs	r3, #0
  403076:	e000      	b.n	40307a <can_init+0x66>
	} else {
		return 1;
  403078:	2301      	movs	r3, #1
	}
}
  40307a:	4618      	mov	r0, r3
  40307c:	3718      	adds	r7, #24
  40307e:	46bd      	mov	sp, r7
  403080:	bd80      	pop	{r7, pc}
  403082:	bf00      	nop
  403084:	00402ec5 	.word	0x00402ec5
  403088:	00403325 	.word	0x00403325
  40308c:	0040309d 	.word	0x0040309d
  403090:	004030dd 	.word	0x004030dd
  403094:	0001869f 	.word	0x0001869f
  403098:	000186a0 	.word	0x000186a0

0040309c <can_enable>:
 * \brief Enable CAN Controller.
 *
 * \param p_can  Pointer to a CAN peripheral instance.
 */
void can_enable(Can *p_can)
{
  40309c:	b480      	push	{r7}
  40309e:	b083      	sub	sp, #12
  4030a0:	af00      	add	r7, sp, #0
  4030a2:	6078      	str	r0, [r7, #4]
	p_can->CAN_MR |= CAN_MR_CANEN;
  4030a4:	687b      	ldr	r3, [r7, #4]
  4030a6:	681b      	ldr	r3, [r3, #0]
  4030a8:	f043 0201 	orr.w	r2, r3, #1
  4030ac:	687b      	ldr	r3, [r7, #4]
  4030ae:	601a      	str	r2, [r3, #0]
}
  4030b0:	bf00      	nop
  4030b2:	370c      	adds	r7, #12
  4030b4:	46bd      	mov	sp, r7
  4030b6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4030ba:	4770      	bx	lr

004030bc <can_disable>:
 * \brief Disable CAN Controller.
 *
 * \param p_can  Pointer to a CAN peripheral instance.
 */
void can_disable(Can *p_can)
{
  4030bc:	b480      	push	{r7}
  4030be:	b083      	sub	sp, #12
  4030c0:	af00      	add	r7, sp, #0
  4030c2:	6078      	str	r0, [r7, #4]
	p_can->CAN_MR &= ~CAN_MR_CANEN;
  4030c4:	687b      	ldr	r3, [r7, #4]
  4030c6:	681b      	ldr	r3, [r3, #0]
  4030c8:	f023 0201 	bic.w	r2, r3, #1
  4030cc:	687b      	ldr	r3, [r7, #4]
  4030ce:	601a      	str	r2, [r3, #0]
}
  4030d0:	bf00      	nop
  4030d2:	370c      	adds	r7, #12
  4030d4:	46bd      	mov	sp, r7
  4030d6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4030da:	4770      	bx	lr

004030dc <can_get_status>:
 * \param p_can Pointer to a CAN peripheral instance.
 *
 * \retval CAN status.
 */
uint32_t can_get_status(Can *p_can)
{
  4030dc:	b480      	push	{r7}
  4030de:	b083      	sub	sp, #12
  4030e0:	af00      	add	r7, sp, #0
  4030e2:	6078      	str	r0, [r7, #4]
	return (p_can->CAN_SR);
  4030e4:	687b      	ldr	r3, [r7, #4]
  4030e6:	691b      	ldr	r3, [r3, #16]
}
  4030e8:	4618      	mov	r0, r3
  4030ea:	370c      	adds	r7, #12
  4030ec:	46bd      	mov	sp, r7
  4030ee:	f85d 7b04 	ldr.w	r7, [sp], #4
  4030f2:	4770      	bx	lr

004030f4 <can_global_send_transfer_cmd>:
 *
 * \param p_can   Pointer to a CAN peripheral instance.
 * \param uc_mask Mask for mailboxes that are requested to transfer.
 */
void can_global_send_transfer_cmd(Can *p_can, uint8_t uc_mask)
{
  4030f4:	b480      	push	{r7}
  4030f6:	b085      	sub	sp, #20
  4030f8:	af00      	add	r7, sp, #0
  4030fa:	6078      	str	r0, [r7, #4]
  4030fc:	460b      	mov	r3, r1
  4030fe:	70fb      	strb	r3, [r7, #3]
	uint32_t ul_reg;

	ul_reg = p_can->CAN_TCR & ((uint32_t) ~GLOBAL_MAILBOX_MASK);
  403100:	687b      	ldr	r3, [r7, #4]
  403102:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  403104:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
  403108:	60fb      	str	r3, [r7, #12]
	p_can->CAN_TCR = ul_reg | uc_mask;
  40310a:	78fa      	ldrb	r2, [r7, #3]
  40310c:	68fb      	ldr	r3, [r7, #12]
  40310e:	431a      	orrs	r2, r3
  403110:	687b      	ldr	r3, [r7, #4]
  403112:	625a      	str	r2, [r3, #36]	; 0x24
}
  403114:	bf00      	nop
  403116:	3714      	adds	r7, #20
  403118:	46bd      	mov	sp, r7
  40311a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40311e:	4770      	bx	lr

00403120 <can_mailbox_get_status>:
 * \param uc_index Indicate which mailbox is to be read.
 *
 * \retval The mailbox status.
 */
uint32_t can_mailbox_get_status(Can *p_can, uint8_t uc_index)
{
  403120:	b480      	push	{r7}
  403122:	b083      	sub	sp, #12
  403124:	af00      	add	r7, sp, #0
  403126:	6078      	str	r0, [r7, #4]
  403128:	460b      	mov	r3, r1
  40312a:	70fb      	strb	r3, [r7, #3]
	return (p_can->CAN_MB[uc_index].CAN_MSR);
  40312c:	78fb      	ldrb	r3, [r7, #3]
  40312e:	687a      	ldr	r2, [r7, #4]
  403130:	015b      	lsls	r3, r3, #5
  403132:	4413      	add	r3, r2
  403134:	f503 7304 	add.w	r3, r3, #528	; 0x210
  403138:	681b      	ldr	r3, [r3, #0]
}
  40313a:	4618      	mov	r0, r3
  40313c:	370c      	adds	r7, #12
  40313e:	46bd      	mov	sp, r7
  403140:	f85d 7b04 	ldr.w	r7, [sp], #4
  403144:	4770      	bx	lr

00403146 <can_mailbox_init>:
 *
 * \param p_can    Pointer to a CAN peripheral instance.
 * \param p_mailbox Pointer to a CAN mailbox instance.
 */
void can_mailbox_init(Can *p_can, can_mb_conf_t *p_mailbox)
{
  403146:	b480      	push	{r7}
  403148:	b085      	sub	sp, #20
  40314a:	af00      	add	r7, sp, #0
  40314c:	6078      	str	r0, [r7, #4]
  40314e:	6039      	str	r1, [r7, #0]
	uint8_t uc_index;

	uc_index = (uint8_t)p_mailbox->ul_mb_idx;
  403150:	683b      	ldr	r3, [r7, #0]
  403152:	681b      	ldr	r3, [r3, #0]
  403154:	73fb      	strb	r3, [r7, #15]
	/* Check the object type of the mailbox. If it's used to disable the
	 * mailbox, reset the whole mailbox. */
	if (!p_mailbox->uc_obj_type) {
  403156:	683b      	ldr	r3, [r7, #0]
  403158:	791b      	ldrb	r3, [r3, #4]
  40315a:	2b00      	cmp	r3, #0
  40315c:	d12f      	bne.n	4031be <can_mailbox_init+0x78>
		p_can->CAN_MB[uc_index].CAN_MMR = 0;
  40315e:	7bfb      	ldrb	r3, [r7, #15]
  403160:	687a      	ldr	r2, [r7, #4]
  403162:	3310      	adds	r3, #16
  403164:	015b      	lsls	r3, r3, #5
  403166:	4413      	add	r3, r2
  403168:	2200      	movs	r2, #0
  40316a:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MAM = 0;
  40316c:	7bfb      	ldrb	r3, [r7, #15]
  40316e:	687a      	ldr	r2, [r7, #4]
  403170:	3310      	adds	r3, #16
  403172:	015b      	lsls	r3, r3, #5
  403174:	4413      	add	r3, r2
  403176:	3304      	adds	r3, #4
  403178:	2200      	movs	r2, #0
  40317a:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MID = 0;
  40317c:	7bfb      	ldrb	r3, [r7, #15]
  40317e:	687a      	ldr	r2, [r7, #4]
  403180:	015b      	lsls	r3, r3, #5
  403182:	4413      	add	r3, r2
  403184:	f503 7302 	add.w	r3, r3, #520	; 0x208
  403188:	2200      	movs	r2, #0
  40318a:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MDL = 0;
  40318c:	7bfb      	ldrb	r3, [r7, #15]
  40318e:	687a      	ldr	r2, [r7, #4]
  403190:	015b      	lsls	r3, r3, #5
  403192:	4413      	add	r3, r2
  403194:	f503 7305 	add.w	r3, r3, #532	; 0x214
  403198:	2200      	movs	r2, #0
  40319a:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MDH = 0;
  40319c:	7bfb      	ldrb	r3, [r7, #15]
  40319e:	687a      	ldr	r2, [r7, #4]
  4031a0:	015b      	lsls	r3, r3, #5
  4031a2:	4413      	add	r3, r2
  4031a4:	f503 7306 	add.w	r3, r3, #536	; 0x218
  4031a8:	2200      	movs	r2, #0
  4031aa:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MCR = 0;
  4031ac:	7bfb      	ldrb	r3, [r7, #15]
  4031ae:	687a      	ldr	r2, [r7, #4]
  4031b0:	015b      	lsls	r3, r3, #5
  4031b2:	4413      	add	r3, r2
  4031b4:	f503 7307 	add.w	r3, r3, #540	; 0x21c
  4031b8:	2200      	movs	r2, #0
  4031ba:	601a      	str	r2, [r3, #0]
		return;
  4031bc:	e050      	b.n	403260 <can_mailbox_init+0x11a>
	}

	/* Set the priority in Transmit mode. */
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  4031be:	7bfb      	ldrb	r3, [r7, #15]
  4031c0:	7bfa      	ldrb	r2, [r7, #15]
  4031c2:	6879      	ldr	r1, [r7, #4]
  4031c4:	3210      	adds	r2, #16
  4031c6:	0152      	lsls	r2, r2, #5
  4031c8:	440a      	add	r2, r1
  4031ca:	6812      	ldr	r2, [r2, #0]
  4031cc:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
			~CAN_MMR_PRIOR_Msk) |
			(p_mailbox->uc_tx_prio << CAN_MMR_PRIOR_Pos);
  4031d0:	6839      	ldr	r1, [r7, #0]
  4031d2:	79c9      	ldrb	r1, [r1, #7]
  4031d4:	0409      	lsls	r1, r1, #16
			~CAN_MMR_PRIOR_Msk) |
  4031d6:	430a      	orrs	r2, r1
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  4031d8:	6879      	ldr	r1, [r7, #4]
  4031da:	3310      	adds	r3, #16
  4031dc:	015b      	lsls	r3, r3, #5
  4031de:	440b      	add	r3, r1
  4031e0:	601a      	str	r2, [r3, #0]

	/* Set the message ID and message acceptance mask for the mailbox in
	 * other modes. */
	if (p_mailbox->uc_id_ver) {
  4031e2:	683b      	ldr	r3, [r7, #0]
  4031e4:	795b      	ldrb	r3, [r3, #5]
  4031e6:	2b00      	cmp	r3, #0
  4031e8:	d016      	beq.n	403218 <can_mailbox_init+0xd2>
		p_can->CAN_MB[uc_index].CAN_MAM = p_mailbox->ul_id_msk |
  4031ea:	7bfb      	ldrb	r3, [r7, #15]
  4031ec:	683a      	ldr	r2, [r7, #0]
  4031ee:	68d2      	ldr	r2, [r2, #12]
  4031f0:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
  4031f4:	6879      	ldr	r1, [r7, #4]
  4031f6:	3310      	adds	r3, #16
  4031f8:	015b      	lsls	r3, r3, #5
  4031fa:	440b      	add	r3, r1
  4031fc:	3304      	adds	r3, #4
  4031fe:	601a      	str	r2, [r3, #0]
				CAN_MAM_MIDE;
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id |
  403200:	7bfb      	ldrb	r3, [r7, #15]
  403202:	683a      	ldr	r2, [r7, #0]
  403204:	6912      	ldr	r2, [r2, #16]
  403206:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
  40320a:	6879      	ldr	r1, [r7, #4]
  40320c:	015b      	lsls	r3, r3, #5
  40320e:	440b      	add	r3, r1
  403210:	f503 7302 	add.w	r3, r3, #520	; 0x208
  403214:	601a      	str	r2, [r3, #0]
  403216:	e011      	b.n	40323c <can_mailbox_init+0xf6>
				CAN_MAM_MIDE;
	} else {
		p_can->CAN_MB[uc_index].CAN_MAM = p_mailbox->ul_id_msk;
  403218:	7bfb      	ldrb	r3, [r7, #15]
  40321a:	683a      	ldr	r2, [r7, #0]
  40321c:	68d2      	ldr	r2, [r2, #12]
  40321e:	6879      	ldr	r1, [r7, #4]
  403220:	3310      	adds	r3, #16
  403222:	015b      	lsls	r3, r3, #5
  403224:	440b      	add	r3, r1
  403226:	3304      	adds	r3, #4
  403228:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id;
  40322a:	7bfb      	ldrb	r3, [r7, #15]
  40322c:	683a      	ldr	r2, [r7, #0]
  40322e:	6912      	ldr	r2, [r2, #16]
  403230:	6879      	ldr	r1, [r7, #4]
  403232:	015b      	lsls	r3, r3, #5
  403234:	440b      	add	r3, r1
  403236:	f503 7302 	add.w	r3, r3, #520	; 0x208
  40323a:	601a      	str	r2, [r3, #0]
	}

	/* Set up mailbox in one of the five different modes. */
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  40323c:	7bfb      	ldrb	r3, [r7, #15]
  40323e:	7bfa      	ldrb	r2, [r7, #15]
  403240:	6879      	ldr	r1, [r7, #4]
  403242:	3210      	adds	r2, #16
  403244:	0152      	lsls	r2, r2, #5
  403246:	440a      	add	r2, r1
  403248:	6812      	ldr	r2, [r2, #0]
  40324a:	f022 62e0 	bic.w	r2, r2, #117440512	; 0x7000000
			~CAN_MMR_MOT_Msk) |
			(p_mailbox->uc_obj_type << CAN_MMR_MOT_Pos);
  40324e:	6839      	ldr	r1, [r7, #0]
  403250:	7909      	ldrb	r1, [r1, #4]
  403252:	0609      	lsls	r1, r1, #24
			~CAN_MMR_MOT_Msk) |
  403254:	430a      	orrs	r2, r1
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  403256:	6879      	ldr	r1, [r7, #4]
  403258:	3310      	adds	r3, #16
  40325a:	015b      	lsls	r3, r3, #5
  40325c:	440b      	add	r3, r1
  40325e:	601a      	str	r2, [r3, #0]
}
  403260:	3714      	adds	r7, #20
  403262:	46bd      	mov	sp, r7
  403264:	f85d 7b04 	ldr.w	r7, [sp], #4
  403268:	4770      	bx	lr
	...

0040326c <can_mailbox_write>:
 * \note After calling this function, the mailbox message won't be sent out
 *until
 * can_mailbox_send_transfer_cmd() is called.
 */
uint32_t can_mailbox_write(Can *p_can, can_mb_conf_t *p_mailbox)
{
  40326c:	b580      	push	{r7, lr}
  40326e:	b084      	sub	sp, #16
  403270:	af00      	add	r7, sp, #0
  403272:	6078      	str	r0, [r7, #4]
  403274:	6039      	str	r1, [r7, #0]
	uint32_t ul_status;
	uint8_t uc_index;

	uc_index = (uint8_t)p_mailbox->ul_mb_idx;
  403276:	683b      	ldr	r3, [r7, #0]
  403278:	681b      	ldr	r3, [r3, #0]
  40327a:	73fb      	strb	r3, [r7, #15]
	/* Read the mailbox status firstly to check whether the mailbox is ready
	 *or not. */
	p_mailbox->ul_status = can_mailbox_get_status(p_can, uc_index);
  40327c:	7bfb      	ldrb	r3, [r7, #15]
  40327e:	4619      	mov	r1, r3
  403280:	6878      	ldr	r0, [r7, #4]
  403282:	4b27      	ldr	r3, [pc, #156]	; (403320 <can_mailbox_write+0xb4>)
  403284:	4798      	blx	r3
  403286:	4602      	mov	r2, r0
  403288:	683b      	ldr	r3, [r7, #0]
  40328a:	609a      	str	r2, [r3, #8]
	ul_status = p_mailbox->ul_status;
  40328c:	683b      	ldr	r3, [r7, #0]
  40328e:	689b      	ldr	r3, [r3, #8]
  403290:	60bb      	str	r3, [r7, #8]
	if (!(ul_status & CAN_MSR_MRDY)) {
  403292:	68bb      	ldr	r3, [r7, #8]
  403294:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
  403298:	2b00      	cmp	r3, #0
  40329a:	d101      	bne.n	4032a0 <can_mailbox_write+0x34>
		return CAN_MAILBOX_NOT_READY;
  40329c:	2301      	movs	r3, #1
  40329e:	e03b      	b.n	403318 <can_mailbox_write+0xac>
	}

	/* Write transmit identifier. */
	if (p_mailbox->uc_id_ver) {
  4032a0:	683b      	ldr	r3, [r7, #0]
  4032a2:	795b      	ldrb	r3, [r3, #5]
  4032a4:	2b00      	cmp	r3, #0
  4032a6:	d00b      	beq.n	4032c0 <can_mailbox_write+0x54>
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id |
  4032a8:	7bfb      	ldrb	r3, [r7, #15]
  4032aa:	683a      	ldr	r2, [r7, #0]
  4032ac:	6912      	ldr	r2, [r2, #16]
  4032ae:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
  4032b2:	6879      	ldr	r1, [r7, #4]
  4032b4:	015b      	lsls	r3, r3, #5
  4032b6:	440b      	add	r3, r1
  4032b8:	f503 7302 	add.w	r3, r3, #520	; 0x208
  4032bc:	601a      	str	r2, [r3, #0]
  4032be:	e008      	b.n	4032d2 <can_mailbox_write+0x66>
				CAN_MAM_MIDE;
	} else {
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id;
  4032c0:	7bfb      	ldrb	r3, [r7, #15]
  4032c2:	683a      	ldr	r2, [r7, #0]
  4032c4:	6912      	ldr	r2, [r2, #16]
  4032c6:	6879      	ldr	r1, [r7, #4]
  4032c8:	015b      	lsls	r3, r3, #5
  4032ca:	440b      	add	r3, r1
  4032cc:	f503 7302 	add.w	r3, r3, #520	; 0x208
  4032d0:	601a      	str	r2, [r3, #0]
	}

	/* Write transmit data into mailbox data register. */
	p_can->CAN_MB[uc_index].CAN_MDL = p_mailbox->ul_datal;
  4032d2:	7bfb      	ldrb	r3, [r7, #15]
  4032d4:	683a      	ldr	r2, [r7, #0]
  4032d6:	6992      	ldr	r2, [r2, #24]
  4032d8:	6879      	ldr	r1, [r7, #4]
  4032da:	015b      	lsls	r3, r3, #5
  4032dc:	440b      	add	r3, r1
  4032de:	f503 7305 	add.w	r3, r3, #532	; 0x214
  4032e2:	601a      	str	r2, [r3, #0]
	if (p_mailbox->uc_length > 4) {
  4032e4:	683b      	ldr	r3, [r7, #0]
  4032e6:	799b      	ldrb	r3, [r3, #6]
  4032e8:	2b04      	cmp	r3, #4
  4032ea:	d908      	bls.n	4032fe <can_mailbox_write+0x92>
		p_can->CAN_MB[uc_index].CAN_MDH = p_mailbox->ul_datah;
  4032ec:	7bfb      	ldrb	r3, [r7, #15]
  4032ee:	683a      	ldr	r2, [r7, #0]
  4032f0:	69d2      	ldr	r2, [r2, #28]
  4032f2:	6879      	ldr	r1, [r7, #4]
  4032f4:	015b      	lsls	r3, r3, #5
  4032f6:	440b      	add	r3, r1
  4032f8:	f503 7306 	add.w	r3, r3, #536	; 0x218
  4032fc:	601a      	str	r2, [r3, #0]
	}

	/* Write transmit data length into mailbox control register. */
	p_can->CAN_MB[uc_index].CAN_MCR = CAN_MCR_MDLC(p_mailbox->uc_length);
  4032fe:	7bfb      	ldrb	r3, [r7, #15]
  403300:	683a      	ldr	r2, [r7, #0]
  403302:	7992      	ldrb	r2, [r2, #6]
  403304:	0412      	lsls	r2, r2, #16
  403306:	f402 2270 	and.w	r2, r2, #983040	; 0xf0000
  40330a:	6879      	ldr	r1, [r7, #4]
  40330c:	015b      	lsls	r3, r3, #5
  40330e:	440b      	add	r3, r1
  403310:	f503 7307 	add.w	r3, r3, #540	; 0x21c
  403314:	601a      	str	r2, [r3, #0]

	return CAN_MAILBOX_TRANSFER_OK;
  403316:	2300      	movs	r3, #0
}
  403318:	4618      	mov	r0, r3
  40331a:	3710      	adds	r7, #16
  40331c:	46bd      	mov	sp, r7
  40331e:	bd80      	pop	{r7, pc}
  403320:	00403121 	.word	0x00403121

00403324 <can_reset_all_mailbox>:
 * \brief Reset the eight mailboxes.
 *
 * \param p_can Pointer to a CAN peripheral instance.
 */
void can_reset_all_mailbox(Can *p_can)
{
  403324:	b580      	push	{r7, lr}
  403326:	b08c      	sub	sp, #48	; 0x30
  403328:	af00      	add	r7, sp, #0
  40332a:	6078      	str	r0, [r7, #4]
	can_mb_conf_t mb_config_t;

	/* Set the mailbox object type parameter to disable the mailbox. */
	mb_config_t.uc_obj_type = CAN_MB_DISABLE_MODE;
  40332c:	2300      	movs	r3, #0
  40332e:	743b      	strb	r3, [r7, #16]

	for (uint8_t i = 0; i < CANMB_NUMBER; i++) {
  403330:	2300      	movs	r3, #0
  403332:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  403336:	e00d      	b.n	403354 <can_reset_all_mailbox+0x30>
		mb_config_t.ul_mb_idx = i;
  403338:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  40333c:	60fb      	str	r3, [r7, #12]
		can_mailbox_init(p_can, &mb_config_t);
  40333e:	f107 030c 	add.w	r3, r7, #12
  403342:	4619      	mov	r1, r3
  403344:	6878      	ldr	r0, [r7, #4]
  403346:	4b07      	ldr	r3, [pc, #28]	; (403364 <can_reset_all_mailbox+0x40>)
  403348:	4798      	blx	r3
	for (uint8_t i = 0; i < CANMB_NUMBER; i++) {
  40334a:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  40334e:	3301      	adds	r3, #1
  403350:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  403354:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  403358:	2b07      	cmp	r3, #7
  40335a:	d9ed      	bls.n	403338 <can_reset_all_mailbox+0x14>
	}
}
  40335c:	bf00      	nop
  40335e:	3730      	adds	r7, #48	; 0x30
  403360:	46bd      	mov	sp, r7
  403362:	bd80      	pop	{r7, pc}
  403364:	00403147 	.word	0x00403147

00403368 <pio_set_peripheral>:
 * \param ul_type PIO type.
 * \param ul_mask Bitmask of one or more pin(s) to configure.
 */
void pio_set_peripheral(Pio *p_pio, const pio_type_t ul_type,
		const uint32_t ul_mask)
{
  403368:	b480      	push	{r7}
  40336a:	b087      	sub	sp, #28
  40336c:	af00      	add	r7, sp, #0
  40336e:	60f8      	str	r0, [r7, #12]
  403370:	60b9      	str	r1, [r7, #8]
  403372:	607a      	str	r2, [r7, #4]
	uint32_t ul_sr;

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;
  403374:	68fb      	ldr	r3, [r7, #12]
  403376:	687a      	ldr	r2, [r7, #4]
  403378:	645a      	str	r2, [r3, #68]	; 0x44

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  40337a:	68bb      	ldr	r3, [r7, #8]
  40337c:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
  403380:	d04a      	beq.n	403418 <pio_set_peripheral+0xb0>
  403382:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
  403386:	d808      	bhi.n	40339a <pio_set_peripheral+0x32>
  403388:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
  40338c:	d016      	beq.n	4033bc <pio_set_peripheral+0x54>
  40338e:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  403392:	d02c      	beq.n	4033ee <pio_set_peripheral+0x86>
  403394:	2b00      	cmp	r3, #0
  403396:	d069      	beq.n	40346c <pio_set_peripheral+0x104>
  403398:	e064      	b.n	403464 <pio_set_peripheral+0xfc>
  40339a:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  40339e:	d065      	beq.n	40346c <pio_set_peripheral+0x104>
  4033a0:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  4033a4:	d803      	bhi.n	4033ae <pio_set_peripheral+0x46>
  4033a6:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
  4033aa:	d04a      	beq.n	403442 <pio_set_peripheral+0xda>
  4033ac:	e05a      	b.n	403464 <pio_set_peripheral+0xfc>
  4033ae:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
  4033b2:	d05b      	beq.n	40346c <pio_set_peripheral+0x104>
  4033b4:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  4033b8:	d058      	beq.n	40346c <pio_set_peripheral+0x104>
  4033ba:	e053      	b.n	403464 <pio_set_peripheral+0xfc>
	case PIO_PERIPH_A:
		ul_sr = p_pio->PIO_ABCDSR[0];
  4033bc:	68fb      	ldr	r3, [r7, #12]
  4033be:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  4033c0:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  4033c2:	68fb      	ldr	r3, [r7, #12]
  4033c4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  4033c6:	687b      	ldr	r3, [r7, #4]
  4033c8:	43d9      	mvns	r1, r3
  4033ca:	697b      	ldr	r3, [r7, #20]
  4033cc:	400b      	ands	r3, r1
  4033ce:	401a      	ands	r2, r3
  4033d0:	68fb      	ldr	r3, [r7, #12]
  4033d2:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  4033d4:	68fb      	ldr	r3, [r7, #12]
  4033d6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  4033d8:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  4033da:	68fb      	ldr	r3, [r7, #12]
  4033dc:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  4033de:	687b      	ldr	r3, [r7, #4]
  4033e0:	43d9      	mvns	r1, r3
  4033e2:	697b      	ldr	r3, [r7, #20]
  4033e4:	400b      	ands	r3, r1
  4033e6:	401a      	ands	r2, r3
  4033e8:	68fb      	ldr	r3, [r7, #12]
  4033ea:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  4033ec:	e03a      	b.n	403464 <pio_set_peripheral+0xfc>
	case PIO_PERIPH_B:
		ul_sr = p_pio->PIO_ABCDSR[0];
  4033ee:	68fb      	ldr	r3, [r7, #12]
  4033f0:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  4033f2:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  4033f4:	687a      	ldr	r2, [r7, #4]
  4033f6:	697b      	ldr	r3, [r7, #20]
  4033f8:	431a      	orrs	r2, r3
  4033fa:	68fb      	ldr	r3, [r7, #12]
  4033fc:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  4033fe:	68fb      	ldr	r3, [r7, #12]
  403400:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  403402:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  403404:	68fb      	ldr	r3, [r7, #12]
  403406:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  403408:	687b      	ldr	r3, [r7, #4]
  40340a:	43d9      	mvns	r1, r3
  40340c:	697b      	ldr	r3, [r7, #20]
  40340e:	400b      	ands	r3, r1
  403410:	401a      	ands	r2, r3
  403412:	68fb      	ldr	r3, [r7, #12]
  403414:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  403416:	e025      	b.n	403464 <pio_set_peripheral+0xfc>
#if (!SAMG)
	case PIO_PERIPH_C:
		ul_sr = p_pio->PIO_ABCDSR[0];
  403418:	68fb      	ldr	r3, [r7, #12]
  40341a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  40341c:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  40341e:	68fb      	ldr	r3, [r7, #12]
  403420:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  403422:	687b      	ldr	r3, [r7, #4]
  403424:	43d9      	mvns	r1, r3
  403426:	697b      	ldr	r3, [r7, #20]
  403428:	400b      	ands	r3, r1
  40342a:	401a      	ands	r2, r3
  40342c:	68fb      	ldr	r3, [r7, #12]
  40342e:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  403430:	68fb      	ldr	r3, [r7, #12]
  403432:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  403434:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  403436:	687a      	ldr	r2, [r7, #4]
  403438:	697b      	ldr	r3, [r7, #20]
  40343a:	431a      	orrs	r2, r3
  40343c:	68fb      	ldr	r3, [r7, #12]
  40343e:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  403440:	e010      	b.n	403464 <pio_set_peripheral+0xfc>
	case PIO_PERIPH_D:
		ul_sr = p_pio->PIO_ABCDSR[0];
  403442:	68fb      	ldr	r3, [r7, #12]
  403444:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  403446:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  403448:	687a      	ldr	r2, [r7, #4]
  40344a:	697b      	ldr	r3, [r7, #20]
  40344c:	431a      	orrs	r2, r3
  40344e:	68fb      	ldr	r3, [r7, #12]
  403450:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  403452:	68fb      	ldr	r3, [r7, #12]
  403454:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  403456:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  403458:	687a      	ldr	r2, [r7, #4]
  40345a:	697b      	ldr	r3, [r7, #20]
  40345c:	431a      	orrs	r2, r3
  40345e:	68fb      	ldr	r3, [r7, #12]
  403460:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  403462:	bf00      	nop
#else
#error "Unsupported device"
#endif

	/* Remove the pins from under the control of PIO */
	p_pio->PIO_PDR = ul_mask;
  403464:	68fb      	ldr	r3, [r7, #12]
  403466:	687a      	ldr	r2, [r7, #4]
  403468:	605a      	str	r2, [r3, #4]
  40346a:	e000      	b.n	40346e <pio_set_peripheral+0x106>
		return;
  40346c:	bf00      	nop
}
  40346e:	371c      	adds	r7, #28
  403470:	46bd      	mov	sp, r7
  403472:	f85d 7b04 	ldr.w	r7, [sp], #4
  403476:	4770      	bx	lr

00403478 <pio_get_interrupt_status>:
 * \param p_pio Pointer to a PIO instance.
 *
 * \return The interrupt status value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
  403478:	b480      	push	{r7}
  40347a:	b083      	sub	sp, #12
  40347c:	af00      	add	r7, sp, #0
  40347e:	6078      	str	r0, [r7, #4]
	return p_pio->PIO_ISR;
  403480:	687b      	ldr	r3, [r7, #4]
  403482:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
}
  403484:	4618      	mov	r0, r3
  403486:	370c      	adds	r7, #12
  403488:	46bd      	mov	sp, r7
  40348a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40348e:	4770      	bx	lr

00403490 <pio_get_interrupt_mask>:
 * \param p_pio Pointer to a PIO instance.
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
  403490:	b480      	push	{r7}
  403492:	b083      	sub	sp, #12
  403494:	af00      	add	r7, sp, #0
  403496:	6078      	str	r0, [r7, #4]
	return p_pio->PIO_IMR;
  403498:	687b      	ldr	r3, [r7, #4]
  40349a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
}
  40349c:	4618      	mov	r0, r3
  40349e:	370c      	adds	r7, #12
  4034a0:	46bd      	mov	sp, r7
  4034a2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4034a6:	4770      	bx	lr

004034a8 <pmc_switch_mck_to_pllack>:
 *
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
  4034a8:	b480      	push	{r7}
  4034aa:	b085      	sub	sp, #20
  4034ac:	af00      	add	r7, sp, #0
  4034ae:	6078      	str	r0, [r7, #4]
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  4034b0:	491d      	ldr	r1, [pc, #116]	; (403528 <pmc_switch_mck_to_pllack+0x80>)
  4034b2:	4b1d      	ldr	r3, [pc, #116]	; (403528 <pmc_switch_mck_to_pllack+0x80>)
  4034b4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4034b6:	f023 0270 	bic.w	r2, r3, #112	; 0x70
  4034ba:	687b      	ldr	r3, [r7, #4]
  4034bc:	4313      	orrs	r3, r2
  4034be:	630b      	str	r3, [r1, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  4034c0:	f44f 6300 	mov.w	r3, #2048	; 0x800
  4034c4:	60fb      	str	r3, [r7, #12]
  4034c6:	e007      	b.n	4034d8 <pmc_switch_mck_to_pllack+0x30>
			--ul_timeout) {
		if (ul_timeout == 0) {
  4034c8:	68fb      	ldr	r3, [r7, #12]
  4034ca:	2b00      	cmp	r3, #0
  4034cc:	d101      	bne.n	4034d2 <pmc_switch_mck_to_pllack+0x2a>
			return 1;
  4034ce:	2301      	movs	r3, #1
  4034d0:	e023      	b.n	40351a <pmc_switch_mck_to_pllack+0x72>
			--ul_timeout) {
  4034d2:	68fb      	ldr	r3, [r7, #12]
  4034d4:	3b01      	subs	r3, #1
  4034d6:	60fb      	str	r3, [r7, #12]
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  4034d8:	4b13      	ldr	r3, [pc, #76]	; (403528 <pmc_switch_mck_to_pllack+0x80>)
  4034da:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4034dc:	f003 0308 	and.w	r3, r3, #8
  4034e0:	2b00      	cmp	r3, #0
  4034e2:	d0f1      	beq.n	4034c8 <pmc_switch_mck_to_pllack+0x20>
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  4034e4:	4a10      	ldr	r2, [pc, #64]	; (403528 <pmc_switch_mck_to_pllack+0x80>)
  4034e6:	4b10      	ldr	r3, [pc, #64]	; (403528 <pmc_switch_mck_to_pllack+0x80>)
  4034e8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4034ea:	f023 0303 	bic.w	r3, r3, #3
  4034ee:	f043 0302 	orr.w	r3, r3, #2
  4034f2:	6313      	str	r3, [r2, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  4034f4:	f44f 6300 	mov.w	r3, #2048	; 0x800
  4034f8:	60fb      	str	r3, [r7, #12]
  4034fa:	e007      	b.n	40350c <pmc_switch_mck_to_pllack+0x64>
			--ul_timeout) {
		if (ul_timeout == 0) {
  4034fc:	68fb      	ldr	r3, [r7, #12]
  4034fe:	2b00      	cmp	r3, #0
  403500:	d101      	bne.n	403506 <pmc_switch_mck_to_pllack+0x5e>
			return 1;
  403502:	2301      	movs	r3, #1
  403504:	e009      	b.n	40351a <pmc_switch_mck_to_pllack+0x72>
			--ul_timeout) {
  403506:	68fb      	ldr	r3, [r7, #12]
  403508:	3b01      	subs	r3, #1
  40350a:	60fb      	str	r3, [r7, #12]
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40350c:	4b06      	ldr	r3, [pc, #24]	; (403528 <pmc_switch_mck_to_pllack+0x80>)
  40350e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  403510:	f003 0308 	and.w	r3, r3, #8
  403514:	2b00      	cmp	r3, #0
  403516:	d0f1      	beq.n	4034fc <pmc_switch_mck_to_pllack+0x54>
		}
	}

	return 0;
  403518:	2300      	movs	r3, #0
}
  40351a:	4618      	mov	r0, r3
  40351c:	3714      	adds	r7, #20
  40351e:	46bd      	mov	sp, r7
  403520:	f85d 7b04 	ldr.w	r7, [sp], #4
  403524:	4770      	bx	lr
  403526:	bf00      	nop
  403528:	400e0400 	.word	0x400e0400

0040352c <pmc_switch_sclk_to_32kxtal>:
 *       VDDIO power supply.
 *
 * \param ul_bypass 0 for Xtal, 1 for bypass.
 */
void pmc_switch_sclk_to_32kxtal(uint32_t ul_bypass)
{
  40352c:	b480      	push	{r7}
  40352e:	b083      	sub	sp, #12
  403530:	af00      	add	r7, sp, #0
  403532:	6078      	str	r0, [r7, #4]
	/* Set Bypass mode if required */
	if (ul_bypass == 1) {
  403534:	687b      	ldr	r3, [r7, #4]
  403536:	2b01      	cmp	r3, #1
  403538:	d107      	bne.n	40354a <pmc_switch_sclk_to_32kxtal+0x1e>
		SUPC->SUPC_MR |= SUPC_MR_KEY_PASSWD |
  40353a:	4a08      	ldr	r2, [pc, #32]	; (40355c <pmc_switch_sclk_to_32kxtal+0x30>)
  40353c:	4b07      	ldr	r3, [pc, #28]	; (40355c <pmc_switch_sclk_to_32kxtal+0x30>)
  40353e:	689b      	ldr	r3, [r3, #8]
  403540:	f043 4325 	orr.w	r3, r3, #2768240640	; 0xa5000000
  403544:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  403548:	6093      	str	r3, [r2, #8]
			SUPC_MR_OSCBYPASS;
	}

	SUPC->SUPC_CR = SUPC_CR_KEY_PASSWD | SUPC_CR_XTALSEL;
  40354a:	4b04      	ldr	r3, [pc, #16]	; (40355c <pmc_switch_sclk_to_32kxtal+0x30>)
  40354c:	4a04      	ldr	r2, [pc, #16]	; (403560 <pmc_switch_sclk_to_32kxtal+0x34>)
  40354e:	601a      	str	r2, [r3, #0]
}
  403550:	bf00      	nop
  403552:	370c      	adds	r7, #12
  403554:	46bd      	mov	sp, r7
  403556:	f85d 7b04 	ldr.w	r7, [sp], #4
  40355a:	4770      	bx	lr
  40355c:	400e1810 	.word	0x400e1810
  403560:	a5000008 	.word	0xa5000008

00403564 <pmc_osc_is_ready_32kxtal>:
 *
 * \retval 1 External 32k Xtal is ready.
 * \retval 0 External 32k Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_32kxtal(void)
{
  403564:	b480      	push	{r7}
  403566:	af00      	add	r7, sp, #0
	return ((SUPC->SUPC_SR & SUPC_SR_OSCSEL)
  403568:	4b09      	ldr	r3, [pc, #36]	; (403590 <pmc_osc_is_ready_32kxtal+0x2c>)
  40356a:	695b      	ldr	r3, [r3, #20]
  40356c:	f003 0380 	and.w	r3, r3, #128	; 0x80
			&& (PMC->PMC_SR & PMC_SR_OSCSELS));
  403570:	2b00      	cmp	r3, #0
  403572:	d007      	beq.n	403584 <pmc_osc_is_ready_32kxtal+0x20>
  403574:	4b07      	ldr	r3, [pc, #28]	; (403594 <pmc_osc_is_ready_32kxtal+0x30>)
  403576:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  403578:	f003 0380 	and.w	r3, r3, #128	; 0x80
  40357c:	2b00      	cmp	r3, #0
  40357e:	d001      	beq.n	403584 <pmc_osc_is_ready_32kxtal+0x20>
  403580:	2301      	movs	r3, #1
  403582:	e000      	b.n	403586 <pmc_osc_is_ready_32kxtal+0x22>
  403584:	2300      	movs	r3, #0
}
  403586:	4618      	mov	r0, r3
  403588:	46bd      	mov	sp, r7
  40358a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40358e:	4770      	bx	lr
  403590:	400e1810 	.word	0x400e1810
  403594:	400e0400 	.word	0x400e0400

00403598 <pmc_switch_mainck_to_fastrc>:
 * \retval 0 Success.
 * \retval 1 Timeout error.
 * \retval 2 Invalid frequency.
 */
void pmc_switch_mainck_to_fastrc(uint32_t ul_moscrcf)
{
  403598:	b480      	push	{r7}
  40359a:	b083      	sub	sp, #12
  40359c:	af00      	add	r7, sp, #0
  40359e:	6078      	str	r0, [r7, #4]
	/* Enable Fast RC oscillator but DO NOT switch to RC now */
	PMC->CKGR_MOR |= (CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCRCEN);
  4035a0:	4a18      	ldr	r2, [pc, #96]	; (403604 <pmc_switch_mainck_to_fastrc+0x6c>)
  4035a2:	4b18      	ldr	r3, [pc, #96]	; (403604 <pmc_switch_mainck_to_fastrc+0x6c>)
  4035a4:	6a1b      	ldr	r3, [r3, #32]
  4035a6:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  4035aa:	f043 0308 	orr.w	r3, r3, #8
  4035ae:	6213      	str	r3, [r2, #32]

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  4035b0:	bf00      	nop
  4035b2:	4b14      	ldr	r3, [pc, #80]	; (403604 <pmc_switch_mainck_to_fastrc+0x6c>)
  4035b4:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4035b6:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  4035ba:	2b00      	cmp	r3, #0
  4035bc:	d0f9      	beq.n	4035b2 <pmc_switch_mainck_to_fastrc+0x1a>

	/* Change Fast RC oscillator frequency */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  4035be:	4911      	ldr	r1, [pc, #68]	; (403604 <pmc_switch_mainck_to_fastrc+0x6c>)
  4035c0:	4b10      	ldr	r3, [pc, #64]	; (403604 <pmc_switch_mainck_to_fastrc+0x6c>)
  4035c2:	6a1b      	ldr	r3, [r3, #32]
  4035c4:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  4035c8:	f023 0370 	bic.w	r3, r3, #112	; 0x70
			CKGR_MOR_KEY_PASSWD | ul_moscrcf;
  4035cc:	687a      	ldr	r2, [r7, #4]
  4035ce:	4313      	orrs	r3, r2
  4035d0:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  4035d4:	620b      	str	r3, [r1, #32]

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  4035d6:	bf00      	nop
  4035d8:	4b0a      	ldr	r3, [pc, #40]	; (403604 <pmc_switch_mainck_to_fastrc+0x6c>)
  4035da:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4035dc:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  4035e0:	2b00      	cmp	r3, #0
  4035e2:	d0f9      	beq.n	4035d8 <pmc_switch_mainck_to_fastrc+0x40>

	/* Switch to Fast RC */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCSEL) |
  4035e4:	4a07      	ldr	r2, [pc, #28]	; (403604 <pmc_switch_mainck_to_fastrc+0x6c>)
  4035e6:	4b07      	ldr	r3, [pc, #28]	; (403604 <pmc_switch_mainck_to_fastrc+0x6c>)
  4035e8:	6a1b      	ldr	r3, [r3, #32]
  4035ea:	f023 739b 	bic.w	r3, r3, #20316160	; 0x1360000
  4035ee:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  4035f2:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  4035f6:	6213      	str	r3, [r2, #32]
			CKGR_MOR_KEY_PASSWD;
}
  4035f8:	bf00      	nop
  4035fa:	370c      	adds	r7, #12
  4035fc:	46bd      	mov	sp, r7
  4035fe:	f85d 7b04 	ldr.w	r7, [sp], #4
  403602:	4770      	bx	lr
  403604:	400e0400 	.word	0x400e0400

00403608 <pmc_switch_mainck_to_xtal>:
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
  403608:	b480      	push	{r7}
  40360a:	b083      	sub	sp, #12
  40360c:	af00      	add	r7, sp, #0
  40360e:	6078      	str	r0, [r7, #4]
  403610:	6039      	str	r1, [r7, #0]
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
  403612:	687b      	ldr	r3, [r7, #4]
  403614:	2b00      	cmp	r3, #0
  403616:	d008      	beq.n	40362a <pmc_switch_mainck_to_xtal+0x22>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  403618:	4916      	ldr	r1, [pc, #88]	; (403674 <pmc_switch_mainck_to_xtal+0x6c>)
  40361a:	4b16      	ldr	r3, [pc, #88]	; (403674 <pmc_switch_mainck_to_xtal+0x6c>)
  40361c:	6a1b      	ldr	r3, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
  40361e:	4a16      	ldr	r2, [pc, #88]	; (403678 <pmc_switch_mainck_to_xtal+0x70>)
  403620:	401a      	ands	r2, r3
  403622:	4b16      	ldr	r3, [pc, #88]	; (40367c <pmc_switch_mainck_to_xtal+0x74>)
  403624:	4313      	orrs	r3, r2
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  403626:	620b      	str	r3, [r1, #32]
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));

		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
	}
}
  403628:	e01e      	b.n	403668 <pmc_switch_mainck_to_xtal+0x60>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  40362a:	4912      	ldr	r1, [pc, #72]	; (403674 <pmc_switch_mainck_to_xtal+0x6c>)
  40362c:	4b11      	ldr	r3, [pc, #68]	; (403674 <pmc_switch_mainck_to_xtal+0x6c>)
  40362e:	6a1b      	ldr	r3, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  403630:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  403634:	f023 0303 	bic.w	r3, r3, #3
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
  403638:	683a      	ldr	r2, [r7, #0]
  40363a:	0212      	lsls	r2, r2, #8
  40363c:	b292      	uxth	r2, r2
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  40363e:	4313      	orrs	r3, r2
  403640:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  403644:	f043 0301 	orr.w	r3, r3, #1
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  403648:	620b      	str	r3, [r1, #32]
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
  40364a:	bf00      	nop
  40364c:	4b09      	ldr	r3, [pc, #36]	; (403674 <pmc_switch_mainck_to_xtal+0x6c>)
  40364e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  403650:	f003 0301 	and.w	r3, r3, #1
  403654:	2b00      	cmp	r3, #0
  403656:	d0f9      	beq.n	40364c <pmc_switch_mainck_to_xtal+0x44>
		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
  403658:	4a06      	ldr	r2, [pc, #24]	; (403674 <pmc_switch_mainck_to_xtal+0x6c>)
  40365a:	4b06      	ldr	r3, [pc, #24]	; (403674 <pmc_switch_mainck_to_xtal+0x6c>)
  40365c:	6a1b      	ldr	r3, [r3, #32]
  40365e:	f043 739b 	orr.w	r3, r3, #20316160	; 0x1360000
  403662:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  403666:	6213      	str	r3, [r2, #32]
}
  403668:	bf00      	nop
  40366a:	370c      	adds	r7, #12
  40366c:	46bd      	mov	sp, r7
  40366e:	f85d 7b04 	ldr.w	r7, [sp], #4
  403672:	4770      	bx	lr
  403674:	400e0400 	.word	0x400e0400
  403678:	fec8fffc 	.word	0xfec8fffc
  40367c:	01370002 	.word	0x01370002

00403680 <pmc_osc_is_ready_mainck>:
 *
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
  403680:	b480      	push	{r7}
  403682:	af00      	add	r7, sp, #0
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
  403684:	4b04      	ldr	r3, [pc, #16]	; (403698 <pmc_osc_is_ready_mainck+0x18>)
  403686:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  403688:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
}
  40368c:	4618      	mov	r0, r3
  40368e:	46bd      	mov	sp, r7
  403690:	f85d 7b04 	ldr.w	r7, [sp], #4
  403694:	4770      	bx	lr
  403696:	bf00      	nop
  403698:	400e0400 	.word	0x400e0400

0040369c <pmc_disable_pllack>:

/**
 * \brief Disable PLLA clock.
 */
void pmc_disable_pllack(void)
{
  40369c:	b480      	push	{r7}
  40369e:	af00      	add	r7, sp, #0
#if (SAM4C || SAM4CM || SAM4CP || SAMG)
	PMC->CKGR_PLLAR = CKGR_PLLAR_MULA(0);
#else
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
  4036a0:	4b04      	ldr	r3, [pc, #16]	; (4036b4 <pmc_disable_pllack+0x18>)
  4036a2:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  4036a6:	629a      	str	r2, [r3, #40]	; 0x28
#endif
}
  4036a8:	bf00      	nop
  4036aa:	46bd      	mov	sp, r7
  4036ac:	f85d 7b04 	ldr.w	r7, [sp], #4
  4036b0:	4770      	bx	lr
  4036b2:	bf00      	nop
  4036b4:	400e0400 	.word	0x400e0400

004036b8 <pmc_is_locked_pllack>:
 *
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
  4036b8:	b480      	push	{r7}
  4036ba:	af00      	add	r7, sp, #0
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  4036bc:	4b04      	ldr	r3, [pc, #16]	; (4036d0 <pmc_is_locked_pllack+0x18>)
  4036be:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4036c0:	f003 0302 	and.w	r3, r3, #2
}
  4036c4:	4618      	mov	r0, r3
  4036c6:	46bd      	mov	sp, r7
  4036c8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4036cc:	4770      	bx	lr
  4036ce:	bf00      	nop
  4036d0:	400e0400 	.word	0x400e0400

004036d4 <pmc_enable_periph_clk>:
 *
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
  4036d4:	b480      	push	{r7}
  4036d6:	b083      	sub	sp, #12
  4036d8:	af00      	add	r7, sp, #0
  4036da:	6078      	str	r0, [r7, #4]
	PMC->PMC_PCR = ul_id & 0x7F;
	pcr = PMC->PMC_PCR | PMC_PCR_EN | PMC_PCR_CMD;
	PMC->PMC_PCR = pcr;
	return 0;
#else
	if (ul_id > MAX_PERIPH_ID) {
  4036dc:	687b      	ldr	r3, [r7, #4]
  4036de:	2b2f      	cmp	r3, #47	; 0x2f
  4036e0:	d901      	bls.n	4036e6 <pmc_enable_periph_clk+0x12>
		return 1;
  4036e2:	2301      	movs	r3, #1
  4036e4:	e02f      	b.n	403746 <pmc_enable_periph_clk+0x72>
	}

	if (ul_id < 32) {
  4036e6:	687b      	ldr	r3, [r7, #4]
  4036e8:	2b1f      	cmp	r3, #31
  4036ea:	d813      	bhi.n	403714 <pmc_enable_periph_clk+0x40>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  4036ec:	4b19      	ldr	r3, [pc, #100]	; (403754 <pmc_enable_periph_clk+0x80>)
  4036ee:	699a      	ldr	r2, [r3, #24]
  4036f0:	2101      	movs	r1, #1
  4036f2:	687b      	ldr	r3, [r7, #4]
  4036f4:	fa01 f303 	lsl.w	r3, r1, r3
  4036f8:	401a      	ands	r2, r3
  4036fa:	2101      	movs	r1, #1
  4036fc:	687b      	ldr	r3, [r7, #4]
  4036fe:	fa01 f303 	lsl.w	r3, r1, r3
  403702:	429a      	cmp	r2, r3
  403704:	d01e      	beq.n	403744 <pmc_enable_periph_clk+0x70>
			PMC->PMC_PCER0 = 1 << ul_id;
  403706:	4a13      	ldr	r2, [pc, #76]	; (403754 <pmc_enable_periph_clk+0x80>)
  403708:	2101      	movs	r1, #1
  40370a:	687b      	ldr	r3, [r7, #4]
  40370c:	fa01 f303 	lsl.w	r3, r1, r3
  403710:	6113      	str	r3, [r2, #16]
  403712:	e017      	b.n	403744 <pmc_enable_periph_clk+0x70>
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CM || SAM4CP || SAMG55 || SAMV71 || SAMV70 || SAME70 || SAMS70)
	} else {
		ul_id -= 32;
  403714:	687b      	ldr	r3, [r7, #4]
  403716:	3b20      	subs	r3, #32
  403718:	607b      	str	r3, [r7, #4]
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  40371a:	4b0e      	ldr	r3, [pc, #56]	; (403754 <pmc_enable_periph_clk+0x80>)
  40371c:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
  403720:	2101      	movs	r1, #1
  403722:	687b      	ldr	r3, [r7, #4]
  403724:	fa01 f303 	lsl.w	r3, r1, r3
  403728:	401a      	ands	r2, r3
  40372a:	2101      	movs	r1, #1
  40372c:	687b      	ldr	r3, [r7, #4]
  40372e:	fa01 f303 	lsl.w	r3, r1, r3
  403732:	429a      	cmp	r2, r3
  403734:	d006      	beq.n	403744 <pmc_enable_periph_clk+0x70>
			PMC->PMC_PCER1 = 1 << ul_id;
  403736:	4a07      	ldr	r2, [pc, #28]	; (403754 <pmc_enable_periph_clk+0x80>)
  403738:	2101      	movs	r1, #1
  40373a:	687b      	ldr	r3, [r7, #4]
  40373c:	fa01 f303 	lsl.w	r3, r1, r3
  403740:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
		}
#endif
	}

	return 0;
  403744:	2300      	movs	r3, #0
#endif /* defined(REG_PMC_PCR) && !SAMG55 */
}
  403746:	4618      	mov	r0, r3
  403748:	370c      	adds	r7, #12
  40374a:	46bd      	mov	sp, r7
  40374c:	f85d 7b04 	ldr.w	r7, [sp], #4
  403750:	4770      	bx	lr
  403752:	bf00      	nop
  403754:	400e0400 	.word	0x400e0400

00403758 <twi_enable_master_mode>:
 * \brief Enable TWI master mode.
 *
 * \param p_twi Pointer to a TWI instance.
 */
void twi_enable_master_mode(Twi *p_twi)
{
  403758:	b480      	push	{r7}
  40375a:	b083      	sub	sp, #12
  40375c:	af00      	add	r7, sp, #0
  40375e:	6078      	str	r0, [r7, #4]
	/* Set Master Disable bit and Slave Disable bit */
	p_twi->TWI_CR = TWI_CR_MSDIS;
  403760:	687b      	ldr	r3, [r7, #4]
  403762:	2208      	movs	r2, #8
  403764:	601a      	str	r2, [r3, #0]
	p_twi->TWI_CR = TWI_CR_SVDIS;
  403766:	687b      	ldr	r3, [r7, #4]
  403768:	2220      	movs	r2, #32
  40376a:	601a      	str	r2, [r3, #0]

	/* Set Master Enable bit */
	p_twi->TWI_CR = TWI_CR_MSEN;
  40376c:	687b      	ldr	r3, [r7, #4]
  40376e:	2204      	movs	r2, #4
  403770:	601a      	str	r2, [r3, #0]
}
  403772:	bf00      	nop
  403774:	370c      	adds	r7, #12
  403776:	46bd      	mov	sp, r7
  403778:	f85d 7b04 	ldr.w	r7, [sp], #4
  40377c:	4770      	bx	lr
	...

00403780 <twi_master_init>:
 * \param p_opt Options for initializing the TWI module (see \ref twi_options_t).
 *
 * \return TWI_SUCCESS if initialization is complete, error code otherwise.
 */
uint32_t twi_master_init(Twi *p_twi, const twi_options_t *p_opt)
{
  403780:	b580      	push	{r7, lr}
  403782:	b084      	sub	sp, #16
  403784:	af00      	add	r7, sp, #0
  403786:	6078      	str	r0, [r7, #4]
  403788:	6039      	str	r1, [r7, #0]
	uint32_t status = TWI_SUCCESS;
  40378a:	2300      	movs	r3, #0
  40378c:	60fb      	str	r3, [r7, #12]

	/* Disable TWI interrupts */
	p_twi->TWI_IDR = ~0UL;
  40378e:	687b      	ldr	r3, [r7, #4]
  403790:	f04f 32ff 	mov.w	r2, #4294967295
  403794:	629a      	str	r2, [r3, #40]	; 0x28

	/* Dummy read in status register */
	p_twi->TWI_SR;
  403796:	687b      	ldr	r3, [r7, #4]
  403798:	6a1b      	ldr	r3, [r3, #32]

	/* Reset TWI peripheral */
	twi_reset(p_twi);
  40379a:	6878      	ldr	r0, [r7, #4]
  40379c:	4b0e      	ldr	r3, [pc, #56]	; (4037d8 <twi_master_init+0x58>)
  40379e:	4798      	blx	r3

	twi_enable_master_mode(p_twi);
  4037a0:	6878      	ldr	r0, [r7, #4]
  4037a2:	4b0e      	ldr	r3, [pc, #56]	; (4037dc <twi_master_init+0x5c>)
  4037a4:	4798      	blx	r3

	/* Select the speed */
	if (twi_set_speed(p_twi, p_opt->speed, p_opt->master_clk) == FAIL) {
  4037a6:	683b      	ldr	r3, [r7, #0]
  4037a8:	6859      	ldr	r1, [r3, #4]
  4037aa:	683b      	ldr	r3, [r7, #0]
  4037ac:	681b      	ldr	r3, [r3, #0]
  4037ae:	461a      	mov	r2, r3
  4037b0:	6878      	ldr	r0, [r7, #4]
  4037b2:	4b0b      	ldr	r3, [pc, #44]	; (4037e0 <twi_master_init+0x60>)
  4037b4:	4798      	blx	r3
  4037b6:	4603      	mov	r3, r0
  4037b8:	2b01      	cmp	r3, #1
  4037ba:	d101      	bne.n	4037c0 <twi_master_init+0x40>
		/* The desired speed setting is rejected */
		status = TWI_INVALID_ARGUMENT;
  4037bc:	2301      	movs	r3, #1
  4037be:	60fb      	str	r3, [r7, #12]
	}

	if (p_opt->smbus == 1) {
  4037c0:	683b      	ldr	r3, [r7, #0]
  4037c2:	7a5b      	ldrb	r3, [r3, #9]
  4037c4:	2b01      	cmp	r3, #1
  4037c6:	d102      	bne.n	4037ce <twi_master_init+0x4e>
		p_twi->TWI_CR = TWI_CR_QUICK;
  4037c8:	687b      	ldr	r3, [r7, #4]
  4037ca:	2240      	movs	r2, #64	; 0x40
  4037cc:	601a      	str	r2, [r3, #0]
	}

	return status;
  4037ce:	68fb      	ldr	r3, [r7, #12]
}
  4037d0:	4618      	mov	r0, r3
  4037d2:	3710      	adds	r7, #16
  4037d4:	46bd      	mov	sp, r7
  4037d6:	bd80      	pop	{r7, pc}
  4037d8:	00403a11 	.word	0x00403a11
  4037dc:	00403759 	.word	0x00403759
  4037e0:	004037e5 	.word	0x004037e5

004037e4 <twi_set_speed>:
 *
 * \retval PASS New speed setting is accepted.
 * \retval FAIL New speed setting is rejected.
 */
uint32_t twi_set_speed(Twi *p_twi, uint32_t ul_speed, uint32_t ul_mck)
{
  4037e4:	b480      	push	{r7}
  4037e6:	b089      	sub	sp, #36	; 0x24
  4037e8:	af00      	add	r7, sp, #0
  4037ea:	60f8      	str	r0, [r7, #12]
  4037ec:	60b9      	str	r1, [r7, #8]
  4037ee:	607a      	str	r2, [r7, #4]
	uint32_t ckdiv = 0;
  4037f0:	2300      	movs	r3, #0
  4037f2:	61fb      	str	r3, [r7, #28]
	uint32_t c_lh_div;
	uint32_t cldiv, chdiv;

	if (ul_speed > I2C_FAST_MODE_SPEED) {
  4037f4:	68bb      	ldr	r3, [r7, #8]
  4037f6:	4a34      	ldr	r2, [pc, #208]	; (4038c8 <twi_set_speed+0xe4>)
  4037f8:	4293      	cmp	r3, r2
  4037fa:	d901      	bls.n	403800 <twi_set_speed+0x1c>
		return FAIL;
  4037fc:	2301      	movs	r3, #1
  4037fe:	e05d      	b.n	4038bc <twi_set_speed+0xd8>
	}

	/* Low level time not less than 1.3us of I2C Fast Mode. */
	if (ul_speed > LOW_LEVEL_TIME_LIMIT) {
  403800:	68bb      	ldr	r3, [r7, #8]
  403802:	4a32      	ldr	r2, [pc, #200]	; (4038cc <twi_set_speed+0xe8>)
  403804:	4293      	cmp	r3, r2
  403806:	d937      	bls.n	403878 <twi_set_speed+0x94>
		/* Low level of time fixed for 1.3us. */
		cldiv = ul_mck / (LOW_LEVEL_TIME_LIMIT * TWI_CLK_DIVIDER) - TWI_CLK_CALC_ARGU;
  403808:	687b      	ldr	r3, [r7, #4]
  40380a:	4a31      	ldr	r2, [pc, #196]	; (4038d0 <twi_set_speed+0xec>)
  40380c:	fba2 2303 	umull	r2, r3, r2, r3
  403810:	0b9b      	lsrs	r3, r3, #14
  403812:	3b04      	subs	r3, #4
  403814:	617b      	str	r3, [r7, #20]
		chdiv = ul_mck / ((ul_speed + (ul_speed - LOW_LEVEL_TIME_LIMIT)) * TWI_CLK_DIVIDER) - TWI_CLK_CALC_ARGU;
  403816:	68ba      	ldr	r2, [r7, #8]
  403818:	4b2e      	ldr	r3, [pc, #184]	; (4038d4 <twi_set_speed+0xf0>)
  40381a:	4413      	add	r3, r2
  40381c:	009b      	lsls	r3, r3, #2
  40381e:	687a      	ldr	r2, [r7, #4]
  403820:	fbb2 f3f3 	udiv	r3, r2, r3
  403824:	3b04      	subs	r3, #4
  403826:	613b      	str	r3, [r7, #16]
		
		/* cldiv must fit in 8 bits, ckdiv must fit in 3 bits */
		while ((cldiv > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  403828:	e005      	b.n	403836 <twi_set_speed+0x52>
			/* Increase clock divider */
			ckdiv++;
  40382a:	69fb      	ldr	r3, [r7, #28]
  40382c:	3301      	adds	r3, #1
  40382e:	61fb      	str	r3, [r7, #28]
			/* Divide cldiv value */
			cldiv /= TWI_CLK_DIVIDER;
  403830:	697b      	ldr	r3, [r7, #20]
  403832:	085b      	lsrs	r3, r3, #1
  403834:	617b      	str	r3, [r7, #20]
		while ((cldiv > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  403836:	697b      	ldr	r3, [r7, #20]
  403838:	2bff      	cmp	r3, #255	; 0xff
  40383a:	d909      	bls.n	403850 <twi_set_speed+0x6c>
  40383c:	69fb      	ldr	r3, [r7, #28]
  40383e:	2b06      	cmp	r3, #6
  403840:	d9f3      	bls.n	40382a <twi_set_speed+0x46>
		}
		/* chdiv must fit in 8 bits, ckdiv must fit in 3 bits */
		while ((chdiv > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  403842:	e005      	b.n	403850 <twi_set_speed+0x6c>
			/* Increase clock divider */
			ckdiv++;
  403844:	69fb      	ldr	r3, [r7, #28]
  403846:	3301      	adds	r3, #1
  403848:	61fb      	str	r3, [r7, #28]
			/* Divide cldiv value */
			chdiv /= TWI_CLK_DIVIDER;
  40384a:	693b      	ldr	r3, [r7, #16]
  40384c:	085b      	lsrs	r3, r3, #1
  40384e:	613b      	str	r3, [r7, #16]
		while ((chdiv > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  403850:	693b      	ldr	r3, [r7, #16]
  403852:	2bff      	cmp	r3, #255	; 0xff
  403854:	d902      	bls.n	40385c <twi_set_speed+0x78>
  403856:	69fb      	ldr	r3, [r7, #28]
  403858:	2b06      	cmp	r3, #6
  40385a:	d9f3      	bls.n	403844 <twi_set_speed+0x60>
		}

		/* set clock waveform generator register */
		p_twi->TWI_CWGR =
				TWI_CWGR_CLDIV(cldiv) | TWI_CWGR_CHDIV(chdiv) |
  40385c:	697b      	ldr	r3, [r7, #20]
  40385e:	b2da      	uxtb	r2, r3
  403860:	693b      	ldr	r3, [r7, #16]
  403862:	021b      	lsls	r3, r3, #8
  403864:	b29b      	uxth	r3, r3
  403866:	431a      	orrs	r2, r3
				TWI_CWGR_CKDIV(ckdiv);		
  403868:	69fb      	ldr	r3, [r7, #28]
  40386a:	041b      	lsls	r3, r3, #16
  40386c:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
				TWI_CWGR_CLDIV(cldiv) | TWI_CWGR_CHDIV(chdiv) |
  403870:	431a      	orrs	r2, r3
		p_twi->TWI_CWGR =
  403872:	68fb      	ldr	r3, [r7, #12]
  403874:	611a      	str	r2, [r3, #16]
  403876:	e020      	b.n	4038ba <twi_set_speed+0xd6>
	} else {
		c_lh_div = ul_mck / (ul_speed * TWI_CLK_DIVIDER) - TWI_CLK_CALC_ARGU;
  403878:	68bb      	ldr	r3, [r7, #8]
  40387a:	005b      	lsls	r3, r3, #1
  40387c:	687a      	ldr	r2, [r7, #4]
  40387e:	fbb2 f3f3 	udiv	r3, r2, r3
  403882:	3b04      	subs	r3, #4
  403884:	61bb      	str	r3, [r7, #24]

		/* cldiv must fit in 8 bits, ckdiv must fit in 3 bits */
		while ((c_lh_div > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  403886:	e005      	b.n	403894 <twi_set_speed+0xb0>
			/* Increase clock divider */
			ckdiv++;
  403888:	69fb      	ldr	r3, [r7, #28]
  40388a:	3301      	adds	r3, #1
  40388c:	61fb      	str	r3, [r7, #28]
			/* Divide cldiv value */
			c_lh_div /= TWI_CLK_DIVIDER;
  40388e:	69bb      	ldr	r3, [r7, #24]
  403890:	085b      	lsrs	r3, r3, #1
  403892:	61bb      	str	r3, [r7, #24]
		while ((c_lh_div > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  403894:	69bb      	ldr	r3, [r7, #24]
  403896:	2bff      	cmp	r3, #255	; 0xff
  403898:	d902      	bls.n	4038a0 <twi_set_speed+0xbc>
  40389a:	69fb      	ldr	r3, [r7, #28]
  40389c:	2b06      	cmp	r3, #6
  40389e:	d9f3      	bls.n	403888 <twi_set_speed+0xa4>
		}

		/* set clock waveform generator register */
		p_twi->TWI_CWGR =
				TWI_CWGR_CLDIV(c_lh_div) | TWI_CWGR_CHDIV(c_lh_div) |
  4038a0:	69bb      	ldr	r3, [r7, #24]
  4038a2:	b2da      	uxtb	r2, r3
  4038a4:	69bb      	ldr	r3, [r7, #24]
  4038a6:	021b      	lsls	r3, r3, #8
  4038a8:	b29b      	uxth	r3, r3
  4038aa:	431a      	orrs	r2, r3
				TWI_CWGR_CKDIV(ckdiv);
  4038ac:	69fb      	ldr	r3, [r7, #28]
  4038ae:	041b      	lsls	r3, r3, #16
  4038b0:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
				TWI_CWGR_CLDIV(c_lh_div) | TWI_CWGR_CHDIV(c_lh_div) |
  4038b4:	431a      	orrs	r2, r3
		p_twi->TWI_CWGR =
  4038b6:	68fb      	ldr	r3, [r7, #12]
  4038b8:	611a      	str	r2, [r3, #16]
	}

	return PASS;
  4038ba:	2300      	movs	r3, #0
}
  4038bc:	4618      	mov	r0, r3
  4038be:	3724      	adds	r7, #36	; 0x24
  4038c0:	46bd      	mov	sp, r7
  4038c2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4038c6:	4770      	bx	lr
  4038c8:	00061a80 	.word	0x00061a80
  4038cc:	0005dc00 	.word	0x0005dc00
  4038d0:	057619f1 	.word	0x057619f1
  4038d4:	3ffd1200 	.word	0x3ffd1200

004038d8 <twi_mk_addr>:
 * which byte is the MSB to start with.
 *
 * Please see the device datasheet for details on this.
 */
uint32_t twi_mk_addr(const uint8_t *addr, int len)
{
  4038d8:	b480      	push	{r7}
  4038da:	b085      	sub	sp, #20
  4038dc:	af00      	add	r7, sp, #0
  4038de:	6078      	str	r0, [r7, #4]
  4038e0:	6039      	str	r1, [r7, #0]
	uint32_t val;

	if (len == 0)
  4038e2:	683b      	ldr	r3, [r7, #0]
  4038e4:	2b00      	cmp	r3, #0
  4038e6:	d101      	bne.n	4038ec <twi_mk_addr+0x14>
		return 0;
  4038e8:	2300      	movs	r3, #0
  4038ea:	e01d      	b.n	403928 <twi_mk_addr+0x50>

	val = addr[0];
  4038ec:	687b      	ldr	r3, [r7, #4]
  4038ee:	781b      	ldrb	r3, [r3, #0]
  4038f0:	60fb      	str	r3, [r7, #12]
	if (len > 1) {
  4038f2:	683b      	ldr	r3, [r7, #0]
  4038f4:	2b01      	cmp	r3, #1
  4038f6:	dd09      	ble.n	40390c <twi_mk_addr+0x34>
		val <<= 8;
  4038f8:	68fb      	ldr	r3, [r7, #12]
  4038fa:	021b      	lsls	r3, r3, #8
  4038fc:	60fb      	str	r3, [r7, #12]
		val |= addr[1];
  4038fe:	687b      	ldr	r3, [r7, #4]
  403900:	3301      	adds	r3, #1
  403902:	781b      	ldrb	r3, [r3, #0]
  403904:	461a      	mov	r2, r3
  403906:	68fb      	ldr	r3, [r7, #12]
  403908:	4313      	orrs	r3, r2
  40390a:	60fb      	str	r3, [r7, #12]
	}
	if (len > 2) {
  40390c:	683b      	ldr	r3, [r7, #0]
  40390e:	2b02      	cmp	r3, #2
  403910:	dd09      	ble.n	403926 <twi_mk_addr+0x4e>
		val <<= 8;
  403912:	68fb      	ldr	r3, [r7, #12]
  403914:	021b      	lsls	r3, r3, #8
  403916:	60fb      	str	r3, [r7, #12]
		val |= addr[2];
  403918:	687b      	ldr	r3, [r7, #4]
  40391a:	3302      	adds	r3, #2
  40391c:	781b      	ldrb	r3, [r3, #0]
  40391e:	461a      	mov	r2, r3
  403920:	68fb      	ldr	r3, [r7, #12]
  403922:	4313      	orrs	r3, r2
  403924:	60fb      	str	r3, [r7, #12]
	}
	return val;
  403926:	68fb      	ldr	r3, [r7, #12]
}
  403928:	4618      	mov	r0, r3
  40392a:	3714      	adds	r7, #20
  40392c:	46bd      	mov	sp, r7
  40392e:	f85d 7b04 	ldr.w	r7, [sp], #4
  403932:	4770      	bx	lr

00403934 <twi_master_write>:
 * \param p_packet Packet information and data (see \ref twi_packet_t).
 *
 * \return TWI_SUCCESS if all bytes were written, error code otherwise.
 */
uint32_t twi_master_write(Twi *p_twi, twi_packet_t *p_packet)
{
  403934:	b580      	push	{r7, lr}
  403936:	b086      	sub	sp, #24
  403938:	af00      	add	r7, sp, #0
  40393a:	6078      	str	r0, [r7, #4]
  40393c:	6039      	str	r1, [r7, #0]
	uint32_t status;
	uint32_t cnt = p_packet->length;
  40393e:	683b      	ldr	r3, [r7, #0]
  403940:	68db      	ldr	r3, [r3, #12]
  403942:	617b      	str	r3, [r7, #20]
	uint8_t *buffer = p_packet->buffer;
  403944:	683b      	ldr	r3, [r7, #0]
  403946:	689b      	ldr	r3, [r3, #8]
  403948:	613b      	str	r3, [r7, #16]

	/* Check argument */
	if (cnt == 0) {
  40394a:	697b      	ldr	r3, [r7, #20]
  40394c:	2b00      	cmp	r3, #0
  40394e:	d101      	bne.n	403954 <twi_master_write+0x20>
		return TWI_INVALID_ARGUMENT;
  403950:	2301      	movs	r3, #1
  403952:	e056      	b.n	403a02 <twi_master_write+0xce>
	}

	/* Set write mode, slave address and 3 internal address byte lengths */
	p_twi->TWI_MMR = 0;
  403954:	687b      	ldr	r3, [r7, #4]
  403956:	2200      	movs	r2, #0
  403958:	605a      	str	r2, [r3, #4]
	p_twi->TWI_MMR = TWI_MMR_DADR(p_packet->chip) |
  40395a:	683b      	ldr	r3, [r7, #0]
  40395c:	7c1b      	ldrb	r3, [r3, #16]
  40395e:	041b      	lsls	r3, r3, #16
  403960:	f403 02fe 	and.w	r2, r3, #8323072	; 0x7f0000
			((p_packet->addr_length << TWI_MMR_IADRSZ_Pos) &
  403964:	683b      	ldr	r3, [r7, #0]
  403966:	685b      	ldr	r3, [r3, #4]
  403968:	021b      	lsls	r3, r3, #8
  40396a:	f403 7340 	and.w	r3, r3, #768	; 0x300
	p_twi->TWI_MMR = TWI_MMR_DADR(p_packet->chip) |
  40396e:	431a      	orrs	r2, r3
  403970:	687b      	ldr	r3, [r7, #4]
  403972:	605a      	str	r2, [r3, #4]
			TWI_MMR_IADRSZ_Msk);

	/* Set internal address for remote chip */
	p_twi->TWI_IADR = 0;
  403974:	687b      	ldr	r3, [r7, #4]
  403976:	2200      	movs	r2, #0
  403978:	60da      	str	r2, [r3, #12]
	p_twi->TWI_IADR = twi_mk_addr(p_packet->addr, p_packet->addr_length);
  40397a:	683a      	ldr	r2, [r7, #0]
  40397c:	683b      	ldr	r3, [r7, #0]
  40397e:	685b      	ldr	r3, [r3, #4]
  403980:	4619      	mov	r1, r3
  403982:	4610      	mov	r0, r2
  403984:	4b21      	ldr	r3, [pc, #132]	; (403a0c <twi_master_write+0xd8>)
  403986:	4798      	blx	r3
  403988:	4602      	mov	r2, r0
  40398a:	687b      	ldr	r3, [r7, #4]
  40398c:	60da      	str	r2, [r3, #12]

	/* Send all bytes */
	while (cnt > 0) {
  40398e:	e019      	b.n	4039c4 <twi_master_write+0x90>
		status = p_twi->TWI_SR;
  403990:	687b      	ldr	r3, [r7, #4]
  403992:	6a1b      	ldr	r3, [r3, #32]
  403994:	60fb      	str	r3, [r7, #12]
		if (status & TWI_SR_NACK) {
  403996:	68fb      	ldr	r3, [r7, #12]
  403998:	f403 7380 	and.w	r3, r3, #256	; 0x100
  40399c:	2b00      	cmp	r3, #0
  40399e:	d001      	beq.n	4039a4 <twi_master_write+0x70>
			return TWI_RECEIVE_NACK;
  4039a0:	2305      	movs	r3, #5
  4039a2:	e02e      	b.n	403a02 <twi_master_write+0xce>
		}

		if (!(status & TWI_SR_TXRDY)) {
  4039a4:	68fb      	ldr	r3, [r7, #12]
  4039a6:	f003 0304 	and.w	r3, r3, #4
  4039aa:	2b00      	cmp	r3, #0
  4039ac:	d100      	bne.n	4039b0 <twi_master_write+0x7c>
			continue;
  4039ae:	e009      	b.n	4039c4 <twi_master_write+0x90>
		}
		p_twi->TWI_THR = *buffer++;
  4039b0:	693b      	ldr	r3, [r7, #16]
  4039b2:	1c5a      	adds	r2, r3, #1
  4039b4:	613a      	str	r2, [r7, #16]
  4039b6:	781b      	ldrb	r3, [r3, #0]
  4039b8:	461a      	mov	r2, r3
  4039ba:	687b      	ldr	r3, [r7, #4]
  4039bc:	635a      	str	r2, [r3, #52]	; 0x34

		cnt--;
  4039be:	697b      	ldr	r3, [r7, #20]
  4039c0:	3b01      	subs	r3, #1
  4039c2:	617b      	str	r3, [r7, #20]
	while (cnt > 0) {
  4039c4:	697b      	ldr	r3, [r7, #20]
  4039c6:	2b00      	cmp	r3, #0
  4039c8:	d1e2      	bne.n	403990 <twi_master_write+0x5c>
	}

	while (1) {
		status = p_twi->TWI_SR;
  4039ca:	687b      	ldr	r3, [r7, #4]
  4039cc:	6a1b      	ldr	r3, [r3, #32]
  4039ce:	60fb      	str	r3, [r7, #12]
		if (status & TWI_SR_NACK) {
  4039d0:	68fb      	ldr	r3, [r7, #12]
  4039d2:	f403 7380 	and.w	r3, r3, #256	; 0x100
  4039d6:	2b00      	cmp	r3, #0
  4039d8:	d001      	beq.n	4039de <twi_master_write+0xaa>
			return TWI_RECEIVE_NACK;
  4039da:	2305      	movs	r3, #5
  4039dc:	e011      	b.n	403a02 <twi_master_write+0xce>
		}

		if (status & TWI_SR_TXRDY) {
  4039de:	68fb      	ldr	r3, [r7, #12]
  4039e0:	f003 0304 	and.w	r3, r3, #4
  4039e4:	2b00      	cmp	r3, #0
  4039e6:	d100      	bne.n	4039ea <twi_master_write+0xb6>
		status = p_twi->TWI_SR;
  4039e8:	e7ef      	b.n	4039ca <twi_master_write+0x96>
			break;
  4039ea:	bf00      	nop
		}
	}

	p_twi->TWI_CR = TWI_CR_STOP;
  4039ec:	687b      	ldr	r3, [r7, #4]
  4039ee:	2202      	movs	r2, #2
  4039f0:	601a      	str	r2, [r3, #0]

	while (!(p_twi->TWI_SR & TWI_SR_TXCOMP)) {
  4039f2:	bf00      	nop
  4039f4:	687b      	ldr	r3, [r7, #4]
  4039f6:	6a1b      	ldr	r3, [r3, #32]
  4039f8:	f003 0301 	and.w	r3, r3, #1
  4039fc:	2b00      	cmp	r3, #0
  4039fe:	d0f9      	beq.n	4039f4 <twi_master_write+0xc0>
	}

	return TWI_SUCCESS;
  403a00:	2300      	movs	r3, #0
}
  403a02:	4618      	mov	r0, r3
  403a04:	3718      	adds	r7, #24
  403a06:	46bd      	mov	sp, r7
  403a08:	bd80      	pop	{r7, pc}
  403a0a:	bf00      	nop
  403a0c:	004038d9 	.word	0x004038d9

00403a10 <twi_reset>:
 * \brief Reset TWI.
 *
 * \param p_twi Pointer to a TWI instance.
 */
void twi_reset(Twi *p_twi)
{
  403a10:	b480      	push	{r7}
  403a12:	b083      	sub	sp, #12
  403a14:	af00      	add	r7, sp, #0
  403a16:	6078      	str	r0, [r7, #4]
	/* Set SWRST bit to reset TWI peripheral */
	p_twi->TWI_CR = TWI_CR_SWRST;
  403a18:	687b      	ldr	r3, [r7, #4]
  403a1a:	2280      	movs	r2, #128	; 0x80
  403a1c:	601a      	str	r2, [r3, #0]
	p_twi->TWI_RHR;
  403a1e:	687b      	ldr	r3, [r7, #4]
  403a20:	6b1b      	ldr	r3, [r3, #48]	; 0x30
}
  403a22:	bf00      	nop
  403a24:	370c      	adds	r7, #12
  403a26:	46bd      	mov	sp, r7
  403a28:	f85d 7b04 	ldr.w	r7, [sp], #4
  403a2c:	4770      	bx	lr
	...

00403a30 <__aeabi_uldivmod>:
  403a30:	b953      	cbnz	r3, 403a48 <__aeabi_uldivmod+0x18>
  403a32:	b94a      	cbnz	r2, 403a48 <__aeabi_uldivmod+0x18>
  403a34:	2900      	cmp	r1, #0
  403a36:	bf08      	it	eq
  403a38:	2800      	cmpeq	r0, #0
  403a3a:	bf1c      	itt	ne
  403a3c:	f04f 31ff 	movne.w	r1, #4294967295
  403a40:	f04f 30ff 	movne.w	r0, #4294967295
  403a44:	f000 b97a 	b.w	403d3c <__aeabi_idiv0>
  403a48:	f1ad 0c08 	sub.w	ip, sp, #8
  403a4c:	e96d ce04 	strd	ip, lr, [sp, #-16]!
  403a50:	f000 f806 	bl	403a60 <__udivmoddi4>
  403a54:	f8dd e004 	ldr.w	lr, [sp, #4]
  403a58:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  403a5c:	b004      	add	sp, #16
  403a5e:	4770      	bx	lr

00403a60 <__udivmoddi4>:
  403a60:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  403a64:	468c      	mov	ip, r1
  403a66:	460d      	mov	r5, r1
  403a68:	4604      	mov	r4, r0
  403a6a:	9e08      	ldr	r6, [sp, #32]
  403a6c:	2b00      	cmp	r3, #0
  403a6e:	d151      	bne.n	403b14 <__udivmoddi4+0xb4>
  403a70:	428a      	cmp	r2, r1
  403a72:	4617      	mov	r7, r2
  403a74:	d96d      	bls.n	403b52 <__udivmoddi4+0xf2>
  403a76:	fab2 fe82 	clz	lr, r2
  403a7a:	f1be 0f00 	cmp.w	lr, #0
  403a7e:	d00b      	beq.n	403a98 <__udivmoddi4+0x38>
  403a80:	f1ce 0c20 	rsb	ip, lr, #32
  403a84:	fa01 f50e 	lsl.w	r5, r1, lr
  403a88:	fa20 fc0c 	lsr.w	ip, r0, ip
  403a8c:	fa02 f70e 	lsl.w	r7, r2, lr
  403a90:	ea4c 0c05 	orr.w	ip, ip, r5
  403a94:	fa00 f40e 	lsl.w	r4, r0, lr
  403a98:	ea4f 4a17 	mov.w	sl, r7, lsr #16
  403a9c:	0c25      	lsrs	r5, r4, #16
  403a9e:	fbbc f8fa 	udiv	r8, ip, sl
  403aa2:	fa1f f987 	uxth.w	r9, r7
  403aa6:	fb0a cc18 	mls	ip, sl, r8, ip
  403aaa:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
  403aae:	fb08 f309 	mul.w	r3, r8, r9
  403ab2:	42ab      	cmp	r3, r5
  403ab4:	d90a      	bls.n	403acc <__udivmoddi4+0x6c>
  403ab6:	19ed      	adds	r5, r5, r7
  403ab8:	f108 32ff 	add.w	r2, r8, #4294967295
  403abc:	f080 8123 	bcs.w	403d06 <__udivmoddi4+0x2a6>
  403ac0:	42ab      	cmp	r3, r5
  403ac2:	f240 8120 	bls.w	403d06 <__udivmoddi4+0x2a6>
  403ac6:	f1a8 0802 	sub.w	r8, r8, #2
  403aca:	443d      	add	r5, r7
  403acc:	1aed      	subs	r5, r5, r3
  403ace:	b2a4      	uxth	r4, r4
  403ad0:	fbb5 f0fa 	udiv	r0, r5, sl
  403ad4:	fb0a 5510 	mls	r5, sl, r0, r5
  403ad8:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
  403adc:	fb00 f909 	mul.w	r9, r0, r9
  403ae0:	45a1      	cmp	r9, r4
  403ae2:	d909      	bls.n	403af8 <__udivmoddi4+0x98>
  403ae4:	19e4      	adds	r4, r4, r7
  403ae6:	f100 33ff 	add.w	r3, r0, #4294967295
  403aea:	f080 810a 	bcs.w	403d02 <__udivmoddi4+0x2a2>
  403aee:	45a1      	cmp	r9, r4
  403af0:	f240 8107 	bls.w	403d02 <__udivmoddi4+0x2a2>
  403af4:	3802      	subs	r0, #2
  403af6:	443c      	add	r4, r7
  403af8:	eba4 0409 	sub.w	r4, r4, r9
  403afc:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
  403b00:	2100      	movs	r1, #0
  403b02:	2e00      	cmp	r6, #0
  403b04:	d061      	beq.n	403bca <__udivmoddi4+0x16a>
  403b06:	fa24 f40e 	lsr.w	r4, r4, lr
  403b0a:	2300      	movs	r3, #0
  403b0c:	6034      	str	r4, [r6, #0]
  403b0e:	6073      	str	r3, [r6, #4]
  403b10:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  403b14:	428b      	cmp	r3, r1
  403b16:	d907      	bls.n	403b28 <__udivmoddi4+0xc8>
  403b18:	2e00      	cmp	r6, #0
  403b1a:	d054      	beq.n	403bc6 <__udivmoddi4+0x166>
  403b1c:	2100      	movs	r1, #0
  403b1e:	e886 0021 	stmia.w	r6, {r0, r5}
  403b22:	4608      	mov	r0, r1
  403b24:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  403b28:	fab3 f183 	clz	r1, r3
  403b2c:	2900      	cmp	r1, #0
  403b2e:	f040 808e 	bne.w	403c4e <__udivmoddi4+0x1ee>
  403b32:	42ab      	cmp	r3, r5
  403b34:	d302      	bcc.n	403b3c <__udivmoddi4+0xdc>
  403b36:	4282      	cmp	r2, r0
  403b38:	f200 80fa 	bhi.w	403d30 <__udivmoddi4+0x2d0>
  403b3c:	1a84      	subs	r4, r0, r2
  403b3e:	eb65 0503 	sbc.w	r5, r5, r3
  403b42:	2001      	movs	r0, #1
  403b44:	46ac      	mov	ip, r5
  403b46:	2e00      	cmp	r6, #0
  403b48:	d03f      	beq.n	403bca <__udivmoddi4+0x16a>
  403b4a:	e886 1010 	stmia.w	r6, {r4, ip}
  403b4e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  403b52:	b912      	cbnz	r2, 403b5a <__udivmoddi4+0xfa>
  403b54:	2701      	movs	r7, #1
  403b56:	fbb7 f7f2 	udiv	r7, r7, r2
  403b5a:	fab7 fe87 	clz	lr, r7
  403b5e:	f1be 0f00 	cmp.w	lr, #0
  403b62:	d134      	bne.n	403bce <__udivmoddi4+0x16e>
  403b64:	1beb      	subs	r3, r5, r7
  403b66:	0c3a      	lsrs	r2, r7, #16
  403b68:	fa1f fc87 	uxth.w	ip, r7
  403b6c:	2101      	movs	r1, #1
  403b6e:	fbb3 f8f2 	udiv	r8, r3, r2
  403b72:	0c25      	lsrs	r5, r4, #16
  403b74:	fb02 3318 	mls	r3, r2, r8, r3
  403b78:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
  403b7c:	fb0c f308 	mul.w	r3, ip, r8
  403b80:	42ab      	cmp	r3, r5
  403b82:	d907      	bls.n	403b94 <__udivmoddi4+0x134>
  403b84:	19ed      	adds	r5, r5, r7
  403b86:	f108 30ff 	add.w	r0, r8, #4294967295
  403b8a:	d202      	bcs.n	403b92 <__udivmoddi4+0x132>
  403b8c:	42ab      	cmp	r3, r5
  403b8e:	f200 80d1 	bhi.w	403d34 <__udivmoddi4+0x2d4>
  403b92:	4680      	mov	r8, r0
  403b94:	1aed      	subs	r5, r5, r3
  403b96:	b2a3      	uxth	r3, r4
  403b98:	fbb5 f0f2 	udiv	r0, r5, r2
  403b9c:	fb02 5510 	mls	r5, r2, r0, r5
  403ba0:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
  403ba4:	fb0c fc00 	mul.w	ip, ip, r0
  403ba8:	45a4      	cmp	ip, r4
  403baa:	d907      	bls.n	403bbc <__udivmoddi4+0x15c>
  403bac:	19e4      	adds	r4, r4, r7
  403bae:	f100 33ff 	add.w	r3, r0, #4294967295
  403bb2:	d202      	bcs.n	403bba <__udivmoddi4+0x15a>
  403bb4:	45a4      	cmp	ip, r4
  403bb6:	f200 80b8 	bhi.w	403d2a <__udivmoddi4+0x2ca>
  403bba:	4618      	mov	r0, r3
  403bbc:	eba4 040c 	sub.w	r4, r4, ip
  403bc0:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
  403bc4:	e79d      	b.n	403b02 <__udivmoddi4+0xa2>
  403bc6:	4631      	mov	r1, r6
  403bc8:	4630      	mov	r0, r6
  403bca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  403bce:	f1ce 0420 	rsb	r4, lr, #32
  403bd2:	fa05 f30e 	lsl.w	r3, r5, lr
  403bd6:	fa07 f70e 	lsl.w	r7, r7, lr
  403bda:	fa20 f804 	lsr.w	r8, r0, r4
  403bde:	0c3a      	lsrs	r2, r7, #16
  403be0:	fa25 f404 	lsr.w	r4, r5, r4
  403be4:	ea48 0803 	orr.w	r8, r8, r3
  403be8:	fbb4 f1f2 	udiv	r1, r4, r2
  403bec:	ea4f 4518 	mov.w	r5, r8, lsr #16
  403bf0:	fb02 4411 	mls	r4, r2, r1, r4
  403bf4:	fa1f fc87 	uxth.w	ip, r7
  403bf8:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
  403bfc:	fb01 f30c 	mul.w	r3, r1, ip
  403c00:	42ab      	cmp	r3, r5
  403c02:	fa00 f40e 	lsl.w	r4, r0, lr
  403c06:	d909      	bls.n	403c1c <__udivmoddi4+0x1bc>
  403c08:	19ed      	adds	r5, r5, r7
  403c0a:	f101 30ff 	add.w	r0, r1, #4294967295
  403c0e:	f080 808a 	bcs.w	403d26 <__udivmoddi4+0x2c6>
  403c12:	42ab      	cmp	r3, r5
  403c14:	f240 8087 	bls.w	403d26 <__udivmoddi4+0x2c6>
  403c18:	3902      	subs	r1, #2
  403c1a:	443d      	add	r5, r7
  403c1c:	1aeb      	subs	r3, r5, r3
  403c1e:	fa1f f588 	uxth.w	r5, r8
  403c22:	fbb3 f0f2 	udiv	r0, r3, r2
  403c26:	fb02 3310 	mls	r3, r2, r0, r3
  403c2a:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
  403c2e:	fb00 f30c 	mul.w	r3, r0, ip
  403c32:	42ab      	cmp	r3, r5
  403c34:	d907      	bls.n	403c46 <__udivmoddi4+0x1e6>
  403c36:	19ed      	adds	r5, r5, r7
  403c38:	f100 38ff 	add.w	r8, r0, #4294967295
  403c3c:	d26f      	bcs.n	403d1e <__udivmoddi4+0x2be>
  403c3e:	42ab      	cmp	r3, r5
  403c40:	d96d      	bls.n	403d1e <__udivmoddi4+0x2be>
  403c42:	3802      	subs	r0, #2
  403c44:	443d      	add	r5, r7
  403c46:	1aeb      	subs	r3, r5, r3
  403c48:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
  403c4c:	e78f      	b.n	403b6e <__udivmoddi4+0x10e>
  403c4e:	f1c1 0720 	rsb	r7, r1, #32
  403c52:	fa22 f807 	lsr.w	r8, r2, r7
  403c56:	408b      	lsls	r3, r1
  403c58:	fa05 f401 	lsl.w	r4, r5, r1
  403c5c:	ea48 0303 	orr.w	r3, r8, r3
  403c60:	fa20 fe07 	lsr.w	lr, r0, r7
  403c64:	ea4f 4c13 	mov.w	ip, r3, lsr #16
  403c68:	40fd      	lsrs	r5, r7
  403c6a:	ea4e 0e04 	orr.w	lr, lr, r4
  403c6e:	fbb5 f9fc 	udiv	r9, r5, ip
  403c72:	ea4f 441e 	mov.w	r4, lr, lsr #16
  403c76:	fb0c 5519 	mls	r5, ip, r9, r5
  403c7a:	fa1f f883 	uxth.w	r8, r3
  403c7e:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
  403c82:	fb09 f408 	mul.w	r4, r9, r8
  403c86:	42ac      	cmp	r4, r5
  403c88:	fa02 f201 	lsl.w	r2, r2, r1
  403c8c:	fa00 fa01 	lsl.w	sl, r0, r1
  403c90:	d908      	bls.n	403ca4 <__udivmoddi4+0x244>
  403c92:	18ed      	adds	r5, r5, r3
  403c94:	f109 30ff 	add.w	r0, r9, #4294967295
  403c98:	d243      	bcs.n	403d22 <__udivmoddi4+0x2c2>
  403c9a:	42ac      	cmp	r4, r5
  403c9c:	d941      	bls.n	403d22 <__udivmoddi4+0x2c2>
  403c9e:	f1a9 0902 	sub.w	r9, r9, #2
  403ca2:	441d      	add	r5, r3
  403ca4:	1b2d      	subs	r5, r5, r4
  403ca6:	fa1f fe8e 	uxth.w	lr, lr
  403caa:	fbb5 f0fc 	udiv	r0, r5, ip
  403cae:	fb0c 5510 	mls	r5, ip, r0, r5
  403cb2:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
  403cb6:	fb00 f808 	mul.w	r8, r0, r8
  403cba:	45a0      	cmp	r8, r4
  403cbc:	d907      	bls.n	403cce <__udivmoddi4+0x26e>
  403cbe:	18e4      	adds	r4, r4, r3
  403cc0:	f100 35ff 	add.w	r5, r0, #4294967295
  403cc4:	d229      	bcs.n	403d1a <__udivmoddi4+0x2ba>
  403cc6:	45a0      	cmp	r8, r4
  403cc8:	d927      	bls.n	403d1a <__udivmoddi4+0x2ba>
  403cca:	3802      	subs	r0, #2
  403ccc:	441c      	add	r4, r3
  403cce:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
  403cd2:	eba4 0408 	sub.w	r4, r4, r8
  403cd6:	fba0 8902 	umull	r8, r9, r0, r2
  403cda:	454c      	cmp	r4, r9
  403cdc:	46c6      	mov	lr, r8
  403cde:	464d      	mov	r5, r9
  403ce0:	d315      	bcc.n	403d0e <__udivmoddi4+0x2ae>
  403ce2:	d012      	beq.n	403d0a <__udivmoddi4+0x2aa>
  403ce4:	b156      	cbz	r6, 403cfc <__udivmoddi4+0x29c>
  403ce6:	ebba 030e 	subs.w	r3, sl, lr
  403cea:	eb64 0405 	sbc.w	r4, r4, r5
  403cee:	fa04 f707 	lsl.w	r7, r4, r7
  403cf2:	40cb      	lsrs	r3, r1
  403cf4:	431f      	orrs	r7, r3
  403cf6:	40cc      	lsrs	r4, r1
  403cf8:	6037      	str	r7, [r6, #0]
  403cfa:	6074      	str	r4, [r6, #4]
  403cfc:	2100      	movs	r1, #0
  403cfe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  403d02:	4618      	mov	r0, r3
  403d04:	e6f8      	b.n	403af8 <__udivmoddi4+0x98>
  403d06:	4690      	mov	r8, r2
  403d08:	e6e0      	b.n	403acc <__udivmoddi4+0x6c>
  403d0a:	45c2      	cmp	sl, r8
  403d0c:	d2ea      	bcs.n	403ce4 <__udivmoddi4+0x284>
  403d0e:	ebb8 0e02 	subs.w	lr, r8, r2
  403d12:	eb69 0503 	sbc.w	r5, r9, r3
  403d16:	3801      	subs	r0, #1
  403d18:	e7e4      	b.n	403ce4 <__udivmoddi4+0x284>
  403d1a:	4628      	mov	r0, r5
  403d1c:	e7d7      	b.n	403cce <__udivmoddi4+0x26e>
  403d1e:	4640      	mov	r0, r8
  403d20:	e791      	b.n	403c46 <__udivmoddi4+0x1e6>
  403d22:	4681      	mov	r9, r0
  403d24:	e7be      	b.n	403ca4 <__udivmoddi4+0x244>
  403d26:	4601      	mov	r1, r0
  403d28:	e778      	b.n	403c1c <__udivmoddi4+0x1bc>
  403d2a:	3802      	subs	r0, #2
  403d2c:	443c      	add	r4, r7
  403d2e:	e745      	b.n	403bbc <__udivmoddi4+0x15c>
  403d30:	4608      	mov	r0, r1
  403d32:	e708      	b.n	403b46 <__udivmoddi4+0xe6>
  403d34:	f1a8 0802 	sub.w	r8, r8, #2
  403d38:	443d      	add	r5, r7
  403d3a:	e72b      	b.n	403b94 <__udivmoddi4+0x134>

00403d3c <__aeabi_idiv0>:
  403d3c:	4770      	bx	lr
  403d3e:	bf00      	nop

00403d40 <__libc_init_array>:
  403d40:	b570      	push	{r4, r5, r6, lr}
  403d42:	4e0f      	ldr	r6, [pc, #60]	; (403d80 <__libc_init_array+0x40>)
  403d44:	4d0f      	ldr	r5, [pc, #60]	; (403d84 <__libc_init_array+0x44>)
  403d46:	1b76      	subs	r6, r6, r5
  403d48:	10b6      	asrs	r6, r6, #2
  403d4a:	bf18      	it	ne
  403d4c:	2400      	movne	r4, #0
  403d4e:	d005      	beq.n	403d5c <__libc_init_array+0x1c>
  403d50:	3401      	adds	r4, #1
  403d52:	f855 3b04 	ldr.w	r3, [r5], #4
  403d56:	4798      	blx	r3
  403d58:	42a6      	cmp	r6, r4
  403d5a:	d1f9      	bne.n	403d50 <__libc_init_array+0x10>
  403d5c:	4e0a      	ldr	r6, [pc, #40]	; (403d88 <__libc_init_array+0x48>)
  403d5e:	4d0b      	ldr	r5, [pc, #44]	; (403d8c <__libc_init_array+0x4c>)
  403d60:	1b76      	subs	r6, r6, r5
  403d62:	f000 f999 	bl	404098 <_init>
  403d66:	10b6      	asrs	r6, r6, #2
  403d68:	bf18      	it	ne
  403d6a:	2400      	movne	r4, #0
  403d6c:	d006      	beq.n	403d7c <__libc_init_array+0x3c>
  403d6e:	3401      	adds	r4, #1
  403d70:	f855 3b04 	ldr.w	r3, [r5], #4
  403d74:	4798      	blx	r3
  403d76:	42a6      	cmp	r6, r4
  403d78:	d1f9      	bne.n	403d6e <__libc_init_array+0x2e>
  403d7a:	bd70      	pop	{r4, r5, r6, pc}
  403d7c:	bd70      	pop	{r4, r5, r6, pc}
  403d7e:	bf00      	nop
  403d80:	004040a4 	.word	0x004040a4
  403d84:	004040a4 	.word	0x004040a4
  403d88:	004040ac 	.word	0x004040ac
  403d8c:	004040a4 	.word	0x004040a4

00403d90 <memset>:
  403d90:	b470      	push	{r4, r5, r6}
  403d92:	0786      	lsls	r6, r0, #30
  403d94:	d046      	beq.n	403e24 <memset+0x94>
  403d96:	1e54      	subs	r4, r2, #1
  403d98:	2a00      	cmp	r2, #0
  403d9a:	d041      	beq.n	403e20 <memset+0x90>
  403d9c:	b2ca      	uxtb	r2, r1
  403d9e:	4603      	mov	r3, r0
  403da0:	e002      	b.n	403da8 <memset+0x18>
  403da2:	f114 34ff 	adds.w	r4, r4, #4294967295
  403da6:	d33b      	bcc.n	403e20 <memset+0x90>
  403da8:	f803 2b01 	strb.w	r2, [r3], #1
  403dac:	079d      	lsls	r5, r3, #30
  403dae:	d1f8      	bne.n	403da2 <memset+0x12>
  403db0:	2c03      	cmp	r4, #3
  403db2:	d92e      	bls.n	403e12 <memset+0x82>
  403db4:	b2cd      	uxtb	r5, r1
  403db6:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
  403dba:	2c0f      	cmp	r4, #15
  403dbc:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
  403dc0:	d919      	bls.n	403df6 <memset+0x66>
  403dc2:	f103 0210 	add.w	r2, r3, #16
  403dc6:	4626      	mov	r6, r4
  403dc8:	3e10      	subs	r6, #16
  403dca:	2e0f      	cmp	r6, #15
  403dcc:	f842 5c10 	str.w	r5, [r2, #-16]
  403dd0:	f842 5c0c 	str.w	r5, [r2, #-12]
  403dd4:	f842 5c08 	str.w	r5, [r2, #-8]
  403dd8:	f842 5c04 	str.w	r5, [r2, #-4]
  403ddc:	f102 0210 	add.w	r2, r2, #16
  403de0:	d8f2      	bhi.n	403dc8 <memset+0x38>
  403de2:	f1a4 0210 	sub.w	r2, r4, #16
  403de6:	f022 020f 	bic.w	r2, r2, #15
  403dea:	f004 040f 	and.w	r4, r4, #15
  403dee:	3210      	adds	r2, #16
  403df0:	2c03      	cmp	r4, #3
  403df2:	4413      	add	r3, r2
  403df4:	d90d      	bls.n	403e12 <memset+0x82>
  403df6:	461e      	mov	r6, r3
  403df8:	4622      	mov	r2, r4
  403dfa:	3a04      	subs	r2, #4
  403dfc:	2a03      	cmp	r2, #3
  403dfe:	f846 5b04 	str.w	r5, [r6], #4
  403e02:	d8fa      	bhi.n	403dfa <memset+0x6a>
  403e04:	1f22      	subs	r2, r4, #4
  403e06:	f022 0203 	bic.w	r2, r2, #3
  403e0a:	3204      	adds	r2, #4
  403e0c:	4413      	add	r3, r2
  403e0e:	f004 0403 	and.w	r4, r4, #3
  403e12:	b12c      	cbz	r4, 403e20 <memset+0x90>
  403e14:	b2c9      	uxtb	r1, r1
  403e16:	441c      	add	r4, r3
  403e18:	f803 1b01 	strb.w	r1, [r3], #1
  403e1c:	429c      	cmp	r4, r3
  403e1e:	d1fb      	bne.n	403e18 <memset+0x88>
  403e20:	bc70      	pop	{r4, r5, r6}
  403e22:	4770      	bx	lr
  403e24:	4614      	mov	r4, r2
  403e26:	4603      	mov	r3, r0
  403e28:	e7c2      	b.n	403db0 <memset+0x20>
  403e2a:	bf00      	nop

00403e2c <register_fini>:
  403e2c:	4b02      	ldr	r3, [pc, #8]	; (403e38 <register_fini+0xc>)
  403e2e:	b113      	cbz	r3, 403e36 <register_fini+0xa>
  403e30:	4802      	ldr	r0, [pc, #8]	; (403e3c <register_fini+0x10>)
  403e32:	f000 b805 	b.w	403e40 <atexit>
  403e36:	4770      	bx	lr
  403e38:	00000000 	.word	0x00000000
  403e3c:	00403e4d 	.word	0x00403e4d

00403e40 <atexit>:
  403e40:	2300      	movs	r3, #0
  403e42:	4601      	mov	r1, r0
  403e44:	461a      	mov	r2, r3
  403e46:	4618      	mov	r0, r3
  403e48:	f000 b81e 	b.w	403e88 <__register_exitproc>

00403e4c <__libc_fini_array>:
  403e4c:	b538      	push	{r3, r4, r5, lr}
  403e4e:	4c0a      	ldr	r4, [pc, #40]	; (403e78 <__libc_fini_array+0x2c>)
  403e50:	4d0a      	ldr	r5, [pc, #40]	; (403e7c <__libc_fini_array+0x30>)
  403e52:	1b64      	subs	r4, r4, r5
  403e54:	10a4      	asrs	r4, r4, #2
  403e56:	d00a      	beq.n	403e6e <__libc_fini_array+0x22>
  403e58:	f104 4380 	add.w	r3, r4, #1073741824	; 0x40000000
  403e5c:	3b01      	subs	r3, #1
  403e5e:	eb05 0583 	add.w	r5, r5, r3, lsl #2
  403e62:	3c01      	subs	r4, #1
  403e64:	f855 3904 	ldr.w	r3, [r5], #-4
  403e68:	4798      	blx	r3
  403e6a:	2c00      	cmp	r4, #0
  403e6c:	d1f9      	bne.n	403e62 <__libc_fini_array+0x16>
  403e6e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  403e72:	f000 b91b 	b.w	4040ac <_fini>
  403e76:	bf00      	nop
  403e78:	004040bc 	.word	0x004040bc
  403e7c:	004040b8 	.word	0x004040b8

00403e80 <__retarget_lock_acquire_recursive>:
  403e80:	4770      	bx	lr
  403e82:	bf00      	nop

00403e84 <__retarget_lock_release_recursive>:
  403e84:	4770      	bx	lr
  403e86:	bf00      	nop

00403e88 <__register_exitproc>:
  403e88:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  403e8c:	4d2c      	ldr	r5, [pc, #176]	; (403f40 <__register_exitproc+0xb8>)
  403e8e:	4606      	mov	r6, r0
  403e90:	6828      	ldr	r0, [r5, #0]
  403e92:	4698      	mov	r8, r3
  403e94:	460f      	mov	r7, r1
  403e96:	4691      	mov	r9, r2
  403e98:	f7ff fff2 	bl	403e80 <__retarget_lock_acquire_recursive>
  403e9c:	4b29      	ldr	r3, [pc, #164]	; (403f44 <__register_exitproc+0xbc>)
  403e9e:	681c      	ldr	r4, [r3, #0]
  403ea0:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
  403ea4:	2b00      	cmp	r3, #0
  403ea6:	d03e      	beq.n	403f26 <__register_exitproc+0x9e>
  403ea8:	685a      	ldr	r2, [r3, #4]
  403eaa:	2a1f      	cmp	r2, #31
  403eac:	dc1c      	bgt.n	403ee8 <__register_exitproc+0x60>
  403eae:	f102 0e01 	add.w	lr, r2, #1
  403eb2:	b176      	cbz	r6, 403ed2 <__register_exitproc+0x4a>
  403eb4:	eb03 0182 	add.w	r1, r3, r2, lsl #2
  403eb8:	2401      	movs	r4, #1
  403eba:	f8c1 9088 	str.w	r9, [r1, #136]	; 0x88
  403ebe:	f8d3 0188 	ldr.w	r0, [r3, #392]	; 0x188
  403ec2:	4094      	lsls	r4, r2
  403ec4:	4320      	orrs	r0, r4
  403ec6:	2e02      	cmp	r6, #2
  403ec8:	f8c3 0188 	str.w	r0, [r3, #392]	; 0x188
  403ecc:	f8c1 8108 	str.w	r8, [r1, #264]	; 0x108
  403ed0:	d023      	beq.n	403f1a <__register_exitproc+0x92>
  403ed2:	3202      	adds	r2, #2
  403ed4:	f8c3 e004 	str.w	lr, [r3, #4]
  403ed8:	6828      	ldr	r0, [r5, #0]
  403eda:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
  403ede:	f7ff ffd1 	bl	403e84 <__retarget_lock_release_recursive>
  403ee2:	2000      	movs	r0, #0
  403ee4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  403ee8:	4b17      	ldr	r3, [pc, #92]	; (403f48 <__register_exitproc+0xc0>)
  403eea:	b30b      	cbz	r3, 403f30 <__register_exitproc+0xa8>
  403eec:	f44f 70c8 	mov.w	r0, #400	; 0x190
  403ef0:	f3af 8000 	nop.w
  403ef4:	4603      	mov	r3, r0
  403ef6:	b1d8      	cbz	r0, 403f30 <__register_exitproc+0xa8>
  403ef8:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
  403efc:	6002      	str	r2, [r0, #0]
  403efe:	2100      	movs	r1, #0
  403f00:	6041      	str	r1, [r0, #4]
  403f02:	460a      	mov	r2, r1
  403f04:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
  403f08:	f04f 0e01 	mov.w	lr, #1
  403f0c:	f8c0 1188 	str.w	r1, [r0, #392]	; 0x188
  403f10:	f8c0 118c 	str.w	r1, [r0, #396]	; 0x18c
  403f14:	2e00      	cmp	r6, #0
  403f16:	d0dc      	beq.n	403ed2 <__register_exitproc+0x4a>
  403f18:	e7cc      	b.n	403eb4 <__register_exitproc+0x2c>
  403f1a:	f8d3 118c 	ldr.w	r1, [r3, #396]	; 0x18c
  403f1e:	430c      	orrs	r4, r1
  403f20:	f8c3 418c 	str.w	r4, [r3, #396]	; 0x18c
  403f24:	e7d5      	b.n	403ed2 <__register_exitproc+0x4a>
  403f26:	f504 73a6 	add.w	r3, r4, #332	; 0x14c
  403f2a:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
  403f2e:	e7bb      	b.n	403ea8 <__register_exitproc+0x20>
  403f30:	6828      	ldr	r0, [r5, #0]
  403f32:	f7ff ffa7 	bl	403e84 <__retarget_lock_release_recursive>
  403f36:	f04f 30ff 	mov.w	r0, #4294967295
  403f3a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  403f3e:	bf00      	nop
  403f40:	20000438 	.word	0x20000438
  403f44:	00404094 	.word	0x00404094
  403f48:	00000000 	.word	0x00000000

00403f4c <SSD1311_CFG_SCRIPT>:
  403f4c:	08020000 71022a02 72020003 79020003     .....*.q...r...y
  403f5c:	7f028102 6002d502 7802d902 1002da02     .......`...x....
  403f6c:	4002db02 0302dc02 78027804 06020902     ...@.....x.x....
  403f7c:	01022802 06020202 05040c02 00000101     .(..............

00403f8c <sd_mmc_trans_units>:
  403f8c:	0000000a 00000064 000003e8 00002710     ....d........'..
	...

00403fa8 <sd_trans_multipliers>:
  403fa8:	00000000 0000000a 0000000c 0000000d     ................
  403fb8:	0000000f 00000014 00000019 0000001e     ................
  403fc8:	00000023 00000028 0000002d 00000032     #...(...-...2...
  403fd8:	00000037 0000003c 00000046 00000050     7...<...F...P...

00403fe8 <mmc_trans_multipliers>:
  403fe8:	00000000 0000000a 0000000c 0000000d     ................
  403ff8:	0000000f 00000014 0000001a 0000001e     ................
  404008:	00000023 00000028 0000002d 00000034     #...(...-...4...
  404018:	00000037 0000003c 00000046 00000050     7...<...F...P...

00404028 <can_bit_time>:
  404028:	02020308 02094b03 43020303 0303030a     .....K.....C....
  404038:	040b4603 48040303 0404030c 040d4304     .F.....H.....C..
  404048:	4d040404 0504040e 040f4004 43040505     ...M.....@.....C
  404058:	05050510 06114504 47040505 06060512     .....E.....G....
  404068:	06134304 44040606 06060714 08154604     .C.....D.....F..
  404078:	47040606 07070716 08174404 46040708     ...G.....D.....F
  404088:	08080718 08194304 44040808              .....C.....D

00404094 <_global_impure_ptr>:
  404094:	20000010                                ... 

00404098 <_init>:
  404098:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40409a:	bf00      	nop
  40409c:	bcf8      	pop	{r3, r4, r5, r6, r7}
  40409e:	bc08      	pop	{r3}
  4040a0:	469e      	mov	lr, r3
  4040a2:	4770      	bx	lr

004040a4 <__init_array_start>:
  4040a4:	00403e2d 	.word	0x00403e2d

004040a8 <__frame_dummy_init_array_entry>:
  4040a8:	0040011d                                ..@.

004040ac <_fini>:
  4040ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4040ae:	bf00      	nop
  4040b0:	bcf8      	pop	{r3, r4, r5, r6, r7}
  4040b2:	bc08      	pop	{r3}
  4040b4:	469e      	mov	lr, r3
  4040b6:	4770      	bx	lr

004040b8 <__fini_array_start>:
  4040b8:	004000f9 	.word	0x004000f9

Disassembly of section .relocate:

20000000 <portable_delay_cycles>:
RAMFUNC
void portable_delay_cycles(unsigned long n)
{
	UNUSED(n);

	__asm (
20000000:	f3bf 8f5f 	dmb	sy
20000004:	3801      	subs	r0, #1
20000006:	d1fb      	bne.n	20000000 <portable_delay_cycles>
20000008:	4770      	bx	lr

2000000a <g_interrupt_enabled>:
2000000a:	0001                                        ..

2000000c <SystemCoreClock>:
2000000c:	0900 003d                                   ..=.

20000010 <impure_data>:
20000010:	0000 0000 02fc 2000 0364 2000 03cc 2000     ....... d.. ... 
	...
200000b8:	0001 0000 0000 0000 330e abcd 1234 e66d     .........3..4.m.
200000c8:	deec 0005 000b 0000 0000 0000 0000 0000     ................
	...

20000438 <__atexit_recursive_mutex>:
20000438:	0534 2000                                   4.. 
