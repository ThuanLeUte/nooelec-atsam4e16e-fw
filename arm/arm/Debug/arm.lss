
arm.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000040ec  00400000  00400000  00010000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  004040ec  004040ec  000140ec  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     0000043c  20000000  004040f4  00020000  2**3
                  CONTENTS, ALLOC, LOAD, CODE
  3 .bss          0000011c  2000043c  00404530  0002043c  2**2
                  ALLOC
  4 .stack        00003000  20000558  0040464c  0002043c  2**0
                  ALLOC
  5 .ARM.attributes 0000002e  00000000  00000000  0002043c  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  0002046a  2**0
                  CONTENTS, READONLY
  7 .debug_info   0001a5e2  00000000  00000000  000204c3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00003a68  00000000  00000000  0003aaa5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00005b96  00000000  00000000  0003e50d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00000c58  00000000  00000000  000440a3  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000ba0  00000000  00000000  00044cfb  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  0001df9a  00000000  00000000  0004589b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00011648  00000000  00000000  00063835  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0006cda3  00000000  00000000  00074e7d  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  0000237c  00000000  00000000  000e1c20  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <exception_table>:
  400000:	58 35 00 20 01 2a 40 00 fd 29 40 00 fd 29 40 00     X5. .*@..)@..)@.
  400010:	fd 29 40 00 fd 29 40 00 fd 29 40 00 00 00 00 00     .)@..)@..)@.....
	...
  40002c:	fd 29 40 00 fd 29 40 00 00 00 00 00 fd 29 40 00     .)@..)@......)@.
  40003c:	fd 29 40 00 fd 29 40 00 fd 29 40 00 fd 29 40 00     .)@..)@..)@..)@.
  40004c:	fd 29 40 00 fd 29 40 00 fd 29 40 00 fd 29 40 00     .)@..)@..)@..)@.
  40005c:	fd 29 40 00 fd 29 40 00 9d 2d 40 00 b1 2d 40 00     .)@..)@..-@..-@.
  40006c:	c5 2d 40 00 d9 2d 40 00 ed 2d 40 00 fd 29 40 00     .-@..-@..-@..)@.
  40007c:	fd 29 40 00 fd 29 40 00 fd 29 40 00 fd 29 40 00     .)@..)@..)@..)@.
  40008c:	fd 29 40 00 fd 29 40 00 fd 29 40 00 fd 29 40 00     .)@..)@..)@..)@.
  40009c:	fd 29 40 00 fd 29 40 00 fd 29 40 00 fd 29 40 00     .)@..)@..)@..)@.
  4000ac:	fd 29 40 00 fd 29 40 00 fd 29 40 00 fd 29 40 00     .)@..)@..)@..)@.
  4000bc:	fd 29 40 00 fd 29 40 00 fd 29 40 00 fd 29 40 00     .)@..)@..)@..)@.
  4000cc:	fd 29 40 00 fd 29 40 00 fd 29 40 00 fd 29 40 00     .)@..)@..)@..)@.
  4000dc:	fd 29 40 00 fd 29 40 00 fd 29 40 00 fd 29 40 00     .)@..)@..)@..)@.
  4000ec:	fd 29 40 00 fd 29 40 00 fd 29 40 00                 .)@..)@..)@.

004000f8 <__do_global_dtors_aux>:
  4000f8:	b510      	push	{r4, lr}
  4000fa:	4c05      	ldr	r4, [pc, #20]	; (400110 <__do_global_dtors_aux+0x18>)
  4000fc:	7823      	ldrb	r3, [r4, #0]
  4000fe:	b933      	cbnz	r3, 40010e <__do_global_dtors_aux+0x16>
  400100:	4b04      	ldr	r3, [pc, #16]	; (400114 <__do_global_dtors_aux+0x1c>)
  400102:	b113      	cbz	r3, 40010a <__do_global_dtors_aux+0x12>
  400104:	4804      	ldr	r0, [pc, #16]	; (400118 <__do_global_dtors_aux+0x20>)
  400106:	f3af 8000 	nop.w
  40010a:	2301      	movs	r3, #1
  40010c:	7023      	strb	r3, [r4, #0]
  40010e:	bd10      	pop	{r4, pc}
  400110:	2000043c 	.word	0x2000043c
  400114:	00000000 	.word	0x00000000
  400118:	004040f4 	.word	0x004040f4

0040011c <frame_dummy>:
  40011c:	4b0c      	ldr	r3, [pc, #48]	; (400150 <frame_dummy+0x34>)
  40011e:	b143      	cbz	r3, 400132 <frame_dummy+0x16>
  400120:	480c      	ldr	r0, [pc, #48]	; (400154 <frame_dummy+0x38>)
  400122:	490d      	ldr	r1, [pc, #52]	; (400158 <frame_dummy+0x3c>)
  400124:	b510      	push	{r4, lr}
  400126:	f3af 8000 	nop.w
  40012a:	480c      	ldr	r0, [pc, #48]	; (40015c <frame_dummy+0x40>)
  40012c:	6803      	ldr	r3, [r0, #0]
  40012e:	b923      	cbnz	r3, 40013a <frame_dummy+0x1e>
  400130:	bd10      	pop	{r4, pc}
  400132:	480a      	ldr	r0, [pc, #40]	; (40015c <frame_dummy+0x40>)
  400134:	6803      	ldr	r3, [r0, #0]
  400136:	b933      	cbnz	r3, 400146 <frame_dummy+0x2a>
  400138:	4770      	bx	lr
  40013a:	4b09      	ldr	r3, [pc, #36]	; (400160 <frame_dummy+0x44>)
  40013c:	2b00      	cmp	r3, #0
  40013e:	d0f7      	beq.n	400130 <frame_dummy+0x14>
  400140:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  400144:	4718      	bx	r3
  400146:	4b06      	ldr	r3, [pc, #24]	; (400160 <frame_dummy+0x44>)
  400148:	2b00      	cmp	r3, #0
  40014a:	d0f5      	beq.n	400138 <frame_dummy+0x1c>
  40014c:	4718      	bx	r3
  40014e:	bf00      	nop
  400150:	00000000 	.word	0x00000000
  400154:	004040f4 	.word	0x004040f4
  400158:	20000440 	.word	0x20000440
  40015c:	004040f4 	.word	0x004040f4
  400160:	00000000 	.word	0x00000000

00400164 <osc_get_rate>:

	return 0;
}

static inline uint32_t osc_get_rate(uint32_t ul_id)
{
  400164:	b480      	push	{r7}
  400166:	b083      	sub	sp, #12
  400168:	af00      	add	r7, sp, #0
  40016a:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  40016c:	687b      	ldr	r3, [r7, #4]
  40016e:	2b07      	cmp	r3, #7
  400170:	d825      	bhi.n	4001be <osc_get_rate+0x5a>
  400172:	a201      	add	r2, pc, #4	; (adr r2, 400178 <osc_get_rate+0x14>)
  400174:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  400178:	00400199 	.word	0x00400199
  40017c:	0040019f 	.word	0x0040019f
  400180:	004001a5 	.word	0x004001a5
  400184:	004001ab 	.word	0x004001ab
  400188:	004001af 	.word	0x004001af
  40018c:	004001b3 	.word	0x004001b3
  400190:	004001b7 	.word	0x004001b7
  400194:	004001bb 	.word	0x004001bb
	case OSC_SLCK_32K_RC:
		return OSC_SLCK_32K_RC_HZ;
  400198:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  40019c:	e010      	b.n	4001c0 <osc_get_rate+0x5c>

	case OSC_SLCK_32K_XTAL:
		return BOARD_FREQ_SLCK_XTAL;
  40019e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  4001a2:	e00d      	b.n	4001c0 <osc_get_rate+0x5c>

	case OSC_SLCK_32K_BYPASS:
		return BOARD_FREQ_SLCK_BYPASS;
  4001a4:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  4001a8:	e00a      	b.n	4001c0 <osc_get_rate+0x5c>

	case OSC_MAINCK_4M_RC:
		return OSC_MAINCK_4M_RC_HZ;
  4001aa:	4b08      	ldr	r3, [pc, #32]	; (4001cc <osc_get_rate+0x68>)
  4001ac:	e008      	b.n	4001c0 <osc_get_rate+0x5c>

	case OSC_MAINCK_8M_RC:
		return OSC_MAINCK_8M_RC_HZ;
  4001ae:	4b08      	ldr	r3, [pc, #32]	; (4001d0 <osc_get_rate+0x6c>)
  4001b0:	e006      	b.n	4001c0 <osc_get_rate+0x5c>

	case OSC_MAINCK_12M_RC:
		return OSC_MAINCK_12M_RC_HZ;
  4001b2:	4b08      	ldr	r3, [pc, #32]	; (4001d4 <osc_get_rate+0x70>)
  4001b4:	e004      	b.n	4001c0 <osc_get_rate+0x5c>

	case OSC_MAINCK_XTAL:
		return BOARD_FREQ_MAINCK_XTAL;
  4001b6:	4b07      	ldr	r3, [pc, #28]	; (4001d4 <osc_get_rate+0x70>)
  4001b8:	e002      	b.n	4001c0 <osc_get_rate+0x5c>

	case OSC_MAINCK_BYPASS:
		return BOARD_FREQ_MAINCK_BYPASS;
  4001ba:	4b06      	ldr	r3, [pc, #24]	; (4001d4 <osc_get_rate+0x70>)
  4001bc:	e000      	b.n	4001c0 <osc_get_rate+0x5c>
	}

	return 0;
  4001be:	2300      	movs	r3, #0
}
  4001c0:	4618      	mov	r0, r3
  4001c2:	370c      	adds	r7, #12
  4001c4:	46bd      	mov	sp, r7
  4001c6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4001ca:	4770      	bx	lr
  4001cc:	003d0900 	.word	0x003d0900
  4001d0:	007a1200 	.word	0x007a1200
  4001d4:	00b71b00 	.word	0x00b71b00

004001d8 <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern uint32_t sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
  4001d8:	b580      	push	{r7, lr}
  4001da:	af00      	add	r7, sp, #0
	} else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_MAINCK_BYPASS) {
		return OSC_MAINCK_BYPASS_HZ;
	}
#ifdef CONFIG_PLL0_SOURCE
	else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_PLLACK) {
		return pll_get_default_rate(0);
  4001dc:	2006      	movs	r0, #6
  4001de:	4b03      	ldr	r3, [pc, #12]	; (4001ec <sysclk_get_main_hz+0x14>)
  4001e0:	4798      	blx	r3
  4001e2:	4603      	mov	r3, r0
  4001e4:	011b      	lsls	r3, r3, #4

	else {
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
  4001e6:	4618      	mov	r0, r3
  4001e8:	bd80      	pop	{r7, pc}
  4001ea:	bf00      	nop
  4001ec:	00400165 	.word	0x00400165

004001f0 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
  4001f0:	b580      	push	{r7, lr}
  4001f2:	af00      	add	r7, sp, #0
	/* CONFIG_SYSCLK_PRES is the register value for setting the expected */
	/* prescaler, not an immediate value. */
	return sysclk_get_main_hz() /
  4001f4:	4b02      	ldr	r3, [pc, #8]	; (400200 <sysclk_get_cpu_hz+0x10>)
  4001f6:	4798      	blx	r3
  4001f8:	4603      	mov	r3, r0
  4001fa:	085b      	lsrs	r3, r3, #1
		((CONFIG_SYSCLK_PRES == SYSCLK_PRES_3) ? 3 :
			(1 << (CONFIG_SYSCLK_PRES >> PMC_MCKR_PRES_Pos)));
}
  4001fc:	4618      	mov	r0, r3
  4001fe:	bd80      	pop	{r7, pc}
  400200:	004001d9 	.word	0x004001d9

00400204 <sysclk_get_peripheral_hz>:
 * \brief Retrieves the current rate in Hz of the peripheral clocks.
 *
 * \return Frequency of the peripheral clocks, in Hz.
 */
static inline uint32_t sysclk_get_peripheral_hz(void)
{
  400204:	b580      	push	{r7, lr}
  400206:	af00      	add	r7, sp, #0
	/* CONFIG_SYSCLK_PRES is the register value for setting the expected */
	/* prescaler, not an immediate value. */
	return sysclk_get_main_hz() /
  400208:	4b02      	ldr	r3, [pc, #8]	; (400214 <sysclk_get_peripheral_hz+0x10>)
  40020a:	4798      	blx	r3
  40020c:	4603      	mov	r3, r0
  40020e:	085b      	lsrs	r3, r3, #1
		((CONFIG_SYSCLK_PRES == SYSCLK_PRES_3) ? 3 :
			(1 << (CONFIG_SYSCLK_PRES >> PMC_MCKR_PRES_Pos)));
}
  400210:	4618      	mov	r0, r3
  400212:	bd80      	pop	{r7, pc}
  400214:	004001d9 	.word	0x004001d9

00400218 <sysclk_enable_peripheral_clock>:
 * \brief Enable a peripheral's clock.
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
  400218:	b580      	push	{r7, lr}
  40021a:	b082      	sub	sp, #8
  40021c:	af00      	add	r7, sp, #0
  40021e:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  400220:	6878      	ldr	r0, [r7, #4]
  400222:	4b03      	ldr	r3, [pc, #12]	; (400230 <sysclk_enable_peripheral_clock+0x18>)
  400224:	4798      	blx	r3
}
  400226:	bf00      	nop
  400228:	3708      	adds	r7, #8
  40022a:	46bd      	mov	sp, r7
  40022c:	bd80      	pop	{r7, pc}
  40022e:	bf00      	nop
  400230:	00403215 	.word	0x00403215

00400234 <twi_master_setup>:
typedef twi_options_t twi_master_options_t;
typedef twi_packet_t twi_package_t;

static inline uint32_t twi_master_setup(twi_master_t p_twi,
		twi_master_options_t *p_opt)
{
  400234:	b580      	push	{r7, lr}
  400236:	b082      	sub	sp, #8
  400238:	af00      	add	r7, sp, #0
  40023a:	6078      	str	r0, [r7, #4]
  40023c:	6039      	str	r1, [r7, #0]
	p_opt->master_clk = sysclk_get_peripheral_hz();
  40023e:	4b10      	ldr	r3, [pc, #64]	; (400280 <twi_master_setup+0x4c>)
  400240:	4798      	blx	r3
  400242:	4602      	mov	r2, r0
  400244:	683b      	ldr	r3, [r7, #0]
  400246:	601a      	str	r2, [r3, #0]
	p_opt->smbus      = 0;
  400248:	683b      	ldr	r3, [r7, #0]
  40024a:	2200      	movs	r2, #0
  40024c:	725a      	strb	r2, [r3, #9]
	} else {
		// Do Nothing
	}
#else
#if (!(SAMG51 || SAMG53 || SAMG54))
	if (p_twi == TWI0) {
  40024e:	687b      	ldr	r3, [r7, #4]
  400250:	4a0c      	ldr	r2, [pc, #48]	; (400284 <twi_master_setup+0x50>)
  400252:	4293      	cmp	r3, r2
  400254:	d103      	bne.n	40025e <twi_master_setup+0x2a>
		sysclk_enable_peripheral_clock(ID_TWI0);
  400256:	2011      	movs	r0, #17
  400258:	4b0b      	ldr	r3, [pc, #44]	; (400288 <twi_master_setup+0x54>)
  40025a:	4798      	blx	r3
  40025c:	e006      	b.n	40026c <twi_master_setup+0x38>
	} else
#endif
	if (p_twi == TWI1) {
  40025e:	687b      	ldr	r3, [r7, #4]
  400260:	4a0a      	ldr	r2, [pc, #40]	; (40028c <twi_master_setup+0x58>)
  400262:	4293      	cmp	r3, r2
  400264:	d102      	bne.n	40026c <twi_master_setup+0x38>
		sysclk_enable_peripheral_clock(ID_TWI1);
  400266:	2012      	movs	r0, #18
  400268:	4b07      	ldr	r3, [pc, #28]	; (400288 <twi_master_setup+0x54>)
  40026a:	4798      	blx	r3
	} else {
		// Do Nothing
	}
#endif

	return (twi_master_init(p_twi, p_opt));
  40026c:	6839      	ldr	r1, [r7, #0]
  40026e:	6878      	ldr	r0, [r7, #4]
  400270:	4b07      	ldr	r3, [pc, #28]	; (400290 <twi_master_setup+0x5c>)
  400272:	4798      	blx	r3
  400274:	4603      	mov	r3, r0
}
  400276:	4618      	mov	r0, r3
  400278:	3708      	adds	r7, #8
  40027a:	46bd      	mov	sp, r7
  40027c:	bd80      	pop	{r7, pc}
  40027e:	bf00      	nop
  400280:	00400205 	.word	0x00400205
  400284:	400a8000 	.word	0x400a8000
  400288:	00400219 	.word	0x00400219
  40028c:	400ac000 	.word	0x400ac000
  400290:	00403321 	.word	0x00403321

00400294 <bsp_hw_init>:
static void m_bsp_i2c_init(void);
static void m_bsp_sdcard_init(void);

/* Function definitions ----------------------------------------------- */
void bsp_hw_init(void)
{
  400294:	b580      	push	{r7, lr}
  400296:	af00      	add	r7, sp, #0
  m_bsp_i2c_init();
  400298:	4b03      	ldr	r3, [pc, #12]	; (4002a8 <bsp_hw_init+0x14>)
  40029a:	4798      	blx	r3
  bsp_gpio_init();
  40029c:	4b03      	ldr	r3, [pc, #12]	; (4002ac <bsp_hw_init+0x18>)
  40029e:	4798      	blx	r3
  m_bsp_sdcard_init();
  4002a0:	4b03      	ldr	r3, [pc, #12]	; (4002b0 <bsp_hw_init+0x1c>)
  4002a2:	4798      	blx	r3
}
  4002a4:	bf00      	nop
  4002a6:	bd80      	pop	{r7, pc}
  4002a8:	004003b1 	.word	0x004003b1
  4002ac:	00400669 	.word	0x00400669
  4002b0:	004003e5 	.word	0x004003e5

004002b4 <bsp_i2c_write>:

int bsp_i2c_write(uint8_t slave_addr, uint8_t reg_addr, uint8_t *p_data, uint32_t len)
{
  4002b4:	b580      	push	{r7, lr}
  4002b6:	b08a      	sub	sp, #40	; 0x28
  4002b8:	af00      	add	r7, sp, #0
  4002ba:	60ba      	str	r2, [r7, #8]
  4002bc:	607b      	str	r3, [r7, #4]
  4002be:	4603      	mov	r3, r0
  4002c0:	73fb      	strb	r3, [r7, #15]
  4002c2:	460b      	mov	r3, r1
  4002c4:	73bb      	strb	r3, [r7, #14]
  twi_package_t packet_write;

  packet_write.chip        = slave_addr;        // TWI slave bus address
  4002c6:	7bfb      	ldrb	r3, [r7, #15]
  4002c8:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
  packet_write.addr[0]     = reg_addr;          // TWI slave memory address data
  4002cc:	7bbb      	ldrb	r3, [r7, #14]
  4002ce:	753b      	strb	r3, [r7, #20]
  packet_write.addr_length = sizeof(reg_addr);  // TWI slave memory address data size
  4002d0:	2301      	movs	r3, #1
  4002d2:	61bb      	str	r3, [r7, #24]
  packet_write.buffer      = (void *)p_data;    // Transfer data source buffer
  4002d4:	68bb      	ldr	r3, [r7, #8]
  4002d6:	61fb      	str	r3, [r7, #28]
  packet_write.length      = len;               // Transfer data size (bytes)
  4002d8:	687b      	ldr	r3, [r7, #4]
  4002da:	623b      	str	r3, [r7, #32]

  return twi_master_write(TWI0, &packet_write);
  4002dc:	f107 0314 	add.w	r3, r7, #20
  4002e0:	4619      	mov	r1, r3
  4002e2:	4804      	ldr	r0, [pc, #16]	; (4002f4 <bsp_i2c_write+0x40>)
  4002e4:	4b04      	ldr	r3, [pc, #16]	; (4002f8 <bsp_i2c_write+0x44>)
  4002e6:	4798      	blx	r3
  4002e8:	4603      	mov	r3, r0
}
  4002ea:	4618      	mov	r0, r3
  4002ec:	3728      	adds	r7, #40	; 0x28
  4002ee:	46bd      	mov	sp, r7
  4002f0:	bd80      	pop	{r7, pc}
  4002f2:	bf00      	nop
  4002f4:	400a8000 	.word	0x400a8000
  4002f8:	00403385 	.word	0x00403385
  4002fc:	00000000 	.word	0x00000000

00400300 <bsp_delay>:

void bsp_delay(uint32_t ms)
{
  400300:	b5f0      	push	{r4, r5, r6, r7, lr}
  400302:	b083      	sub	sp, #12
  400304:	af00      	add	r7, sp, #0
  400306:	6078      	str	r0, [r7, #4]
  delay_ms(ms);
  400308:	687b      	ldr	r3, [r7, #4]
  40030a:	2b00      	cmp	r3, #0
  40030c:	d026      	beq.n	40035c <bsp_delay+0x5c>
  40030e:	687b      	ldr	r3, [r7, #4]
  400310:	461d      	mov	r5, r3
  400312:	f04f 0600 	mov.w	r6, #0
  400316:	4b22      	ldr	r3, [pc, #136]	; (4003a0 <bsp_delay+0xa0>)
  400318:	4798      	blx	r3
  40031a:	4603      	mov	r3, r0
  40031c:	f04f 0400 	mov.w	r4, #0
  400320:	fb03 f106 	mul.w	r1, r3, r6
  400324:	fb05 f204 	mul.w	r2, r5, r4
  400328:	440a      	add	r2, r1
  40032a:	fba5 3403 	umull	r3, r4, r5, r3
  40032e:	4422      	add	r2, r4
  400330:	4614      	mov	r4, r2
  400332:	f243 61af 	movw	r1, #13999	; 0x36af
  400336:	f04f 0200 	mov.w	r2, #0
  40033a:	185d      	adds	r5, r3, r1
  40033c:	eb44 0602 	adc.w	r6, r4, r2
  400340:	4628      	mov	r0, r5
  400342:	4631      	mov	r1, r6
  400344:	4c17      	ldr	r4, [pc, #92]	; (4003a4 <bsp_delay+0xa4>)
  400346:	f243 62b0 	movw	r2, #14000	; 0x36b0
  40034a:	f04f 0300 	mov.w	r3, #0
  40034e:	47a0      	blx	r4
  400350:	4603      	mov	r3, r0
  400352:	460c      	mov	r4, r1
  400354:	4618      	mov	r0, r3
  400356:	4b14      	ldr	r3, [pc, #80]	; (4003a8 <bsp_delay+0xa8>)
  400358:	4798      	blx	r3
}
  40035a:	e016      	b.n	40038a <bsp_delay+0x8a>
  delay_ms(ms);
  40035c:	4b10      	ldr	r3, [pc, #64]	; (4003a0 <bsp_delay+0xa0>)
  40035e:	4798      	blx	r3
  400360:	4603      	mov	r3, r0
  400362:	f04f 0400 	mov.w	r4, #0
  400366:	a20c      	add	r2, pc, #48	; (adr r2, 400398 <bsp_delay+0x98>)
  400368:	e9d2 1200 	ldrd	r1, r2, [r2]
  40036c:	185d      	adds	r5, r3, r1
  40036e:	eb44 0602 	adc.w	r6, r4, r2
  400372:	4628      	mov	r0, r5
  400374:	4631      	mov	r1, r6
  400376:	4c0b      	ldr	r4, [pc, #44]	; (4003a4 <bsp_delay+0xa4>)
  400378:	4a0c      	ldr	r2, [pc, #48]	; (4003ac <bsp_delay+0xac>)
  40037a:	f04f 0300 	mov.w	r3, #0
  40037e:	47a0      	blx	r4
  400380:	4603      	mov	r3, r0
  400382:	460c      	mov	r4, r1
  400384:	4618      	mov	r0, r3
  400386:	4b08      	ldr	r3, [pc, #32]	; (4003a8 <bsp_delay+0xa8>)
  400388:	4798      	blx	r3
}
  40038a:	bf00      	nop
  40038c:	370c      	adds	r7, #12
  40038e:	46bd      	mov	sp, r7
  400390:	bdf0      	pop	{r4, r5, r6, r7, pc}
  400392:	bf00      	nop
  400394:	f3af 8000 	nop.w
  400398:	00d59f7f 	.word	0x00d59f7f
  40039c:	00000000 	.word	0x00000000
  4003a0:	004001f1 	.word	0x004001f1
  4003a4:	0040340d 	.word	0x0040340d
  4003a8:	20000001 	.word	0x20000001
  4003ac:	00d59f80 	.word	0x00d59f80

004003b0 <m_bsp_i2c_init>:
/* Private function definitions ---------------------------------------- */
/**
 * @brief I2C init
 */
static void m_bsp_i2c_init(void)
{
  4003b0:	b580      	push	{r7, lr}
  4003b2:	b084      	sub	sp, #16
  4003b4:	af00      	add	r7, sp, #0
  twi_master_options_t opt = {
  4003b6:	1d3b      	adds	r3, r7, #4
  4003b8:	2200      	movs	r2, #0
  4003ba:	601a      	str	r2, [r3, #0]
  4003bc:	605a      	str	r2, [r3, #4]
  4003be:	609a      	str	r2, [r3, #8]
  4003c0:	4b05      	ldr	r3, [pc, #20]	; (4003d8 <m_bsp_i2c_init+0x28>)
  4003c2:	60bb      	str	r3, [r7, #8]
      .speed = 100000
  };

  twi_master_setup(TWI0, &opt);
  4003c4:	1d3b      	adds	r3, r7, #4
  4003c6:	4619      	mov	r1, r3
  4003c8:	4804      	ldr	r0, [pc, #16]	; (4003dc <m_bsp_i2c_init+0x2c>)
  4003ca:	4b05      	ldr	r3, [pc, #20]	; (4003e0 <m_bsp_i2c_init+0x30>)
  4003cc:	4798      	blx	r3
}
  4003ce:	bf00      	nop
  4003d0:	3710      	adds	r7, #16
  4003d2:	46bd      	mov	sp, r7
  4003d4:	bd80      	pop	{r7, pc}
  4003d6:	bf00      	nop
  4003d8:	000186a0 	.word	0x000186a0
  4003dc:	400a8000 	.word	0x400a8000
  4003e0:	00400235 	.word	0x00400235

004003e4 <m_bsp_sdcard_init>:

/**
 * @brief Sdcard init
 */
static void m_bsp_sdcard_init(void)
{
  4003e4:	b580      	push	{r7, lr}
  4003e6:	b082      	sub	sp, #8
  4003e8:	af00      	add	r7, sp, #0
  Ctrl_status status;

  // Enable PIOA clock to detect Card Detect (CD) change
  sysclk_enable_peripheral_clock(ID_PIOA);
  4003ea:	2009      	movs	r0, #9
  4003ec:	4b10      	ldr	r3, [pc, #64]	; (400430 <m_bsp_sdcard_init+0x4c>)
  4003ee:	4798      	blx	r3

  // Configure SD card pins as per MCI peripheral (periph C)
  pio_set_peripheral(PIOA, PIO_PERIPH_C, PIO_PA30C_MCDA0 | // MCI Data 0
  4003f0:	f04f 427c 	mov.w	r2, #4227858432	; 0xfc000000
  4003f4:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  4003f8:	480e      	ldr	r0, [pc, #56]	; (400434 <m_bsp_sdcard_init+0x50>)
  4003fa:	4b0f      	ldr	r3, [pc, #60]	; (400438 <m_bsp_sdcard_init+0x54>)
  4003fc:	4798      	blx	r3
                                         PIO_PA27C_MCDA3 | // MCI Data 3
                                         PIO_PA28C_MCCDA | // MCI Command
                                         PIO_PA29C_MCCK);  // MCI Clock

  // Initialize SD MMC stack
  sd_mmc_init();
  4003fe:	4b0f      	ldr	r3, [pc, #60]	; (40043c <m_bsp_sdcard_init+0x58>)
  400400:	4798      	blx	r3

  //  Wait until SD stack initialized and SD card inserted
  do
  {
    // Check if stack ready
    status = sd_mmc_test_unit_ready(0);
  400402:	2000      	movs	r0, #0
  400404:	4b0e      	ldr	r3, [pc, #56]	; (400440 <m_bsp_sdcard_init+0x5c>)
  400406:	4798      	blx	r3
  400408:	4603      	mov	r3, r0
  40040a:	71fb      	strb	r3, [r7, #7]
    if (status == CTRL_FAIL)
  40040c:	79fb      	ldrb	r3, [r7, #7]
  40040e:	2b01      	cmp	r3, #1
  400410:	d106      	bne.n	400420 <m_bsp_sdcard_init+0x3c>
    {
      // Wait for a card to be inserted
      while (sd_mmc_check(0) != CTRL_NO_PRESENT)
  400412:	bf00      	nop
  400414:	2000      	movs	r0, #0
  400416:	4b0b      	ldr	r3, [pc, #44]	; (400444 <m_bsp_sdcard_init+0x60>)
  400418:	4798      	blx	r3
  40041a:	4603      	mov	r3, r0
  40041c:	2b02      	cmp	r3, #2
  40041e:	d1f9      	bne.n	400414 <m_bsp_sdcard_init+0x30>
      {
        // Use a timeout here for real projects.
      }
    }
  } while (status != CTRL_GOOD);
  400420:	79fb      	ldrb	r3, [r7, #7]
  400422:	2b00      	cmp	r3, #0
  400424:	d1ed      	bne.n	400402 <m_bsp_sdcard_init+0x1e>
}
  400426:	bf00      	nop
  400428:	3708      	adds	r7, #8
  40042a:	46bd      	mov	sp, r7
  40042c:	bd80      	pop	{r7, pc}
  40042e:	bf00      	nop
  400430:	00400219 	.word	0x00400219
  400434:	400e0e00 	.word	0x400e0e00
  400438:	00403019 	.word	0x00403019
  40043c:	00401c69 	.word	0x00401c69
  400440:	00401d4d 	.word	0x00401d4d
  400444:	00401cad 	.word	0x00401cad

00400448 <osc_get_rate>:
{
  400448:	b480      	push	{r7}
  40044a:	b083      	sub	sp, #12
  40044c:	af00      	add	r7, sp, #0
  40044e:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  400450:	687b      	ldr	r3, [r7, #4]
  400452:	2b07      	cmp	r3, #7
  400454:	d825      	bhi.n	4004a2 <osc_get_rate+0x5a>
  400456:	a201      	add	r2, pc, #4	; (adr r2, 40045c <osc_get_rate+0x14>)
  400458:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  40045c:	0040047d 	.word	0x0040047d
  400460:	00400483 	.word	0x00400483
  400464:	00400489 	.word	0x00400489
  400468:	0040048f 	.word	0x0040048f
  40046c:	00400493 	.word	0x00400493
  400470:	00400497 	.word	0x00400497
  400474:	0040049b 	.word	0x0040049b
  400478:	0040049f 	.word	0x0040049f
		return OSC_SLCK_32K_RC_HZ;
  40047c:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  400480:	e010      	b.n	4004a4 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_XTAL;
  400482:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  400486:	e00d      	b.n	4004a4 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_BYPASS;
  400488:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  40048c:	e00a      	b.n	4004a4 <osc_get_rate+0x5c>
		return OSC_MAINCK_4M_RC_HZ;
  40048e:	4b08      	ldr	r3, [pc, #32]	; (4004b0 <osc_get_rate+0x68>)
  400490:	e008      	b.n	4004a4 <osc_get_rate+0x5c>
		return OSC_MAINCK_8M_RC_HZ;
  400492:	4b08      	ldr	r3, [pc, #32]	; (4004b4 <osc_get_rate+0x6c>)
  400494:	e006      	b.n	4004a4 <osc_get_rate+0x5c>
		return OSC_MAINCK_12M_RC_HZ;
  400496:	4b08      	ldr	r3, [pc, #32]	; (4004b8 <osc_get_rate+0x70>)
  400498:	e004      	b.n	4004a4 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_XTAL;
  40049a:	4b07      	ldr	r3, [pc, #28]	; (4004b8 <osc_get_rate+0x70>)
  40049c:	e002      	b.n	4004a4 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_BYPASS;
  40049e:	4b06      	ldr	r3, [pc, #24]	; (4004b8 <osc_get_rate+0x70>)
  4004a0:	e000      	b.n	4004a4 <osc_get_rate+0x5c>
	return 0;
  4004a2:	2300      	movs	r3, #0
}
  4004a4:	4618      	mov	r0, r3
  4004a6:	370c      	adds	r7, #12
  4004a8:	46bd      	mov	sp, r7
  4004aa:	f85d 7b04 	ldr.w	r7, [sp], #4
  4004ae:	4770      	bx	lr
  4004b0:	003d0900 	.word	0x003d0900
  4004b4:	007a1200 	.word	0x007a1200
  4004b8:	00b71b00 	.word	0x00b71b00

004004bc <sysclk_get_main_hz>:
{
  4004bc:	b580      	push	{r7, lr}
  4004be:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  4004c0:	2006      	movs	r0, #6
  4004c2:	4b03      	ldr	r3, [pc, #12]	; (4004d0 <sysclk_get_main_hz+0x14>)
  4004c4:	4798      	blx	r3
  4004c6:	4603      	mov	r3, r0
  4004c8:	011b      	lsls	r3, r3, #4
}
  4004ca:	4618      	mov	r0, r3
  4004cc:	bd80      	pop	{r7, pc}
  4004ce:	bf00      	nop
  4004d0:	00400449 	.word	0x00400449

004004d4 <sysclk_get_cpu_hz>:
{
  4004d4:	b580      	push	{r7, lr}
  4004d6:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  4004d8:	4b02      	ldr	r3, [pc, #8]	; (4004e4 <sysclk_get_cpu_hz+0x10>)
  4004da:	4798      	blx	r3
  4004dc:	4603      	mov	r3, r0
  4004de:	085b      	lsrs	r3, r3, #1
}
  4004e0:	4618      	mov	r0, r3
  4004e2:	bd80      	pop	{r7, pc}
  4004e4:	004004bd 	.word	0x004004bd

004004e8 <bsp_can_init>:
can_mb_conf_t m_can1_mailbox;

/* Private function prototypes ---------------------------------------- */
/* Function definitions ----------------------------------------------- */
void bsp_can_init(void)
{
  4004e8:	b580      	push	{r7, lr}
  4004ea:	b082      	sub	sp, #8
  4004ec:	af00      	add	r7, sp, #0
  uint32_t ul_sysclk = sysclk_get_cpu_hz();
  4004ee:	4b1b      	ldr	r3, [pc, #108]	; (40055c <bsp_can_init+0x74>)
  4004f0:	4798      	blx	r3
  4004f2:	6078      	str	r0, [r7, #4]

  pmc_enable_periph_clk(ID_CAN1);
  4004f4:	2026      	movs	r0, #38	; 0x26
  4004f6:	4b1a      	ldr	r3, [pc, #104]	; (400560 <bsp_can_init+0x78>)
  4004f8:	4798      	blx	r3

  can_init(CAN1, ul_sysclk, CAN_BPS_250K);
  4004fa:	22fa      	movs	r2, #250	; 0xfa
  4004fc:	6879      	ldr	r1, [r7, #4]
  4004fe:	4819      	ldr	r0, [pc, #100]	; (400564 <bsp_can_init+0x7c>)
  400500:	4b19      	ldr	r3, [pc, #100]	; (400568 <bsp_can_init+0x80>)
  400502:	4798      	blx	r3
  can_reset_all_mailbox(CAN1);
  400504:	4817      	ldr	r0, [pc, #92]	; (400564 <bsp_can_init+0x7c>)
  400506:	4b19      	ldr	r3, [pc, #100]	; (40056c <bsp_can_init+0x84>)
  400508:	4798      	blx	r3

  m_can1_mailbox.ul_mb_idx   = 0;
  40050a:	4b19      	ldr	r3, [pc, #100]	; (400570 <bsp_can_init+0x88>)
  40050c:	2200      	movs	r2, #0
  40050e:	601a      	str	r2, [r3, #0]
  m_can1_mailbox.uc_obj_type = CAN_MB_TX_MODE;
  400510:	4b17      	ldr	r3, [pc, #92]	; (400570 <bsp_can_init+0x88>)
  400512:	2203      	movs	r2, #3
  400514:	711a      	strb	r2, [r3, #4]
  m_can1_mailbox.uc_tx_prio  = 15;
  400516:	4b16      	ldr	r3, [pc, #88]	; (400570 <bsp_can_init+0x88>)
  400518:	220f      	movs	r2, #15
  40051a:	71da      	strb	r2, [r3, #7]
  m_can1_mailbox.uc_id_ver   = 0;
  40051c:	4b14      	ldr	r3, [pc, #80]	; (400570 <bsp_can_init+0x88>)
  40051e:	2200      	movs	r2, #0
  400520:	715a      	strb	r2, [r3, #5]
  m_can1_mailbox.ul_id_msk   = 0;
  400522:	4b13      	ldr	r3, [pc, #76]	; (400570 <bsp_can_init+0x88>)
  400524:	2200      	movs	r2, #0
  400526:	60da      	str	r2, [r3, #12]
  can_mailbox_init(CAN1, &m_can1_mailbox);
  400528:	4911      	ldr	r1, [pc, #68]	; (400570 <bsp_can_init+0x88>)
  40052a:	480e      	ldr	r0, [pc, #56]	; (400564 <bsp_can_init+0x7c>)
  40052c:	4b11      	ldr	r3, [pc, #68]	; (400574 <bsp_can_init+0x8c>)
  40052e:	4798      	blx	r3
  
  m_can1_mailbox.ul_id     = CAN_MID_MIDvA(0x07);
  400530:	4b0f      	ldr	r3, [pc, #60]	; (400570 <bsp_can_init+0x88>)
  400532:	f44f 12e0 	mov.w	r2, #1835008	; 0x1c0000
  400536:	611a      	str	r2, [r3, #16]
  m_can1_mailbox.ul_datal  = 0x12345678;
  400538:	4b0d      	ldr	r3, [pc, #52]	; (400570 <bsp_can_init+0x88>)
  40053a:	4a0f      	ldr	r2, [pc, #60]	; (400578 <bsp_can_init+0x90>)
  40053c:	619a      	str	r2, [r3, #24]
  m_can1_mailbox.ul_datah  = 0x87654321;
  40053e:	4b0c      	ldr	r3, [pc, #48]	; (400570 <bsp_can_init+0x88>)
  400540:	4a0e      	ldr	r2, [pc, #56]	; (40057c <bsp_can_init+0x94>)
  400542:	61da      	str	r2, [r3, #28]
  m_can1_mailbox.uc_length = 8;
  400544:	4b0a      	ldr	r3, [pc, #40]	; (400570 <bsp_can_init+0x88>)
  400546:	2208      	movs	r2, #8
  400548:	719a      	strb	r2, [r3, #6]
  can_mailbox_write(CAN1, &m_can1_mailbox);
  40054a:	4909      	ldr	r1, [pc, #36]	; (400570 <bsp_can_init+0x88>)
  40054c:	4805      	ldr	r0, [pc, #20]	; (400564 <bsp_can_init+0x7c>)
  40054e:	4b0c      	ldr	r3, [pc, #48]	; (400580 <bsp_can_init+0x98>)
  400550:	4798      	blx	r3
}
  400552:	bf00      	nop
  400554:	3708      	adds	r7, #8
  400556:	46bd      	mov	sp, r7
  400558:	bd80      	pop	{r7, pc}
  40055a:	bf00      	nop
  40055c:	004004d5 	.word	0x004004d5
  400560:	00403215 	.word	0x00403215
  400564:	40014000 	.word	0x40014000
  400568:	00402f1d 	.word	0x00402f1d
  40056c:	00402ef9 	.word	0x00402ef9
  400570:	20000504 	.word	0x20000504
  400574:	00402e0d 	.word	0x00402e0d
  400578:	12345678 	.word	0x12345678
  40057c:	87654321 	.word	0x87654321
  400580:	00402e8f 	.word	0x00402e8f

00400584 <bsp_can_send>:

void bsp_can_send(void)
{
  400584:	b580      	push	{r7, lr}
  400586:	af00      	add	r7, sp, #0
  can_global_send_transfer_cmd(CAN1, CAN_TCR_MB0);
  400588:	2101      	movs	r1, #1
  40058a:	4802      	ldr	r0, [pc, #8]	; (400594 <bsp_can_send+0x10>)
  40058c:	4b02      	ldr	r3, [pc, #8]	; (400598 <bsp_can_send+0x14>)
  40058e:	4798      	blx	r3
}
  400590:	bf00      	nop
  400592:	bd80      	pop	{r7, pc}
  400594:	40014000 	.word	0x40014000
  400598:	00402e01 	.word	0x00402e01

0040059c <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  40059c:	b480      	push	{r7}
  40059e:	b083      	sub	sp, #12
  4005a0:	af00      	add	r7, sp, #0
  4005a2:	4603      	mov	r3, r0
  4005a4:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
  4005a6:	f997 3007 	ldrsb.w	r3, [r7, #7]
  4005aa:	2b00      	cmp	r3, #0
  4005ac:	db0b      	blt.n	4005c6 <__NVIC_EnableIRQ+0x2a>
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  4005ae:	4909      	ldr	r1, [pc, #36]	; (4005d4 <__NVIC_EnableIRQ+0x38>)
  4005b0:	f997 3007 	ldrsb.w	r3, [r7, #7]
  4005b4:	095b      	lsrs	r3, r3, #5
  4005b6:	79fa      	ldrb	r2, [r7, #7]
  4005b8:	f002 021f 	and.w	r2, r2, #31
  4005bc:	2001      	movs	r0, #1
  4005be:	fa00 f202 	lsl.w	r2, r0, r2
  4005c2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
  4005c6:	bf00      	nop
  4005c8:	370c      	adds	r7, #12
  4005ca:	46bd      	mov	sp, r7
  4005cc:	f85d 7b04 	ldr.w	r7, [sp], #4
  4005d0:	4770      	bx	lr
  4005d2:	bf00      	nop
  4005d4:	e000e100 	.word	0xe000e100

004005d8 <__NVIC_ClearPendingIRQ>:
  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  4005d8:	b480      	push	{r7}
  4005da:	b083      	sub	sp, #12
  4005dc:	af00      	add	r7, sp, #0
  4005de:	4603      	mov	r3, r0
  4005e0:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
  4005e2:	f997 3007 	ldrsb.w	r3, [r7, #7]
  4005e6:	2b00      	cmp	r3, #0
  4005e8:	db0c      	blt.n	400604 <__NVIC_ClearPendingIRQ+0x2c>
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  4005ea:	4909      	ldr	r1, [pc, #36]	; (400610 <__NVIC_ClearPendingIRQ+0x38>)
  4005ec:	f997 3007 	ldrsb.w	r3, [r7, #7]
  4005f0:	095b      	lsrs	r3, r3, #5
  4005f2:	79fa      	ldrb	r2, [r7, #7]
  4005f4:	f002 021f 	and.w	r2, r2, #31
  4005f8:	2001      	movs	r0, #1
  4005fa:	fa00 f202 	lsl.w	r2, r0, r2
  4005fe:	3360      	adds	r3, #96	; 0x60
  400600:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
  400604:	bf00      	nop
  400606:	370c      	adds	r7, #12
  400608:	46bd      	mov	sp, r7
  40060a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40060e:	4770      	bx	lr
  400610:	e000e100 	.word	0xe000e100

00400614 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  400614:	b480      	push	{r7}
  400616:	b083      	sub	sp, #12
  400618:	af00      	add	r7, sp, #0
  40061a:	4603      	mov	r3, r0
  40061c:	6039      	str	r1, [r7, #0]
  40061e:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
  400620:	f997 3007 	ldrsb.w	r3, [r7, #7]
  400624:	2b00      	cmp	r3, #0
  400626:	db0a      	blt.n	40063e <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  400628:	490d      	ldr	r1, [pc, #52]	; (400660 <__NVIC_SetPriority+0x4c>)
  40062a:	f997 3007 	ldrsb.w	r3, [r7, #7]
  40062e:	683a      	ldr	r2, [r7, #0]
  400630:	b2d2      	uxtb	r2, r2
  400632:	0112      	lsls	r2, r2, #4
  400634:	b2d2      	uxtb	r2, r2
  400636:	440b      	add	r3, r1
  400638:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
  40063c:	e00a      	b.n	400654 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  40063e:	4909      	ldr	r1, [pc, #36]	; (400664 <__NVIC_SetPriority+0x50>)
  400640:	79fb      	ldrb	r3, [r7, #7]
  400642:	f003 030f 	and.w	r3, r3, #15
  400646:	3b04      	subs	r3, #4
  400648:	683a      	ldr	r2, [r7, #0]
  40064a:	b2d2      	uxtb	r2, r2
  40064c:	0112      	lsls	r2, r2, #4
  40064e:	b2d2      	uxtb	r2, r2
  400650:	440b      	add	r3, r1
  400652:	761a      	strb	r2, [r3, #24]
}
  400654:	bf00      	nop
  400656:	370c      	adds	r7, #12
  400658:	46bd      	mov	sp, r7
  40065a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40065e:	4770      	bx	lr
  400660:	e000e100 	.word	0xe000e100
  400664:	e000ed00 	.word	0xe000ed00

00400668 <bsp_gpio_init>:
/* Private macros ----------------------------------------------------- */
/* Public variables --------------------------------------------------- */
/* Private variables -------------------------------------------------- */
/* Private function prototypes ---------------------------------------- */
void bsp_gpio_init(void)
{
  400668:	b5b0      	push	{r4, r5, r7, lr}
  40066a:	b084      	sub	sp, #16
  40066c:	af02      	add	r7, sp, #8
  #define PORT       BSP_IO_GET_PORT(&IO_SENSOR[i])
  #define PORT_ID    BSP_IO_GET_PORT_ID(&IO_SENSOR[i])
  #define PIN        BSP_IO_GET_PIN(&IO_SENSOR[i])
  #define PIN_INDEX  BSP_IO_GET_PIN_INDEX(&IO_SENSOR[i])

  for (uint8_t i = 1; i <= SENSOR_COUNT_MAX; i++)
  40066e:	2301      	movs	r3, #1
  400670:	71fb      	strb	r3, [r7, #7]
  400672:	e042      	b.n	4006fa <bsp_gpio_init+0x92>
  {
    // Configure as input with pull-up and denouncing
    pio_set_input(PORT, PIN, PIO_INPUT | PIO_PULLUP | PIO_DEBOUNCE);
  400674:	79fb      	ldrb	r3, [r7, #7]
  400676:	011b      	lsls	r3, r3, #4
  400678:	4a3c      	ldr	r2, [pc, #240]	; (40076c <bsp_gpio_init+0x104>)
  40067a:	4413      	add	r3, r2
  40067c:	4618      	mov	r0, r3
  40067e:	4b3c      	ldr	r3, [pc, #240]	; (400770 <bsp_gpio_init+0x108>)
  400680:	4798      	blx	r3
  400682:	4604      	mov	r4, r0
  400684:	79fb      	ldrb	r3, [r7, #7]
  400686:	011b      	lsls	r3, r3, #4
  400688:	4a38      	ldr	r2, [pc, #224]	; (40076c <bsp_gpio_init+0x104>)
  40068a:	4413      	add	r3, r2
  40068c:	4618      	mov	r0, r3
  40068e:	4b39      	ldr	r3, [pc, #228]	; (400774 <bsp_gpio_init+0x10c>)
  400690:	4798      	blx	r3
  400692:	4603      	mov	r3, r0
  400694:	4a38      	ldr	r2, [pc, #224]	; (400778 <bsp_gpio_init+0x110>)
  400696:	4619      	mov	r1, r3
  400698:	4620      	mov	r0, r4
  40069a:	4b38      	ldr	r3, [pc, #224]	; (40077c <bsp_gpio_init+0x114>)
  40069c:	4798      	blx	r3

    // Configure External Interrupt on falling edge
    pio_handler_set(PORT, PORT_ID, PIN, PIO_IT_FALL_EDGE, bsp_io_interrupt_handler);
  40069e:	79fb      	ldrb	r3, [r7, #7]
  4006a0:	011b      	lsls	r3, r3, #4
  4006a2:	4a32      	ldr	r2, [pc, #200]	; (40076c <bsp_gpio_init+0x104>)
  4006a4:	4413      	add	r3, r2
  4006a6:	4618      	mov	r0, r3
  4006a8:	4b31      	ldr	r3, [pc, #196]	; (400770 <bsp_gpio_init+0x108>)
  4006aa:	4798      	blx	r3
  4006ac:	4604      	mov	r4, r0
  4006ae:	79fb      	ldrb	r3, [r7, #7]
  4006b0:	011b      	lsls	r3, r3, #4
  4006b2:	4a2e      	ldr	r2, [pc, #184]	; (40076c <bsp_gpio_init+0x104>)
  4006b4:	4413      	add	r3, r2
  4006b6:	4618      	mov	r0, r3
  4006b8:	4b31      	ldr	r3, [pc, #196]	; (400780 <bsp_gpio_init+0x118>)
  4006ba:	4798      	blx	r3
  4006bc:	4605      	mov	r5, r0
  4006be:	79fb      	ldrb	r3, [r7, #7]
  4006c0:	011b      	lsls	r3, r3, #4
  4006c2:	4a2a      	ldr	r2, [pc, #168]	; (40076c <bsp_gpio_init+0x104>)
  4006c4:	4413      	add	r3, r2
  4006c6:	4618      	mov	r0, r3
  4006c8:	4b2a      	ldr	r3, [pc, #168]	; (400774 <bsp_gpio_init+0x10c>)
  4006ca:	4798      	blx	r3
  4006cc:	4603      	mov	r3, r0
  4006ce:	461a      	mov	r2, r3
  4006d0:	4b2c      	ldr	r3, [pc, #176]	; (400784 <bsp_gpio_init+0x11c>)
  4006d2:	9300      	str	r3, [sp, #0]
  4006d4:	2350      	movs	r3, #80	; 0x50
  4006d6:	4629      	mov	r1, r5
  4006d8:	4620      	mov	r0, r4
  4006da:	4c2b      	ldr	r4, [pc, #172]	; (400788 <bsp_gpio_init+0x120>)
  4006dc:	47a0      	blx	r4

    // Enable external interrupt
    pio_enable_pin_interrupt(PIN_INDEX);
  4006de:	79fb      	ldrb	r3, [r7, #7]
  4006e0:	011b      	lsls	r3, r3, #4
  4006e2:	4a22      	ldr	r2, [pc, #136]	; (40076c <bsp_gpio_init+0x104>)
  4006e4:	4413      	add	r3, r2
  4006e6:	4618      	mov	r0, r3
  4006e8:	4b28      	ldr	r3, [pc, #160]	; (40078c <bsp_gpio_init+0x124>)
  4006ea:	4798      	blx	r3
  4006ec:	4603      	mov	r3, r0
  4006ee:	4618      	mov	r0, r3
  4006f0:	4b27      	ldr	r3, [pc, #156]	; (400790 <bsp_gpio_init+0x128>)
  4006f2:	4798      	blx	r3
  for (uint8_t i = 1; i <= SENSOR_COUNT_MAX; i++)
  4006f4:	79fb      	ldrb	r3, [r7, #7]
  4006f6:	3301      	adds	r3, #1
  4006f8:	71fb      	strb	r3, [r7, #7]
  4006fa:	79fb      	ldrb	r3, [r7, #7]
  4006fc:	2b63      	cmp	r3, #99	; 0x63
  4006fe:	d9b9      	bls.n	400674 <bsp_gpio_init+0xc>
  }

  // Configure Ext Interrupt in NVIC
  irq_register_handler(PIOA_IRQn, 0);
  400700:	2009      	movs	r0, #9
  400702:	4b24      	ldr	r3, [pc, #144]	; (400794 <bsp_gpio_init+0x12c>)
  400704:	4798      	blx	r3
  400706:	2100      	movs	r1, #0
  400708:	2009      	movs	r0, #9
  40070a:	4b23      	ldr	r3, [pc, #140]	; (400798 <bsp_gpio_init+0x130>)
  40070c:	4798      	blx	r3
  40070e:	2009      	movs	r0, #9
  400710:	4b22      	ldr	r3, [pc, #136]	; (40079c <bsp_gpio_init+0x134>)
  400712:	4798      	blx	r3
  irq_register_handler(PIOB_IRQn, 0);
  400714:	200a      	movs	r0, #10
  400716:	4b1f      	ldr	r3, [pc, #124]	; (400794 <bsp_gpio_init+0x12c>)
  400718:	4798      	blx	r3
  40071a:	2100      	movs	r1, #0
  40071c:	200a      	movs	r0, #10
  40071e:	4b1e      	ldr	r3, [pc, #120]	; (400798 <bsp_gpio_init+0x130>)
  400720:	4798      	blx	r3
  400722:	200a      	movs	r0, #10
  400724:	4b1d      	ldr	r3, [pc, #116]	; (40079c <bsp_gpio_init+0x134>)
  400726:	4798      	blx	r3
  irq_register_handler(PIOC_IRQn, 0);
  400728:	200b      	movs	r0, #11
  40072a:	4b1a      	ldr	r3, [pc, #104]	; (400794 <bsp_gpio_init+0x12c>)
  40072c:	4798      	blx	r3
  40072e:	2100      	movs	r1, #0
  400730:	200b      	movs	r0, #11
  400732:	4b19      	ldr	r3, [pc, #100]	; (400798 <bsp_gpio_init+0x130>)
  400734:	4798      	blx	r3
  400736:	200b      	movs	r0, #11
  400738:	4b18      	ldr	r3, [pc, #96]	; (40079c <bsp_gpio_init+0x134>)
  40073a:	4798      	blx	r3
  irq_register_handler(PIOD_IRQn, 0);
  40073c:	200c      	movs	r0, #12
  40073e:	4b15      	ldr	r3, [pc, #84]	; (400794 <bsp_gpio_init+0x12c>)
  400740:	4798      	blx	r3
  400742:	2100      	movs	r1, #0
  400744:	200c      	movs	r0, #12
  400746:	4b14      	ldr	r3, [pc, #80]	; (400798 <bsp_gpio_init+0x130>)
  400748:	4798      	blx	r3
  40074a:	200c      	movs	r0, #12
  40074c:	4b13      	ldr	r3, [pc, #76]	; (40079c <bsp_gpio_init+0x134>)
  40074e:	4798      	blx	r3
  irq_register_handler(PIOE_IRQn, 0);
  400750:	200d      	movs	r0, #13
  400752:	4b10      	ldr	r3, [pc, #64]	; (400794 <bsp_gpio_init+0x12c>)
  400754:	4798      	blx	r3
  400756:	2100      	movs	r1, #0
  400758:	200d      	movs	r0, #13
  40075a:	4b0f      	ldr	r3, [pc, #60]	; (400798 <bsp_gpio_init+0x130>)
  40075c:	4798      	blx	r3
  40075e:	200d      	movs	r0, #13
  400760:	4b0e      	ldr	r3, [pc, #56]	; (40079c <bsp_gpio_init+0x134>)
  400762:	4798      	blx	r3

  #undef PORT
  #undef PORT_ID
  #undef PIN
  #undef PIN_INDEX
}
  400764:	bf00      	nop
  400766:	3708      	adds	r7, #8
  400768:	46bd      	mov	sp, r7
  40076a:	bdb0      	pop	{r4, r5, r7, pc}
  40076c:	00403928 	.word	0x00403928
  400770:	004007b7 	.word	0x004007b7
  400774:	004007e7 	.word	0x004007e7
  400778:	28000009 	.word	0x28000009
  40077c:	004030ab 	.word	0x004030ab
  400780:	004007cf 	.word	0x004007cf
  400784:	004007a1 	.word	0x004007a1
  400788:	00402d2d 	.word	0x00402d2d
  40078c:	00400801 	.word	0x00400801
  400790:	00403113 	.word	0x00403113
  400794:	004005d9 	.word	0x004005d9
  400798:	00400615 	.word	0x00400615
  40079c:	0040059d 	.word	0x0040059d

004007a0 <bsp_io_interrupt_handler>:

void bsp_io_interrupt_handler(uint32_t id, uint32_t index)
{
  4007a0:	b480      	push	{r7}
  4007a2:	b083      	sub	sp, #12
  4007a4:	af00      	add	r7, sp, #0
  4007a6:	6078      	str	r0, [r7, #4]
  4007a8:	6039      	str	r1, [r7, #0]

}
  4007aa:	bf00      	nop
  4007ac:	370c      	adds	r7, #12
  4007ae:	46bd      	mov	sp, r7
  4007b0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4007b4:	4770      	bx	lr

004007b6 <bsp_io_get_port_address>:

/* Function definitions ----------------------------------------------- */
Pio *bsp_io_get_port_address(const bsp_io_10_t *io)
{
  4007b6:	b480      	push	{r7}
  4007b8:	b083      	sub	sp, #12
  4007ba:	af00      	add	r7, sp, #0
  4007bc:	6078      	str	r0, [r7, #4]
  return io->port;
  4007be:	687b      	ldr	r3, [r7, #4]
  4007c0:	681b      	ldr	r3, [r3, #0]
}
  4007c2:	4618      	mov	r0, r3
  4007c4:	370c      	adds	r7, #12
  4007c6:	46bd      	mov	sp, r7
  4007c8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4007cc:	4770      	bx	lr

004007ce <bsp_io_get_port_id>:

uint32_t bsp_io_get_port_id(const bsp_io_10_t *io)
{
  4007ce:	b480      	push	{r7}
  4007d0:	b083      	sub	sp, #12
  4007d2:	af00      	add	r7, sp, #0
  4007d4:	6078      	str	r0, [r7, #4]
  return io->port_id;
  4007d6:	687b      	ldr	r3, [r7, #4]
  4007d8:	685b      	ldr	r3, [r3, #4]
}
  4007da:	4618      	mov	r0, r3
  4007dc:	370c      	adds	r7, #12
  4007de:	46bd      	mov	sp, r7
  4007e0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4007e4:	4770      	bx	lr

004007e6 <bsp_io_get_pin>:

uint16_t bsp_io_get_pin(const bsp_io_10_t *io)
{
  4007e6:	b480      	push	{r7}
  4007e8:	b083      	sub	sp, #12
  4007ea:	af00      	add	r7, sp, #0
  4007ec:	6078      	str	r0, [r7, #4]
  return io->pin;
  4007ee:	687b      	ldr	r3, [r7, #4]
  4007f0:	689b      	ldr	r3, [r3, #8]
  4007f2:	b29b      	uxth	r3, r3
}
  4007f4:	4618      	mov	r0, r3
  4007f6:	370c      	adds	r7, #12
  4007f8:	46bd      	mov	sp, r7
  4007fa:	f85d 7b04 	ldr.w	r7, [sp], #4
  4007fe:	4770      	bx	lr

00400800 <bsp_io_get_pin_index>:

uint16_t bsp_io_get_pin_index(const bsp_io_10_t *io)
{
  400800:	b480      	push	{r7}
  400802:	b083      	sub	sp, #12
  400804:	af00      	add	r7, sp, #0
  400806:	6078      	str	r0, [r7, #4]
  return io->pin_index;
  400808:	687b      	ldr	r3, [r7, #4]
  40080a:	68db      	ldr	r3, [r3, #12]
  40080c:	b29b      	uxth	r3, r3
}
  40080e:	4618      	mov	r0, r3
  400810:	370c      	adds	r7, #12
  400812:	46bd      	mov	sp, r7
  400814:	f85d 7b04 	ldr.w	r7, [sp], #4
  400818:	4770      	bx	lr
	...

0040081c <bsp_lcd_init>:
/* Public variables --------------------------------------------------- */
/* Private variables -------------------------------------------------- */
/* Private function prototypes ---------------------------------------- */
/* Function definitions ----------------------------------------------- */
void bsp_lcd_init(void)
{
  40081c:	b598      	push	{r3, r4, r7, lr}
  40081e:	af00      	add	r7, sp, #0
  m_ssd1311.device_address = SSD1311_I2C_ADDRESS;
  400820:	4b09      	ldr	r3, [pc, #36]	; (400848 <bsp_lcd_init+0x2c>)
  400822:	223c      	movs	r2, #60	; 0x3c
  400824:	701a      	strb	r2, [r3, #0]
  m_ssd1311.i2c_write      = bsp_i2c_write;
  400826:	4b08      	ldr	r3, [pc, #32]	; (400848 <bsp_lcd_init+0x2c>)
  400828:	4a08      	ldr	r2, [pc, #32]	; (40084c <bsp_lcd_init+0x30>)
  40082a:	605a      	str	r2, [r3, #4]
  m_ssd1311.delay          = bsp_delay;
  40082c:	4b06      	ldr	r3, [pc, #24]	; (400848 <bsp_lcd_init+0x2c>)
  40082e:	4a08      	ldr	r2, [pc, #32]	; (400850 <bsp_lcd_init+0x34>)
  400830:	609a      	str	r2, [r3, #8]
  
  ssd1311_init(&m_ssd1311);
  400832:	4805      	ldr	r0, [pc, #20]	; (400848 <bsp_lcd_init+0x2c>)
  400834:	4b07      	ldr	r3, [pc, #28]	; (400854 <bsp_lcd_init+0x38>)
  400836:	4798      	blx	r3

  ssd1311_send_string(&m_ssd1311, "Temp", 0, 0);
  400838:	2300      	movs	r3, #0
  40083a:	2200      	movs	r2, #0
  40083c:	4906      	ldr	r1, [pc, #24]	; (400858 <bsp_lcd_init+0x3c>)
  40083e:	4802      	ldr	r0, [pc, #8]	; (400848 <bsp_lcd_init+0x2c>)
  400840:	4c06      	ldr	r4, [pc, #24]	; (40085c <bsp_lcd_init+0x40>)
  400842:	47a0      	blx	r4
}
  400844:	bf00      	nop
  400846:	bd98      	pop	{r3, r4, r7, pc}
  400848:	20000524 	.word	0x20000524
  40084c:	004002b5 	.word	0x004002b5
  400850:	00400301 	.word	0x00400301
  400854:	00400861 	.word	0x00400861
  400858:	00403f68 	.word	0x00403f68
  40085c:	0040093d 	.word	0x0040093d

00400860 <ssd1311_init>:
void cursPos(ssd1311_t *me, uint8_t col, uint8_t row);


/* Function definitions ----------------------------------------------- */
base_status_t ssd1311_init(ssd1311_t *me)
{
  400860:	b580      	push	{r7, lr}
  400862:	b082      	sub	sp, #8
  400864:	af00      	add	r7, sp, #0
  400866:	6078      	str	r0, [r7, #4]
  if ((me == NULL) || (me->i2c_write == NULL))
  400868:	687b      	ldr	r3, [r7, #4]
  40086a:	2b00      	cmp	r3, #0
  40086c:	d003      	beq.n	400876 <ssd1311_init+0x16>
  40086e:	687b      	ldr	r3, [r7, #4]
  400870:	685b      	ldr	r3, [r3, #4]
  400872:	2b00      	cmp	r3, #0
  400874:	d101      	bne.n	40087a <ssd1311_init+0x1a>
    return BS_ERROR_PARAMS;
  400876:	2301      	movs	r3, #1
  400878:	e003      	b.n	400882 <ssd1311_init+0x22>

  m_ssd1311_run_cfg_script(me);
  40087a:	6878      	ldr	r0, [r7, #4]
  40087c:	4b03      	ldr	r3, [pc, #12]	; (40088c <ssd1311_init+0x2c>)
  40087e:	4798      	blx	r3

  return BS_OK;
  400880:	2300      	movs	r3, #0
}
  400882:	4618      	mov	r0, r3
  400884:	3708      	adds	r7, #8
  400886:	46bd      	mov	sp, r7
  400888:	bd80      	pop	{r7, pc}
  40088a:	bf00      	nop
  40088c:	00400999 	.word	0x00400999

00400890 <ssd1311_write_cmd>:

base_status_t ssd1311_write_cmd(ssd1311_t *me, uint8_t cmd)
{
  400890:	b590      	push	{r4, r7, lr}
  400892:	b083      	sub	sp, #12
  400894:	af00      	add	r7, sp, #0
  400896:	6078      	str	r0, [r7, #4]
  400898:	460b      	mov	r3, r1
  40089a:	70fb      	strb	r3, [r7, #3]
  CHECK(BS_OK == me->i2c_write(me->device_address, SSD1311_CMD_MODE, &cmd, 1), BS_ERROR);
  40089c:	687b      	ldr	r3, [r7, #4]
  40089e:	685c      	ldr	r4, [r3, #4]
  4008a0:	687b      	ldr	r3, [r7, #4]
  4008a2:	7818      	ldrb	r0, [r3, #0]
  4008a4:	1cfa      	adds	r2, r7, #3
  4008a6:	2301      	movs	r3, #1
  4008a8:	2180      	movs	r1, #128	; 0x80
  4008aa:	47a0      	blx	r4
  4008ac:	4603      	mov	r3, r0
  4008ae:	2b00      	cmp	r3, #0
  4008b0:	d001      	beq.n	4008b6 <ssd1311_write_cmd+0x26>
  4008b2:	2302      	movs	r3, #2
  4008b4:	e000      	b.n	4008b8 <ssd1311_write_cmd+0x28>

  return BS_OK;
  4008b6:	2300      	movs	r3, #0
}
  4008b8:	4618      	mov	r0, r3
  4008ba:	370c      	adds	r7, #12
  4008bc:	46bd      	mov	sp, r7
  4008be:	bd90      	pop	{r4, r7, pc}

004008c0 <ssd1311_write_data_byte>:

  return BS_OK;
}

base_status_t ssd1311_write_data_byte(ssd1311_t *me, uint8_t data)
{
  4008c0:	b590      	push	{r4, r7, lr}
  4008c2:	b083      	sub	sp, #12
  4008c4:	af00      	add	r7, sp, #0
  4008c6:	6078      	str	r0, [r7, #4]
  4008c8:	460b      	mov	r3, r1
  4008ca:	70fb      	strb	r3, [r7, #3]
  CHECK(BS_OK == me->i2c_write(me->device_address, SSD1311_DATA_MODE, &data, 1), BS_ERROR);
  4008cc:	687b      	ldr	r3, [r7, #4]
  4008ce:	685c      	ldr	r4, [r3, #4]
  4008d0:	687b      	ldr	r3, [r7, #4]
  4008d2:	7818      	ldrb	r0, [r3, #0]
  4008d4:	1cfa      	adds	r2, r7, #3
  4008d6:	2301      	movs	r3, #1
  4008d8:	2140      	movs	r1, #64	; 0x40
  4008da:	47a0      	blx	r4
  4008dc:	4603      	mov	r3, r0
  4008de:	2b00      	cmp	r3, #0
  4008e0:	d001      	beq.n	4008e6 <ssd1311_write_data_byte+0x26>
  4008e2:	2302      	movs	r3, #2
  4008e4:	e000      	b.n	4008e8 <ssd1311_write_data_byte+0x28>

  return BS_OK;
  4008e6:	2300      	movs	r3, #0
}
  4008e8:	4618      	mov	r0, r3
  4008ea:	370c      	adds	r7, #12
  4008ec:	46bd      	mov	sp, r7
  4008ee:	bd90      	pop	{r4, r7, pc}

004008f0 <cursPos>:

void cursPos(ssd1311_t *me, uint8_t col, uint8_t row)
{
  4008f0:	b580      	push	{r7, lr}
  4008f2:	b084      	sub	sp, #16
  4008f4:	af00      	add	r7, sp, #0
  4008f6:	6078      	str	r0, [r7, #4]
  4008f8:	460b      	mov	r3, r1
  4008fa:	70fb      	strb	r3, [r7, #3]
  4008fc:	4613      	mov	r3, r2
  4008fe:	70bb      	strb	r3, [r7, #2]
  int row_offsets[] = {0x00, 0x40};
  400900:	2300      	movs	r3, #0
  400902:	60bb      	str	r3, [r7, #8]
  400904:	2340      	movs	r3, #64	; 0x40
  400906:	60fb      	str	r3, [r7, #12]

  ssd1311_write_cmd(me, 0x80 | (col + row_offsets[row]));
  400908:	78bb      	ldrb	r3, [r7, #2]
  40090a:	009b      	lsls	r3, r3, #2
  40090c:	f107 0210 	add.w	r2, r7, #16
  400910:	4413      	add	r3, r2
  400912:	f853 3c08 	ldr.w	r3, [r3, #-8]
  400916:	b2da      	uxtb	r2, r3
  400918:	78fb      	ldrb	r3, [r7, #3]
  40091a:	4413      	add	r3, r2
  40091c:	b2db      	uxtb	r3, r3
  40091e:	b25b      	sxtb	r3, r3
  400920:	f063 037f 	orn	r3, r3, #127	; 0x7f
  400924:	b25b      	sxtb	r3, r3
  400926:	b2db      	uxtb	r3, r3
  400928:	4619      	mov	r1, r3
  40092a:	6878      	ldr	r0, [r7, #4]
  40092c:	4b02      	ldr	r3, [pc, #8]	; (400938 <cursPos+0x48>)
  40092e:	4798      	blx	r3
}
  400930:	bf00      	nop
  400932:	3710      	adds	r7, #16
  400934:	46bd      	mov	sp, r7
  400936:	bd80      	pop	{r7, pc}
  400938:	00400891 	.word	0x00400891

0040093c <ssd1311_send_string>:

void ssd1311_send_string(ssd1311_t *me, const char *string, uint8_t col, uint8_t row)
{
  40093c:	b580      	push	{r7, lr}
  40093e:	b086      	sub	sp, #24
  400940:	af00      	add	r7, sp, #0
  400942:	60f8      	str	r0, [r7, #12]
  400944:	60b9      	str	r1, [r7, #8]
  400946:	4611      	mov	r1, r2
  400948:	461a      	mov	r2, r3
  40094a:	460b      	mov	r3, r1
  40094c:	71fb      	strb	r3, [r7, #7]
  40094e:	4613      	mov	r3, r2
  400950:	71bb      	strb	r3, [r7, #6]
  unsigned char i = 0;
  400952:	2300      	movs	r3, #0
  400954:	75fb      	strb	r3, [r7, #23]
  cursPos(me, col, row);
  400956:	79ba      	ldrb	r2, [r7, #6]
  400958:	79fb      	ldrb	r3, [r7, #7]
  40095a:	4619      	mov	r1, r3
  40095c:	68f8      	ldr	r0, [r7, #12]
  40095e:	4b0c      	ldr	r3, [pc, #48]	; (400990 <ssd1311_send_string+0x54>)
  400960:	4798      	blx	r3

  while(string[i])
  400962:	e00a      	b.n	40097a <ssd1311_send_string+0x3e>
  {
    ssd1311_write_data_byte(me, string[i]);
  400964:	7dfb      	ldrb	r3, [r7, #23]
  400966:	68ba      	ldr	r2, [r7, #8]
  400968:	4413      	add	r3, r2
  40096a:	781b      	ldrb	r3, [r3, #0]
  40096c:	4619      	mov	r1, r3
  40096e:	68f8      	ldr	r0, [r7, #12]
  400970:	4b08      	ldr	r3, [pc, #32]	; (400994 <ssd1311_send_string+0x58>)
  400972:	4798      	blx	r3
    i++;
  400974:	7dfb      	ldrb	r3, [r7, #23]
  400976:	3301      	adds	r3, #1
  400978:	75fb      	strb	r3, [r7, #23]
  while(string[i])
  40097a:	7dfb      	ldrb	r3, [r7, #23]
  40097c:	68ba      	ldr	r2, [r7, #8]
  40097e:	4413      	add	r3, r2
  400980:	781b      	ldrb	r3, [r3, #0]
  400982:	2b00      	cmp	r3, #0
  400984:	d1ee      	bne.n	400964 <ssd1311_send_string+0x28>
  }
}
  400986:	bf00      	nop
  400988:	3718      	adds	r7, #24
  40098a:	46bd      	mov	sp, r7
  40098c:	bd80      	pop	{r7, pc}
  40098e:	bf00      	nop
  400990:	004008f1 	.word	0x004008f1
  400994:	004008c1 	.word	0x004008c1

00400998 <m_ssd1311_run_cfg_script>:
 * @return
 * - BS_OK
 * - BS_ERROR
 */
static base_status_t m_ssd1311_run_cfg_script(ssd1311_t *me)
{
  400998:	b580      	push	{r7, lr}
  40099a:	b084      	sub	sp, #16
  40099c:	af00      	add	r7, sp, #0
  40099e:	6078      	str	r0, [r7, #4]
  int i          = 0;
  4009a0:	2300      	movs	r3, #0
  4009a2:	60fb      	str	r3, [r7, #12]
  int end_script = 0;
  4009a4:	2300      	movs	r3, #0
  4009a6:	60bb      	str	r3, [r7, #8]

  do
  {
    switch (SSD1311_CFG_SCRIPT[i].cmd)
  4009a8:	4a20      	ldr	r2, [pc, #128]	; (400a2c <m_ssd1311_run_cfg_script+0x94>)
  4009aa:	68fb      	ldr	r3, [r7, #12]
  4009ac:	f812 3013 	ldrb.w	r3, [r2, r3, lsl #1]
  4009b0:	2b04      	cmp	r3, #4
  4009b2:	d82e      	bhi.n	400a12 <m_ssd1311_run_cfg_script+0x7a>
  4009b4:	a201      	add	r2, pc, #4	; (adr r2, 4009bc <m_ssd1311_run_cfg_script+0x24>)
  4009b6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4009ba:	bf00      	nop
  4009bc:	00400a13 	.word	0x00400a13
  4009c0:	00400a0d 	.word	0x00400a0d
  4009c4:	004009d1 	.word	0x004009d1
  4009c8:	004009e5 	.word	0x004009e5
  4009cc:	004009f9 	.word	0x004009f9
    {
    case SSD1311_START:
      break;
    case SSD1311_CMD:
      ssd1311_write_cmd(me, SSD1311_CFG_SCRIPT[i].data & 0xFF);
  4009d0:	4a16      	ldr	r2, [pc, #88]	; (400a2c <m_ssd1311_run_cfg_script+0x94>)
  4009d2:	68fb      	ldr	r3, [r7, #12]
  4009d4:	005b      	lsls	r3, r3, #1
  4009d6:	4413      	add	r3, r2
  4009d8:	785b      	ldrb	r3, [r3, #1]
  4009da:	4619      	mov	r1, r3
  4009dc:	6878      	ldr	r0, [r7, #4]
  4009de:	4b14      	ldr	r3, [pc, #80]	; (400a30 <m_ssd1311_run_cfg_script+0x98>)
  4009e0:	4798      	blx	r3
      break;
  4009e2:	e017      	b.n	400a14 <m_ssd1311_run_cfg_script+0x7c>
    case SSD1311_DATA:
      ssd1311_write_data_byte(me, SSD1311_CFG_SCRIPT[i].data & 0xFF);
  4009e4:	4a11      	ldr	r2, [pc, #68]	; (400a2c <m_ssd1311_run_cfg_script+0x94>)
  4009e6:	68fb      	ldr	r3, [r7, #12]
  4009e8:	005b      	lsls	r3, r3, #1
  4009ea:	4413      	add	r3, r2
  4009ec:	785b      	ldrb	r3, [r3, #1]
  4009ee:	4619      	mov	r1, r3
  4009f0:	6878      	ldr	r0, [r7, #4]
  4009f2:	4b10      	ldr	r3, [pc, #64]	; (400a34 <m_ssd1311_run_cfg_script+0x9c>)
  4009f4:	4798      	blx	r3
      break;
  4009f6:	e00d      	b.n	400a14 <m_ssd1311_run_cfg_script+0x7c>
    case SSD1311_DELAY:
      me->delay(SSD1311_CFG_SCRIPT[i].data);
  4009f8:	687b      	ldr	r3, [r7, #4]
  4009fa:	689a      	ldr	r2, [r3, #8]
  4009fc:	490b      	ldr	r1, [pc, #44]	; (400a2c <m_ssd1311_run_cfg_script+0x94>)
  4009fe:	68fb      	ldr	r3, [r7, #12]
  400a00:	005b      	lsls	r3, r3, #1
  400a02:	440b      	add	r3, r1
  400a04:	785b      	ldrb	r3, [r3, #1]
  400a06:	4618      	mov	r0, r3
  400a08:	4790      	blx	r2
      break;
  400a0a:	e003      	b.n	400a14 <m_ssd1311_run_cfg_script+0x7c>
    case SSD1311_END:
      end_script = 1;
  400a0c:	2301      	movs	r3, #1
  400a0e:	60bb      	str	r3, [r7, #8]
      break;
  400a10:	e000      	b.n	400a14 <m_ssd1311_run_cfg_script+0x7c>
    default:
      break;
  400a12:	bf00      	nop
    }
    i++;
  400a14:	68fb      	ldr	r3, [r7, #12]
  400a16:	3301      	adds	r3, #1
  400a18:	60fb      	str	r3, [r7, #12]
  }
  while (!end_script);
  400a1a:	68bb      	ldr	r3, [r7, #8]
  400a1c:	2b00      	cmp	r3, #0
  400a1e:	d0c3      	beq.n	4009a8 <m_ssd1311_run_cfg_script+0x10>

  return BS_OK;
  400a20:	2300      	movs	r3, #0
}
  400a22:	4618      	mov	r0, r3
  400a24:	3710      	adds	r7, #16
  400a26:	46bd      	mov	sp, r7
  400a28:	bd80      	pop	{r7, pc}
  400a2a:	bf00      	nop
  400a2c:	00403f70 	.word	0x00403f70
  400a30:	00400891 	.word	0x00400891
  400a34:	004008c1 	.word	0x004008c1

00400a38 <sys_init>:
/* Private function prototypes ---------------------------------------- */
static void m_sys_sdcard_test(void);

/* Function definitions ----------------------------------------------- */
void sys_init(void)
{
  400a38:	b580      	push	{r7, lr}
  400a3a:	af00      	add	r7, sp, #0
  sysclk_init();  // Initialize System Clock
  400a3c:	4b05      	ldr	r3, [pc, #20]	; (400a54 <sys_init+0x1c>)
  400a3e:	4798      	blx	r3
  board_init();   // Board init
  400a40:	4b05      	ldr	r3, [pc, #20]	; (400a58 <sys_init+0x20>)
  400a42:	4798      	blx	r3
  bsp_hw_init();  // Hardware init
  400a44:	4b05      	ldr	r3, [pc, #20]	; (400a5c <sys_init+0x24>)
  400a46:	4798      	blx	r3
  bsp_can_init(); // Can bus init
  400a48:	4b05      	ldr	r3, [pc, #20]	; (400a60 <sys_init+0x28>)
  400a4a:	4798      	blx	r3

  bsp_lcd_init();
  400a4c:	4b05      	ldr	r3, [pc, #20]	; (400a64 <sys_init+0x2c>)
  400a4e:	4798      	blx	r3
}
  400a50:	bf00      	nop
  400a52:	bd80      	pop	{r7, pc}
  400a54:	00402c5d 	.word	0x00402c5d
  400a58:	00402111 	.word	0x00402111
  400a5c:	00400295 	.word	0x00400295
  400a60:	004004e9 	.word	0x004004e9
  400a64:	0040081d 	.word	0x0040081d

00400a68 <sys_run>:

void sys_run(void)
{
  400a68:	b580      	push	{r7, lr}
  400a6a:	af00      	add	r7, sp, #0
  bsp_can_send();
  400a6c:	4b03      	ldr	r3, [pc, #12]	; (400a7c <sys_run+0x14>)
  400a6e:	4798      	blx	r3
  bsp_delay(1000);
  400a70:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  400a74:	4b02      	ldr	r3, [pc, #8]	; (400a80 <sys_run+0x18>)
  400a76:	4798      	blx	r3
}
  400a78:	bf00      	nop
  400a7a:	bd80      	pop	{r7, pc}
  400a7c:	00400585 	.word	0x00400585
  400a80:	00400301 	.word	0x00400301

00400a84 <SDMMC_UNSTUFF_BITS>:
 * \brief Macro function to extract a bits field from a large SD MMC register
 * Used by : CSD, SCR, Switch status
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
  400a84:	b480      	push	{r7}
  400a86:	b087      	sub	sp, #28
  400a88:	af00      	add	r7, sp, #0
  400a8a:	60f8      	str	r0, [r7, #12]
  400a8c:	4608      	mov	r0, r1
  400a8e:	4611      	mov	r1, r2
  400a90:	461a      	mov	r2, r3
  400a92:	4603      	mov	r3, r0
  400a94:	817b      	strh	r3, [r7, #10]
  400a96:	460b      	mov	r3, r1
  400a98:	813b      	strh	r3, [r7, #8]
  400a9a:	4613      	mov	r3, r2
  400a9c:	71fb      	strb	r3, [r7, #7]
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400a9e:	897a      	ldrh	r2, [r7, #10]
  400aa0:	893b      	ldrh	r3, [r7, #8]
  400aa2:	1ad3      	subs	r3, r2, r3
  400aa4:	3307      	adds	r3, #7
  400aa6:	2b00      	cmp	r3, #0
  400aa8:	da00      	bge.n	400aac <SDMMC_UNSTUFF_BITS+0x28>
  400aaa:	3307      	adds	r3, #7
  400aac:	10db      	asrs	r3, r3, #3
  400aae:	3b01      	subs	r3, #1
  400ab0:	68fa      	ldr	r2, [r7, #12]
  400ab2:	4413      	add	r3, r2
  400ab4:	781b      	ldrb	r3, [r3, #0]
  400ab6:	461a      	mov	r2, r3
  400ab8:	893b      	ldrh	r3, [r7, #8]
  400aba:	f003 0307 	and.w	r3, r3, #7
  400abe:	fa42 f303 	asr.w	r3, r2, r3
  400ac2:	617b      	str	r3, [r7, #20]
	if (((pos % 8) + size) > 8) {
  400ac4:	893b      	ldrh	r3, [r7, #8]
  400ac6:	f003 0207 	and.w	r2, r3, #7
  400aca:	79fb      	ldrb	r3, [r7, #7]
  400acc:	4413      	add	r3, r2
  400ace:	2b08      	cmp	r3, #8
  400ad0:	dd16      	ble.n	400b00 <SDMMC_UNSTUFF_BITS+0x7c>
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400ad2:	897a      	ldrh	r2, [r7, #10]
  400ad4:	893b      	ldrh	r3, [r7, #8]
  400ad6:	1ad3      	subs	r3, r2, r3
  400ad8:	3307      	adds	r3, #7
  400ada:	2b00      	cmp	r3, #0
  400adc:	da00      	bge.n	400ae0 <SDMMC_UNSTUFF_BITS+0x5c>
  400ade:	3307      	adds	r3, #7
  400ae0:	10db      	asrs	r3, r3, #3
  400ae2:	3b02      	subs	r3, #2
  400ae4:	68fa      	ldr	r2, [r7, #12]
  400ae6:	4413      	add	r3, r2
  400ae8:	781b      	ldrb	r3, [r3, #0]
  400aea:	461a      	mov	r2, r3
  400aec:	893b      	ldrh	r3, [r7, #8]
  400aee:	f003 0307 	and.w	r3, r3, #7
  400af2:	f1c3 0308 	rsb	r3, r3, #8
  400af6:	fa02 f303 	lsl.w	r3, r2, r3
  400afa:	697a      	ldr	r2, [r7, #20]
  400afc:	4313      	orrs	r3, r2
  400afe:	617b      	str	r3, [r7, #20]
	}
	if (((pos % 8) + size) > 16) {
  400b00:	893b      	ldrh	r3, [r7, #8]
  400b02:	f003 0207 	and.w	r2, r3, #7
  400b06:	79fb      	ldrb	r3, [r7, #7]
  400b08:	4413      	add	r3, r2
  400b0a:	2b10      	cmp	r3, #16
  400b0c:	dd16      	ble.n	400b3c <SDMMC_UNSTUFF_BITS+0xb8>
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400b0e:	897a      	ldrh	r2, [r7, #10]
  400b10:	893b      	ldrh	r3, [r7, #8]
  400b12:	1ad3      	subs	r3, r2, r3
  400b14:	3307      	adds	r3, #7
  400b16:	2b00      	cmp	r3, #0
  400b18:	da00      	bge.n	400b1c <SDMMC_UNSTUFF_BITS+0x98>
  400b1a:	3307      	adds	r3, #7
  400b1c:	10db      	asrs	r3, r3, #3
  400b1e:	3b03      	subs	r3, #3
  400b20:	68fa      	ldr	r2, [r7, #12]
  400b22:	4413      	add	r3, r2
  400b24:	781b      	ldrb	r3, [r3, #0]
  400b26:	461a      	mov	r2, r3
  400b28:	893b      	ldrh	r3, [r7, #8]
  400b2a:	f003 0307 	and.w	r3, r3, #7
  400b2e:	f1c3 0310 	rsb	r3, r3, #16
  400b32:	fa02 f303 	lsl.w	r3, r2, r3
  400b36:	697a      	ldr	r2, [r7, #20]
  400b38:	4313      	orrs	r3, r2
  400b3a:	617b      	str	r3, [r7, #20]
	}
	if (((pos % 8) + size) > 16) {
  400b3c:	893b      	ldrh	r3, [r7, #8]
  400b3e:	f003 0207 	and.w	r2, r3, #7
  400b42:	79fb      	ldrb	r3, [r7, #7]
  400b44:	4413      	add	r3, r2
  400b46:	2b10      	cmp	r3, #16
  400b48:	dd16      	ble.n	400b78 <SDMMC_UNSTUFF_BITS+0xf4>
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400b4a:	897a      	ldrh	r2, [r7, #10]
  400b4c:	893b      	ldrh	r3, [r7, #8]
  400b4e:	1ad3      	subs	r3, r2, r3
  400b50:	3307      	adds	r3, #7
  400b52:	2b00      	cmp	r3, #0
  400b54:	da00      	bge.n	400b58 <SDMMC_UNSTUFF_BITS+0xd4>
  400b56:	3307      	adds	r3, #7
  400b58:	10db      	asrs	r3, r3, #3
  400b5a:	3b03      	subs	r3, #3
  400b5c:	68fa      	ldr	r2, [r7, #12]
  400b5e:	4413      	add	r3, r2
  400b60:	781b      	ldrb	r3, [r3, #0]
  400b62:	461a      	mov	r2, r3
  400b64:	893b      	ldrh	r3, [r7, #8]
  400b66:	f003 0307 	and.w	r3, r3, #7
  400b6a:	f1c3 0310 	rsb	r3, r3, #16
  400b6e:	fa02 f303 	lsl.w	r3, r2, r3
  400b72:	697a      	ldr	r2, [r7, #20]
  400b74:	4313      	orrs	r3, r2
  400b76:	617b      	str	r3, [r7, #20]
	}
	value &=  ((uint32_t)1 << size) - 1;
  400b78:	79fb      	ldrb	r3, [r7, #7]
  400b7a:	2201      	movs	r2, #1
  400b7c:	fa02 f303 	lsl.w	r3, r2, r3
  400b80:	3b01      	subs	r3, #1
  400b82:	697a      	ldr	r2, [r7, #20]
  400b84:	4013      	ands	r3, r2
  400b86:	617b      	str	r3, [r7, #20]
	return value;
  400b88:	697b      	ldr	r3, [r7, #20]
}
  400b8a:	4618      	mov	r0, r3
  400b8c:	371c      	adds	r7, #28
  400b8e:	46bd      	mov	sp, r7
  400b90:	f85d 7b04 	ldr.w	r7, [sp], #4
  400b94:	4770      	bx	lr
	...

00400b98 <mmc_mci_op_cond>:
 * - CMD1 reads OCR
 *
 * \return true if success, otherwise false
 */
static bool mmc_mci_op_cond(void)
{
  400b98:	b580      	push	{r7, lr}
  400b9a:	b082      	sub	sp, #8
  400b9c:	af00      	add	r7, sp, #0
	/*
	 * Timeout 1s = 400KHz / ((6+6)*8) cylces = 4200 retry
	 * 6 = cmd byte size
	 * 6 = response byte size
	 */
	retry = 4200;
  400b9e:	f241 0368 	movw	r3, #4200	; 0x1068
  400ba2:	607b      	str	r3, [r7, #4]
	do {
		if (!driver_send_cmd(MMC_MCI_CMD1_SEND_OP_COND,
  400ba4:	4917      	ldr	r1, [pc, #92]	; (400c04 <mmc_mci_op_cond+0x6c>)
  400ba6:	f244 5001 	movw	r0, #17665	; 0x4501
  400baa:	4b17      	ldr	r3, [pc, #92]	; (400c08 <mmc_mci_op_cond+0x70>)
  400bac:	4798      	blx	r3
  400bae:	4603      	mov	r3, r0
  400bb0:	f083 0301 	eor.w	r3, r3, #1
  400bb4:	b2db      	uxtb	r3, r3
  400bb6:	2b00      	cmp	r3, #0
  400bb8:	d001      	beq.n	400bbe <mmc_mci_op_cond+0x26>
				SD_MMC_VOLTAGE_SUPPORT | OCR_ACCESS_MODE_SECTOR)) {
			sd_mmc_debug("%s: CMD1 MCI Fail - Busy retry %d\n\r",
					__func__, (int)(4200 - retry));
			return false;
  400bba:	2300      	movs	r3, #0
  400bbc:	e01e      	b.n	400bfc <mmc_mci_op_cond+0x64>
		}
		// Check busy flag
		resp = driver_get_response();
  400bbe:	4b13      	ldr	r3, [pc, #76]	; (400c0c <mmc_mci_op_cond+0x74>)
  400bc0:	4798      	blx	r3
  400bc2:	6038      	str	r0, [r7, #0]
		if (resp & OCR_POWER_UP_BUSY) {
  400bc4:	683b      	ldr	r3, [r7, #0]
  400bc6:	2b00      	cmp	r3, #0
  400bc8:	da0f      	bge.n	400bea <mmc_mci_op_cond+0x52>
			// Check OCR value
			if ((resp & OCR_ACCESS_MODE_MASK)
  400bca:	683b      	ldr	r3, [r7, #0]
  400bcc:	f003 43c0 	and.w	r3, r3, #1610612736	; 0x60000000
  400bd0:	f1b3 4f80 	cmp.w	r3, #1073741824	; 0x40000000
  400bd4:	d110      	bne.n	400bf8 <mmc_mci_op_cond+0x60>
					== OCR_ACCESS_MODE_SECTOR) {
				sd_mmc_card->type |= CARD_TYPE_HC;
  400bd6:	4b0e      	ldr	r3, [pc, #56]	; (400c10 <mmc_mci_op_cond+0x78>)
  400bd8:	681b      	ldr	r3, [r3, #0]
  400bda:	4a0d      	ldr	r2, [pc, #52]	; (400c10 <mmc_mci_op_cond+0x78>)
  400bdc:	6812      	ldr	r2, [r2, #0]
  400bde:	7ad2      	ldrb	r2, [r2, #11]
  400be0:	f042 0208 	orr.w	r2, r2, #8
  400be4:	b2d2      	uxtb	r2, r2
  400be6:	72da      	strb	r2, [r3, #11]
			}
			break;
  400be8:	e006      	b.n	400bf8 <mmc_mci_op_cond+0x60>
		}
		if (retry-- == 0) {
  400bea:	687b      	ldr	r3, [r7, #4]
  400bec:	1e5a      	subs	r2, r3, #1
  400bee:	607a      	str	r2, [r7, #4]
  400bf0:	2b00      	cmp	r3, #0
  400bf2:	d1d7      	bne.n	400ba4 <mmc_mci_op_cond+0xc>
			sd_mmc_debug("%s: CMD1 Timeout on busy\n\r", __func__);
			return false;
  400bf4:	2300      	movs	r3, #0
  400bf6:	e001      	b.n	400bfc <mmc_mci_op_cond+0x64>
			break;
  400bf8:	bf00      	nop
		}
	} while (1);
	return true;
  400bfa:	2301      	movs	r3, #1
}
  400bfc:	4618      	mov	r0, r3
  400bfe:	3708      	adds	r7, #8
  400c00:	46bd      	mov	sp, r7
  400c02:	bd80      	pop	{r7, pc}
  400c04:	401f8000 	.word	0x401f8000
  400c08:	0040263d 	.word	0x0040263d
  400c0c:	00402681 	.word	0x00402681
  400c10:	2000047c 	.word	0x2000047c

00400c14 <sd_mci_op_cond>:
 * \param v2   Shall be 1 if it is a SD card V2
 *
 * \return true if success, otherwise false
 */
static bool sd_mci_op_cond(uint8_t v2)
{
  400c14:	b580      	push	{r7, lr}
  400c16:	b086      	sub	sp, #24
  400c18:	af00      	add	r7, sp, #0
  400c1a:	4603      	mov	r3, r0
  400c1c:	71fb      	strb	r3, [r7, #7]
	 * 6 = cmd byte size
	 * 6 = response byte size
	 * 6 = cmd byte size
	 * 6 = response byte size
	 */
	retry = 2100;
  400c1e:	f640 0334 	movw	r3, #2100	; 0x834
  400c22:	613b      	str	r3, [r7, #16]
	do {
		// CMD55 - Indicate to the card that the next command is an
		// application specific command rather than a standard command.
		if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, 0)) {
  400c24:	2100      	movs	r1, #0
  400c26:	f241 1037 	movw	r0, #4407	; 0x1137
  400c2a:	4b21      	ldr	r3, [pc, #132]	; (400cb0 <sd_mci_op_cond+0x9c>)
  400c2c:	4798      	blx	r3
  400c2e:	4603      	mov	r3, r0
  400c30:	f083 0301 	eor.w	r3, r3, #1
  400c34:	b2db      	uxtb	r3, r3
  400c36:	2b00      	cmp	r3, #0
  400c38:	d001      	beq.n	400c3e <sd_mci_op_cond+0x2a>
			sd_mmc_debug("%s: CMD55 Fail\n\r", __func__);
			return false;
  400c3a:	2300      	movs	r3, #0
  400c3c:	e034      	b.n	400ca8 <sd_mci_op_cond+0x94>
		}

		// (ACMD41) Sends host OCR register
		arg = SD_MMC_VOLTAGE_SUPPORT;
  400c3e:	f44f 13fc 	mov.w	r3, #2064384	; 0x1f8000
  400c42:	617b      	str	r3, [r7, #20]
		if (v2) {
  400c44:	79fb      	ldrb	r3, [r7, #7]
  400c46:	2b00      	cmp	r3, #0
  400c48:	d003      	beq.n	400c52 <sd_mci_op_cond+0x3e>
			arg |= SD_ACMD41_HCS;
  400c4a:	697b      	ldr	r3, [r7, #20]
  400c4c:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
  400c50:	617b      	str	r3, [r7, #20]
		}
		// Check response
		if (!driver_send_cmd(SD_MCI_ACMD41_SD_SEND_OP_COND, arg)) {
  400c52:	6979      	ldr	r1, [r7, #20]
  400c54:	f244 5029 	movw	r0, #17705	; 0x4529
  400c58:	4b15      	ldr	r3, [pc, #84]	; (400cb0 <sd_mci_op_cond+0x9c>)
  400c5a:	4798      	blx	r3
  400c5c:	4603      	mov	r3, r0
  400c5e:	f083 0301 	eor.w	r3, r3, #1
  400c62:	b2db      	uxtb	r3, r3
  400c64:	2b00      	cmp	r3, #0
  400c66:	d001      	beq.n	400c6c <sd_mci_op_cond+0x58>
			sd_mmc_debug("%s: ACMD41 Fail\n\r", __func__);
			return false;
  400c68:	2300      	movs	r3, #0
  400c6a:	e01d      	b.n	400ca8 <sd_mci_op_cond+0x94>
		}
		resp = driver_get_response();
  400c6c:	4b11      	ldr	r3, [pc, #68]	; (400cb4 <sd_mci_op_cond+0xa0>)
  400c6e:	4798      	blx	r3
  400c70:	60f8      	str	r0, [r7, #12]
		if (resp & OCR_POWER_UP_BUSY) {
  400c72:	68fb      	ldr	r3, [r7, #12]
  400c74:	2b00      	cmp	r3, #0
  400c76:	da0e      	bge.n	400c96 <sd_mci_op_cond+0x82>
			// Card is ready
			if ((resp & OCR_CCS) != 0) {
  400c78:	68fb      	ldr	r3, [r7, #12]
  400c7a:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
  400c7e:	2b00      	cmp	r3, #0
  400c80:	d010      	beq.n	400ca4 <sd_mci_op_cond+0x90>
				sd_mmc_card->type |= CARD_TYPE_HC;
  400c82:	4b0d      	ldr	r3, [pc, #52]	; (400cb8 <sd_mci_op_cond+0xa4>)
  400c84:	681b      	ldr	r3, [r3, #0]
  400c86:	4a0c      	ldr	r2, [pc, #48]	; (400cb8 <sd_mci_op_cond+0xa4>)
  400c88:	6812      	ldr	r2, [r2, #0]
  400c8a:	7ad2      	ldrb	r2, [r2, #11]
  400c8c:	f042 0208 	orr.w	r2, r2, #8
  400c90:	b2d2      	uxtb	r2, r2
  400c92:	72da      	strb	r2, [r3, #11]
			}
			break;
  400c94:	e006      	b.n	400ca4 <sd_mci_op_cond+0x90>
		}
		if (retry-- == 0) {
  400c96:	693b      	ldr	r3, [r7, #16]
  400c98:	1e5a      	subs	r2, r3, #1
  400c9a:	613a      	str	r2, [r7, #16]
  400c9c:	2b00      	cmp	r3, #0
  400c9e:	d1c1      	bne.n	400c24 <sd_mci_op_cond+0x10>
			sd_mmc_debug("%s: ACMD41 Timeout on busy, resp32 0x%08x \n\r",
					__func__, resp);
			return false;
  400ca0:	2300      	movs	r3, #0
  400ca2:	e001      	b.n	400ca8 <sd_mci_op_cond+0x94>
			break;
  400ca4:	bf00      	nop
		}
	} while (1);
	return true;
  400ca6:	2301      	movs	r3, #1
}
  400ca8:	4618      	mov	r0, r3
  400caa:	3718      	adds	r7, #24
  400cac:	46bd      	mov	sp, r7
  400cae:	bd80      	pop	{r7, pc}
  400cb0:	0040263d 	.word	0x0040263d
  400cb4:	00402681 	.word	0x00402681
  400cb8:	2000047c 	.word	0x2000047c

00400cbc <sdio_op_cond>:
 *   sd_mmc_card->type is updated
 *
 * \return true if success, otherwise false
 */
static bool sdio_op_cond(void)
{
  400cbc:	b580      	push	{r7, lr}
  400cbe:	b082      	sub	sp, #8
  400cc0:	af00      	add	r7, sp, #0
	uint32_t resp;

	// CMD5 - SDIO send operation condition (OCR) command.
	if (!driver_send_cmd(SDIO_CMD5_SEND_OP_COND, 0)) {
  400cc2:	2100      	movs	r1, #0
  400cc4:	f244 5005 	movw	r0, #17669	; 0x4505
  400cc8:	4b23      	ldr	r3, [pc, #140]	; (400d58 <sdio_op_cond+0x9c>)
  400cca:	4798      	blx	r3
  400ccc:	4603      	mov	r3, r0
  400cce:	f083 0301 	eor.w	r3, r3, #1
  400cd2:	b2db      	uxtb	r3, r3
  400cd4:	2b00      	cmp	r3, #0
  400cd6:	d001      	beq.n	400cdc <sdio_op_cond+0x20>
		sd_mmc_debug("%s: CMD5 Fail\n\r", __func__);
		return true; // No error but card type not updated
  400cd8:	2301      	movs	r3, #1
  400cda:	e039      	b.n	400d50 <sdio_op_cond+0x94>
	}
	resp = driver_get_response();
  400cdc:	4b1f      	ldr	r3, [pc, #124]	; (400d5c <sdio_op_cond+0xa0>)
  400cde:	4798      	blx	r3
  400ce0:	6078      	str	r0, [r7, #4]
	if ((resp & OCR_SDIO_NF) == 0) {
  400ce2:	687b      	ldr	r3, [r7, #4]
  400ce4:	f003 43e0 	and.w	r3, r3, #1879048192	; 0x70000000
  400ce8:	2b00      	cmp	r3, #0
  400cea:	d101      	bne.n	400cf0 <sdio_op_cond+0x34>
		return true; // No error but card type not updated
  400cec:	2301      	movs	r3, #1
  400cee:	e02f      	b.n	400d50 <sdio_op_cond+0x94>
	 * Wait card ready
	 * Timeout 1s = 400KHz / ((6+4)*8) cylces = 5000 retry
	 * 6 = cmd byte size
	 * 4(SPI) 6(MCI) = response byte size
	 */
	uint32_t cmd5_retry = 5000;
  400cf0:	f241 3388 	movw	r3, #5000	; 0x1388
  400cf4:	603b      	str	r3, [r7, #0]
	while (1) {
		// CMD5 - SDIO send operation condition (OCR) command.
		if (!driver_send_cmd(SDIO_CMD5_SEND_OP_COND,
  400cf6:	687b      	ldr	r3, [r7, #4]
  400cf8:	f403 13fc 	and.w	r3, r3, #2064384	; 0x1f8000
  400cfc:	4619      	mov	r1, r3
  400cfe:	f244 5005 	movw	r0, #17669	; 0x4505
  400d02:	4b15      	ldr	r3, [pc, #84]	; (400d58 <sdio_op_cond+0x9c>)
  400d04:	4798      	blx	r3
  400d06:	4603      	mov	r3, r0
  400d08:	f083 0301 	eor.w	r3, r3, #1
  400d0c:	b2db      	uxtb	r3, r3
  400d0e:	2b00      	cmp	r3, #0
  400d10:	d001      	beq.n	400d16 <sdio_op_cond+0x5a>
				resp & SD_MMC_VOLTAGE_SUPPORT)) {
			sd_mmc_debug("%s: CMD5 Fail\n\r", __func__);
			return false;
  400d12:	2300      	movs	r3, #0
  400d14:	e01c      	b.n	400d50 <sdio_op_cond+0x94>
		}
		resp = driver_get_response();
  400d16:	4b11      	ldr	r3, [pc, #68]	; (400d5c <sdio_op_cond+0xa0>)
  400d18:	4798      	blx	r3
  400d1a:	6078      	str	r0, [r7, #4]
		if ((resp & OCR_POWER_UP_BUSY) == OCR_POWER_UP_BUSY) {
  400d1c:	687b      	ldr	r3, [r7, #4]
  400d1e:	2b00      	cmp	r3, #0
  400d20:	db06      	blt.n	400d30 <sdio_op_cond+0x74>
			break;
		}
		if (cmd5_retry-- == 0) {
  400d22:	683b      	ldr	r3, [r7, #0]
  400d24:	1e5a      	subs	r2, r3, #1
  400d26:	603a      	str	r2, [r7, #0]
  400d28:	2b00      	cmp	r3, #0
  400d2a:	d1e4      	bne.n	400cf6 <sdio_op_cond+0x3a>
			sd_mmc_debug("%s: CMD5 Timeout on busy\n\r", __func__);
			return false;
  400d2c:	2300      	movs	r3, #0
  400d2e:	e00f      	b.n	400d50 <sdio_op_cond+0x94>
			break;
  400d30:	bf00      	nop
		}
	}
	// Update card type at the end of busy
	if ((resp & OCR_SDIO_MP) > 0) {
  400d32:	687b      	ldr	r3, [r7, #4]
  400d34:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
  400d38:	2b00      	cmp	r3, #0
  400d3a:	d004      	beq.n	400d46 <sdio_op_cond+0x8a>
		sd_mmc_card->type = CARD_TYPE_SD_COMBO;
  400d3c:	4b08      	ldr	r3, [pc, #32]	; (400d60 <sdio_op_cond+0xa4>)
  400d3e:	681b      	ldr	r3, [r3, #0]
  400d40:	2205      	movs	r2, #5
  400d42:	72da      	strb	r2, [r3, #11]
  400d44:	e003      	b.n	400d4e <sdio_op_cond+0x92>
	} else {
		sd_mmc_card->type = CARD_TYPE_SDIO;
  400d46:	4b06      	ldr	r3, [pc, #24]	; (400d60 <sdio_op_cond+0xa4>)
  400d48:	681b      	ldr	r3, [r3, #0]
  400d4a:	2204      	movs	r2, #4
  400d4c:	72da      	strb	r2, [r3, #11]
	}
	return true; // No error and card type updated with SDIO type
  400d4e:	2301      	movs	r3, #1
}
  400d50:	4618      	mov	r0, r3
  400d52:	3708      	adds	r7, #8
  400d54:	46bd      	mov	sp, r7
  400d56:	bd80      	pop	{r7, pc}
  400d58:	0040263d 	.word	0x0040263d
  400d5c:	00402681 	.word	0x00402681
  400d60:	2000047c 	.word	0x2000047c

00400d64 <sdio_get_max_speed>:
 *   and update sd_mmc_card->clock
 *
 * \return true if success, otherwise false
 */
static bool sdio_get_max_speed(void)
{
  400d64:	b590      	push	{r4, r7, lr}
  400d66:	b08b      	sub	sp, #44	; 0x2c
  400d68:	af02      	add	r7, sp, #8
	uint32_t mul;
	uint8_t tplfe_max_tran_speed, i;
	uint8_t addr_cis[4];

	/* Read CIS area address in CCCR area */
	addr_old = SDIO_CCCR_CIS_PTR;
  400d6a:	2309      	movs	r3, #9
  400d6c:	61bb      	str	r3, [r7, #24]
	for(i = 0; i < 4; i++) {
  400d6e:	2300      	movs	r3, #0
  400d70:	75bb      	strb	r3, [r7, #22]
  400d72:	e00f      	b.n	400d94 <sdio_get_max_speed+0x30>
		sdio_cmd52(SDIO_CMD52_READ_FLAG, SDIO_CIA, addr_old, 0, &addr_cis[i]);
  400d74:	7dbb      	ldrb	r3, [r7, #22]
  400d76:	463a      	mov	r2, r7
  400d78:	4413      	add	r3, r2
  400d7a:	9300      	str	r3, [sp, #0]
  400d7c:	2300      	movs	r3, #0
  400d7e:	69ba      	ldr	r2, [r7, #24]
  400d80:	2100      	movs	r1, #0
  400d82:	2000      	movs	r0, #0
  400d84:	4c46      	ldr	r4, [pc, #280]	; (400ea0 <sdio_get_max_speed+0x13c>)
  400d86:	47a0      	blx	r4
		addr_old++;
  400d88:	69bb      	ldr	r3, [r7, #24]
  400d8a:	3301      	adds	r3, #1
  400d8c:	61bb      	str	r3, [r7, #24]
	for(i = 0; i < 4; i++) {
  400d8e:	7dbb      	ldrb	r3, [r7, #22]
  400d90:	3301      	adds	r3, #1
  400d92:	75bb      	strb	r3, [r7, #22]
  400d94:	7dbb      	ldrb	r3, [r7, #22]
  400d96:	2b03      	cmp	r3, #3
  400d98:	d9ec      	bls.n	400d74 <sdio_get_max_speed+0x10>
	}
	addr_old = addr_cis[0] + (addr_cis[1] << 8) + \
  400d9a:	783b      	ldrb	r3, [r7, #0]
  400d9c:	461a      	mov	r2, r3
  400d9e:	787b      	ldrb	r3, [r7, #1]
  400da0:	021b      	lsls	r3, r3, #8
  400da2:	441a      	add	r2, r3
				(addr_cis[2] << 16) + (addr_cis[3] << 24);
  400da4:	78bb      	ldrb	r3, [r7, #2]
  400da6:	041b      	lsls	r3, r3, #16
	addr_old = addr_cis[0] + (addr_cis[1] << 8) + \
  400da8:	441a      	add	r2, r3
				(addr_cis[2] << 16) + (addr_cis[3] << 24);
  400daa:	78fb      	ldrb	r3, [r7, #3]
  400dac:	061b      	lsls	r3, r3, #24
  400dae:	4413      	add	r3, r2
	addr_old = addr_cis[0] + (addr_cis[1] << 8) + \
  400db0:	61bb      	str	r3, [r7, #24]
	addr_new = addr_old;
  400db2:	69bb      	ldr	r3, [r7, #24]
  400db4:	61fb      	str	r3, [r7, #28]

	while (1) {
		/* Read a sample of CIA area */
		for(i=0; i<3; i++) {
  400db6:	2300      	movs	r3, #0
  400db8:	75bb      	strb	r3, [r7, #22]
  400dba:	e00f      	b.n	400ddc <sdio_get_max_speed+0x78>
			sdio_cmd52(SDIO_CMD52_READ_FLAG, SDIO_CIA, addr_new, 0, &buf[i]);
  400dbc:	7dbb      	ldrb	r3, [r7, #22]
  400dbe:	1d3a      	adds	r2, r7, #4
  400dc0:	4413      	add	r3, r2
  400dc2:	9300      	str	r3, [sp, #0]
  400dc4:	2300      	movs	r3, #0
  400dc6:	69fa      	ldr	r2, [r7, #28]
  400dc8:	2100      	movs	r1, #0
  400dca:	2000      	movs	r0, #0
  400dcc:	4c34      	ldr	r4, [pc, #208]	; (400ea0 <sdio_get_max_speed+0x13c>)
  400dce:	47a0      	blx	r4
			addr_new++;
  400dd0:	69fb      	ldr	r3, [r7, #28]
  400dd2:	3301      	adds	r3, #1
  400dd4:	61fb      	str	r3, [r7, #28]
		for(i=0; i<3; i++) {
  400dd6:	7dbb      	ldrb	r3, [r7, #22]
  400dd8:	3301      	adds	r3, #1
  400dda:	75bb      	strb	r3, [r7, #22]
  400ddc:	7dbb      	ldrb	r3, [r7, #22]
  400dde:	2b02      	cmp	r3, #2
  400de0:	d9ec      	bls.n	400dbc <sdio_get_max_speed+0x58>
		}
		if (buf[0] == SDIO_CISTPL_END) {
  400de2:	793b      	ldrb	r3, [r7, #4]
  400de4:	2bff      	cmp	r3, #255	; 0xff
  400de6:	d101      	bne.n	400dec <sdio_get_max_speed+0x88>
			return false; /* Tuple error */
  400de8:	2300      	movs	r3, #0
  400dea:	e055      	b.n	400e98 <sdio_get_max_speed+0x134>
		}
		if (buf[0] == SDIO_CISTPL_FUNCE && buf[2] == 0x00) {
  400dec:	793b      	ldrb	r3, [r7, #4]
  400dee:	2b22      	cmp	r3, #34	; 0x22
  400df0:	d102      	bne.n	400df8 <sdio_get_max_speed+0x94>
  400df2:	79bb      	ldrb	r3, [r7, #6]
  400df4:	2b00      	cmp	r3, #0
  400df6:	d012      	beq.n	400e1e <sdio_get_max_speed+0xba>
			break; /* Fun0 tuple found */
		}
		if (buf[1] == 0) {
  400df8:	797b      	ldrb	r3, [r7, #5]
  400dfa:	2b00      	cmp	r3, #0
  400dfc:	d101      	bne.n	400e02 <sdio_get_max_speed+0x9e>
			return false; /* Tuple error */
  400dfe:	2300      	movs	r3, #0
  400e00:	e04a      	b.n	400e98 <sdio_get_max_speed+0x134>
		}
		/* Next address */
		addr_new += buf[1]-1;
  400e02:	797b      	ldrb	r3, [r7, #5]
  400e04:	461a      	mov	r2, r3
  400e06:	69fb      	ldr	r3, [r7, #28]
  400e08:	4413      	add	r3, r2
  400e0a:	3b01      	subs	r3, #1
  400e0c:	61fb      	str	r3, [r7, #28]
		if (addr_new > (addr_old + 256)) {
  400e0e:	69bb      	ldr	r3, [r7, #24]
  400e10:	f503 7280 	add.w	r2, r3, #256	; 0x100
  400e14:	69fb      	ldr	r3, [r7, #28]
  400e16:	429a      	cmp	r2, r3
  400e18:	d2cd      	bcs.n	400db6 <sdio_get_max_speed+0x52>
			return false; /* Outoff CIS area */
  400e1a:	2300      	movs	r3, #0
  400e1c:	e03c      	b.n	400e98 <sdio_get_max_speed+0x134>
			break; /* Fun0 tuple found */
  400e1e:	bf00      	nop
		}
	}

	/* Read all Fun0 tuple fields: fn0_blk_siz & max_tran_speed */
	addr_new -= 3;
  400e20:	69fb      	ldr	r3, [r7, #28]
  400e22:	3b03      	subs	r3, #3
  400e24:	61fb      	str	r3, [r7, #28]
	for(i = 0; i < 6; i++) {
  400e26:	2300      	movs	r3, #0
  400e28:	75bb      	strb	r3, [r7, #22]
  400e2a:	e00f      	b.n	400e4c <sdio_get_max_speed+0xe8>
		sdio_cmd52(SDIO_CMD52_READ_FLAG, SDIO_CIA, addr_new, 0, &buf[i]);
  400e2c:	7dbb      	ldrb	r3, [r7, #22]
  400e2e:	1d3a      	adds	r2, r7, #4
  400e30:	4413      	add	r3, r2
  400e32:	9300      	str	r3, [sp, #0]
  400e34:	2300      	movs	r3, #0
  400e36:	69fa      	ldr	r2, [r7, #28]
  400e38:	2100      	movs	r1, #0
  400e3a:	2000      	movs	r0, #0
  400e3c:	4c18      	ldr	r4, [pc, #96]	; (400ea0 <sdio_get_max_speed+0x13c>)
  400e3e:	47a0      	blx	r4
		addr_new++;
  400e40:	69fb      	ldr	r3, [r7, #28]
  400e42:	3301      	adds	r3, #1
  400e44:	61fb      	str	r3, [r7, #28]
	for(i = 0; i < 6; i++) {
  400e46:	7dbb      	ldrb	r3, [r7, #22]
  400e48:	3301      	adds	r3, #1
  400e4a:	75bb      	strb	r3, [r7, #22]
  400e4c:	7dbb      	ldrb	r3, [r7, #22]
  400e4e:	2b05      	cmp	r3, #5
  400e50:	d9ec      	bls.n	400e2c <sdio_get_max_speed+0xc8>
	}

	tplfe_max_tran_speed = buf[5];
  400e52:	7a7b      	ldrb	r3, [r7, #9]
  400e54:	75fb      	strb	r3, [r7, #23]
	if (tplfe_max_tran_speed > 0x32) {
  400e56:	7dfb      	ldrb	r3, [r7, #23]
  400e58:	2b32      	cmp	r3, #50	; 0x32
  400e5a:	d901      	bls.n	400e60 <sdio_get_max_speed+0xfc>
		/* Error on SDIO register, the high speed is not activated
		 * and the clock can not be more than 25MHz.
		 * This error is present on specific SDIO card
		 * (H&D wireless card - HDG104 WiFi SIP).
		 */
		tplfe_max_tran_speed = 0x32; /* 25Mhz */
  400e5c:	2332      	movs	r3, #50	; 0x32
  400e5e:	75fb      	strb	r3, [r7, #23]
	}

	/* Decode transfer speed in Hz.*/
	unit = sd_mmc_trans_units[tplfe_max_tran_speed & 0x7];
  400e60:	7dfb      	ldrb	r3, [r7, #23]
  400e62:	f003 0307 	and.w	r3, r3, #7
  400e66:	4a0f      	ldr	r2, [pc, #60]	; (400ea4 <sdio_get_max_speed+0x140>)
  400e68:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  400e6c:	613b      	str	r3, [r7, #16]
	mul = sd_trans_multipliers[(tplfe_max_tran_speed >> 3) & 0xF];
  400e6e:	7dfb      	ldrb	r3, [r7, #23]
  400e70:	08db      	lsrs	r3, r3, #3
  400e72:	b2db      	uxtb	r3, r3
  400e74:	f003 030f 	and.w	r3, r3, #15
  400e78:	4a0b      	ldr	r2, [pc, #44]	; (400ea8 <sdio_get_max_speed+0x144>)
  400e7a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  400e7e:	60fb      	str	r3, [r7, #12]
	sd_mmc_card->clock = unit * mul * 1000;
  400e80:	4b0a      	ldr	r3, [pc, #40]	; (400eac <sdio_get_max_speed+0x148>)
  400e82:	681b      	ldr	r3, [r3, #0]
  400e84:	693a      	ldr	r2, [r7, #16]
  400e86:	68f9      	ldr	r1, [r7, #12]
  400e88:	fb01 f202 	mul.w	r2, r1, r2
  400e8c:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  400e90:	fb01 f202 	mul.w	r2, r1, r2
  400e94:	601a      	str	r2, [r3, #0]
	 * which supports upto 25MHz.
	 * A SDIO card alone can be:
	 * - a Low-Speed SDIO card which supports 400Khz minimum
	 * - a Full-Speed SDIO card which supports upto 25MHz
	 */
	return true;
  400e96:	2301      	movs	r3, #1
}
  400e98:	4618      	mov	r0, r3
  400e9a:	3724      	adds	r7, #36	; 0x24
  400e9c:	46bd      	mov	sp, r7
  400e9e:	bd90      	pop	{r4, r7, pc}
  400ea0:	00401535 	.word	0x00401535
  400ea4:	00403fbc 	.word	0x00403fbc
  400ea8:	00403fd8 	.word	0x00403fd8
  400eac:	2000047c 	.word	0x2000047c

00400eb0 <sdio_cmd52_set_bus_width>:
 * \note sd_mmc_card->bus_width is updated.
 *
 * \return true if success, otherwise false
 */
static bool sdio_cmd52_set_bus_width(void)
{
  400eb0:	b590      	push	{r4, r7, lr}
  400eb2:	b085      	sub	sp, #20
  400eb4:	af02      	add	r7, sp, #8
	 * A SDIO Low-Speed alone can supports 4bit (Optional)
	 */
	uint8_t u8_value;

	// Check 4bit support in 4BLS of "Card Capability" register
	if (!sdio_cmd52(SDIO_CMD52_READ_FLAG, SDIO_CIA, SDIO_CCCR_CAP,
  400eb6:	1dfb      	adds	r3, r7, #7
  400eb8:	9300      	str	r3, [sp, #0]
  400eba:	2300      	movs	r3, #0
  400ebc:	2208      	movs	r2, #8
  400ebe:	2100      	movs	r1, #0
  400ec0:	2000      	movs	r0, #0
  400ec2:	4c15      	ldr	r4, [pc, #84]	; (400f18 <sdio_cmd52_set_bus_width+0x68>)
  400ec4:	47a0      	blx	r4
  400ec6:	4603      	mov	r3, r0
  400ec8:	f083 0301 	eor.w	r3, r3, #1
  400ecc:	b2db      	uxtb	r3, r3
  400ece:	2b00      	cmp	r3, #0
  400ed0:	d001      	beq.n	400ed6 <sdio_cmd52_set_bus_width+0x26>
			0, &u8_value)) {
		return false;
  400ed2:	2300      	movs	r3, #0
  400ed4:	e01c      	b.n	400f10 <sdio_cmd52_set_bus_width+0x60>
	}
	if ((u8_value & SDIO_CAP_4BLS) != SDIO_CAP_4BLS) {
  400ed6:	79fb      	ldrb	r3, [r7, #7]
  400ed8:	b25b      	sxtb	r3, r3
  400eda:	2b00      	cmp	r3, #0
  400edc:	db01      	blt.n	400ee2 <sdio_cmd52_set_bus_width+0x32>
		// No supported, it is not a protocol error
		return true;
  400ede:	2301      	movs	r3, #1
  400ee0:	e016      	b.n	400f10 <sdio_cmd52_set_bus_width+0x60>
	}
	// HS mode possible, then enable
	u8_value = SDIO_BUSWIDTH_4B;
  400ee2:	2302      	movs	r3, #2
  400ee4:	71fb      	strb	r3, [r7, #7]
	if (!sdio_cmd52(SDIO_CMD52_WRITE_FLAG, SDIO_CIA, SDIO_CCCR_BUS_CTRL,
  400ee6:	1dfb      	adds	r3, r7, #7
  400ee8:	9300      	str	r3, [sp, #0]
  400eea:	2301      	movs	r3, #1
  400eec:	2207      	movs	r2, #7
  400eee:	2100      	movs	r1, #0
  400ef0:	2001      	movs	r0, #1
  400ef2:	4c09      	ldr	r4, [pc, #36]	; (400f18 <sdio_cmd52_set_bus_width+0x68>)
  400ef4:	47a0      	blx	r4
  400ef6:	4603      	mov	r3, r0
  400ef8:	f083 0301 	eor.w	r3, r3, #1
  400efc:	b2db      	uxtb	r3, r3
  400efe:	2b00      	cmp	r3, #0
  400f00:	d001      	beq.n	400f06 <sdio_cmd52_set_bus_width+0x56>
			1, &u8_value)) {
		return false;
  400f02:	2300      	movs	r3, #0
  400f04:	e004      	b.n	400f10 <sdio_cmd52_set_bus_width+0x60>
	}
	sd_mmc_card->bus_width = 4;
  400f06:	4b05      	ldr	r3, [pc, #20]	; (400f1c <sdio_cmd52_set_bus_width+0x6c>)
  400f08:	681b      	ldr	r3, [r3, #0]
  400f0a:	2204      	movs	r2, #4
  400f0c:	735a      	strb	r2, [r3, #13]
	sd_mmc_debug("%d-bit bus width enabled.\n\r", (int)sd_mmc_card->bus_width);
	return true;
  400f0e:	2301      	movs	r3, #1
}
  400f10:	4618      	mov	r0, r3
  400f12:	370c      	adds	r7, #12
  400f14:	46bd      	mov	sp, r7
  400f16:	bd90      	pop	{r4, r7, pc}
  400f18:	00401535 	.word	0x00401535
  400f1c:	2000047c 	.word	0x2000047c

00400f20 <sdio_cmd52_set_high_speed>:
 * \note sd_mmc_card->clock is updated.
 *
 * \return true if success, otherwise false
 */
static bool sdio_cmd52_set_high_speed(void)
{
  400f20:	b590      	push	{r4, r7, lr}
  400f22:	b085      	sub	sp, #20
  400f24:	af02      	add	r7, sp, #8
	uint8_t u8_value;

	// Check CIA.HS
	if (!sdio_cmd52(SDIO_CMD52_READ_FLAG, SDIO_CIA, SDIO_CCCR_HS, 0, &u8_value)) {
  400f26:	1dfb      	adds	r3, r7, #7
  400f28:	9300      	str	r3, [sp, #0]
  400f2a:	2300      	movs	r3, #0
  400f2c:	2213      	movs	r2, #19
  400f2e:	2100      	movs	r1, #0
  400f30:	2000      	movs	r0, #0
  400f32:	4c19      	ldr	r4, [pc, #100]	; (400f98 <sdio_cmd52_set_high_speed+0x78>)
  400f34:	47a0      	blx	r4
  400f36:	4603      	mov	r3, r0
  400f38:	f083 0301 	eor.w	r3, r3, #1
  400f3c:	b2db      	uxtb	r3, r3
  400f3e:	2b00      	cmp	r3, #0
  400f40:	d001      	beq.n	400f46 <sdio_cmd52_set_high_speed+0x26>
		return false;
  400f42:	2300      	movs	r3, #0
  400f44:	e024      	b.n	400f90 <sdio_cmd52_set_high_speed+0x70>
	}
	if ((u8_value & SDIO_SHS) != SDIO_SHS) {
  400f46:	79fb      	ldrb	r3, [r7, #7]
  400f48:	f003 0301 	and.w	r3, r3, #1
  400f4c:	2b00      	cmp	r3, #0
  400f4e:	d101      	bne.n	400f54 <sdio_cmd52_set_high_speed+0x34>
		// No supported, it is not a protocol error
		return true;
  400f50:	2301      	movs	r3, #1
  400f52:	e01d      	b.n	400f90 <sdio_cmd52_set_high_speed+0x70>
	}
	// HS mode possible, then enable
	u8_value = SDIO_EHS;
  400f54:	2302      	movs	r3, #2
  400f56:	71fb      	strb	r3, [r7, #7]
	if (!sdio_cmd52(SDIO_CMD52_WRITE_FLAG, SDIO_CIA, SDIO_CCCR_HS,
  400f58:	1dfb      	adds	r3, r7, #7
  400f5a:	9300      	str	r3, [sp, #0]
  400f5c:	2301      	movs	r3, #1
  400f5e:	2213      	movs	r2, #19
  400f60:	2100      	movs	r1, #0
  400f62:	2001      	movs	r0, #1
  400f64:	4c0c      	ldr	r4, [pc, #48]	; (400f98 <sdio_cmd52_set_high_speed+0x78>)
  400f66:	47a0      	blx	r4
  400f68:	4603      	mov	r3, r0
  400f6a:	f083 0301 	eor.w	r3, r3, #1
  400f6e:	b2db      	uxtb	r3, r3
  400f70:	2b00      	cmp	r3, #0
  400f72:	d001      	beq.n	400f78 <sdio_cmd52_set_high_speed+0x58>
			1, &u8_value)) {
		return false;
  400f74:	2300      	movs	r3, #0
  400f76:	e00b      	b.n	400f90 <sdio_cmd52_set_high_speed+0x70>
	}
	sd_mmc_card->high_speed = 1;
  400f78:	4b08      	ldr	r3, [pc, #32]	; (400f9c <sdio_cmd52_set_high_speed+0x7c>)
  400f7a:	681b      	ldr	r3, [r3, #0]
  400f7c:	2201      	movs	r2, #1
  400f7e:	779a      	strb	r2, [r3, #30]
	sd_mmc_card->clock *= 2;
  400f80:	4b06      	ldr	r3, [pc, #24]	; (400f9c <sdio_cmd52_set_high_speed+0x7c>)
  400f82:	681b      	ldr	r3, [r3, #0]
  400f84:	4a05      	ldr	r2, [pc, #20]	; (400f9c <sdio_cmd52_set_high_speed+0x7c>)
  400f86:	6812      	ldr	r2, [r2, #0]
  400f88:	6812      	ldr	r2, [r2, #0]
  400f8a:	0052      	lsls	r2, r2, #1
  400f8c:	601a      	str	r2, [r3, #0]
	return true;
  400f8e:	2301      	movs	r3, #1
}
  400f90:	4618      	mov	r0, r3
  400f92:	370c      	adds	r7, #12
  400f94:	46bd      	mov	sp, r7
  400f96:	bd90      	pop	{r4, r7, pc}
  400f98:	00401535 	.word	0x00401535
  400f9c:	2000047c 	.word	0x2000047c

00400fa0 <sd_cm6_set_high_speed>:
 * \note sd_mmc_card->clock is updated.
 *
 * \return true if success, otherwise false
 */
static bool sd_cm6_set_high_speed(void)
{
  400fa0:	b590      	push	{r4, r7, lr}
  400fa2:	b093      	sub	sp, #76	; 0x4c
  400fa4:	af02      	add	r7, sp, #8
	uint8_t switch_status[SD_SW_STATUS_BSIZE] = {0};
  400fa6:	463b      	mov	r3, r7
  400fa8:	2240      	movs	r2, #64	; 0x40
  400faa:	2100      	movs	r1, #0
  400fac:	4618      	mov	r0, r3
  400fae:	4b2f      	ldr	r3, [pc, #188]	; (40106c <sd_cm6_set_high_speed+0xcc>)
  400fb0:	4798      	blx	r3

	if (!driver_adtc_start(SD_CMD6_SWITCH_FUNC,
  400fb2:	2301      	movs	r3, #1
  400fb4:	9300      	str	r3, [sp, #0]
  400fb6:	2301      	movs	r3, #1
  400fb8:	2240      	movs	r2, #64	; 0x40
  400fba:	492d      	ldr	r1, [pc, #180]	; (401070 <sd_cm6_set_high_speed+0xd0>)
  400fbc:	482d      	ldr	r0, [pc, #180]	; (401074 <sd_cm6_set_high_speed+0xd4>)
  400fbe:	4c2e      	ldr	r4, [pc, #184]	; (401078 <sd_cm6_set_high_speed+0xd8>)
  400fc0:	47a0      	blx	r4
  400fc2:	4603      	mov	r3, r0
  400fc4:	f083 0301 	eor.w	r3, r3, #1
  400fc8:	b2db      	uxtb	r3, r3
  400fca:	2b00      	cmp	r3, #0
  400fcc:	d001      	beq.n	400fd2 <sd_cm6_set_high_speed+0x32>
			| SD_CMD6_GRP4_NO_INFLUENCE
			| SD_CMD6_GRP3_NO_INFLUENCE
			| SD_CMD6_GRP2_DEFAULT
			| SD_CMD6_GRP1_HIGH_SPEED,
			SD_SW_STATUS_BSIZE, 1, true)) {
		return false;
  400fce:	2300      	movs	r3, #0
  400fd0:	e047      	b.n	401062 <sd_cm6_set_high_speed+0xc2>
	}
	if (!driver_start_read_blocks(switch_status, 1)) {
  400fd2:	463b      	mov	r3, r7
  400fd4:	2101      	movs	r1, #1
  400fd6:	4618      	mov	r0, r3
  400fd8:	4b28      	ldr	r3, [pc, #160]	; (40107c <sd_cm6_set_high_speed+0xdc>)
  400fda:	4798      	blx	r3
  400fdc:	4603      	mov	r3, r0
  400fde:	f083 0301 	eor.w	r3, r3, #1
  400fe2:	b2db      	uxtb	r3, r3
  400fe4:	2b00      	cmp	r3, #0
  400fe6:	d001      	beq.n	400fec <sd_cm6_set_high_speed+0x4c>
		return false;
  400fe8:	2300      	movs	r3, #0
  400fea:	e03a      	b.n	401062 <sd_cm6_set_high_speed+0xc2>
	}
	if (!driver_wait_end_of_read_blocks()) {
  400fec:	4b24      	ldr	r3, [pc, #144]	; (401080 <sd_cm6_set_high_speed+0xe0>)
  400fee:	4798      	blx	r3
  400ff0:	4603      	mov	r3, r0
  400ff2:	f083 0301 	eor.w	r3, r3, #1
  400ff6:	b2db      	uxtb	r3, r3
  400ff8:	2b00      	cmp	r3, #0
  400ffa:	d001      	beq.n	401000 <sd_cm6_set_high_speed+0x60>
		return false;
  400ffc:	2300      	movs	r3, #0
  400ffe:	e030      	b.n	401062 <sd_cm6_set_high_speed+0xc2>
	}

	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  401000:	4b20      	ldr	r3, [pc, #128]	; (401084 <sd_cm6_set_high_speed+0xe4>)
  401002:	4798      	blx	r3
  401004:	4603      	mov	r3, r0
  401006:	f003 0380 	and.w	r3, r3, #128	; 0x80
  40100a:	2b00      	cmp	r3, #0
  40100c:	d001      	beq.n	401012 <sd_cm6_set_high_speed+0x72>
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
  40100e:	2300      	movs	r3, #0
  401010:	e027      	b.n	401062 <sd_cm6_set_high_speed+0xc2>
	}
	if (SD_SW_STATUS_FUN_GRP1_RC(switch_status)
  401012:	4638      	mov	r0, r7
  401014:	2304      	movs	r3, #4
  401016:	f44f 72bc 	mov.w	r2, #376	; 0x178
  40101a:	f44f 7100 	mov.w	r1, #512	; 0x200
  40101e:	4c1a      	ldr	r4, [pc, #104]	; (401088 <sd_cm6_set_high_speed+0xe8>)
  401020:	47a0      	blx	r4
  401022:	4603      	mov	r3, r0
  401024:	2b0f      	cmp	r3, #15
  401026:	d101      	bne.n	40102c <sd_cm6_set_high_speed+0x8c>
			== SD_SW_STATUS_FUN_GRP_RC_ERROR) {
		// No supported, it is not a protocol error
		return true;
  401028:	2301      	movs	r3, #1
  40102a:	e01a      	b.n	401062 <sd_cm6_set_high_speed+0xc2>
	}
	if (SD_SW_STATUS_FUN_GRP1_BUSY(switch_status)) {
  40102c:	4638      	mov	r0, r7
  40102e:	2310      	movs	r3, #16
  401030:	f44f 7288 	mov.w	r2, #272	; 0x110
  401034:	f44f 7100 	mov.w	r1, #512	; 0x200
  401038:	4c13      	ldr	r4, [pc, #76]	; (401088 <sd_cm6_set_high_speed+0xe8>)
  40103a:	47a0      	blx	r4
  40103c:	4603      	mov	r3, r0
  40103e:	2b00      	cmp	r3, #0
  401040:	d001      	beq.n	401046 <sd_cm6_set_high_speed+0xa6>
		sd_mmc_debug("%s: CMD6 SD_SW_STATUS_FUN_GRP1_BUSY\n\r", __func__);
		return false;
  401042:	2300      	movs	r3, #0
  401044:	e00d      	b.n	401062 <sd_cm6_set_high_speed+0xc2>
	}
	// CMD6 function switching period is within 8 clocks
	// after the end bit of status data.
	driver_send_clock();
  401046:	4b11      	ldr	r3, [pc, #68]	; (40108c <sd_cm6_set_high_speed+0xec>)
  401048:	4798      	blx	r3
	sd_mmc_card->high_speed = 1;
  40104a:	4b11      	ldr	r3, [pc, #68]	; (401090 <sd_cm6_set_high_speed+0xf0>)
  40104c:	681b      	ldr	r3, [r3, #0]
  40104e:	2201      	movs	r2, #1
  401050:	779a      	strb	r2, [r3, #30]
	sd_mmc_card->clock *= 2;
  401052:	4b0f      	ldr	r3, [pc, #60]	; (401090 <sd_cm6_set_high_speed+0xf0>)
  401054:	681b      	ldr	r3, [r3, #0]
  401056:	4a0e      	ldr	r2, [pc, #56]	; (401090 <sd_cm6_set_high_speed+0xf0>)
  401058:	6812      	ldr	r2, [r2, #0]
  40105a:	6812      	ldr	r2, [r2, #0]
  40105c:	0052      	lsls	r2, r2, #1
  40105e:	601a      	str	r2, [r3, #0]
	return true;
  401060:	2301      	movs	r3, #1
}
  401062:	4618      	mov	r0, r3
  401064:	3744      	adds	r7, #68	; 0x44
  401066:	46bd      	mov	sp, r7
  401068:	bd90      	pop	{r4, r7, pc}
  40106a:	bf00      	nop
  40106c:	0040376d 	.word	0x0040376d
  401070:	80ffff01 	.word	0x80ffff01
  401074:	00081106 	.word	0x00081106
  401078:	00402709 	.word	0x00402709
  40107c:	004028cd 	.word	0x004028cd
  401080:	0040296d 	.word	0x0040296d
  401084:	00402681 	.word	0x00402681
  401088:	00400a85 	.word	0x00400a85
  40108c:	00402601 	.word	0x00402601
  401090:	2000047c 	.word	0x2000047c

00401094 <mmc_cmd6_set_bus_width>:
 * \param bus_width   Bus width to set
 *
 * \return true if success, otherwise false
 */
static bool mmc_cmd6_set_bus_width(uint8_t bus_width)
{
  401094:	b580      	push	{r7, lr}
  401096:	b084      	sub	sp, #16
  401098:	af00      	add	r7, sp, #0
  40109a:	4603      	mov	r3, r0
  40109c:	71fb      	strb	r3, [r7, #7]
	uint32_t arg;

	switch (bus_width) {
  40109e:	79fb      	ldrb	r3, [r7, #7]
  4010a0:	2b04      	cmp	r3, #4
  4010a2:	d004      	beq.n	4010ae <mmc_cmd6_set_bus_width+0x1a>
  4010a4:	2b08      	cmp	r3, #8
  4010a6:	d105      	bne.n	4010b4 <mmc_cmd6_set_bus_width+0x20>
	case 8:
		arg = MMC_CMD6_ACCESS_SET_BITS
  4010a8:	4b13      	ldr	r3, [pc, #76]	; (4010f8 <mmc_cmd6_set_bus_width+0x64>)
  4010aa:	60fb      	str	r3, [r7, #12]
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_8BIT;
		break;
  4010ac:	e005      	b.n	4010ba <mmc_cmd6_set_bus_width+0x26>
	case 4:
		arg = MMC_CMD6_ACCESS_SET_BITS
  4010ae:	4b13      	ldr	r3, [pc, #76]	; (4010fc <mmc_cmd6_set_bus_width+0x68>)
  4010b0:	60fb      	str	r3, [r7, #12]
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_4BIT;
		break;
  4010b2:	e002      	b.n	4010ba <mmc_cmd6_set_bus_width+0x26>
	default:
		arg = MMC_CMD6_ACCESS_SET_BITS
  4010b4:	4b12      	ldr	r3, [pc, #72]	; (401100 <mmc_cmd6_set_bus_width+0x6c>)
  4010b6:	60fb      	str	r3, [r7, #12]
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_1BIT;
		break;
  4010b8:	bf00      	nop
	}
	if (!driver_send_cmd(MMC_CMD6_SWITCH, arg)) {
  4010ba:	68f9      	ldr	r1, [r7, #12]
  4010bc:	f243 1006 	movw	r0, #12550	; 0x3106
  4010c0:	4b10      	ldr	r3, [pc, #64]	; (401104 <mmc_cmd6_set_bus_width+0x70>)
  4010c2:	4798      	blx	r3
  4010c4:	4603      	mov	r3, r0
  4010c6:	f083 0301 	eor.w	r3, r3, #1
  4010ca:	b2db      	uxtb	r3, r3
  4010cc:	2b00      	cmp	r3, #0
  4010ce:	d001      	beq.n	4010d4 <mmc_cmd6_set_bus_width+0x40>
		return false;
  4010d0:	2300      	movs	r3, #0
  4010d2:	e00d      	b.n	4010f0 <mmc_cmd6_set_bus_width+0x5c>
	}
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  4010d4:	4b0c      	ldr	r3, [pc, #48]	; (401108 <mmc_cmd6_set_bus_width+0x74>)
  4010d6:	4798      	blx	r3
  4010d8:	4603      	mov	r3, r0
  4010da:	f003 0380 	and.w	r3, r3, #128	; 0x80
  4010de:	2b00      	cmp	r3, #0
  4010e0:	d001      	beq.n	4010e6 <mmc_cmd6_set_bus_width+0x52>
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
  4010e2:	2300      	movs	r3, #0
  4010e4:	e004      	b.n	4010f0 <mmc_cmd6_set_bus_width+0x5c>
	}
	sd_mmc_card->bus_width = bus_width;
  4010e6:	4b09      	ldr	r3, [pc, #36]	; (40110c <mmc_cmd6_set_bus_width+0x78>)
  4010e8:	681b      	ldr	r3, [r3, #0]
  4010ea:	79fa      	ldrb	r2, [r7, #7]
  4010ec:	735a      	strb	r2, [r3, #13]
	sd_mmc_debug("%d-bit bus width enabled.\n\r", (int)sd_mmc_card->bus_width);
	return true;
  4010ee:	2301      	movs	r3, #1
}
  4010f0:	4618      	mov	r0, r3
  4010f2:	3710      	adds	r7, #16
  4010f4:	46bd      	mov	sp, r7
  4010f6:	bd80      	pop	{r7, pc}
  4010f8:	01b70200 	.word	0x01b70200
  4010fc:	01b70100 	.word	0x01b70100
  401100:	01b70000 	.word	0x01b70000
  401104:	0040263d 	.word	0x0040263d
  401108:	00402681 	.word	0x00402681
  40110c:	2000047c 	.word	0x2000047c

00401110 <mmc_cmd6_set_high_speed>:
 * \note sd_mmc_card->clock is updated.
 *
 * \return true if success, otherwise false
 */
static bool mmc_cmd6_set_high_speed(void)
{
  401110:	b580      	push	{r7, lr}
  401112:	af00      	add	r7, sp, #0
	if (!driver_send_cmd(MMC_CMD6_SWITCH,
  401114:	4910      	ldr	r1, [pc, #64]	; (401158 <mmc_cmd6_set_high_speed+0x48>)
  401116:	f243 1006 	movw	r0, #12550	; 0x3106
  40111a:	4b10      	ldr	r3, [pc, #64]	; (40115c <mmc_cmd6_set_high_speed+0x4c>)
  40111c:	4798      	blx	r3
  40111e:	4603      	mov	r3, r0
  401120:	f083 0301 	eor.w	r3, r3, #1
  401124:	b2db      	uxtb	r3, r3
  401126:	2b00      	cmp	r3, #0
  401128:	d001      	beq.n	40112e <mmc_cmd6_set_high_speed+0x1e>
			MMC_CMD6_ACCESS_WRITE_BYTE
			| MMC_CMD6_INDEX_HS_TIMING
			| MMC_CMD6_VALUE_HS_TIMING_ENABLE)) {
		return false;
  40112a:	2300      	movs	r3, #0
  40112c:	e011      	b.n	401152 <mmc_cmd6_set_high_speed+0x42>
	}
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  40112e:	4b0c      	ldr	r3, [pc, #48]	; (401160 <mmc_cmd6_set_high_speed+0x50>)
  401130:	4798      	blx	r3
  401132:	4603      	mov	r3, r0
  401134:	f003 0380 	and.w	r3, r3, #128	; 0x80
  401138:	2b00      	cmp	r3, #0
  40113a:	d001      	beq.n	401140 <mmc_cmd6_set_high_speed+0x30>
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
  40113c:	2300      	movs	r3, #0
  40113e:	e008      	b.n	401152 <mmc_cmd6_set_high_speed+0x42>
	}
	sd_mmc_card->high_speed = 1;
  401140:	4b08      	ldr	r3, [pc, #32]	; (401164 <mmc_cmd6_set_high_speed+0x54>)
  401142:	681b      	ldr	r3, [r3, #0]
  401144:	2201      	movs	r2, #1
  401146:	779a      	strb	r2, [r3, #30]
	sd_mmc_card->clock = 52000000lu;
  401148:	4b06      	ldr	r3, [pc, #24]	; (401164 <mmc_cmd6_set_high_speed+0x54>)
  40114a:	681b      	ldr	r3, [r3, #0]
  40114c:	4a06      	ldr	r2, [pc, #24]	; (401168 <mmc_cmd6_set_high_speed+0x58>)
  40114e:	601a      	str	r2, [r3, #0]
	return true;
  401150:	2301      	movs	r3, #1
}
  401152:	4618      	mov	r0, r3
  401154:	bd80      	pop	{r7, pc}
  401156:	bf00      	nop
  401158:	03b90100 	.word	0x03b90100
  40115c:	0040263d 	.word	0x0040263d
  401160:	00402681 	.word	0x00402681
  401164:	2000047c 	.word	0x2000047c
  401168:	03197500 	.word	0x03197500

0040116c <sd_cmd8>:
 *
 * \return true if success, otherwise false
 *         with a update of \ref sd_mmc_err.
 */
static bool sd_cmd8(uint8_t * v2)
{
  40116c:	b580      	push	{r7, lr}
  40116e:	b084      	sub	sp, #16
  401170:	af00      	add	r7, sp, #0
  401172:	6078      	str	r0, [r7, #4]
	uint32_t resp;

	*v2 = 0;
  401174:	687b      	ldr	r3, [r7, #4]
  401176:	2200      	movs	r2, #0
  401178:	701a      	strb	r2, [r3, #0]
	// Test for SD version 2
	if (!driver_send_cmd(SD_CMD8_SEND_IF_COND,
  40117a:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
  40117e:	f245 5008 	movw	r0, #21768	; 0x5508
  401182:	4b11      	ldr	r3, [pc, #68]	; (4011c8 <sd_cmd8+0x5c>)
  401184:	4798      	blx	r3
  401186:	4603      	mov	r3, r0
  401188:	f083 0301 	eor.w	r3, r3, #1
  40118c:	b2db      	uxtb	r3, r3
  40118e:	2b00      	cmp	r3, #0
  401190:	d001      	beq.n	401196 <sd_cmd8+0x2a>
			SD_CMD8_PATTERN | SD_CMD8_HIGH_VOLTAGE)) {
		return true; // It is not a V2
  401192:	2301      	movs	r3, #1
  401194:	e014      	b.n	4011c0 <sd_cmd8+0x54>
	}
	// Check R7 response
	resp = driver_get_response();
  401196:	4b0d      	ldr	r3, [pc, #52]	; (4011cc <sd_cmd8+0x60>)
  401198:	4798      	blx	r3
  40119a:	60f8      	str	r0, [r7, #12]
	if (resp == 0xFFFFFFFF) {
  40119c:	68fb      	ldr	r3, [r7, #12]
  40119e:	f1b3 3fff 	cmp.w	r3, #4294967295
  4011a2:	d101      	bne.n	4011a8 <sd_cmd8+0x3c>
		// No compliance R7 value
		return true; // It is not a V2
  4011a4:	2301      	movs	r3, #1
  4011a6:	e00b      	b.n	4011c0 <sd_cmd8+0x54>
	}
	if ((resp & (SD_CMD8_MASK_PATTERN | SD_CMD8_MASK_VOLTAGE))
  4011a8:	68fb      	ldr	r3, [r7, #12]
  4011aa:	f3c3 030b 	ubfx	r3, r3, #0, #12
  4011ae:	f5b3 7fd5 	cmp.w	r3, #426	; 0x1aa
  4011b2:	d001      	beq.n	4011b8 <sd_cmd8+0x4c>
				!= (SD_CMD8_PATTERN | SD_CMD8_HIGH_VOLTAGE)) {
		sd_mmc_debug("%s: CMD8 resp32 0x%08x UNUSABLE CARD\n\r",
				__func__, resp);
		return false;
  4011b4:	2300      	movs	r3, #0
  4011b6:	e003      	b.n	4011c0 <sd_cmd8+0x54>
	}
	sd_mmc_debug("SD card V2\n\r");
	*v2 = 1;
  4011b8:	687b      	ldr	r3, [r7, #4]
  4011ba:	2201      	movs	r2, #1
  4011bc:	701a      	strb	r2, [r3, #0]
	return true;
  4011be:	2301      	movs	r3, #1
}
  4011c0:	4618      	mov	r0, r3
  4011c2:	3710      	adds	r7, #16
  4011c4:	46bd      	mov	sp, r7
  4011c6:	bd80      	pop	{r7, pc}
  4011c8:	0040263d 	.word	0x0040263d
  4011cc:	00402681 	.word	0x00402681

004011d0 <mmc_cmd8>:
 * support information
 *
 * \return true if success, otherwise false
 */
static bool mmc_cmd8(uint8_t *b_authorize_high_speed)
{
  4011d0:	b590      	push	{r4, r7, lr}
  4011d2:	b089      	sub	sp, #36	; 0x24
  4011d4:	af02      	add	r7, sp, #8
  4011d6:	6078      	str	r0, [r7, #4]
	uint16_t i;
	uint32_t ext_csd;
	uint32_t sec_count;

	if (!driver_adtc_start(MMC_CMD8_SEND_EXT_CSD, 0,
  4011d8:	2300      	movs	r3, #0
  4011da:	9300      	str	r3, [sp, #0]
  4011dc:	2301      	movs	r3, #1
  4011de:	f44f 7200 	mov.w	r2, #512	; 0x200
  4011e2:	2100      	movs	r1, #0
  4011e4:	4833      	ldr	r0, [pc, #204]	; (4012b4 <mmc_cmd8+0xe4>)
  4011e6:	4c34      	ldr	r4, [pc, #208]	; (4012b8 <mmc_cmd8+0xe8>)
  4011e8:	47a0      	blx	r4
  4011ea:	4603      	mov	r3, r0
  4011ec:	f083 0301 	eor.w	r3, r3, #1
  4011f0:	b2db      	uxtb	r3, r3
  4011f2:	2b00      	cmp	r3, #0
  4011f4:	d001      	beq.n	4011fa <mmc_cmd8+0x2a>
			EXT_CSD_BSIZE, 1, false)) {
		return false;
  4011f6:	2300      	movs	r3, #0
  4011f8:	e058      	b.n	4012ac <mmc_cmd8+0xdc>
	//** Read and decode Extended Extended CSD
	// Note: The read access is done in byte to avoid a buffer
	// of EXT_CSD_BSIZE Byte in stack.

	// Read card type
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
  4011fa:	2300      	movs	r3, #0
  4011fc:	82fb      	strh	r3, [r7, #22]
  4011fe:	e00f      	b.n	401220 <mmc_cmd8+0x50>
		if (!driver_read_word(&ext_csd)) {
  401200:	f107 0310 	add.w	r3, r7, #16
  401204:	4618      	mov	r0, r3
  401206:	4b2d      	ldr	r3, [pc, #180]	; (4012bc <mmc_cmd8+0xec>)
  401208:	4798      	blx	r3
  40120a:	4603      	mov	r3, r0
  40120c:	f083 0301 	eor.w	r3, r3, #1
  401210:	b2db      	uxtb	r3, r3
  401212:	2b00      	cmp	r3, #0
  401214:	d001      	beq.n	40121a <mmc_cmd8+0x4a>
			return false;
  401216:	2300      	movs	r3, #0
  401218:	e048      	b.n	4012ac <mmc_cmd8+0xdc>
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
  40121a:	8afb      	ldrh	r3, [r7, #22]
  40121c:	3301      	adds	r3, #1
  40121e:	82fb      	strh	r3, [r7, #22]
  401220:	8afb      	ldrh	r3, [r7, #22]
  401222:	2b31      	cmp	r3, #49	; 0x31
  401224:	d9ec      	bls.n	401200 <mmc_cmd8+0x30>
		}
	}
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
			& MMC_CTYPE_52MHZ;
  401226:	693b      	ldr	r3, [r7, #16]
  401228:	b2db      	uxtb	r3, r3
  40122a:	f003 0302 	and.w	r3, r3, #2
  40122e:	b2da      	uxtb	r2, r3
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
  401230:	687b      	ldr	r3, [r7, #4]
  401232:	701a      	strb	r2, [r3, #0]

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
  401234:	4b22      	ldr	r3, [pc, #136]	; (4012c0 <mmc_cmd8+0xf0>)
  401236:	681b      	ldr	r3, [r3, #0]
  401238:	f103 000e 	add.w	r0, r3, #14
  40123c:	230c      	movs	r3, #12
  40123e:	223e      	movs	r2, #62	; 0x3e
  401240:	2180      	movs	r1, #128	; 0x80
  401242:	4c20      	ldr	r4, [pc, #128]	; (4012c4 <mmc_cmd8+0xf4>)
  401244:	47a0      	blx	r4
  401246:	4602      	mov	r2, r0
  401248:	f640 73ff 	movw	r3, #4095	; 0xfff
  40124c:	429a      	cmp	r2, r3
  40124e:	d129      	bne.n	4012a4 <mmc_cmd8+0xd4>
		// For high capacity SD/MMC card,
		// memory capacity = SEC_COUNT * 512 byte
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
  401250:	e00f      	b.n	401272 <mmc_cmd8+0xa2>
			if (!driver_read_word(&sec_count)) {
  401252:	f107 030c 	add.w	r3, r7, #12
  401256:	4618      	mov	r0, r3
  401258:	4b18      	ldr	r3, [pc, #96]	; (4012bc <mmc_cmd8+0xec>)
  40125a:	4798      	blx	r3
  40125c:	4603      	mov	r3, r0
  40125e:	f083 0301 	eor.w	r3, r3, #1
  401262:	b2db      	uxtb	r3, r3
  401264:	2b00      	cmp	r3, #0
  401266:	d001      	beq.n	40126c <mmc_cmd8+0x9c>
				return false;
  401268:	2300      	movs	r3, #0
  40126a:	e01f      	b.n	4012ac <mmc_cmd8+0xdc>
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
  40126c:	8afb      	ldrh	r3, [r7, #22]
  40126e:	3301      	adds	r3, #1
  401270:	82fb      	strh	r3, [r7, #22]
  401272:	8afb      	ldrh	r3, [r7, #22]
  401274:	2b35      	cmp	r3, #53	; 0x35
  401276:	d9ec      	bls.n	401252 <mmc_cmd8+0x82>
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
  401278:	4b11      	ldr	r3, [pc, #68]	; (4012c0 <mmc_cmd8+0xf0>)
  40127a:	681b      	ldr	r3, [r3, #0]
  40127c:	68fa      	ldr	r2, [r7, #12]
  40127e:	0852      	lsrs	r2, r2, #1
  401280:	605a      	str	r2, [r3, #4]
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
  401282:	e00f      	b.n	4012a4 <mmc_cmd8+0xd4>
		if (!driver_read_word(&sec_count)) {
  401284:	f107 030c 	add.w	r3, r7, #12
  401288:	4618      	mov	r0, r3
  40128a:	4b0c      	ldr	r3, [pc, #48]	; (4012bc <mmc_cmd8+0xec>)
  40128c:	4798      	blx	r3
  40128e:	4603      	mov	r3, r0
  401290:	f083 0301 	eor.w	r3, r3, #1
  401294:	b2db      	uxtb	r3, r3
  401296:	2b00      	cmp	r3, #0
  401298:	d001      	beq.n	40129e <mmc_cmd8+0xce>
			return false;
  40129a:	2300      	movs	r3, #0
  40129c:	e006      	b.n	4012ac <mmc_cmd8+0xdc>
	for (; i < EXT_CSD_BSIZE / 4; i++) {
  40129e:	8afb      	ldrh	r3, [r7, #22]
  4012a0:	3301      	adds	r3, #1
  4012a2:	82fb      	strh	r3, [r7, #22]
  4012a4:	8afb      	ldrh	r3, [r7, #22]
  4012a6:	2b7f      	cmp	r3, #127	; 0x7f
  4012a8:	d9ec      	bls.n	401284 <mmc_cmd8+0xb4>
		}
	}
	return true;
  4012aa:	2301      	movs	r3, #1
}
  4012ac:	4618      	mov	r0, r3
  4012ae:	371c      	adds	r7, #28
  4012b0:	46bd      	mov	sp, r7
  4012b2:	bd90      	pop	{r4, r7, pc}
  4012b4:	00081108 	.word	0x00081108
  4012b8:	00402709 	.word	0x00402709
  4012bc:	00402831 	.word	0x00402831
  4012c0:	2000047c 	.word	0x2000047c
  4012c4:	00400a85 	.word	0x00400a85

004012c8 <sd_mmc_cmd9_mci>:
 * data (CSD) on the CMD line mci.
 *
 * \return true if success, otherwise false
 */
static bool sd_mmc_cmd9_mci(void)
{
  4012c8:	b580      	push	{r7, lr}
  4012ca:	af00      	add	r7, sp, #0
	if (!driver_send_cmd(SDMMC_MCI_CMD9_SEND_CSD, (uint32_t)sd_mmc_card->rca << 16)) {
  4012cc:	4b0c      	ldr	r3, [pc, #48]	; (401300 <sd_mmc_cmd9_mci+0x38>)
  4012ce:	681b      	ldr	r3, [r3, #0]
  4012d0:	891b      	ldrh	r3, [r3, #8]
  4012d2:	041b      	lsls	r3, r3, #16
  4012d4:	4619      	mov	r1, r3
  4012d6:	f641 3009 	movw	r0, #6921	; 0x1b09
  4012da:	4b0a      	ldr	r3, [pc, #40]	; (401304 <sd_mmc_cmd9_mci+0x3c>)
  4012dc:	4798      	blx	r3
  4012de:	4603      	mov	r3, r0
  4012e0:	f083 0301 	eor.w	r3, r3, #1
  4012e4:	b2db      	uxtb	r3, r3
  4012e6:	2b00      	cmp	r3, #0
  4012e8:	d001      	beq.n	4012ee <sd_mmc_cmd9_mci+0x26>
		return false;
  4012ea:	2300      	movs	r3, #0
  4012ec:	e006      	b.n	4012fc <sd_mmc_cmd9_mci+0x34>
	}
	driver_get_response_128(sd_mmc_card->csd);
  4012ee:	4b04      	ldr	r3, [pc, #16]	; (401300 <sd_mmc_cmd9_mci+0x38>)
  4012f0:	681b      	ldr	r3, [r3, #0]
  4012f2:	330e      	adds	r3, #14
  4012f4:	4618      	mov	r0, r3
  4012f6:	4b04      	ldr	r3, [pc, #16]	; (401308 <sd_mmc_cmd9_mci+0x40>)
  4012f8:	4798      	blx	r3
	return true;
  4012fa:	2301      	movs	r3, #1
}
  4012fc:	4618      	mov	r0, r3
  4012fe:	bd80      	pop	{r7, pc}
  401300:	2000047c 	.word	0x2000047c
  401304:	0040263d 	.word	0x0040263d
  401308:	00402699 	.word	0x00402699

0040130c <mmc_decode_csd>:

/**
 * \brief Decodes MMC CSD register
 */
static void mmc_decode_csd(void)
{
  40130c:	b5b0      	push	{r4, r5, r7, lr}
  40130e:	b084      	sub	sp, #16
  401310:	af00      	add	r7, sp, #0
 	uint32_t unit;
	uint32_t mul;
	uint32_t tran_speed;

	// Get MMC System Specification version supported by the card
	switch (MMC_CSD_SPEC_VERS(sd_mmc_card->csd)) {
  401312:	4b48      	ldr	r3, [pc, #288]	; (401434 <mmc_decode_csd+0x128>)
  401314:	681b      	ldr	r3, [r3, #0]
  401316:	f103 000e 	add.w	r0, r3, #14
  40131a:	2304      	movs	r3, #4
  40131c:	227a      	movs	r2, #122	; 0x7a
  40131e:	2180      	movs	r1, #128	; 0x80
  401320:	4c45      	ldr	r4, [pc, #276]	; (401438 <mmc_decode_csd+0x12c>)
  401322:	47a0      	blx	r4
  401324:	4603      	mov	r3, r0
  401326:	3b01      	subs	r3, #1
  401328:	2b03      	cmp	r3, #3
  40132a:	d80b      	bhi.n	401344 <mmc_decode_csd+0x38>
  40132c:	a201      	add	r2, pc, #4	; (adr r2, 401334 <mmc_decode_csd+0x28>)
  40132e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  401332:	bf00      	nop
  401334:	0040134f 	.word	0x0040134f
  401338:	00401359 	.word	0x00401359
  40133c:	00401363 	.word	0x00401363
  401340:	0040136d 	.word	0x0040136d
	default:
	case 0:
		sd_mmc_card->version = CARD_VER_MMC_1_2;
  401344:	4b3b      	ldr	r3, [pc, #236]	; (401434 <mmc_decode_csd+0x128>)
  401346:	681b      	ldr	r3, [r3, #0]
  401348:	2212      	movs	r2, #18
  40134a:	731a      	strb	r2, [r3, #12]
		break;
  40134c:	e013      	b.n	401376 <mmc_decode_csd+0x6a>

	case 1:
		sd_mmc_card->version = CARD_VER_MMC_1_4;
  40134e:	4b39      	ldr	r3, [pc, #228]	; (401434 <mmc_decode_csd+0x128>)
  401350:	681b      	ldr	r3, [r3, #0]
  401352:	2214      	movs	r2, #20
  401354:	731a      	strb	r2, [r3, #12]
		break;
  401356:	e00e      	b.n	401376 <mmc_decode_csd+0x6a>

	case 2:
		sd_mmc_card->version = CARD_VER_MMC_2_2;
  401358:	4b36      	ldr	r3, [pc, #216]	; (401434 <mmc_decode_csd+0x128>)
  40135a:	681b      	ldr	r3, [r3, #0]
  40135c:	2222      	movs	r2, #34	; 0x22
  40135e:	731a      	strb	r2, [r3, #12]
		break;
  401360:	e009      	b.n	401376 <mmc_decode_csd+0x6a>

	case 3:
		sd_mmc_card->version = CARD_VER_MMC_3;
  401362:	4b34      	ldr	r3, [pc, #208]	; (401434 <mmc_decode_csd+0x128>)
  401364:	681b      	ldr	r3, [r3, #0]
  401366:	2230      	movs	r2, #48	; 0x30
  401368:	731a      	strb	r2, [r3, #12]
		break;
  40136a:	e004      	b.n	401376 <mmc_decode_csd+0x6a>

	case 4:
		sd_mmc_card->version = CARD_VER_MMC_4;
  40136c:	4b31      	ldr	r3, [pc, #196]	; (401434 <mmc_decode_csd+0x128>)
  40136e:	681b      	ldr	r3, [r3, #0]
  401370:	2240      	movs	r2, #64	; 0x40
  401372:	731a      	strb	r2, [r3, #12]
		break;
  401374:	bf00      	nop
	}

	// Get MMC memory max transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
  401376:	4b2f      	ldr	r3, [pc, #188]	; (401434 <mmc_decode_csd+0x128>)
  401378:	681b      	ldr	r3, [r3, #0]
  40137a:	f103 000e 	add.w	r0, r3, #14
  40137e:	2308      	movs	r3, #8
  401380:	2260      	movs	r2, #96	; 0x60
  401382:	2180      	movs	r1, #128	; 0x80
  401384:	4c2c      	ldr	r4, [pc, #176]	; (401438 <mmc_decode_csd+0x12c>)
  401386:	47a0      	blx	r4
  401388:	60f8      	str	r0, [r7, #12]
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  40138a:	68fb      	ldr	r3, [r7, #12]
  40138c:	f003 0307 	and.w	r3, r3, #7
  401390:	4a2a      	ldr	r2, [pc, #168]	; (40143c <mmc_decode_csd+0x130>)
  401392:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  401396:	60bb      	str	r3, [r7, #8]
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
  401398:	68fb      	ldr	r3, [r7, #12]
  40139a:	08db      	lsrs	r3, r3, #3
  40139c:	f003 030f 	and.w	r3, r3, #15
  4013a0:	4a27      	ldr	r2, [pc, #156]	; (401440 <mmc_decode_csd+0x134>)
  4013a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  4013a6:	607b      	str	r3, [r7, #4]
	sd_mmc_card->clock = unit * mul * 1000;
  4013a8:	4b22      	ldr	r3, [pc, #136]	; (401434 <mmc_decode_csd+0x128>)
  4013aa:	681b      	ldr	r3, [r3, #0]
  4013ac:	68ba      	ldr	r2, [r7, #8]
  4013ae:	6879      	ldr	r1, [r7, #4]
  4013b0:	fb01 f202 	mul.w	r2, r1, r2
  4013b4:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  4013b8:	fb01 f202 	mul.w	r2, r1, r2
  4013bc:	601a      	str	r2, [r3, #0]
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD/MMC card:
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
  4013be:	4b1d      	ldr	r3, [pc, #116]	; (401434 <mmc_decode_csd+0x128>)
  4013c0:	681b      	ldr	r3, [r3, #0]
  4013c2:	f103 000e 	add.w	r0, r3, #14
  4013c6:	230c      	movs	r3, #12
  4013c8:	223e      	movs	r2, #62	; 0x3e
  4013ca:	2180      	movs	r1, #128	; 0x80
  4013cc:	4c1a      	ldr	r4, [pc, #104]	; (401438 <mmc_decode_csd+0x12c>)
  4013ce:	47a0      	blx	r4
  4013d0:	4602      	mov	r2, r0
  4013d2:	f640 73ff 	movw	r3, #4095	; 0xfff
  4013d6:	429a      	cmp	r2, r3
  4013d8:	d028      	beq.n	40142c <mmc_decode_csd+0x120>
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
  4013da:	4b16      	ldr	r3, [pc, #88]	; (401434 <mmc_decode_csd+0x128>)
  4013dc:	681b      	ldr	r3, [r3, #0]
  4013de:	f103 000e 	add.w	r0, r3, #14
  4013e2:	230c      	movs	r3, #12
  4013e4:	223e      	movs	r2, #62	; 0x3e
  4013e6:	2180      	movs	r1, #128	; 0x80
  4013e8:	4c13      	ldr	r4, [pc, #76]	; (401438 <mmc_decode_csd+0x12c>)
  4013ea:	47a0      	blx	r4
  4013ec:	4603      	mov	r3, r0
  4013ee:	1c5c      	adds	r4, r3, #1
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
  4013f0:	4b10      	ldr	r3, [pc, #64]	; (401434 <mmc_decode_csd+0x128>)
  4013f2:	681b      	ldr	r3, [r3, #0]
  4013f4:	f103 000e 	add.w	r0, r3, #14
  4013f8:	2303      	movs	r3, #3
  4013fa:	222f      	movs	r2, #47	; 0x2f
  4013fc:	2180      	movs	r1, #128	; 0x80
  4013fe:	4d0e      	ldr	r5, [pc, #56]	; (401438 <mmc_decode_csd+0x12c>)
  401400:	47a8      	blx	r5
  401402:	4603      	mov	r3, r0
  401404:	3302      	adds	r3, #2
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
  401406:	fa04 f303 	lsl.w	r3, r4, r3
  40140a:	603b      	str	r3, [r7, #0]
		sd_mmc_card->capacity = blocknr *
  40140c:	4b09      	ldr	r3, [pc, #36]	; (401434 <mmc_decode_csd+0x128>)
  40140e:	681c      	ldr	r4, [r3, #0]
			(1 << MMC_CSD_READ_BL_LEN(sd_mmc_card->csd)) / 1024;
  401410:	4b08      	ldr	r3, [pc, #32]	; (401434 <mmc_decode_csd+0x128>)
  401412:	681b      	ldr	r3, [r3, #0]
  401414:	f103 000e 	add.w	r0, r3, #14
  401418:	2304      	movs	r3, #4
  40141a:	2250      	movs	r2, #80	; 0x50
  40141c:	2180      	movs	r1, #128	; 0x80
  40141e:	4d06      	ldr	r5, [pc, #24]	; (401438 <mmc_decode_csd+0x12c>)
  401420:	47a8      	blx	r5
  401422:	4602      	mov	r2, r0
		sd_mmc_card->capacity = blocknr *
  401424:	683b      	ldr	r3, [r7, #0]
  401426:	4093      	lsls	r3, r2
			(1 << MMC_CSD_READ_BL_LEN(sd_mmc_card->csd)) / 1024;
  401428:	0a9b      	lsrs	r3, r3, #10
		sd_mmc_card->capacity = blocknr *
  40142a:	6063      	str	r3, [r4, #4]
	}
}
  40142c:	bf00      	nop
  40142e:	3710      	adds	r7, #16
  401430:	46bd      	mov	sp, r7
  401432:	bdb0      	pop	{r4, r5, r7, pc}
  401434:	2000047c 	.word	0x2000047c
  401438:	00400a85 	.word	0x00400a85
  40143c:	00403fbc 	.word	0x00403fbc
  401440:	00404018 	.word	0x00404018

00401444 <sd_decode_csd>:

/**
 * \brief Decodes SD CSD register
 */
static void sd_decode_csd(void)
{
  401444:	b5b0      	push	{r4, r5, r7, lr}
  401446:	b084      	sub	sp, #16
  401448:	af00      	add	r7, sp, #0
 	uint32_t unit;
	uint32_t mul;
	uint32_t tran_speed;

	// Get SD memory maximum transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
  40144a:	4b36      	ldr	r3, [pc, #216]	; (401524 <sd_decode_csd+0xe0>)
  40144c:	681b      	ldr	r3, [r3, #0]
  40144e:	f103 000e 	add.w	r0, r3, #14
  401452:	2308      	movs	r3, #8
  401454:	2260      	movs	r2, #96	; 0x60
  401456:	2180      	movs	r1, #128	; 0x80
  401458:	4c33      	ldr	r4, [pc, #204]	; (401528 <sd_decode_csd+0xe4>)
  40145a:	47a0      	blx	r4
  40145c:	60f8      	str	r0, [r7, #12]
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  40145e:	68fb      	ldr	r3, [r7, #12]
  401460:	f003 0307 	and.w	r3, r3, #7
  401464:	4a31      	ldr	r2, [pc, #196]	; (40152c <sd_decode_csd+0xe8>)
  401466:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40146a:	60bb      	str	r3, [r7, #8]
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
  40146c:	68fb      	ldr	r3, [r7, #12]
  40146e:	08db      	lsrs	r3, r3, #3
  401470:	f003 030f 	and.w	r3, r3, #15
  401474:	4a2e      	ldr	r2, [pc, #184]	; (401530 <sd_decode_csd+0xec>)
  401476:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  40147a:	607b      	str	r3, [r7, #4]
	sd_mmc_card->clock = unit * mul * 1000;
  40147c:	4b29      	ldr	r3, [pc, #164]	; (401524 <sd_decode_csd+0xe0>)
  40147e:	681b      	ldr	r3, [r3, #0]
  401480:	68ba      	ldr	r2, [r7, #8]
  401482:	6879      	ldr	r1, [r7, #4]
  401484:	fb01 f202 	mul.w	r2, r1, r2
  401488:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
  40148c:	fb01 f202 	mul.w	r2, r1, r2
  401490:	601a      	str	r2, [r3, #0]
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD card:
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
  401492:	4b24      	ldr	r3, [pc, #144]	; (401524 <sd_decode_csd+0xe0>)
  401494:	681b      	ldr	r3, [r3, #0]
  401496:	f103 000e 	add.w	r0, r3, #14
  40149a:	2302      	movs	r3, #2
  40149c:	227e      	movs	r2, #126	; 0x7e
  40149e:	2180      	movs	r1, #128	; 0x80
  4014a0:	4c21      	ldr	r4, [pc, #132]	; (401528 <sd_decode_csd+0xe4>)
  4014a2:	47a0      	blx	r4
  4014a4:	4603      	mov	r3, r0
  4014a6:	2b00      	cmp	r3, #0
  4014a8:	d00f      	beq.n	4014ca <sd_decode_csd+0x86>
		sd_mmc_card->capacity =
  4014aa:	4b1e      	ldr	r3, [pc, #120]	; (401524 <sd_decode_csd+0xe0>)
  4014ac:	681c      	ldr	r4, [r3, #0]
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
  4014ae:	4b1d      	ldr	r3, [pc, #116]	; (401524 <sd_decode_csd+0xe0>)
  4014b0:	681b      	ldr	r3, [r3, #0]
  4014b2:	f103 000e 	add.w	r0, r3, #14
  4014b6:	2316      	movs	r3, #22
  4014b8:	2230      	movs	r2, #48	; 0x30
  4014ba:	2180      	movs	r1, #128	; 0x80
  4014bc:	4d1a      	ldr	r5, [pc, #104]	; (401528 <sd_decode_csd+0xe4>)
  4014be:	47a8      	blx	r5
  4014c0:	4603      	mov	r3, r0
				* 512;
  4014c2:	3301      	adds	r3, #1
  4014c4:	025b      	lsls	r3, r3, #9
		sd_mmc_card->capacity =
  4014c6:	6063      	str	r3, [r4, #4]
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
				(1 << SD_CSD_1_0_READ_BL_LEN(sd_mmc_card->csd))
				/ 1024;
	}
}
  4014c8:	e028      	b.n	40151c <sd_decode_csd+0xd8>
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
  4014ca:	4b16      	ldr	r3, [pc, #88]	; (401524 <sd_decode_csd+0xe0>)
  4014cc:	681b      	ldr	r3, [r3, #0]
  4014ce:	f103 000e 	add.w	r0, r3, #14
  4014d2:	230c      	movs	r3, #12
  4014d4:	223e      	movs	r2, #62	; 0x3e
  4014d6:	2180      	movs	r1, #128	; 0x80
  4014d8:	4c13      	ldr	r4, [pc, #76]	; (401528 <sd_decode_csd+0xe4>)
  4014da:	47a0      	blx	r4
  4014dc:	4603      	mov	r3, r0
  4014de:	1c5c      	adds	r4, r3, #1
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
  4014e0:	4b10      	ldr	r3, [pc, #64]	; (401524 <sd_decode_csd+0xe0>)
  4014e2:	681b      	ldr	r3, [r3, #0]
  4014e4:	f103 000e 	add.w	r0, r3, #14
  4014e8:	2303      	movs	r3, #3
  4014ea:	222f      	movs	r2, #47	; 0x2f
  4014ec:	2180      	movs	r1, #128	; 0x80
  4014ee:	4d0e      	ldr	r5, [pc, #56]	; (401528 <sd_decode_csd+0xe4>)
  4014f0:	47a8      	blx	r5
  4014f2:	4603      	mov	r3, r0
  4014f4:	3302      	adds	r3, #2
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
  4014f6:	fa04 f303 	lsl.w	r3, r4, r3
  4014fa:	603b      	str	r3, [r7, #0]
		sd_mmc_card->capacity = blocknr *
  4014fc:	4b09      	ldr	r3, [pc, #36]	; (401524 <sd_decode_csd+0xe0>)
  4014fe:	681c      	ldr	r4, [r3, #0]
				(1 << SD_CSD_1_0_READ_BL_LEN(sd_mmc_card->csd))
  401500:	4b08      	ldr	r3, [pc, #32]	; (401524 <sd_decode_csd+0xe0>)
  401502:	681b      	ldr	r3, [r3, #0]
  401504:	f103 000e 	add.w	r0, r3, #14
  401508:	2304      	movs	r3, #4
  40150a:	2250      	movs	r2, #80	; 0x50
  40150c:	2180      	movs	r1, #128	; 0x80
  40150e:	4d06      	ldr	r5, [pc, #24]	; (401528 <sd_decode_csd+0xe4>)
  401510:	47a8      	blx	r5
  401512:	4602      	mov	r2, r0
		sd_mmc_card->capacity = blocknr *
  401514:	683b      	ldr	r3, [r7, #0]
  401516:	4093      	lsls	r3, r2
				/ 1024;
  401518:	0a9b      	lsrs	r3, r3, #10
		sd_mmc_card->capacity = blocknr *
  40151a:	6063      	str	r3, [r4, #4]
}
  40151c:	bf00      	nop
  40151e:	3710      	adds	r7, #16
  401520:	46bd      	mov	sp, r7
  401522:	bdb0      	pop	{r4, r5, r7, pc}
  401524:	2000047c 	.word	0x2000047c
  401528:	00400a85 	.word	0x00400a85
  40152c:	00403fbc 	.word	0x00403fbc
  401530:	00403fd8 	.word	0x00403fd8

00401534 <sdio_cmd52>:
 *
 * \return true if success, otherwise false
 */
static bool sdio_cmd52(uint8_t rw_flag, uint8_t func_nb,
		uint32_t reg_addr, uint8_t rd_after_wr, uint8_t *io_data)
{
  401534:	b580      	push	{r7, lr}
  401536:	b082      	sub	sp, #8
  401538:	af00      	add	r7, sp, #0
  40153a:	603a      	str	r2, [r7, #0]
  40153c:	461a      	mov	r2, r3
  40153e:	4603      	mov	r3, r0
  401540:	71fb      	strb	r3, [r7, #7]
  401542:	460b      	mov	r3, r1
  401544:	71bb      	strb	r3, [r7, #6]
  401546:	4613      	mov	r3, r2
  401548:	717b      	strb	r3, [r7, #5]
	Assert(io_data != NULL);
	if (!driver_send_cmd(SDIO_CMD52_IO_RW_DIRECT,
		((uint32_t)*io_data << SDIO_CMD52_WR_DATA)
  40154a:	693b      	ldr	r3, [r7, #16]
  40154c:	781b      	ldrb	r3, [r3, #0]
  40154e:	461a      	mov	r2, r3
		| ((uint32_t)rw_flag << SDIO_CMD52_RW_FLAG)
  401550:	79fb      	ldrb	r3, [r7, #7]
  401552:	07db      	lsls	r3, r3, #31
  401554:	431a      	orrs	r2, r3
		| ((uint32_t)func_nb << SDIO_CMD52_FUNCTION_NUM)
  401556:	79bb      	ldrb	r3, [r7, #6]
  401558:	071b      	lsls	r3, r3, #28
  40155a:	431a      	orrs	r2, r3
		| ((uint32_t)rd_after_wr << SDIO_CMD52_RAW_FLAG)
  40155c:	797b      	ldrb	r3, [r7, #5]
  40155e:	06db      	lsls	r3, r3, #27
  401560:	431a      	orrs	r2, r3
		| ((uint32_t)reg_addr << SDIO_CMD52_REG_ADRR))) {
  401562:	683b      	ldr	r3, [r7, #0]
  401564:	025b      	lsls	r3, r3, #9
	if (!driver_send_cmd(SDIO_CMD52_IO_RW_DIRECT,
  401566:	4313      	orrs	r3, r2
  401568:	4619      	mov	r1, r3
  40156a:	f241 3034 	movw	r0, #4916	; 0x1334
  40156e:	4b0a      	ldr	r3, [pc, #40]	; (401598 <sdio_cmd52+0x64>)
  401570:	4798      	blx	r3
  401572:	4603      	mov	r3, r0
  401574:	f083 0301 	eor.w	r3, r3, #1
  401578:	b2db      	uxtb	r3, r3
  40157a:	2b00      	cmp	r3, #0
  40157c:	d001      	beq.n	401582 <sdio_cmd52+0x4e>
		return false;
  40157e:	2300      	movs	r3, #0
  401580:	e006      	b.n	401590 <sdio_cmd52+0x5c>
	}
	*io_data = driver_get_response() & 0xFF;
  401582:	4b06      	ldr	r3, [pc, #24]	; (40159c <sdio_cmd52+0x68>)
  401584:	4798      	blx	r3
  401586:	4603      	mov	r3, r0
  401588:	b2da      	uxtb	r2, r3
  40158a:	693b      	ldr	r3, [r7, #16]
  40158c:	701a      	strb	r2, [r3, #0]
	return true;
  40158e:	2301      	movs	r3, #1
}
  401590:	4618      	mov	r0, r3
  401592:	3708      	adds	r7, #8
  401594:	46bd      	mov	sp, r7
  401596:	bd80      	pop	{r7, pc}
  401598:	0040263d 	.word	0x0040263d
  40159c:	00402681 	.word	0x00402681

004015a0 <sd_acmd6>:
 * \brief ACMD6 - Define the data bus width to 4 bits bus
 *
 * \return true if success, otherwise false
 */
static bool sd_acmd6(void)
{
  4015a0:	b580      	push	{r7, lr}
  4015a2:	af00      	add	r7, sp, #0
	// CMD55 - Indicate to the card that the next command is an
	// application specific command rather than a standard command.
	if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, (uint32_t)sd_mmc_card->rca << 16)) {
  4015a4:	4b12      	ldr	r3, [pc, #72]	; (4015f0 <sd_acmd6+0x50>)
  4015a6:	681b      	ldr	r3, [r3, #0]
  4015a8:	891b      	ldrh	r3, [r3, #8]
  4015aa:	041b      	lsls	r3, r3, #16
  4015ac:	4619      	mov	r1, r3
  4015ae:	f241 1037 	movw	r0, #4407	; 0x1137
  4015b2:	4b10      	ldr	r3, [pc, #64]	; (4015f4 <sd_acmd6+0x54>)
  4015b4:	4798      	blx	r3
  4015b6:	4603      	mov	r3, r0
  4015b8:	f083 0301 	eor.w	r3, r3, #1
  4015bc:	b2db      	uxtb	r3, r3
  4015be:	2b00      	cmp	r3, #0
  4015c0:	d001      	beq.n	4015c6 <sd_acmd6+0x26>
		return false;
  4015c2:	2300      	movs	r3, #0
  4015c4:	e011      	b.n	4015ea <sd_acmd6+0x4a>
	}
	// 10b = 4 bits bus
	if (!driver_send_cmd(SD_ACMD6_SET_BUS_WIDTH, 0x2)) {
  4015c6:	2102      	movs	r1, #2
  4015c8:	f241 1006 	movw	r0, #4358	; 0x1106
  4015cc:	4b09      	ldr	r3, [pc, #36]	; (4015f4 <sd_acmd6+0x54>)
  4015ce:	4798      	blx	r3
  4015d0:	4603      	mov	r3, r0
  4015d2:	f083 0301 	eor.w	r3, r3, #1
  4015d6:	b2db      	uxtb	r3, r3
  4015d8:	2b00      	cmp	r3, #0
  4015da:	d001      	beq.n	4015e0 <sd_acmd6+0x40>
		return false;
  4015dc:	2300      	movs	r3, #0
  4015de:	e004      	b.n	4015ea <sd_acmd6+0x4a>
	}
	sd_mmc_card->bus_width = 4;
  4015e0:	4b03      	ldr	r3, [pc, #12]	; (4015f0 <sd_acmd6+0x50>)
  4015e2:	681b      	ldr	r3, [r3, #0]
  4015e4:	2204      	movs	r2, #4
  4015e6:	735a      	strb	r2, [r3, #13]
	sd_mmc_debug("%d-bit bus width enabled.\n\r", (int)sd_mmc_card->bus_width);
	return true;
  4015e8:	2301      	movs	r3, #1
}
  4015ea:	4618      	mov	r0, r3
  4015ec:	bd80      	pop	{r7, pc}
  4015ee:	bf00      	nop
  4015f0:	2000047c 	.word	0x2000047c
  4015f4:	0040263d 	.word	0x0040263d

004015f8 <sd_acmd51>:
 *
 *
 * \return true if success, otherwise false
 */
static bool sd_acmd51(void)
{
  4015f8:	b590      	push	{r4, r7, lr}
  4015fa:	b085      	sub	sp, #20
  4015fc:	af02      	add	r7, sp, #8
	uint8_t scr[SD_SCR_REG_BSIZE];

	// CMD55 - Indicate to the card that the next command is an
	// application specific command rather than a standard command.
	if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, (uint32_t)sd_mmc_card->rca << 16)) {
  4015fe:	4b36      	ldr	r3, [pc, #216]	; (4016d8 <sd_acmd51+0xe0>)
  401600:	681b      	ldr	r3, [r3, #0]
  401602:	891b      	ldrh	r3, [r3, #8]
  401604:	041b      	lsls	r3, r3, #16
  401606:	4619      	mov	r1, r3
  401608:	f241 1037 	movw	r0, #4407	; 0x1137
  40160c:	4b33      	ldr	r3, [pc, #204]	; (4016dc <sd_acmd51+0xe4>)
  40160e:	4798      	blx	r3
  401610:	4603      	mov	r3, r0
  401612:	f083 0301 	eor.w	r3, r3, #1
  401616:	b2db      	uxtb	r3, r3
  401618:	2b00      	cmp	r3, #0
  40161a:	d001      	beq.n	401620 <sd_acmd51+0x28>
		return false;
  40161c:	2300      	movs	r3, #0
  40161e:	e057      	b.n	4016d0 <sd_acmd51+0xd8>
	}
	if (!driver_adtc_start(SD_ACMD51_SEND_SCR, 0,
  401620:	2301      	movs	r3, #1
  401622:	9300      	str	r3, [sp, #0]
  401624:	2301      	movs	r3, #1
  401626:	2208      	movs	r2, #8
  401628:	2100      	movs	r1, #0
  40162a:	482d      	ldr	r0, [pc, #180]	; (4016e0 <sd_acmd51+0xe8>)
  40162c:	4c2d      	ldr	r4, [pc, #180]	; (4016e4 <sd_acmd51+0xec>)
  40162e:	47a0      	blx	r4
  401630:	4603      	mov	r3, r0
  401632:	f083 0301 	eor.w	r3, r3, #1
  401636:	b2db      	uxtb	r3, r3
  401638:	2b00      	cmp	r3, #0
  40163a:	d001      	beq.n	401640 <sd_acmd51+0x48>
			SD_SCR_REG_BSIZE, 1, true)) {
		return false;
  40163c:	2300      	movs	r3, #0
  40163e:	e047      	b.n	4016d0 <sd_acmd51+0xd8>
	}
	if (!driver_start_read_blocks(scr, 1)) {
  401640:	463b      	mov	r3, r7
  401642:	2101      	movs	r1, #1
  401644:	4618      	mov	r0, r3
  401646:	4b28      	ldr	r3, [pc, #160]	; (4016e8 <sd_acmd51+0xf0>)
  401648:	4798      	blx	r3
  40164a:	4603      	mov	r3, r0
  40164c:	f083 0301 	eor.w	r3, r3, #1
  401650:	b2db      	uxtb	r3, r3
  401652:	2b00      	cmp	r3, #0
  401654:	d001      	beq.n	40165a <sd_acmd51+0x62>
		return false;
  401656:	2300      	movs	r3, #0
  401658:	e03a      	b.n	4016d0 <sd_acmd51+0xd8>
	}
	if (!driver_wait_end_of_read_blocks()) {
  40165a:	4b24      	ldr	r3, [pc, #144]	; (4016ec <sd_acmd51+0xf4>)
  40165c:	4798      	blx	r3
  40165e:	4603      	mov	r3, r0
  401660:	f083 0301 	eor.w	r3, r3, #1
  401664:	b2db      	uxtb	r3, r3
  401666:	2b00      	cmp	r3, #0
  401668:	d001      	beq.n	40166e <sd_acmd51+0x76>
		return false;
  40166a:	2300      	movs	r3, #0
  40166c:	e030      	b.n	4016d0 <sd_acmd51+0xd8>
	}

	// Get SD Memory Card - Spec. Version
	switch (SD_SCR_SD_SPEC(scr)) {
  40166e:	4638      	mov	r0, r7
  401670:	2304      	movs	r3, #4
  401672:	2238      	movs	r2, #56	; 0x38
  401674:	2140      	movs	r1, #64	; 0x40
  401676:	4c1e      	ldr	r4, [pc, #120]	; (4016f0 <sd_acmd51+0xf8>)
  401678:	47a0      	blx	r4
  40167a:	4603      	mov	r3, r0
  40167c:	2b01      	cmp	r3, #1
  40167e:	d009      	beq.n	401694 <sd_acmd51+0x9c>
  401680:	2b01      	cmp	r3, #1
  401682:	d302      	bcc.n	40168a <sd_acmd51+0x92>
  401684:	2b02      	cmp	r3, #2
  401686:	d00a      	beq.n	40169e <sd_acmd51+0xa6>
  401688:	e01c      	b.n	4016c4 <sd_acmd51+0xcc>
	case SD_SCR_SD_SPEC_1_0_01:
		sd_mmc_card->version = CARD_VER_SD_1_0;
  40168a:	4b13      	ldr	r3, [pc, #76]	; (4016d8 <sd_acmd51+0xe0>)
  40168c:	681b      	ldr	r3, [r3, #0]
  40168e:	2210      	movs	r2, #16
  401690:	731a      	strb	r2, [r3, #12]
		break;
  401692:	e01c      	b.n	4016ce <sd_acmd51+0xd6>

	case SD_SCR_SD_SPEC_1_10:
		sd_mmc_card->version = CARD_VER_SD_1_10;
  401694:	4b10      	ldr	r3, [pc, #64]	; (4016d8 <sd_acmd51+0xe0>)
  401696:	681b      	ldr	r3, [r3, #0]
  401698:	221a      	movs	r2, #26
  40169a:	731a      	strb	r2, [r3, #12]
		break;
  40169c:	e017      	b.n	4016ce <sd_acmd51+0xd6>

	case SD_SCR_SD_SPEC_2_00:
		if (SD_SCR_SD_SPEC3(scr) == SD_SCR_SD_SPEC_3_00) {
  40169e:	4638      	mov	r0, r7
  4016a0:	2301      	movs	r3, #1
  4016a2:	222f      	movs	r2, #47	; 0x2f
  4016a4:	2140      	movs	r1, #64	; 0x40
  4016a6:	4c12      	ldr	r4, [pc, #72]	; (4016f0 <sd_acmd51+0xf8>)
  4016a8:	47a0      	blx	r4
  4016aa:	4603      	mov	r3, r0
  4016ac:	2b01      	cmp	r3, #1
  4016ae:	d104      	bne.n	4016ba <sd_acmd51+0xc2>
			sd_mmc_card->version = CARD_VER_SD_3_0;
  4016b0:	4b09      	ldr	r3, [pc, #36]	; (4016d8 <sd_acmd51+0xe0>)
  4016b2:	681b      	ldr	r3, [r3, #0]
  4016b4:	2230      	movs	r2, #48	; 0x30
  4016b6:	731a      	strb	r2, [r3, #12]
		} else {
			sd_mmc_card->version = CARD_VER_SD_2_0;
		}
		break;
  4016b8:	e009      	b.n	4016ce <sd_acmd51+0xd6>
			sd_mmc_card->version = CARD_VER_SD_2_0;
  4016ba:	4b07      	ldr	r3, [pc, #28]	; (4016d8 <sd_acmd51+0xe0>)
  4016bc:	681b      	ldr	r3, [r3, #0]
  4016be:	2220      	movs	r2, #32
  4016c0:	731a      	strb	r2, [r3, #12]
		break;
  4016c2:	e004      	b.n	4016ce <sd_acmd51+0xd6>

	default:
		sd_mmc_card->version = CARD_VER_SD_1_0;
  4016c4:	4b04      	ldr	r3, [pc, #16]	; (4016d8 <sd_acmd51+0xe0>)
  4016c6:	681b      	ldr	r3, [r3, #0]
  4016c8:	2210      	movs	r2, #16
  4016ca:	731a      	strb	r2, [r3, #12]
		break;
  4016cc:	bf00      	nop
	}
	return true;
  4016ce:	2301      	movs	r3, #1
}
  4016d0:	4618      	mov	r0, r3
  4016d2:	370c      	adds	r7, #12
  4016d4:	46bd      	mov	sp, r7
  4016d6:	bd90      	pop	{r4, r7, pc}
  4016d8:	2000047c 	.word	0x2000047c
  4016dc:	0040263d 	.word	0x0040263d
  4016e0:	00081133 	.word	0x00081133
  4016e4:	00402709 	.word	0x00402709
  4016e8:	004028cd 	.word	0x004028cd
  4016ec:	0040296d 	.word	0x0040296d
  4016f0:	00400a85 	.word	0x00400a85

004016f4 <sd_mmc_select_slot>:
 * \retval SD_MMC_ERR_UNUSABLE Unusable card
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
  4016f4:	b580      	push	{r7, lr}
  4016f6:	b082      	sub	sp, #8
  4016f8:	af00      	add	r7, sp, #0
  4016fa:	4603      	mov	r3, r0
  4016fc:	71fb      	strb	r3, [r7, #7]
	if (slot >= SD_MMC_MEM_CNT) {
  4016fe:	79fb      	ldrb	r3, [r7, #7]
  401700:	2b00      	cmp	r3, #0
  401702:	d001      	beq.n	401708 <sd_mmc_select_slot+0x14>
		return SD_MMC_ERR_SLOT;
  401704:	2304      	movs	r3, #4
  401706:	e040      	b.n	40178a <sd_mmc_select_slot+0x96>
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_UNUSABLE) {
		return SD_MMC_ERR_UNUSABLE;
	}
#else
	// No pin card detection, then always try to install it
	if ((sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD)
  401708:	79fb      	ldrb	r3, [r7, #7]
  40170a:	4a22      	ldr	r2, [pc, #136]	; (401794 <sd_mmc_select_slot+0xa0>)
  40170c:	015b      	lsls	r3, r3, #5
  40170e:	4413      	add	r3, r2
  401710:	330a      	adds	r3, #10
  401712:	781b      	ldrb	r3, [r3, #0]
  401714:	2b04      	cmp	r3, #4
  401716:	d007      	beq.n	401728 <sd_mmc_select_slot+0x34>
			|| (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_UNUSABLE)) {
  401718:	79fb      	ldrb	r3, [r7, #7]
  40171a:	4a1e      	ldr	r2, [pc, #120]	; (401794 <sd_mmc_select_slot+0xa0>)
  40171c:	015b      	lsls	r3, r3, #5
  40171e:	4413      	add	r3, r2
  401720:	330a      	adds	r3, #10
  401722:	781b      	ldrb	r3, [r3, #0]
  401724:	2b03      	cmp	r3, #3
  401726:	d11a      	bne.n	40175e <sd_mmc_select_slot+0x6a>
		// Card is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_INIT;
  401728:	79fb      	ldrb	r3, [r7, #7]
  40172a:	4a1a      	ldr	r2, [pc, #104]	; (401794 <sd_mmc_select_slot+0xa0>)
  40172c:	015b      	lsls	r3, r3, #5
  40172e:	4413      	add	r3, r2
  401730:	330a      	adds	r3, #10
  401732:	2202      	movs	r2, #2
  401734:	701a      	strb	r2, [r3, #0]
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
  401736:	79fb      	ldrb	r3, [r7, #7]
  401738:	4a16      	ldr	r2, [pc, #88]	; (401794 <sd_mmc_select_slot+0xa0>)
  40173a:	015b      	lsls	r3, r3, #5
  40173c:	4413      	add	r3, r2
  40173e:	4a16      	ldr	r2, [pc, #88]	; (401798 <sd_mmc_select_slot+0xa4>)
  401740:	601a      	str	r2, [r3, #0]
		sd_mmc_cards[slot].bus_width = 1;
  401742:	79fb      	ldrb	r3, [r7, #7]
  401744:	4a13      	ldr	r2, [pc, #76]	; (401794 <sd_mmc_select_slot+0xa0>)
  401746:	015b      	lsls	r3, r3, #5
  401748:	4413      	add	r3, r2
  40174a:	330d      	adds	r3, #13
  40174c:	2201      	movs	r2, #1
  40174e:	701a      	strb	r2, [r3, #0]
		sd_mmc_cards[slot].high_speed = 0;
  401750:	79fb      	ldrb	r3, [r7, #7]
  401752:	4a10      	ldr	r2, [pc, #64]	; (401794 <sd_mmc_select_slot+0xa0>)
  401754:	015b      	lsls	r3, r3, #5
  401756:	4413      	add	r3, r2
  401758:	331e      	adds	r3, #30
  40175a:	2200      	movs	r2, #0
  40175c:	701a      	strb	r2, [r3, #0]
	}
#endif

	// Initialize interface
	sd_mmc_slot_sel = slot;
  40175e:	4a0f      	ldr	r2, [pc, #60]	; (40179c <sd_mmc_select_slot+0xa8>)
  401760:	79fb      	ldrb	r3, [r7, #7]
  401762:	7013      	strb	r3, [r2, #0]
	sd_mmc_card = &sd_mmc_cards[slot];
  401764:	79fb      	ldrb	r3, [r7, #7]
  401766:	015b      	lsls	r3, r3, #5
  401768:	4a0a      	ldr	r2, [pc, #40]	; (401794 <sd_mmc_select_slot+0xa0>)
  40176a:	4413      	add	r3, r2
  40176c:	4a0c      	ldr	r2, [pc, #48]	; (4017a0 <sd_mmc_select_slot+0xac>)
  40176e:	6013      	str	r3, [r2, #0]
	sd_mmc_configure_slot();
  401770:	4b0c      	ldr	r3, [pc, #48]	; (4017a4 <sd_mmc_select_slot+0xb0>)
  401772:	4798      	blx	r3
	return (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_INIT) ?
  401774:	79fb      	ldrb	r3, [r7, #7]
  401776:	4a07      	ldr	r2, [pc, #28]	; (401794 <sd_mmc_select_slot+0xa0>)
  401778:	015b      	lsls	r3, r3, #5
  40177a:	4413      	add	r3, r2
  40177c:	330a      	adds	r3, #10
  40177e:	781b      	ldrb	r3, [r3, #0]
			SD_MMC_INIT_ONGOING : SD_MMC_OK;
  401780:	2b02      	cmp	r3, #2
  401782:	bf0c      	ite	eq
  401784:	2301      	moveq	r3, #1
  401786:	2300      	movne	r3, #0
  401788:	b2db      	uxtb	r3, r3
}
  40178a:	4618      	mov	r0, r3
  40178c:	3708      	adds	r7, #8
  40178e:	46bd      	mov	sp, r7
  401790:	bd80      	pop	{r7, pc}
  401792:	bf00      	nop
  401794:	20000458 	.word	0x20000458
  401798:	00061a80 	.word	0x00061a80
  40179c:	20000478 	.word	0x20000478
  4017a0:	2000047c 	.word	0x2000047c
  4017a4:	004017a9 	.word	0x004017a9

004017a8 <sd_mmc_configure_slot>:

/**
 * \brief Configures the driver with the selected card configuration
 */
static void sd_mmc_configure_slot(void)
{
  4017a8:	b598      	push	{r3, r4, r7, lr}
  4017aa:	af00      	add	r7, sp, #0
	driver_select_device(sd_mmc_slot_sel, sd_mmc_card->clock,
  4017ac:	4b09      	ldr	r3, [pc, #36]	; (4017d4 <sd_mmc_configure_slot+0x2c>)
  4017ae:	7818      	ldrb	r0, [r3, #0]
  4017b0:	4b09      	ldr	r3, [pc, #36]	; (4017d8 <sd_mmc_configure_slot+0x30>)
  4017b2:	681b      	ldr	r3, [r3, #0]
  4017b4:	6819      	ldr	r1, [r3, #0]
			sd_mmc_card->bus_width, sd_mmc_card->high_speed);
  4017b6:	4b08      	ldr	r3, [pc, #32]	; (4017d8 <sd_mmc_configure_slot+0x30>)
  4017b8:	681b      	ldr	r3, [r3, #0]
	driver_select_device(sd_mmc_slot_sel, sd_mmc_card->clock,
  4017ba:	7b5a      	ldrb	r2, [r3, #13]
			sd_mmc_card->bus_width, sd_mmc_card->high_speed);
  4017bc:	4b06      	ldr	r3, [pc, #24]	; (4017d8 <sd_mmc_configure_slot+0x30>)
  4017be:	681b      	ldr	r3, [r3, #0]
  4017c0:	7f9b      	ldrb	r3, [r3, #30]
	driver_select_device(sd_mmc_slot_sel, sd_mmc_card->clock,
  4017c2:	2b00      	cmp	r3, #0
  4017c4:	bf14      	ite	ne
  4017c6:	2301      	movne	r3, #1
  4017c8:	2300      	moveq	r3, #0
  4017ca:	b2db      	uxtb	r3, r3
  4017cc:	4c03      	ldr	r4, [pc, #12]	; (4017dc <sd_mmc_configure_slot+0x34>)
  4017ce:	47a0      	blx	r4
}
  4017d0:	bf00      	nop
  4017d2:	bd98      	pop	{r3, r4, r7, pc}
  4017d4:	20000478 	.word	0x20000478
  4017d8:	2000047c 	.word	0x2000047c
  4017dc:	00402551 	.word	0x00402551

004017e0 <sd_mmc_deselect_slot>:

/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
  4017e0:	b580      	push	{r7, lr}
  4017e2:	af00      	add	r7, sp, #0
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  4017e4:	4b05      	ldr	r3, [pc, #20]	; (4017fc <sd_mmc_deselect_slot+0x1c>)
  4017e6:	781b      	ldrb	r3, [r3, #0]
  4017e8:	2b00      	cmp	r3, #0
  4017ea:	d104      	bne.n	4017f6 <sd_mmc_deselect_slot+0x16>
		driver_deselect_device(sd_mmc_slot_sel);
  4017ec:	4b03      	ldr	r3, [pc, #12]	; (4017fc <sd_mmc_deselect_slot+0x1c>)
  4017ee:	781b      	ldrb	r3, [r3, #0]
  4017f0:	4618      	mov	r0, r3
  4017f2:	4b03      	ldr	r3, [pc, #12]	; (401800 <sd_mmc_deselect_slot+0x20>)
  4017f4:	4798      	blx	r3
	}
}
  4017f6:	bf00      	nop
  4017f8:	bd80      	pop	{r7, pc}
  4017fa:	bf00      	nop
  4017fc:	20000478 	.word	0x20000478
  401800:	004025e9 	.word	0x004025e9

00401804 <sd_mmc_mci_card_init>:
 * At last, it will automaticly enable maximum bus width and transfer speed.
 *
 * \return true if success, otherwise false
 */
static bool sd_mmc_mci_card_init(void)
{
  401804:	b590      	push	{r4, r7, lr}
  401806:	b085      	sub	sp, #20
  401808:	af02      	add	r7, sp, #8
	uint8_t v2 = 0;
  40180a:	2300      	movs	r3, #0
  40180c:	71fb      	strb	r3, [r7, #7]
#ifdef SDIO_SUPPORT_ENABLE
	uint8_t data = 0x08;
  40180e:	2308      	movs	r3, #8
  401810:	71bb      	strb	r3, [r7, #6]
#endif

	// In first, try to install SD/SDIO card
	sd_mmc_card->type = CARD_TYPE_SD;
  401812:	4b9a      	ldr	r3, [pc, #616]	; (401a7c <sd_mmc_mci_card_init+0x278>)
  401814:	681b      	ldr	r3, [r3, #0]
  401816:	2201      	movs	r2, #1
  401818:	72da      	strb	r2, [r3, #11]
	sd_mmc_card->version = CARD_VER_UNKNOWN;
  40181a:	4b98      	ldr	r3, [pc, #608]	; (401a7c <sd_mmc_mci_card_init+0x278>)
  40181c:	681b      	ldr	r3, [r3, #0]
  40181e:	2200      	movs	r2, #0
  401820:	731a      	strb	r2, [r3, #12]
	sd_mmc_card->rca = 0;
  401822:	4b96      	ldr	r3, [pc, #600]	; (401a7c <sd_mmc_mci_card_init+0x278>)
  401824:	681b      	ldr	r3, [r3, #0]
  401826:	2200      	movs	r2, #0
  401828:	811a      	strh	r2, [r3, #8]
	sd_mmc_debug("Start SD card install\n\r");

	// Card need of 74 cycles clock minimum to start
	driver_send_clock();
  40182a:	4b95      	ldr	r3, [pc, #596]	; (401a80 <sd_mmc_mci_card_init+0x27c>)
  40182c:	4798      	blx	r3

#ifdef SDIO_SUPPORT_ENABLE
	/* CMD52 Reset SDIO */
	sdio_cmd52(SDIO_CMD52_WRITE_FLAG, SDIO_CIA,SDIO_CCCR_IOA, 0, &data);
  40182e:	1dbb      	adds	r3, r7, #6
  401830:	9300      	str	r3, [sp, #0]
  401832:	2300      	movs	r3, #0
  401834:	2206      	movs	r2, #6
  401836:	2100      	movs	r1, #0
  401838:	2001      	movs	r0, #1
  40183a:	4c92      	ldr	r4, [pc, #584]	; (401a84 <sd_mmc_mci_card_init+0x280>)
  40183c:	47a0      	blx	r4
#endif

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  40183e:	2100      	movs	r1, #0
  401840:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  401844:	4b90      	ldr	r3, [pc, #576]	; (401a88 <sd_mmc_mci_card_init+0x284>)
  401846:	4798      	blx	r3
  401848:	4603      	mov	r3, r0
  40184a:	f083 0301 	eor.w	r3, r3, #1
  40184e:	b2db      	uxtb	r3, r3
  401850:	2b00      	cmp	r3, #0
  401852:	d001      	beq.n	401858 <sd_mmc_mci_card_init+0x54>
		return false;
  401854:	2300      	movs	r3, #0
  401856:	e10d      	b.n	401a74 <sd_mmc_mci_card_init+0x270>
	}
	if (!sd_cmd8(&v2)) {
  401858:	1dfb      	adds	r3, r7, #7
  40185a:	4618      	mov	r0, r3
  40185c:	4b8b      	ldr	r3, [pc, #556]	; (401a8c <sd_mmc_mci_card_init+0x288>)
  40185e:	4798      	blx	r3
  401860:	4603      	mov	r3, r0
  401862:	f083 0301 	eor.w	r3, r3, #1
  401866:	b2db      	uxtb	r3, r3
  401868:	2b00      	cmp	r3, #0
  40186a:	d001      	beq.n	401870 <sd_mmc_mci_card_init+0x6c>
		return false;
  40186c:	2300      	movs	r3, #0
  40186e:	e101      	b.n	401a74 <sd_mmc_mci_card_init+0x270>
	}
	// Try to get the SDIO card's operating condition
	if (!sdio_op_cond()) {
  401870:	4b87      	ldr	r3, [pc, #540]	; (401a90 <sd_mmc_mci_card_init+0x28c>)
  401872:	4798      	blx	r3
  401874:	4603      	mov	r3, r0
  401876:	f083 0301 	eor.w	r3, r3, #1
  40187a:	b2db      	uxtb	r3, r3
  40187c:	2b00      	cmp	r3, #0
  40187e:	d001      	beq.n	401884 <sd_mmc_mci_card_init+0x80>
		return false;
  401880:	2300      	movs	r3, #0
  401882:	e0f7      	b.n	401a74 <sd_mmc_mci_card_init+0x270>
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
  401884:	4b7d      	ldr	r3, [pc, #500]	; (401a7c <sd_mmc_mci_card_init+0x278>)
  401886:	681b      	ldr	r3, [r3, #0]
  401888:	7adb      	ldrb	r3, [r3, #11]
  40188a:	f003 0301 	and.w	r3, r3, #1
  40188e:	2b00      	cmp	r3, #0
  401890:	d011      	beq.n	4018b6 <sd_mmc_mci_card_init+0xb2>
		// Try to get the SD card's operating condition
		if (!sd_mci_op_cond(v2)) {
  401892:	79fb      	ldrb	r3, [r7, #7]
  401894:	4618      	mov	r0, r3
  401896:	4b7f      	ldr	r3, [pc, #508]	; (401a94 <sd_mmc_mci_card_init+0x290>)
  401898:	4798      	blx	r3
  40189a:	4603      	mov	r3, r0
  40189c:	f083 0301 	eor.w	r3, r3, #1
  4018a0:	b2db      	uxtb	r3, r3
  4018a2:	2b00      	cmp	r3, #0
  4018a4:	d007      	beq.n	4018b6 <sd_mmc_mci_card_init+0xb2>
			// It is not a SD card
			sd_mmc_debug("Start MMC Install\n\r");
			sd_mmc_card->type = CARD_TYPE_MMC;
  4018a6:	4b75      	ldr	r3, [pc, #468]	; (401a7c <sd_mmc_mci_card_init+0x278>)
  4018a8:	681b      	ldr	r3, [r3, #0]
  4018aa:	2202      	movs	r2, #2
  4018ac:	72da      	strb	r2, [r3, #11]
			return sd_mmc_mci_install_mmc();
  4018ae:	4b7a      	ldr	r3, [pc, #488]	; (401a98 <sd_mmc_mci_card_init+0x294>)
  4018b0:	4798      	blx	r3
  4018b2:	4603      	mov	r3, r0
  4018b4:	e0de      	b.n	401a74 <sd_mmc_mci_card_init+0x270>
		}
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
  4018b6:	4b71      	ldr	r3, [pc, #452]	; (401a7c <sd_mmc_mci_card_init+0x278>)
  4018b8:	681b      	ldr	r3, [r3, #0]
  4018ba:	7adb      	ldrb	r3, [r3, #11]
  4018bc:	f003 0301 	and.w	r3, r3, #1
  4018c0:	2b00      	cmp	r3, #0
  4018c2:	d00c      	beq.n	4018de <sd_mmc_mci_card_init+0xda>
		// SD MEMORY, Put the Card in Identify Mode
		// Note: The CID is not used in this stack
		if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
  4018c4:	2100      	movs	r1, #0
  4018c6:	f645 3002 	movw	r0, #23298	; 0x5b02
  4018ca:	4b6f      	ldr	r3, [pc, #444]	; (401a88 <sd_mmc_mci_card_init+0x284>)
  4018cc:	4798      	blx	r3
  4018ce:	4603      	mov	r3, r0
  4018d0:	f083 0301 	eor.w	r3, r3, #1
  4018d4:	b2db      	uxtb	r3, r3
  4018d6:	2b00      	cmp	r3, #0
  4018d8:	d001      	beq.n	4018de <sd_mmc_mci_card_init+0xda>
			return false;
  4018da:	2300      	movs	r3, #0
  4018dc:	e0ca      	b.n	401a74 <sd_mmc_mci_card_init+0x270>
		}
	}
	// Ask the card to publish a new relative address (RCA).
	if (!driver_send_cmd(SD_CMD3_SEND_RELATIVE_ADDR, 0)) {
  4018de:	2100      	movs	r1, #0
  4018e0:	f245 1003 	movw	r0, #20739	; 0x5103
  4018e4:	4b68      	ldr	r3, [pc, #416]	; (401a88 <sd_mmc_mci_card_init+0x284>)
  4018e6:	4798      	blx	r3
  4018e8:	4603      	mov	r3, r0
  4018ea:	f083 0301 	eor.w	r3, r3, #1
  4018ee:	b2db      	uxtb	r3, r3
  4018f0:	2b00      	cmp	r3, #0
  4018f2:	d001      	beq.n	4018f8 <sd_mmc_mci_card_init+0xf4>
		return false;
  4018f4:	2300      	movs	r3, #0
  4018f6:	e0bd      	b.n	401a74 <sd_mmc_mci_card_init+0x270>
	}
	sd_mmc_card->rca = (driver_get_response() >> 16) & 0xFFFF;
  4018f8:	4b60      	ldr	r3, [pc, #384]	; (401a7c <sd_mmc_mci_card_init+0x278>)
  4018fa:	681c      	ldr	r4, [r3, #0]
  4018fc:	4b67      	ldr	r3, [pc, #412]	; (401a9c <sd_mmc_mci_card_init+0x298>)
  4018fe:	4798      	blx	r3
  401900:	4603      	mov	r3, r0
  401902:	0c1b      	lsrs	r3, r3, #16
  401904:	b29b      	uxth	r3, r3
  401906:	8123      	strh	r3, [r4, #8]

	// SD MEMORY, Get the Card-Specific Data
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  401908:	4b5c      	ldr	r3, [pc, #368]	; (401a7c <sd_mmc_mci_card_init+0x278>)
  40190a:	681b      	ldr	r3, [r3, #0]
  40190c:	7adb      	ldrb	r3, [r3, #11]
  40190e:	f003 0301 	and.w	r3, r3, #1
  401912:	2b00      	cmp	r3, #0
  401914:	d00b      	beq.n	40192e <sd_mmc_mci_card_init+0x12a>
		if (!sd_mmc_cmd9_mci()) {
  401916:	4b62      	ldr	r3, [pc, #392]	; (401aa0 <sd_mmc_mci_card_init+0x29c>)
  401918:	4798      	blx	r3
  40191a:	4603      	mov	r3, r0
  40191c:	f083 0301 	eor.w	r3, r3, #1
  401920:	b2db      	uxtb	r3, r3
  401922:	2b00      	cmp	r3, #0
  401924:	d001      	beq.n	40192a <sd_mmc_mci_card_init+0x126>
			return false;
  401926:	2300      	movs	r3, #0
  401928:	e0a4      	b.n	401a74 <sd_mmc_mci_card_init+0x270>
		}
		sd_decode_csd();
  40192a:	4b5e      	ldr	r3, [pc, #376]	; (401aa4 <sd_mmc_mci_card_init+0x2a0>)
  40192c:	4798      	blx	r3
	}
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
			(uint32_t)sd_mmc_card->rca << 16)) {
  40192e:	4b53      	ldr	r3, [pc, #332]	; (401a7c <sd_mmc_mci_card_init+0x278>)
  401930:	681b      	ldr	r3, [r3, #0]
  401932:	891b      	ldrh	r3, [r3, #8]
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
  401934:	041b      	lsls	r3, r3, #16
  401936:	4619      	mov	r1, r3
  401938:	f243 1007 	movw	r0, #12551	; 0x3107
  40193c:	4b52      	ldr	r3, [pc, #328]	; (401a88 <sd_mmc_mci_card_init+0x284>)
  40193e:	4798      	blx	r3
  401940:	4603      	mov	r3, r0
  401942:	f083 0301 	eor.w	r3, r3, #1
  401946:	b2db      	uxtb	r3, r3
  401948:	2b00      	cmp	r3, #0
  40194a:	d001      	beq.n	401950 <sd_mmc_mci_card_init+0x14c>
		return false;
  40194c:	2300      	movs	r3, #0
  40194e:	e091      	b.n	401a74 <sd_mmc_mci_card_init+0x270>
	}
	// SD MEMORY, Read the SCR to get card version
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  401950:	4b4a      	ldr	r3, [pc, #296]	; (401a7c <sd_mmc_mci_card_init+0x278>)
  401952:	681b      	ldr	r3, [r3, #0]
  401954:	7adb      	ldrb	r3, [r3, #11]
  401956:	f003 0301 	and.w	r3, r3, #1
  40195a:	2b00      	cmp	r3, #0
  40195c:	d009      	beq.n	401972 <sd_mmc_mci_card_init+0x16e>
		if (!sd_acmd51()) {
  40195e:	4b52      	ldr	r3, [pc, #328]	; (401aa8 <sd_mmc_mci_card_init+0x2a4>)
  401960:	4798      	blx	r3
  401962:	4603      	mov	r3, r0
  401964:	f083 0301 	eor.w	r3, r3, #1
  401968:	b2db      	uxtb	r3, r3
  40196a:	2b00      	cmp	r3, #0
  40196c:	d001      	beq.n	401972 <sd_mmc_mci_card_init+0x16e>
			return false;
  40196e:	2300      	movs	r3, #0
  401970:	e080      	b.n	401a74 <sd_mmc_mci_card_init+0x270>
		}
	}
	if (IS_SDIO()) {
  401972:	4b42      	ldr	r3, [pc, #264]	; (401a7c <sd_mmc_mci_card_init+0x278>)
  401974:	681b      	ldr	r3, [r3, #0]
  401976:	7adb      	ldrb	r3, [r3, #11]
  401978:	f003 0304 	and.w	r3, r3, #4
  40197c:	2b00      	cmp	r3, #0
  40197e:	d009      	beq.n	401994 <sd_mmc_mci_card_init+0x190>
		if (!sdio_get_max_speed()) {
  401980:	4b4a      	ldr	r3, [pc, #296]	; (401aac <sd_mmc_mci_card_init+0x2a8>)
  401982:	4798      	blx	r3
  401984:	4603      	mov	r3, r0
  401986:	f083 0301 	eor.w	r3, r3, #1
  40198a:	b2db      	uxtb	r3, r3
  40198c:	2b00      	cmp	r3, #0
  40198e:	d001      	beq.n	401994 <sd_mmc_mci_card_init+0x190>
			return false;
  401990:	2300      	movs	r3, #0
  401992:	e06f      	b.n	401a74 <sd_mmc_mci_card_init+0x270>
		}
	}
	if ((4 <= driver_get_bus_width(sd_mmc_slot_sel))) {
  401994:	4b46      	ldr	r3, [pc, #280]	; (401ab0 <sd_mmc_mci_card_init+0x2ac>)
  401996:	781b      	ldrb	r3, [r3, #0]
  401998:	4618      	mov	r0, r3
  40199a:	4b46      	ldr	r3, [pc, #280]	; (401ab4 <sd_mmc_mci_card_init+0x2b0>)
  40199c:	4798      	blx	r3
  40199e:	4603      	mov	r3, r0
  4019a0:	2b03      	cmp	r3, #3
  4019a2:	d923      	bls.n	4019ec <sd_mmc_mci_card_init+0x1e8>
		// TRY to enable 4-bit mode
		if (IS_SDIO()) {
  4019a4:	4b35      	ldr	r3, [pc, #212]	; (401a7c <sd_mmc_mci_card_init+0x278>)
  4019a6:	681b      	ldr	r3, [r3, #0]
  4019a8:	7adb      	ldrb	r3, [r3, #11]
  4019aa:	f003 0304 	and.w	r3, r3, #4
  4019ae:	2b00      	cmp	r3, #0
  4019b0:	d009      	beq.n	4019c6 <sd_mmc_mci_card_init+0x1c2>
			if (!sdio_cmd52_set_bus_width()) {
  4019b2:	4b41      	ldr	r3, [pc, #260]	; (401ab8 <sd_mmc_mci_card_init+0x2b4>)
  4019b4:	4798      	blx	r3
  4019b6:	4603      	mov	r3, r0
  4019b8:	f083 0301 	eor.w	r3, r3, #1
  4019bc:	b2db      	uxtb	r3, r3
  4019be:	2b00      	cmp	r3, #0
  4019c0:	d001      	beq.n	4019c6 <sd_mmc_mci_card_init+0x1c2>
				return false;
  4019c2:	2300      	movs	r3, #0
  4019c4:	e056      	b.n	401a74 <sd_mmc_mci_card_init+0x270>
			}
		}
		if (sd_mmc_card->type & CARD_TYPE_SD) {
  4019c6:	4b2d      	ldr	r3, [pc, #180]	; (401a7c <sd_mmc_mci_card_init+0x278>)
  4019c8:	681b      	ldr	r3, [r3, #0]
  4019ca:	7adb      	ldrb	r3, [r3, #11]
  4019cc:	f003 0301 	and.w	r3, r3, #1
  4019d0:	2b00      	cmp	r3, #0
  4019d2:	d009      	beq.n	4019e8 <sd_mmc_mci_card_init+0x1e4>
			if (!sd_acmd6()) {
  4019d4:	4b39      	ldr	r3, [pc, #228]	; (401abc <sd_mmc_mci_card_init+0x2b8>)
  4019d6:	4798      	blx	r3
  4019d8:	4603      	mov	r3, r0
  4019da:	f083 0301 	eor.w	r3, r3, #1
  4019de:	b2db      	uxtb	r3, r3
  4019e0:	2b00      	cmp	r3, #0
  4019e2:	d001      	beq.n	4019e8 <sd_mmc_mci_card_init+0x1e4>
				return false;
  4019e4:	2300      	movs	r3, #0
  4019e6:	e045      	b.n	401a74 <sd_mmc_mci_card_init+0x270>
			}
		}
		// Switch to selected bus mode
		sd_mmc_configure_slot();
  4019e8:	4b35      	ldr	r3, [pc, #212]	; (401ac0 <sd_mmc_mci_card_init+0x2bc>)
  4019ea:	4798      	blx	r3
	}
	if (driver_is_high_speed_capable()) {
  4019ec:	4b35      	ldr	r3, [pc, #212]	; (401ac4 <sd_mmc_mci_card_init+0x2c0>)
  4019ee:	4798      	blx	r3
  4019f0:	4603      	mov	r3, r0
  4019f2:	2b00      	cmp	r3, #0
  4019f4:	d028      	beq.n	401a48 <sd_mmc_mci_card_init+0x244>
		// TRY to enable High-Speed Mode
		if (IS_SDIO()) {
  4019f6:	4b21      	ldr	r3, [pc, #132]	; (401a7c <sd_mmc_mci_card_init+0x278>)
  4019f8:	681b      	ldr	r3, [r3, #0]
  4019fa:	7adb      	ldrb	r3, [r3, #11]
  4019fc:	f003 0304 	and.w	r3, r3, #4
  401a00:	2b00      	cmp	r3, #0
  401a02:	d009      	beq.n	401a18 <sd_mmc_mci_card_init+0x214>
			if (!sdio_cmd52_set_high_speed()) {
  401a04:	4b30      	ldr	r3, [pc, #192]	; (401ac8 <sd_mmc_mci_card_init+0x2c4>)
  401a06:	4798      	blx	r3
  401a08:	4603      	mov	r3, r0
  401a0a:	f083 0301 	eor.w	r3, r3, #1
  401a0e:	b2db      	uxtb	r3, r3
  401a10:	2b00      	cmp	r3, #0
  401a12:	d001      	beq.n	401a18 <sd_mmc_mci_card_init+0x214>
				return false;
  401a14:	2300      	movs	r3, #0
  401a16:	e02d      	b.n	401a74 <sd_mmc_mci_card_init+0x270>
			}
		}
		if (sd_mmc_card->type & CARD_TYPE_SD) {
  401a18:	4b18      	ldr	r3, [pc, #96]	; (401a7c <sd_mmc_mci_card_init+0x278>)
  401a1a:	681b      	ldr	r3, [r3, #0]
  401a1c:	7adb      	ldrb	r3, [r3, #11]
  401a1e:	f003 0301 	and.w	r3, r3, #1
  401a22:	2b00      	cmp	r3, #0
  401a24:	d00e      	beq.n	401a44 <sd_mmc_mci_card_init+0x240>
			if (sd_mmc_card->version > CARD_VER_SD_1_0) {
  401a26:	4b15      	ldr	r3, [pc, #84]	; (401a7c <sd_mmc_mci_card_init+0x278>)
  401a28:	681b      	ldr	r3, [r3, #0]
  401a2a:	7b1b      	ldrb	r3, [r3, #12]
  401a2c:	2b10      	cmp	r3, #16
  401a2e:	d909      	bls.n	401a44 <sd_mmc_mci_card_init+0x240>
				if (!sd_cm6_set_high_speed()) {
  401a30:	4b26      	ldr	r3, [pc, #152]	; (401acc <sd_mmc_mci_card_init+0x2c8>)
  401a32:	4798      	blx	r3
  401a34:	4603      	mov	r3, r0
  401a36:	f083 0301 	eor.w	r3, r3, #1
  401a3a:	b2db      	uxtb	r3, r3
  401a3c:	2b00      	cmp	r3, #0
  401a3e:	d001      	beq.n	401a44 <sd_mmc_mci_card_init+0x240>
					return false;
  401a40:	2300      	movs	r3, #0
  401a42:	e017      	b.n	401a74 <sd_mmc_mci_card_init+0x270>
				}
			}
		}
		// Valid new configuration
		sd_mmc_configure_slot();
  401a44:	4b1e      	ldr	r3, [pc, #120]	; (401ac0 <sd_mmc_mci_card_init+0x2bc>)
  401a46:	4798      	blx	r3
	}
	// SD MEMORY, Set default block size
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  401a48:	4b0c      	ldr	r3, [pc, #48]	; (401a7c <sd_mmc_mci_card_init+0x278>)
  401a4a:	681b      	ldr	r3, [r3, #0]
  401a4c:	7adb      	ldrb	r3, [r3, #11]
  401a4e:	f003 0301 	and.w	r3, r3, #1
  401a52:	2b00      	cmp	r3, #0
  401a54:	d00d      	beq.n	401a72 <sd_mmc_mci_card_init+0x26e>
		if (!driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
  401a56:	f44f 7100 	mov.w	r1, #512	; 0x200
  401a5a:	f241 1010 	movw	r0, #4368	; 0x1110
  401a5e:	4b0a      	ldr	r3, [pc, #40]	; (401a88 <sd_mmc_mci_card_init+0x284>)
  401a60:	4798      	blx	r3
  401a62:	4603      	mov	r3, r0
  401a64:	f083 0301 	eor.w	r3, r3, #1
  401a68:	b2db      	uxtb	r3, r3
  401a6a:	2b00      	cmp	r3, #0
  401a6c:	d001      	beq.n	401a72 <sd_mmc_mci_card_init+0x26e>
			return false;
  401a6e:	2300      	movs	r3, #0
  401a70:	e000      	b.n	401a74 <sd_mmc_mci_card_init+0x270>
		}
	}
	return true;
  401a72:	2301      	movs	r3, #1
}
  401a74:	4618      	mov	r0, r3
  401a76:	370c      	adds	r7, #12
  401a78:	46bd      	mov	sp, r7
  401a7a:	bd90      	pop	{r4, r7, pc}
  401a7c:	2000047c 	.word	0x2000047c
  401a80:	00402601 	.word	0x00402601
  401a84:	00401535 	.word	0x00401535
  401a88:	0040263d 	.word	0x0040263d
  401a8c:	0040116d 	.word	0x0040116d
  401a90:	00400cbd 	.word	0x00400cbd
  401a94:	00400c15 	.word	0x00400c15
  401a98:	00401ad1 	.word	0x00401ad1
  401a9c:	00402681 	.word	0x00402681
  401aa0:	004012c9 	.word	0x004012c9
  401aa4:	00401445 	.word	0x00401445
  401aa8:	004015f9 	.word	0x004015f9
  401aac:	00400d65 	.word	0x00400d65
  401ab0:	20000478 	.word	0x20000478
  401ab4:	0040251d 	.word	0x0040251d
  401ab8:	00400eb1 	.word	0x00400eb1
  401abc:	004015a1 	.word	0x004015a1
  401ac0:	004017a9 	.word	0x004017a9
  401ac4:	0040253f 	.word	0x0040253f
  401ac8:	00400f21 	.word	0x00400f21
  401acc:	00400fa1 	.word	0x00400fa1

00401ad0 <sd_mmc_mci_install_mmc>:
 * At last, it will automaticly enable maximum bus width and transfer speed.
 *
 * \return true if success, otherwise false
 */
static bool sd_mmc_mci_install_mmc(void)
{
  401ad0:	b580      	push	{r7, lr}
  401ad2:	b082      	sub	sp, #8
  401ad4:	af00      	add	r7, sp, #0
	uint8_t b_authorize_high_speed;

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  401ad6:	2100      	movs	r1, #0
  401ad8:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  401adc:	4b56      	ldr	r3, [pc, #344]	; (401c38 <sd_mmc_mci_install_mmc+0x168>)
  401ade:	4798      	blx	r3
  401ae0:	4603      	mov	r3, r0
  401ae2:	f083 0301 	eor.w	r3, r3, #1
  401ae6:	b2db      	uxtb	r3, r3
  401ae8:	2b00      	cmp	r3, #0
  401aea:	d001      	beq.n	401af0 <sd_mmc_mci_install_mmc+0x20>
		return false;
  401aec:	2300      	movs	r3, #0
  401aee:	e09f      	b.n	401c30 <sd_mmc_mci_install_mmc+0x160>
	}

	if (!mmc_mci_op_cond()) {
  401af0:	4b52      	ldr	r3, [pc, #328]	; (401c3c <sd_mmc_mci_install_mmc+0x16c>)
  401af2:	4798      	blx	r3
  401af4:	4603      	mov	r3, r0
  401af6:	f083 0301 	eor.w	r3, r3, #1
  401afa:	b2db      	uxtb	r3, r3
  401afc:	2b00      	cmp	r3, #0
  401afe:	d001      	beq.n	401b04 <sd_mmc_mci_install_mmc+0x34>
		return false;
  401b00:	2300      	movs	r3, #0
  401b02:	e095      	b.n	401c30 <sd_mmc_mci_install_mmc+0x160>
	}

	// Put the Card in Identify Mode
	// Note: The CID is not used in this stack
	if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
  401b04:	2100      	movs	r1, #0
  401b06:	f645 3002 	movw	r0, #23298	; 0x5b02
  401b0a:	4b4b      	ldr	r3, [pc, #300]	; (401c38 <sd_mmc_mci_install_mmc+0x168>)
  401b0c:	4798      	blx	r3
  401b0e:	4603      	mov	r3, r0
  401b10:	f083 0301 	eor.w	r3, r3, #1
  401b14:	b2db      	uxtb	r3, r3
  401b16:	2b00      	cmp	r3, #0
  401b18:	d001      	beq.n	401b1e <sd_mmc_mci_install_mmc+0x4e>
		return false;
  401b1a:	2300      	movs	r3, #0
  401b1c:	e088      	b.n	401c30 <sd_mmc_mci_install_mmc+0x160>
	}
	// Assign relative address to the card.
	sd_mmc_card->rca = 1;
  401b1e:	4b48      	ldr	r3, [pc, #288]	; (401c40 <sd_mmc_mci_install_mmc+0x170>)
  401b20:	681b      	ldr	r3, [r3, #0]
  401b22:	2201      	movs	r2, #1
  401b24:	811a      	strh	r2, [r3, #8]
	if (!driver_send_cmd(MMC_CMD3_SET_RELATIVE_ADDR,
			(uint32_t)sd_mmc_card->rca << 16)) {
  401b26:	4b46      	ldr	r3, [pc, #280]	; (401c40 <sd_mmc_mci_install_mmc+0x170>)
  401b28:	681b      	ldr	r3, [r3, #0]
  401b2a:	891b      	ldrh	r3, [r3, #8]
	if (!driver_send_cmd(MMC_CMD3_SET_RELATIVE_ADDR,
  401b2c:	041b      	lsls	r3, r3, #16
  401b2e:	4619      	mov	r1, r3
  401b30:	f241 1003 	movw	r0, #4355	; 0x1103
  401b34:	4b40      	ldr	r3, [pc, #256]	; (401c38 <sd_mmc_mci_install_mmc+0x168>)
  401b36:	4798      	blx	r3
  401b38:	4603      	mov	r3, r0
  401b3a:	f083 0301 	eor.w	r3, r3, #1
  401b3e:	b2db      	uxtb	r3, r3
  401b40:	2b00      	cmp	r3, #0
  401b42:	d001      	beq.n	401b48 <sd_mmc_mci_install_mmc+0x78>
		return false;
  401b44:	2300      	movs	r3, #0
  401b46:	e073      	b.n	401c30 <sd_mmc_mci_install_mmc+0x160>
	}
	// Get the Card-Specific Data
	if (!sd_mmc_cmd9_mci()) {
  401b48:	4b3e      	ldr	r3, [pc, #248]	; (401c44 <sd_mmc_mci_install_mmc+0x174>)
  401b4a:	4798      	blx	r3
  401b4c:	4603      	mov	r3, r0
  401b4e:	f083 0301 	eor.w	r3, r3, #1
  401b52:	b2db      	uxtb	r3, r3
  401b54:	2b00      	cmp	r3, #0
  401b56:	d001      	beq.n	401b5c <sd_mmc_mci_install_mmc+0x8c>
		return false;
  401b58:	2300      	movs	r3, #0
  401b5a:	e069      	b.n	401c30 <sd_mmc_mci_install_mmc+0x160>
	}
	mmc_decode_csd();
  401b5c:	4b3a      	ldr	r3, [pc, #232]	; (401c48 <sd_mmc_mci_install_mmc+0x178>)
  401b5e:	4798      	blx	r3
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
			(uint32_t)sd_mmc_card->rca << 16)) {
  401b60:	4b37      	ldr	r3, [pc, #220]	; (401c40 <sd_mmc_mci_install_mmc+0x170>)
  401b62:	681b      	ldr	r3, [r3, #0]
  401b64:	891b      	ldrh	r3, [r3, #8]
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
  401b66:	041b      	lsls	r3, r3, #16
  401b68:	4619      	mov	r1, r3
  401b6a:	f243 1007 	movw	r0, #12551	; 0x3107
  401b6e:	4b32      	ldr	r3, [pc, #200]	; (401c38 <sd_mmc_mci_install_mmc+0x168>)
  401b70:	4798      	blx	r3
  401b72:	4603      	mov	r3, r0
  401b74:	f083 0301 	eor.w	r3, r3, #1
  401b78:	b2db      	uxtb	r3, r3
  401b7a:	2b00      	cmp	r3, #0
  401b7c:	d001      	beq.n	401b82 <sd_mmc_mci_install_mmc+0xb2>
		return false;
  401b7e:	2300      	movs	r3, #0
  401b80:	e056      	b.n	401c30 <sd_mmc_mci_install_mmc+0x160>
	}
	if (sd_mmc_card->version >= CARD_VER_MMC_4) {
  401b82:	4b2f      	ldr	r3, [pc, #188]	; (401c40 <sd_mmc_mci_install_mmc+0x170>)
  401b84:	681b      	ldr	r3, [r3, #0]
  401b86:	7b1b      	ldrb	r3, [r3, #12]
  401b88:	2b3f      	cmp	r3, #63	; 0x3f
  401b8a:	d93b      	bls.n	401c04 <sd_mmc_mci_install_mmc+0x134>
		// For MMC 4.0 Higher version
		// Get EXT_CSD
		if (!mmc_cmd8(&b_authorize_high_speed)) {
  401b8c:	1dbb      	adds	r3, r7, #6
  401b8e:	4618      	mov	r0, r3
  401b90:	4b2e      	ldr	r3, [pc, #184]	; (401c4c <sd_mmc_mci_install_mmc+0x17c>)
  401b92:	4798      	blx	r3
  401b94:	4603      	mov	r3, r0
  401b96:	f083 0301 	eor.w	r3, r3, #1
  401b9a:	b2db      	uxtb	r3, r3
  401b9c:	2b00      	cmp	r3, #0
  401b9e:	d001      	beq.n	401ba4 <sd_mmc_mci_install_mmc+0xd4>
			return false;
  401ba0:	2300      	movs	r3, #0
  401ba2:	e045      	b.n	401c30 <sd_mmc_mci_install_mmc+0x160>
		}
		if (4 <= driver_get_bus_width(sd_mmc_slot_sel)) {
  401ba4:	4b2a      	ldr	r3, [pc, #168]	; (401c50 <sd_mmc_mci_install_mmc+0x180>)
  401ba6:	781b      	ldrb	r3, [r3, #0]
  401ba8:	4618      	mov	r0, r3
  401baa:	4b2a      	ldr	r3, [pc, #168]	; (401c54 <sd_mmc_mci_install_mmc+0x184>)
  401bac:	4798      	blx	r3
  401bae:	4603      	mov	r3, r0
  401bb0:	2b03      	cmp	r3, #3
  401bb2:	d912      	bls.n	401bda <sd_mmc_mci_install_mmc+0x10a>
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
  401bb4:	4b26      	ldr	r3, [pc, #152]	; (401c50 <sd_mmc_mci_install_mmc+0x180>)
  401bb6:	781b      	ldrb	r3, [r3, #0]
  401bb8:	4618      	mov	r0, r3
  401bba:	4b26      	ldr	r3, [pc, #152]	; (401c54 <sd_mmc_mci_install_mmc+0x184>)
  401bbc:	4798      	blx	r3
  401bbe:	4603      	mov	r3, r0
  401bc0:	4618      	mov	r0, r3
  401bc2:	4b25      	ldr	r3, [pc, #148]	; (401c58 <sd_mmc_mci_install_mmc+0x188>)
  401bc4:	4798      	blx	r3
  401bc6:	4603      	mov	r3, r0
  401bc8:	f083 0301 	eor.w	r3, r3, #1
  401bcc:	b2db      	uxtb	r3, r3
  401bce:	2b00      	cmp	r3, #0
  401bd0:	d001      	beq.n	401bd6 <sd_mmc_mci_install_mmc+0x106>
				return false;
  401bd2:	2300      	movs	r3, #0
  401bd4:	e02c      	b.n	401c30 <sd_mmc_mci_install_mmc+0x160>
			}
			// Reinitialize the slot with the bus width
			sd_mmc_configure_slot();
  401bd6:	4b21      	ldr	r3, [pc, #132]	; (401c5c <sd_mmc_mci_install_mmc+0x18c>)
  401bd8:	4798      	blx	r3
		}
		if (driver_is_high_speed_capable() && b_authorize_high_speed) {
  401bda:	4b21      	ldr	r3, [pc, #132]	; (401c60 <sd_mmc_mci_install_mmc+0x190>)
  401bdc:	4798      	blx	r3
  401bde:	4603      	mov	r3, r0
  401be0:	2b00      	cmp	r3, #0
  401be2:	d011      	beq.n	401c08 <sd_mmc_mci_install_mmc+0x138>
  401be4:	79bb      	ldrb	r3, [r7, #6]
  401be6:	2b00      	cmp	r3, #0
  401be8:	d00e      	beq.n	401c08 <sd_mmc_mci_install_mmc+0x138>
			// Enable HS
			if (!mmc_cmd6_set_high_speed()) {
  401bea:	4b1e      	ldr	r3, [pc, #120]	; (401c64 <sd_mmc_mci_install_mmc+0x194>)
  401bec:	4798      	blx	r3
  401bee:	4603      	mov	r3, r0
  401bf0:	f083 0301 	eor.w	r3, r3, #1
  401bf4:	b2db      	uxtb	r3, r3
  401bf6:	2b00      	cmp	r3, #0
  401bf8:	d001      	beq.n	401bfe <sd_mmc_mci_install_mmc+0x12e>
				return false;
  401bfa:	2300      	movs	r3, #0
  401bfc:	e018      	b.n	401c30 <sd_mmc_mci_install_mmc+0x160>
			}
			// Reinitialize the slot with the new speed
			sd_mmc_configure_slot();
  401bfe:	4b17      	ldr	r3, [pc, #92]	; (401c5c <sd_mmc_mci_install_mmc+0x18c>)
  401c00:	4798      	blx	r3
  401c02:	e001      	b.n	401c08 <sd_mmc_mci_install_mmc+0x138>
		}
	} else {
		// Reinitialize the slot with the new speed
		sd_mmc_configure_slot();
  401c04:	4b15      	ldr	r3, [pc, #84]	; (401c5c <sd_mmc_mci_install_mmc+0x18c>)
  401c06:	4798      	blx	r3
	}

	uint8_t retry = 10;
  401c08:	230a      	movs	r3, #10
  401c0a:	71fb      	strb	r3, [r7, #7]
	while (retry--) {
  401c0c:	e00a      	b.n	401c24 <sd_mmc_mci_install_mmc+0x154>
		// Retry is a WORKAROUND for no compliance card (Atmel Internal ref. MMC19):
		// These cards seem not ready immediatly
		// after the end of busy of mmc_cmd6_set_high_speed()

		// Set default block size
		if (driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
  401c0e:	f44f 7100 	mov.w	r1, #512	; 0x200
  401c12:	f241 1010 	movw	r0, #4368	; 0x1110
  401c16:	4b08      	ldr	r3, [pc, #32]	; (401c38 <sd_mmc_mci_install_mmc+0x168>)
  401c18:	4798      	blx	r3
  401c1a:	4603      	mov	r3, r0
  401c1c:	2b00      	cmp	r3, #0
  401c1e:	d001      	beq.n	401c24 <sd_mmc_mci_install_mmc+0x154>
			return true;
  401c20:	2301      	movs	r3, #1
  401c22:	e005      	b.n	401c30 <sd_mmc_mci_install_mmc+0x160>
	while (retry--) {
  401c24:	79fb      	ldrb	r3, [r7, #7]
  401c26:	1e5a      	subs	r2, r3, #1
  401c28:	71fa      	strb	r2, [r7, #7]
  401c2a:	2b00      	cmp	r3, #0
  401c2c:	d1ef      	bne.n	401c0e <sd_mmc_mci_install_mmc+0x13e>
		}
	}
	return false;
  401c2e:	2300      	movs	r3, #0
}
  401c30:	4618      	mov	r0, r3
  401c32:	3708      	adds	r7, #8
  401c34:	46bd      	mov	sp, r7
  401c36:	bd80      	pop	{r7, pc}
  401c38:	0040263d 	.word	0x0040263d
  401c3c:	00400b99 	.word	0x00400b99
  401c40:	2000047c 	.word	0x2000047c
  401c44:	004012c9 	.word	0x004012c9
  401c48:	0040130d 	.word	0x0040130d
  401c4c:	004011d1 	.word	0x004011d1
  401c50:	20000478 	.word	0x20000478
  401c54:	0040251d 	.word	0x0040251d
  401c58:	00401095 	.word	0x00401095
  401c5c:	004017a9 	.word	0x004017a9
  401c60:	0040253f 	.word	0x0040253f
  401c64:	00401111 	.word	0x00401111

00401c68 <sd_mmc_init>:

//-------------------------------------------------------------------
//--------------------- PUBLIC FUNCTIONS ----------------------------

void sd_mmc_init(void)
{
  401c68:	b580      	push	{r7, lr}
  401c6a:	b082      	sub	sp, #8
  401c6c:	af00      	add	r7, sp, #0
# define SD_MMC_ENABLE_WP_PIN(slot, unused) \
	pmc_enable_periph_clk(SD_MMC_##slot##_WP_PIO_ID);
	MREPEAT(SD_MMC_MEM_CNT, SD_MMC_ENABLE_WP_PIN, ~)
# undef SD_MMC_ENABLE_WP_PIN
#endif
	for (uint8_t slot = 0; slot < SD_MMC_MEM_CNT; slot++) {
  401c6e:	2300      	movs	r3, #0
  401c70:	71fb      	strb	r3, [r7, #7]
  401c72:	e009      	b.n	401c88 <sd_mmc_init+0x20>
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
  401c74:	79fb      	ldrb	r3, [r7, #7]
  401c76:	4a0a      	ldr	r2, [pc, #40]	; (401ca0 <sd_mmc_init+0x38>)
  401c78:	015b      	lsls	r3, r3, #5
  401c7a:	4413      	add	r3, r2
  401c7c:	330a      	adds	r3, #10
  401c7e:	2204      	movs	r2, #4
  401c80:	701a      	strb	r2, [r3, #0]
	for (uint8_t slot = 0; slot < SD_MMC_MEM_CNT; slot++) {
  401c82:	79fb      	ldrb	r3, [r7, #7]
  401c84:	3301      	adds	r3, #1
  401c86:	71fb      	strb	r3, [r7, #7]
  401c88:	79fb      	ldrb	r3, [r7, #7]
  401c8a:	2b00      	cmp	r3, #0
  401c8c:	d0f2      	beq.n	401c74 <sd_mmc_init+0xc>
	}
	sd_mmc_slot_sel = 0xFF; // No slot configurated
  401c8e:	4b05      	ldr	r3, [pc, #20]	; (401ca4 <sd_mmc_init+0x3c>)
  401c90:	22ff      	movs	r2, #255	; 0xff
  401c92:	701a      	strb	r2, [r3, #0]
	driver_init();
  401c94:	4b04      	ldr	r3, [pc, #16]	; (401ca8 <sd_mmc_init+0x40>)
  401c96:	4798      	blx	r3
}
  401c98:	bf00      	nop
  401c9a:	3708      	adds	r7, #8
  401c9c:	46bd      	mov	sp, r7
  401c9e:	bd80      	pop	{r7, pc}
  401ca0:	20000458 	.word	0x20000458
  401ca4:	20000478 	.word	0x20000478
  401ca8:	004024e5 	.word	0x004024e5

00401cac <sd_mmc_check>:
{
	return SD_MMC_MEM_CNT;
}

sd_mmc_err_t sd_mmc_check(uint8_t slot)
{
  401cac:	b580      	push	{r7, lr}
  401cae:	b084      	sub	sp, #16
  401cb0:	af00      	add	r7, sp, #0
  401cb2:	4603      	mov	r3, r0
  401cb4:	71fb      	strb	r3, [r7, #7]
	sd_mmc_err_t sd_mmc_err;

	sd_mmc_err = sd_mmc_select_slot(slot);
  401cb6:	79fb      	ldrb	r3, [r7, #7]
  401cb8:	4618      	mov	r0, r3
  401cba:	4b11      	ldr	r3, [pc, #68]	; (401d00 <sd_mmc_check+0x54>)
  401cbc:	4798      	blx	r3
  401cbe:	4603      	mov	r3, r0
  401cc0:	73fb      	strb	r3, [r7, #15]
	if (sd_mmc_err != SD_MMC_INIT_ONGOING) {
  401cc2:	7bfb      	ldrb	r3, [r7, #15]
  401cc4:	2b01      	cmp	r3, #1
  401cc6:	d003      	beq.n	401cd0 <sd_mmc_check+0x24>
		sd_mmc_deselect_slot();
  401cc8:	4b0e      	ldr	r3, [pc, #56]	; (401d04 <sd_mmc_check+0x58>)
  401cca:	4798      	blx	r3
		return sd_mmc_err;
  401ccc:	7bfb      	ldrb	r3, [r7, #15]
  401cce:	e013      	b.n	401cf8 <sd_mmc_check+0x4c>
	}

	// Initialization of the card requested
	if (sd_mmc_is_spi()? sd_mmc_spi_card_init()
			: sd_mmc_mci_card_init()) {
  401cd0:	4b0d      	ldr	r3, [pc, #52]	; (401d08 <sd_mmc_check+0x5c>)
  401cd2:	4798      	blx	r3
  401cd4:	4603      	mov	r3, r0
	if (sd_mmc_is_spi()? sd_mmc_spi_card_init()
  401cd6:	2b00      	cmp	r3, #0
  401cd8:	d007      	beq.n	401cea <sd_mmc_check+0x3e>
		sd_mmc_debug("SD/MMC card ready\n\r");
		sd_mmc_card->state = SD_MMC_CARD_STATE_READY;
  401cda:	4b0c      	ldr	r3, [pc, #48]	; (401d0c <sd_mmc_check+0x60>)
  401cdc:	681b      	ldr	r3, [r3, #0]
  401cde:	2200      	movs	r2, #0
  401ce0:	729a      	strb	r2, [r3, #10]
		sd_mmc_deselect_slot();
  401ce2:	4b08      	ldr	r3, [pc, #32]	; (401d04 <sd_mmc_check+0x58>)
  401ce4:	4798      	blx	r3
		// To notify that the card has been just initialized
		// It is necessary for USB Device MSC
		return SD_MMC_INIT_ONGOING;
  401ce6:	2301      	movs	r3, #1
  401ce8:	e006      	b.n	401cf8 <sd_mmc_check+0x4c>
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
  401cea:	4b08      	ldr	r3, [pc, #32]	; (401d0c <sd_mmc_check+0x60>)
  401cec:	681b      	ldr	r3, [r3, #0]
  401cee:	2203      	movs	r2, #3
  401cf0:	729a      	strb	r2, [r3, #10]
	sd_mmc_deselect_slot();
  401cf2:	4b04      	ldr	r3, [pc, #16]	; (401d04 <sd_mmc_check+0x58>)
  401cf4:	4798      	blx	r3
	return SD_MMC_ERR_UNUSABLE;
  401cf6:	2303      	movs	r3, #3
}
  401cf8:	4618      	mov	r0, r3
  401cfa:	3710      	adds	r7, #16
  401cfc:	46bd      	mov	sp, r7
  401cfe:	bd80      	pop	{r7, pc}
  401d00:	004016f5 	.word	0x004016f5
  401d04:	004017e1 	.word	0x004017e1
  401d08:	00401805 	.word	0x00401805
  401d0c:	2000047c 	.word	0x2000047c

00401d10 <sd_mmc_get_type>:

card_type_t sd_mmc_get_type(uint8_t slot)
{
  401d10:	b580      	push	{r7, lr}
  401d12:	b082      	sub	sp, #8
  401d14:	af00      	add	r7, sp, #0
  401d16:	4603      	mov	r3, r0
  401d18:	71fb      	strb	r3, [r7, #7]
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
  401d1a:	79fb      	ldrb	r3, [r7, #7]
  401d1c:	4618      	mov	r0, r3
  401d1e:	4b08      	ldr	r3, [pc, #32]	; (401d40 <sd_mmc_get_type+0x30>)
  401d20:	4798      	blx	r3
  401d22:	4603      	mov	r3, r0
  401d24:	2b00      	cmp	r3, #0
  401d26:	d001      	beq.n	401d2c <sd_mmc_get_type+0x1c>
		return CARD_TYPE_UNKNOWN;
  401d28:	2300      	movs	r3, #0
  401d2a:	e004      	b.n	401d36 <sd_mmc_get_type+0x26>
	}
	sd_mmc_deselect_slot();
  401d2c:	4b05      	ldr	r3, [pc, #20]	; (401d44 <sd_mmc_get_type+0x34>)
  401d2e:	4798      	blx	r3
	return sd_mmc_card->type;
  401d30:	4b05      	ldr	r3, [pc, #20]	; (401d48 <sd_mmc_get_type+0x38>)
  401d32:	681b      	ldr	r3, [r3, #0]
  401d34:	7adb      	ldrb	r3, [r3, #11]
}
  401d36:	4618      	mov	r0, r3
  401d38:	3708      	adds	r7, #8
  401d3a:	46bd      	mov	sp, r7
  401d3c:	bd80      	pop	{r7, pc}
  401d3e:	bf00      	nop
  401d40:	004016f5 	.word	0x004016f5
  401d44:	004017e1 	.word	0x004017e1
  401d48:	2000047c 	.word	0x2000047c

00401d4c <sd_mmc_test_unit_ready>:
 */

static bool sd_mmc_ejected[2] = {false, false};

Ctrl_status sd_mmc_test_unit_ready(uint8_t slot)
{
  401d4c:	b510      	push	{r4, lr}
  401d4e:	4604      	mov	r4, r0
	switch (sd_mmc_check(slot))
  401d50:	4b0f      	ldr	r3, [pc, #60]	; (401d90 <sd_mmc_test_unit_ready+0x44>)
  401d52:	4798      	blx	r3
  401d54:	2801      	cmp	r0, #1
  401d56:	d018      	beq.n	401d8a <sd_mmc_test_unit_ready+0x3e>
  401d58:	b118      	cbz	r0, 401d62 <sd_mmc_test_unit_ready+0x16>
  401d5a:	2802      	cmp	r0, #2
  401d5c:	d010      	beq.n	401d80 <sd_mmc_test_unit_ready+0x34>
	case SD_MMC_ERR_NO_CARD:
		sd_mmc_ejected[slot] = false;
		return CTRL_NO_PRESENT;

	default:
		return CTRL_FAIL;
  401d5e:	2001      	movs	r0, #1
  401d60:	bd10      	pop	{r4, pc}
		if (sd_mmc_ejected[slot]) {
  401d62:	4b0c      	ldr	r3, [pc, #48]	; (401d94 <sd_mmc_test_unit_ready+0x48>)
  401d64:	5d1b      	ldrb	r3, [r3, r4]
  401d66:	b10b      	cbz	r3, 401d6c <sd_mmc_test_unit_ready+0x20>
			return CTRL_NO_PRESENT;
  401d68:	2002      	movs	r0, #2
	}
}
  401d6a:	bd10      	pop	{r4, pc}
		if (sd_mmc_get_type(slot) & (CARD_TYPE_SD | CARD_TYPE_MMC)) {
  401d6c:	4620      	mov	r0, r4
  401d6e:	4b0a      	ldr	r3, [pc, #40]	; (401d98 <sd_mmc_test_unit_ready+0x4c>)
  401d70:	4798      	blx	r3
  401d72:	f000 0003 	and.w	r0, r0, #3
		return CTRL_NO_PRESENT;
  401d76:	2800      	cmp	r0, #0
  401d78:	bf14      	ite	ne
  401d7a:	2000      	movne	r0, #0
  401d7c:	2002      	moveq	r0, #2
  401d7e:	bd10      	pop	{r4, pc}
		sd_mmc_ejected[slot] = false;
  401d80:	2200      	movs	r2, #0
  401d82:	4b04      	ldr	r3, [pc, #16]	; (401d94 <sd_mmc_test_unit_ready+0x48>)
  401d84:	551a      	strb	r2, [r3, r4]
		return CTRL_NO_PRESENT;
  401d86:	2002      	movs	r0, #2
  401d88:	bd10      	pop	{r4, pc}
		return CTRL_BUSY;
  401d8a:	2003      	movs	r0, #3
  401d8c:	bd10      	pop	{r4, pc}
  401d8e:	bf00      	nop
  401d90:	00401cad 	.word	0x00401cad
  401d94:	20000480 	.word	0x20000480
  401d98:	00401d11 	.word	0x00401d11

00401d9c <sysclk_enable_peripheral_clock>:
{
  401d9c:	b580      	push	{r7, lr}
  401d9e:	b082      	sub	sp, #8
  401da0:	af00      	add	r7, sp, #0
  401da2:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  401da4:	6878      	ldr	r0, [r7, #4]
  401da6:	4b03      	ldr	r3, [pc, #12]	; (401db4 <sysclk_enable_peripheral_clock+0x18>)
  401da8:	4798      	blx	r3
}
  401daa:	bf00      	nop
  401dac:	3708      	adds	r7, #8
  401dae:	46bd      	mov	sp, r7
  401db0:	bd80      	pop	{r7, pc}
  401db2:	bf00      	nop
  401db4:	00403215 	.word	0x00403215

00401db8 <ioport_init>:
 *
 * This function must be called before using any other functions in the IOPORT
 * service.
 */
static inline void ioport_init(void)
{
  401db8:	b580      	push	{r7, lr}
  401dba:	af00      	add	r7, sp, #0
}

__always_inline static void arch_ioport_init(void)
{
#ifdef ID_PIOA
	sysclk_enable_peripheral_clock(ID_PIOA);
  401dbc:	2009      	movs	r0, #9
  401dbe:	4b08      	ldr	r3, [pc, #32]	; (401de0 <ioport_init+0x28>)
  401dc0:	4798      	blx	r3
#endif
#ifdef ID_PIOB
	sysclk_enable_peripheral_clock(ID_PIOB);
  401dc2:	200a      	movs	r0, #10
  401dc4:	4b06      	ldr	r3, [pc, #24]	; (401de0 <ioport_init+0x28>)
  401dc6:	4798      	blx	r3
#endif
#ifdef ID_PIOC
	sysclk_enable_peripheral_clock(ID_PIOC);
  401dc8:	200b      	movs	r0, #11
  401dca:	4b05      	ldr	r3, [pc, #20]	; (401de0 <ioport_init+0x28>)
  401dcc:	4798      	blx	r3
#endif
#ifdef ID_PIOD
	sysclk_enable_peripheral_clock(ID_PIOD);
  401dce:	200c      	movs	r0, #12
  401dd0:	4b03      	ldr	r3, [pc, #12]	; (401de0 <ioport_init+0x28>)
  401dd2:	4798      	blx	r3
#endif
#ifdef ID_PIOE
	sysclk_enable_peripheral_clock(ID_PIOE);
  401dd4:	200d      	movs	r0, #13
  401dd6:	4b02      	ldr	r3, [pc, #8]	; (401de0 <ioport_init+0x28>)
  401dd8:	4798      	blx	r3
	arch_ioport_init();
}
  401dda:	bf00      	nop
  401ddc:	bd80      	pop	{r7, pc}
  401dde:	bf00      	nop
  401de0:	00401d9d 	.word	0x00401d9d

00401de4 <ioport_disable_pin>:
 *        IOPORT_CREATE_PIN().
 *
 * \param pin IOPORT pin to disable
 */
static inline void ioport_disable_pin(ioport_pin_t pin)
{
  401de4:	b480      	push	{r7}
  401de6:	b089      	sub	sp, #36	; 0x24
  401de8:	af00      	add	r7, sp, #0
  401dea:	6078      	str	r0, [r7, #4]
  401dec:	687b      	ldr	r3, [r7, #4]
  401dee:	61fb      	str	r3, [r7, #28]
  401df0:	69fb      	ldr	r3, [r7, #28]
  401df2:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  401df4:	69bb      	ldr	r3, [r7, #24]
  401df6:	095a      	lsrs	r2, r3, #5
  401df8:	69fb      	ldr	r3, [r7, #28]
  401dfa:	617b      	str	r3, [r7, #20]
	return 1U << (pin & 0x1F);
  401dfc:	697b      	ldr	r3, [r7, #20]
  401dfe:	f003 031f 	and.w	r3, r3, #31
  401e02:	2101      	movs	r1, #1
  401e04:	fa01 f303 	lsl.w	r3, r1, r3
  401e08:	613a      	str	r2, [r7, #16]
  401e0a:	60fb      	str	r3, [r7, #12]
  401e0c:	693b      	ldr	r3, [r7, #16]
  401e0e:	60bb      	str	r3, [r7, #8]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  401e10:	68bb      	ldr	r3, [r7, #8]
  401e12:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401e16:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401e1a:	025b      	lsls	r3, r3, #9
  401e1c:	461a      	mov	r2, r3
}

__always_inline static void arch_ioport_disable_port(ioport_port_t port,
		ioport_port_mask_t mask)
{
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  401e1e:	68fb      	ldr	r3, [r7, #12]
  401e20:	6053      	str	r3, [r2, #4]
	arch_ioport_disable_pin(pin);
}
  401e22:	bf00      	nop
  401e24:	3724      	adds	r7, #36	; 0x24
  401e26:	46bd      	mov	sp, r7
  401e28:	f85d 7b04 	ldr.w	r7, [sp], #4
  401e2c:	4770      	bx	lr

00401e2e <ioport_set_pin_mode>:
 *
 * \param pin IOPORT pin to configure
 * \param mode Mode masks to configure for the specified pin (\ref ioport_modes)
 */
static inline void ioport_set_pin_mode(ioport_pin_t pin, ioport_mode_t mode)
{
  401e2e:	b480      	push	{r7}
  401e30:	b08d      	sub	sp, #52	; 0x34
  401e32:	af00      	add	r7, sp, #0
  401e34:	6078      	str	r0, [r7, #4]
  401e36:	6039      	str	r1, [r7, #0]
  401e38:	687b      	ldr	r3, [r7, #4]
  401e3a:	62fb      	str	r3, [r7, #44]	; 0x2c
  401e3c:	683b      	ldr	r3, [r7, #0]
  401e3e:	62bb      	str	r3, [r7, #40]	; 0x28
  401e40:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401e42:	627b      	str	r3, [r7, #36]	; 0x24
	return pin >> 5;
  401e44:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401e46:	095a      	lsrs	r2, r3, #5
  401e48:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401e4a:	623b      	str	r3, [r7, #32]
	return 1U << (pin & 0x1F);
  401e4c:	6a3b      	ldr	r3, [r7, #32]
  401e4e:	f003 031f 	and.w	r3, r3, #31
  401e52:	2101      	movs	r1, #1
  401e54:	fa01 f303 	lsl.w	r3, r1, r3
  401e58:	61fa      	str	r2, [r7, #28]
  401e5a:	61bb      	str	r3, [r7, #24]
  401e5c:	6abb      	ldr	r3, [r7, #40]	; 0x28
  401e5e:	617b      	str	r3, [r7, #20]
  401e60:	69fb      	ldr	r3, [r7, #28]
  401e62:	613b      	str	r3, [r7, #16]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  401e64:	693b      	ldr	r3, [r7, #16]
  401e66:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401e6a:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401e6e:	025b      	lsls	r3, r3, #9
}

__always_inline static void arch_ioport_set_port_mode(ioport_port_t port,
		ioport_port_mask_t mask, ioport_mode_t mode)
{
	Pio *base = arch_ioport_port_to_base(port);
  401e70:	60fb      	str	r3, [r7, #12]

	if (mode & IOPORT_MODE_PULLUP) {
  401e72:	697b      	ldr	r3, [r7, #20]
  401e74:	f003 0308 	and.w	r3, r3, #8
  401e78:	2b00      	cmp	r3, #0
  401e7a:	d003      	beq.n	401e84 <ioport_set_pin_mode+0x56>
		base->PIO_PUER = mask;
  401e7c:	68fb      	ldr	r3, [r7, #12]
  401e7e:	69ba      	ldr	r2, [r7, #24]
  401e80:	665a      	str	r2, [r3, #100]	; 0x64
  401e82:	e002      	b.n	401e8a <ioport_set_pin_mode+0x5c>
	} else {
		base->PIO_PUDR = mask;
  401e84:	68fb      	ldr	r3, [r7, #12]
  401e86:	69ba      	ldr	r2, [r7, #24]
  401e88:	661a      	str	r2, [r3, #96]	; 0x60
	}

#if defined(IOPORT_MODE_PULLDOWN)
	if (mode & IOPORT_MODE_PULLDOWN) {
  401e8a:	697b      	ldr	r3, [r7, #20]
  401e8c:	f003 0310 	and.w	r3, r3, #16
  401e90:	2b00      	cmp	r3, #0
  401e92:	d004      	beq.n	401e9e <ioport_set_pin_mode+0x70>
		base->PIO_PPDER = mask;
  401e94:	68fb      	ldr	r3, [r7, #12]
  401e96:	69ba      	ldr	r2, [r7, #24]
  401e98:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  401e9c:	e003      	b.n	401ea6 <ioport_set_pin_mode+0x78>
	} else {
		base->PIO_PPDDR = mask;
  401e9e:	68fb      	ldr	r3, [r7, #12]
  401ea0:	69ba      	ldr	r2, [r7, #24]
  401ea2:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	}
#endif

	if (mode & IOPORT_MODE_OPEN_DRAIN) {
  401ea6:	697b      	ldr	r3, [r7, #20]
  401ea8:	f003 0320 	and.w	r3, r3, #32
  401eac:	2b00      	cmp	r3, #0
  401eae:	d003      	beq.n	401eb8 <ioport_set_pin_mode+0x8a>
		base->PIO_MDER = mask;
  401eb0:	68fb      	ldr	r3, [r7, #12]
  401eb2:	69ba      	ldr	r2, [r7, #24]
  401eb4:	651a      	str	r2, [r3, #80]	; 0x50
  401eb6:	e002      	b.n	401ebe <ioport_set_pin_mode+0x90>
	} else {
		base->PIO_MDDR = mask;
  401eb8:	68fb      	ldr	r3, [r7, #12]
  401eba:	69ba      	ldr	r2, [r7, #24]
  401ebc:	655a      	str	r2, [r3, #84]	; 0x54
	}

	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
  401ebe:	697b      	ldr	r3, [r7, #20]
  401ec0:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
  401ec4:	2b00      	cmp	r3, #0
  401ec6:	d003      	beq.n	401ed0 <ioport_set_pin_mode+0xa2>
		base->PIO_IFER = mask;
  401ec8:	68fb      	ldr	r3, [r7, #12]
  401eca:	69ba      	ldr	r2, [r7, #24]
  401ecc:	621a      	str	r2, [r3, #32]
  401ece:	e002      	b.n	401ed6 <ioport_set_pin_mode+0xa8>
	} else {
		base->PIO_IFDR = mask;
  401ed0:	68fb      	ldr	r3, [r7, #12]
  401ed2:	69ba      	ldr	r2, [r7, #24]
  401ed4:	625a      	str	r2, [r3, #36]	; 0x24
	}

	if (mode & IOPORT_MODE_DEBOUNCE) {
  401ed6:	697b      	ldr	r3, [r7, #20]
  401ed8:	f003 0380 	and.w	r3, r3, #128	; 0x80
  401edc:	2b00      	cmp	r3, #0
  401ede:	d004      	beq.n	401eea <ioport_set_pin_mode+0xbc>
#if SAM3U || SAM3XA
		base->PIO_DIFSR = mask;
#else
		base->PIO_IFSCER = mask;
  401ee0:	68fb      	ldr	r3, [r7, #12]
  401ee2:	69ba      	ldr	r2, [r7, #24]
  401ee4:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  401ee8:	e003      	b.n	401ef2 <ioport_set_pin_mode+0xc4>
#endif
	} else {
#if SAM3U || SAM3XA
		base->PIO_SCIFSR = mask;
#else
		base->PIO_IFSCDR = mask;
  401eea:	68fb      	ldr	r3, [r7, #12]
  401eec:	69ba      	ldr	r2, [r7, #24]
  401eee:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
		base->PIO_ABSR |= mask;
	} else {
		base->PIO_ABSR &= ~mask;
	}
#else
	if (mode & IOPORT_MODE_MUX_BIT0) {
  401ef2:	697b      	ldr	r3, [r7, #20]
  401ef4:	f003 0301 	and.w	r3, r3, #1
  401ef8:	2b00      	cmp	r3, #0
  401efa:	d006      	beq.n	401f0a <ioport_set_pin_mode+0xdc>
		base->PIO_ABCDSR[0] |= mask;
  401efc:	68fb      	ldr	r3, [r7, #12]
  401efe:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  401f00:	69bb      	ldr	r3, [r7, #24]
  401f02:	431a      	orrs	r2, r3
  401f04:	68fb      	ldr	r3, [r7, #12]
  401f06:	671a      	str	r2, [r3, #112]	; 0x70
  401f08:	e006      	b.n	401f18 <ioport_set_pin_mode+0xea>
	} else {
		base->PIO_ABCDSR[0] &= ~mask;
  401f0a:	68fb      	ldr	r3, [r7, #12]
  401f0c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  401f0e:	69bb      	ldr	r3, [r7, #24]
  401f10:	43db      	mvns	r3, r3
  401f12:	401a      	ands	r2, r3
  401f14:	68fb      	ldr	r3, [r7, #12]
  401f16:	671a      	str	r2, [r3, #112]	; 0x70
	}

	if (mode & IOPORT_MODE_MUX_BIT1) {
  401f18:	697b      	ldr	r3, [r7, #20]
  401f1a:	f003 0302 	and.w	r3, r3, #2
  401f1e:	2b00      	cmp	r3, #0
  401f20:	d006      	beq.n	401f30 <ioport_set_pin_mode+0x102>
		base->PIO_ABCDSR[1] |= mask;
  401f22:	68fb      	ldr	r3, [r7, #12]
  401f24:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  401f26:	69bb      	ldr	r3, [r7, #24]
  401f28:	431a      	orrs	r2, r3
  401f2a:	68fb      	ldr	r3, [r7, #12]
  401f2c:	675a      	str	r2, [r3, #116]	; 0x74
	arch_ioport_set_pin_mode(pin, mode);
}
  401f2e:	e006      	b.n	401f3e <ioport_set_pin_mode+0x110>
	} else {
		base->PIO_ABCDSR[1] &= ~mask;
  401f30:	68fb      	ldr	r3, [r7, #12]
  401f32:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  401f34:	69bb      	ldr	r3, [r7, #24]
  401f36:	43db      	mvns	r3, r3
  401f38:	401a      	ands	r2, r3
  401f3a:	68fb      	ldr	r3, [r7, #12]
  401f3c:	675a      	str	r2, [r3, #116]	; 0x74
  401f3e:	bf00      	nop
  401f40:	3734      	adds	r7, #52	; 0x34
  401f42:	46bd      	mov	sp, r7
  401f44:	f85d 7b04 	ldr.w	r7, [sp], #4
  401f48:	4770      	bx	lr

00401f4a <ioport_set_pin_dir>:
 * \param pin IOPORT pin to configure
 * \param dir Direction to set for the specified pin (\ref ioport_direction)
 */
static inline void ioport_set_pin_dir(ioport_pin_t pin,
		enum ioport_direction dir)
{
  401f4a:	b480      	push	{r7}
  401f4c:	b08d      	sub	sp, #52	; 0x34
  401f4e:	af00      	add	r7, sp, #0
  401f50:	6078      	str	r0, [r7, #4]
  401f52:	460b      	mov	r3, r1
  401f54:	70fb      	strb	r3, [r7, #3]
  401f56:	687b      	ldr	r3, [r7, #4]
  401f58:	62fb      	str	r3, [r7, #44]	; 0x2c
  401f5a:	78fb      	ldrb	r3, [r7, #3]
  401f5c:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  401f60:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401f62:	627b      	str	r3, [r7, #36]	; 0x24
  401f64:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401f66:	623b      	str	r3, [r7, #32]
	return pin >> 5;
  401f68:	6a3b      	ldr	r3, [r7, #32]
  401f6a:	095b      	lsrs	r3, r3, #5
  401f6c:	61fb      	str	r3, [r7, #28]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  401f6e:	69fb      	ldr	r3, [r7, #28]
  401f70:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401f74:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401f78:	025b      	lsls	r3, r3, #9
}

__always_inline static void arch_ioport_set_pin_dir(ioport_pin_t pin,
		enum ioport_direction dir)
{
	Pio *base = arch_ioport_pin_to_base(pin);
  401f7a:	61bb      	str	r3, [r7, #24]

	if (dir == IOPORT_DIR_OUTPUT) {
  401f7c:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  401f80:	2b01      	cmp	r3, #1
  401f82:	d109      	bne.n	401f98 <ioport_set_pin_dir+0x4e>
  401f84:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401f86:	617b      	str	r3, [r7, #20]
	return 1U << (pin & 0x1F);
  401f88:	697b      	ldr	r3, [r7, #20]
  401f8a:	f003 031f 	and.w	r3, r3, #31
  401f8e:	2201      	movs	r2, #1
  401f90:	409a      	lsls	r2, r3
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  401f92:	69bb      	ldr	r3, [r7, #24]
  401f94:	611a      	str	r2, [r3, #16]
  401f96:	e00c      	b.n	401fb2 <ioport_set_pin_dir+0x68>
	} else if (dir == IOPORT_DIR_INPUT) {
  401f98:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  401f9c:	2b00      	cmp	r3, #0
  401f9e:	d108      	bne.n	401fb2 <ioport_set_pin_dir+0x68>
  401fa0:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401fa2:	613b      	str	r3, [r7, #16]
	return 1U << (pin & 0x1F);
  401fa4:	693b      	ldr	r3, [r7, #16]
  401fa6:	f003 031f 	and.w	r3, r3, #31
  401faa:	2201      	movs	r2, #1
  401fac:	409a      	lsls	r2, r3
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
  401fae:	69bb      	ldr	r3, [r7, #24]
  401fb0:	615a      	str	r2, [r3, #20]
  401fb2:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401fb4:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  401fb6:	68fb      	ldr	r3, [r7, #12]
  401fb8:	f003 031f 	and.w	r3, r3, #31
  401fbc:	2201      	movs	r2, #1
  401fbe:	409a      	lsls	r2, r3
	}

	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  401fc0:	69bb      	ldr	r3, [r7, #24]
  401fc2:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
	arch_ioport_set_pin_dir(pin, dir);
}
  401fc6:	bf00      	nop
  401fc8:	3734      	adds	r7, #52	; 0x34
  401fca:	46bd      	mov	sp, r7
  401fcc:	f85d 7b04 	ldr.w	r7, [sp], #4
  401fd0:	4770      	bx	lr

00401fd2 <ioport_set_pin_level>:
 *
 * \param pin IOPORT pin to configure
 * \param level Logical value of the pin
 */
static inline void ioport_set_pin_level(ioport_pin_t pin, bool level)
{
  401fd2:	b480      	push	{r7}
  401fd4:	b08b      	sub	sp, #44	; 0x2c
  401fd6:	af00      	add	r7, sp, #0
  401fd8:	6078      	str	r0, [r7, #4]
  401fda:	460b      	mov	r3, r1
  401fdc:	70fb      	strb	r3, [r7, #3]
  401fde:	687b      	ldr	r3, [r7, #4]
  401fe0:	627b      	str	r3, [r7, #36]	; 0x24
  401fe2:	78fb      	ldrb	r3, [r7, #3]
  401fe4:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  401fe8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401fea:	61fb      	str	r3, [r7, #28]
  401fec:	69fb      	ldr	r3, [r7, #28]
  401fee:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  401ff0:	69bb      	ldr	r3, [r7, #24]
  401ff2:	095b      	lsrs	r3, r3, #5
  401ff4:	617b      	str	r3, [r7, #20]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  401ff6:	697b      	ldr	r3, [r7, #20]
  401ff8:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401ffc:	f203 7307 	addw	r3, r3, #1799	; 0x707
  402000:	025b      	lsls	r3, r3, #9
}

__always_inline static void arch_ioport_set_pin_level(ioport_pin_t pin,
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);
  402002:	613b      	str	r3, [r7, #16]

	if (level) {
  402004:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  402008:	2b00      	cmp	r3, #0
  40200a:	d009      	beq.n	402020 <ioport_set_pin_level+0x4e>
  40200c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40200e:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  402010:	68fb      	ldr	r3, [r7, #12]
  402012:	f003 031f 	and.w	r3, r3, #31
  402016:	2201      	movs	r2, #1
  402018:	409a      	lsls	r2, r3
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  40201a:	693b      	ldr	r3, [r7, #16]
  40201c:	631a      	str	r2, [r3, #48]	; 0x30
	arch_ioport_set_pin_level(pin, level);
}
  40201e:	e008      	b.n	402032 <ioport_set_pin_level+0x60>
  402020:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  402022:	60bb      	str	r3, [r7, #8]
	return 1U << (pin & 0x1F);
  402024:	68bb      	ldr	r3, [r7, #8]
  402026:	f003 031f 	and.w	r3, r3, #31
  40202a:	2201      	movs	r2, #1
  40202c:	409a      	lsls	r2, r3
	} else {
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  40202e:	693b      	ldr	r3, [r7, #16]
  402030:	635a      	str	r2, [r3, #52]	; 0x34
  402032:	bf00      	nop
  402034:	372c      	adds	r7, #44	; 0x2c
  402036:	46bd      	mov	sp, r7
  402038:	f85d 7b04 	ldr.w	r7, [sp], #4
  40203c:	4770      	bx	lr
	...

00402040 <ioport_set_pin_sense_mode>:
 * \param pin IOPORT pin to configure
 * \param pin_sense Edge to sense for the pin (\ref ioport_sense)
 */
static inline void ioport_set_pin_sense_mode(ioport_pin_t pin,
		enum ioport_sense pin_sense)
{
  402040:	b480      	push	{r7}
  402042:	b08d      	sub	sp, #52	; 0x34
  402044:	af00      	add	r7, sp, #0
  402046:	6078      	str	r0, [r7, #4]
  402048:	460b      	mov	r3, r1
  40204a:	70fb      	strb	r3, [r7, #3]
  40204c:	687b      	ldr	r3, [r7, #4]
  40204e:	62fb      	str	r3, [r7, #44]	; 0x2c
  402050:	78fb      	ldrb	r3, [r7, #3]
  402052:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  402056:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  402058:	627b      	str	r3, [r7, #36]	; 0x24
	return pin >> 5;
  40205a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40205c:	095a      	lsrs	r2, r3, #5
  40205e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  402060:	623b      	str	r3, [r7, #32]
	return 1U << (pin & 0x1F);
  402062:	6a3b      	ldr	r3, [r7, #32]
  402064:	f003 031f 	and.w	r3, r3, #31
  402068:	2101      	movs	r1, #1
  40206a:	fa01 f303 	lsl.w	r3, r1, r3
  40206e:	61fa      	str	r2, [r7, #28]
  402070:	61bb      	str	r3, [r7, #24]
  402072:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  402076:	75fb      	strb	r3, [r7, #23]
  402078:	69fb      	ldr	r3, [r7, #28]
  40207a:	613b      	str	r3, [r7, #16]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  40207c:	693b      	ldr	r3, [r7, #16]
  40207e:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  402082:	f203 7307 	addw	r3, r3, #1799	; 0x707
  402086:	025b      	lsls	r3, r3, #9
}

__always_inline static void arch_ioport_set_port_sense_mode(ioport_port_t port,
		ioport_port_mask_t mask, enum ioport_sense pin_sense)
{
	Pio *base = arch_ioport_port_to_base(port);
  402088:	60fb      	str	r3, [r7, #12]
	 *       1       0         0    IOPORT_SENSE_FALLING
	 *       1       0         1    IOPORT_SENSE_RISING
	 *       1       1         0    IOPORT_SENSE_LEVEL_LOW
	 *       1       1         1    IOPORT_SENSE_LEVEL_HIGH
	 */
	switch(pin_sense) {
  40208a:	7dfb      	ldrb	r3, [r7, #23]
  40208c:	3b01      	subs	r3, #1
  40208e:	2b03      	cmp	r3, #3
  402090:	d82e      	bhi.n	4020f0 <ioport_set_pin_sense_mode+0xb0>
  402092:	a201      	add	r2, pc, #4	; (adr r2, 402098 <ioport_set_pin_sense_mode+0x58>)
  402094:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  402098:	004020cd 	.word	0x004020cd
  40209c:	004020df 	.word	0x004020df
  4020a0:	004020a9 	.word	0x004020a9
  4020a4:	004020bb 	.word	0x004020bb
	case IOPORT_SENSE_LEVEL_LOW:
		base->PIO_LSR = mask;
  4020a8:	68fb      	ldr	r3, [r7, #12]
  4020aa:	69ba      	ldr	r2, [r7, #24]
  4020ac:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
		base->PIO_FELLSR = mask;
  4020b0:	68fb      	ldr	r3, [r7, #12]
  4020b2:	69ba      	ldr	r2, [r7, #24]
  4020b4:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
  4020b8:	e01f      	b.n	4020fa <ioport_set_pin_sense_mode+0xba>
		break;
	case IOPORT_SENSE_LEVEL_HIGH:
		base->PIO_LSR = mask;
  4020ba:	68fb      	ldr	r3, [r7, #12]
  4020bc:	69ba      	ldr	r2, [r7, #24]
  4020be:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
		base->PIO_REHLSR = mask;
  4020c2:	68fb      	ldr	r3, [r7, #12]
  4020c4:	69ba      	ldr	r2, [r7, #24]
  4020c6:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
  4020ca:	e016      	b.n	4020fa <ioport_set_pin_sense_mode+0xba>
		break;
	case IOPORT_SENSE_FALLING:
		base->PIO_ESR = mask;
  4020cc:	68fb      	ldr	r3, [r7, #12]
  4020ce:	69ba      	ldr	r2, [r7, #24]
  4020d0:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
		base->PIO_FELLSR = mask;
  4020d4:	68fb      	ldr	r3, [r7, #12]
  4020d6:	69ba      	ldr	r2, [r7, #24]
  4020d8:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
  4020dc:	e00d      	b.n	4020fa <ioport_set_pin_sense_mode+0xba>
		break;
	case IOPORT_SENSE_RISING:
		base->PIO_ESR = mask;
  4020de:	68fb      	ldr	r3, [r7, #12]
  4020e0:	69ba      	ldr	r2, [r7, #24]
  4020e2:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
		base->PIO_REHLSR = mask;
  4020e6:	68fb      	ldr	r3, [r7, #12]
  4020e8:	69ba      	ldr	r2, [r7, #24]
  4020ea:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
  4020ee:	e004      	b.n	4020fa <ioport_set_pin_sense_mode+0xba>
		break;
	default:
		base->PIO_AIMDR = mask;
  4020f0:	68fb      	ldr	r3, [r7, #12]
  4020f2:	69ba      	ldr	r2, [r7, #24]
  4020f4:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
	arch_ioport_set_pin_sense_mode(pin, pin_sense);
}
  4020f8:	e003      	b.n	402102 <ioport_set_pin_sense_mode+0xc2>
		return;
	}
	base->PIO_AIMER = mask;
  4020fa:	68fb      	ldr	r3, [r7, #12]
  4020fc:	69ba      	ldr	r2, [r7, #24]
  4020fe:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
  402102:	bf00      	nop
  402104:	3734      	adds	r7, #52	; 0x34
  402106:	46bd      	mov	sp, r7
  402108:	f85d 7b04 	ldr.w	r7, [sp], #4
  40210c:	4770      	bx	lr
  40210e:	bf00      	nop

00402110 <board_init>:
		ioport_set_pin_mode(pin, mode);\
		ioport_set_pin_sense_mode(pin, sense);\
	} while (0)

void board_init(void)
{
  402110:	b580      	push	{r7, lr}
  402112:	af00      	add	r7, sp, #0
#ifndef CONF_BOARD_KEEP_WATCHDOG_AT_INIT
	/* Disable the watchdog */
	WDT->WDT_MR = WDT_MR_WDDIS;
  402114:	4b34      	ldr	r3, [pc, #208]	; (4021e8 <board_init+0xd8>)
  402116:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  40211a:	605a      	str	r2, [r3, #4]
#endif

	/* Initialize IOPORTs */
	ioport_init();
  40211c:	4b33      	ldr	r3, [pc, #204]	; (4021ec <board_init+0xdc>)
  40211e:	4798      	blx	r3

	/* Configure the pins connected to LED as output and set their
	 * default initial state to high (LED off).
	 */
	ioport_set_pin_dir(LED0_GPIO, IOPORT_DIR_OUTPUT);
  402120:	2101      	movs	r1, #1
  402122:	2076      	movs	r0, #118	; 0x76
  402124:	4b32      	ldr	r3, [pc, #200]	; (4021f0 <board_init+0xe0>)
  402126:	4798      	blx	r3
	ioport_set_pin_level(LED0_GPIO, LED0_INACTIVE_LEVEL);
  402128:	2101      	movs	r1, #1
  40212a:	2076      	movs	r0, #118	; 0x76
  40212c:	4b31      	ldr	r3, [pc, #196]	; (4021f4 <board_init+0xe4>)
  40212e:	4798      	blx	r3

	/* Configure Push Button pins */
	ioport_set_pin_input_mode(GPIO_PUSH_BUTTON_1, GPIO_PUSH_BUTTON_1_FLAGS,
  402130:	2100      	movs	r1, #0
  402132:	2002      	movs	r0, #2
  402134:	4b2e      	ldr	r3, [pc, #184]	; (4021f0 <board_init+0xe0>)
  402136:	4798      	blx	r3
  402138:	2188      	movs	r1, #136	; 0x88
  40213a:	2002      	movs	r0, #2
  40213c:	4b2e      	ldr	r3, [pc, #184]	; (4021f8 <board_init+0xe8>)
  40213e:	4798      	blx	r3
  402140:	2102      	movs	r1, #2
  402142:	2002      	movs	r0, #2
  402144:	4b2d      	ldr	r3, [pc, #180]	; (4021fc <board_init+0xec>)
  402146:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_PWM_LED0_GPIO, PIN_PWM_LED0_FLAGS);
#endif

#ifdef CONF_BOARD_CAN
	/* Configure the CAN1 TX and RX pin. */
	ioport_set_pin_peripheral_mode(PIN_CAN1_RX_IDX, PIN_CAN1_RX_FLAGS);
  402148:	2102      	movs	r1, #2
  40214a:	204c      	movs	r0, #76	; 0x4c
  40214c:	4b2a      	ldr	r3, [pc, #168]	; (4021f8 <board_init+0xe8>)
  40214e:	4798      	blx	r3
  402150:	204c      	movs	r0, #76	; 0x4c
  402152:	4b2b      	ldr	r3, [pc, #172]	; (402200 <board_init+0xf0>)
  402154:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_CAN1_TX_IDX, PIN_CAN1_TX_FLAGS);
  402156:	2102      	movs	r1, #2
  402158:	204f      	movs	r0, #79	; 0x4f
  40215a:	4b27      	ldr	r3, [pc, #156]	; (4021f8 <board_init+0xe8>)
  40215c:	4798      	blx	r3
  40215e:	204f      	movs	r0, #79	; 0x4f
  402160:	4b27      	ldr	r3, [pc, #156]	; (402200 <board_init+0xf0>)
  402162:	4798      	blx	r3
	/* Configure the transiver1 RS & EN pins. */
	ioport_set_pin_dir(PIN_CAN1_TR_RS_IDX, IOPORT_DIR_OUTPUT);
  402164:	2101      	movs	r1, #1
  402166:	2082      	movs	r0, #130	; 0x82
  402168:	4b21      	ldr	r3, [pc, #132]	; (4021f0 <board_init+0xe0>)
  40216a:	4798      	blx	r3
	ioport_set_pin_dir(PIN_CAN1_TR_EN_IDX, IOPORT_DIR_OUTPUT);
  40216c:	2101      	movs	r1, #1
  40216e:	2083      	movs	r0, #131	; 0x83
  402170:	4b1f      	ldr	r3, [pc, #124]	; (4021f0 <board_init+0xe0>)
  402172:	4798      	blx	r3
#  endif
#endif

#if defined (CONF_BOARD_SD_MMC_HSMCI)
	/* Configure HSMCI pins */
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCCDA_GPIO, PIN_HSMCI_MCCDA_FLAGS);
  402174:	2102      	movs	r1, #2
  402176:	201c      	movs	r0, #28
  402178:	4b1f      	ldr	r3, [pc, #124]	; (4021f8 <board_init+0xe8>)
  40217a:	4798      	blx	r3
  40217c:	201c      	movs	r0, #28
  40217e:	4b20      	ldr	r3, [pc, #128]	; (402200 <board_init+0xf0>)
  402180:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCCK_GPIO, PIN_HSMCI_MCCK_FLAGS);
  402182:	2102      	movs	r1, #2
  402184:	201d      	movs	r0, #29
  402186:	4b1c      	ldr	r3, [pc, #112]	; (4021f8 <board_init+0xe8>)
  402188:	4798      	blx	r3
  40218a:	201d      	movs	r0, #29
  40218c:	4b1c      	ldr	r3, [pc, #112]	; (402200 <board_init+0xf0>)
  40218e:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCDA0_GPIO, PIN_HSMCI_MCDA0_FLAGS);
  402190:	2102      	movs	r1, #2
  402192:	201e      	movs	r0, #30
  402194:	4b18      	ldr	r3, [pc, #96]	; (4021f8 <board_init+0xe8>)
  402196:	4798      	blx	r3
  402198:	201e      	movs	r0, #30
  40219a:	4b19      	ldr	r3, [pc, #100]	; (402200 <board_init+0xf0>)
  40219c:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCDA1_GPIO, PIN_HSMCI_MCDA1_FLAGS);
  40219e:	2102      	movs	r1, #2
  4021a0:	201f      	movs	r0, #31
  4021a2:	4b15      	ldr	r3, [pc, #84]	; (4021f8 <board_init+0xe8>)
  4021a4:	4798      	blx	r3
  4021a6:	201f      	movs	r0, #31
  4021a8:	4b15      	ldr	r3, [pc, #84]	; (402200 <board_init+0xf0>)
  4021aa:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCDA2_GPIO, PIN_HSMCI_MCDA2_FLAGS);
  4021ac:	2102      	movs	r1, #2
  4021ae:	201a      	movs	r0, #26
  4021b0:	4b11      	ldr	r3, [pc, #68]	; (4021f8 <board_init+0xe8>)
  4021b2:	4798      	blx	r3
  4021b4:	201a      	movs	r0, #26
  4021b6:	4b12      	ldr	r3, [pc, #72]	; (402200 <board_init+0xf0>)
  4021b8:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCDA3_GPIO, PIN_HSMCI_MCDA3_FLAGS);
  4021ba:	2102      	movs	r1, #2
  4021bc:	201b      	movs	r0, #27
  4021be:	4b0e      	ldr	r3, [pc, #56]	; (4021f8 <board_init+0xe8>)
  4021c0:	4798      	blx	r3
  4021c2:	201b      	movs	r0, #27
  4021c4:	4b0e      	ldr	r3, [pc, #56]	; (402200 <board_init+0xf0>)
  4021c6:	4798      	blx	r3
	ioport_set_pin_dir(AT86RFX_SLP_PIN, IOPORT_DIR_OUTPUT);
	ioport_set_pin_level(AT86RFX_SLP_PIN, IOPORT_PIN_LEVEL_HIGH);
#endif  

#if (defined(CONF_BOARD_TWI0) || defined(CONF_BOARD_EDBG_TWI))
	ioport_set_pin_peripheral_mode(TWI0_DATA_GPIO, TWI0_DATA_FLAGS);
  4021c8:	2100      	movs	r1, #0
  4021ca:	2003      	movs	r0, #3
  4021cc:	4b0a      	ldr	r3, [pc, #40]	; (4021f8 <board_init+0xe8>)
  4021ce:	4798      	blx	r3
  4021d0:	2003      	movs	r0, #3
  4021d2:	4b0b      	ldr	r3, [pc, #44]	; (402200 <board_init+0xf0>)
  4021d4:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(TWI0_CLK_GPIO, TWI0_CLK_FLAGS);
  4021d6:	2100      	movs	r1, #0
  4021d8:	2004      	movs	r0, #4
  4021da:	4b07      	ldr	r3, [pc, #28]	; (4021f8 <board_init+0xe8>)
  4021dc:	4798      	blx	r3
  4021de:	2004      	movs	r0, #4
  4021e0:	4b07      	ldr	r3, [pc, #28]	; (402200 <board_init+0xf0>)
  4021e2:	4798      	blx	r3
#endif

}
  4021e4:	bf00      	nop
  4021e6:	bd80      	pop	{r7, pc}
  4021e8:	400e1850 	.word	0x400e1850
  4021ec:	00401db9 	.word	0x00401db9
  4021f0:	00401f4b 	.word	0x00401f4b
  4021f4:	00401fd3 	.word	0x00401fd3
  4021f8:	00401e2f 	.word	0x00401e2f
  4021fc:	00402041 	.word	0x00402041
  402200:	00401de5 	.word	0x00401de5

00402204 <osc_get_rate>:
{
  402204:	b480      	push	{r7}
  402206:	b083      	sub	sp, #12
  402208:	af00      	add	r7, sp, #0
  40220a:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  40220c:	687b      	ldr	r3, [r7, #4]
  40220e:	2b07      	cmp	r3, #7
  402210:	d825      	bhi.n	40225e <osc_get_rate+0x5a>
  402212:	a201      	add	r2, pc, #4	; (adr r2, 402218 <osc_get_rate+0x14>)
  402214:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  402218:	00402239 	.word	0x00402239
  40221c:	0040223f 	.word	0x0040223f
  402220:	00402245 	.word	0x00402245
  402224:	0040224b 	.word	0x0040224b
  402228:	0040224f 	.word	0x0040224f
  40222c:	00402253 	.word	0x00402253
  402230:	00402257 	.word	0x00402257
  402234:	0040225b 	.word	0x0040225b
		return OSC_SLCK_32K_RC_HZ;
  402238:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  40223c:	e010      	b.n	402260 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_XTAL;
  40223e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  402242:	e00d      	b.n	402260 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_BYPASS;
  402244:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  402248:	e00a      	b.n	402260 <osc_get_rate+0x5c>
		return OSC_MAINCK_4M_RC_HZ;
  40224a:	4b08      	ldr	r3, [pc, #32]	; (40226c <osc_get_rate+0x68>)
  40224c:	e008      	b.n	402260 <osc_get_rate+0x5c>
		return OSC_MAINCK_8M_RC_HZ;
  40224e:	4b08      	ldr	r3, [pc, #32]	; (402270 <osc_get_rate+0x6c>)
  402250:	e006      	b.n	402260 <osc_get_rate+0x5c>
		return OSC_MAINCK_12M_RC_HZ;
  402252:	4b08      	ldr	r3, [pc, #32]	; (402274 <osc_get_rate+0x70>)
  402254:	e004      	b.n	402260 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_XTAL;
  402256:	4b07      	ldr	r3, [pc, #28]	; (402274 <osc_get_rate+0x70>)
  402258:	e002      	b.n	402260 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_BYPASS;
  40225a:	4b06      	ldr	r3, [pc, #24]	; (402274 <osc_get_rate+0x70>)
  40225c:	e000      	b.n	402260 <osc_get_rate+0x5c>
	return 0;
  40225e:	2300      	movs	r3, #0
}
  402260:	4618      	mov	r0, r3
  402262:	370c      	adds	r7, #12
  402264:	46bd      	mov	sp, r7
  402266:	f85d 7b04 	ldr.w	r7, [sp], #4
  40226a:	4770      	bx	lr
  40226c:	003d0900 	.word	0x003d0900
  402270:	007a1200 	.word	0x007a1200
  402274:	00b71b00 	.word	0x00b71b00

00402278 <sysclk_get_main_hz>:
{
  402278:	b580      	push	{r7, lr}
  40227a:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  40227c:	2006      	movs	r0, #6
  40227e:	4b03      	ldr	r3, [pc, #12]	; (40228c <sysclk_get_main_hz+0x14>)
  402280:	4798      	blx	r3
  402282:	4603      	mov	r3, r0
  402284:	011b      	lsls	r3, r3, #4
}
  402286:	4618      	mov	r0, r3
  402288:	bd80      	pop	{r7, pc}
  40228a:	bf00      	nop
  40228c:	00402205 	.word	0x00402205

00402290 <sysclk_get_peripheral_hz>:
{
  402290:	b580      	push	{r7, lr}
  402292:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  402294:	4b02      	ldr	r3, [pc, #8]	; (4022a0 <sysclk_get_peripheral_hz+0x10>)
  402296:	4798      	blx	r3
  402298:	4603      	mov	r3, r0
  40229a:	085b      	lsrs	r3, r3, #1
}
  40229c:	4618      	mov	r0, r3
  40229e:	bd80      	pop	{r7, pc}
  4022a0:	00402279 	.word	0x00402279

004022a4 <hsmci_reset>:

/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
  4022a4:	b480      	push	{r7}
  4022a6:	b087      	sub	sp, #28
  4022a8:	af00      	add	r7, sp, #0
	uint32_t mr = HSMCI->HSMCI_MR;
  4022aa:	4b15      	ldr	r3, [pc, #84]	; (402300 <hsmci_reset+0x5c>)
  4022ac:	685b      	ldr	r3, [r3, #4]
  4022ae:	617b      	str	r3, [r7, #20]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  4022b0:	4b13      	ldr	r3, [pc, #76]	; (402300 <hsmci_reset+0x5c>)
  4022b2:	689b      	ldr	r3, [r3, #8]
  4022b4:	613b      	str	r3, [r7, #16]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  4022b6:	4b12      	ldr	r3, [pc, #72]	; (402300 <hsmci_reset+0x5c>)
  4022b8:	68db      	ldr	r3, [r3, #12]
  4022ba:	60fb      	str	r3, [r7, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  4022bc:	4b10      	ldr	r3, [pc, #64]	; (402300 <hsmci_reset+0x5c>)
  4022be:	69db      	ldr	r3, [r3, #28]
  4022c0:	60bb      	str	r3, [r7, #8]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  4022c2:	4b0f      	ldr	r3, [pc, #60]	; (402300 <hsmci_reset+0x5c>)
  4022c4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  4022c6:	607b      	str	r3, [r7, #4]
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  4022c8:	4b0d      	ldr	r3, [pc, #52]	; (402300 <hsmci_reset+0x5c>)
  4022ca:	2280      	movs	r2, #128	; 0x80
  4022cc:	601a      	str	r2, [r3, #0]
	HSMCI->HSMCI_MR = mr;
  4022ce:	4a0c      	ldr	r2, [pc, #48]	; (402300 <hsmci_reset+0x5c>)
  4022d0:	697b      	ldr	r3, [r7, #20]
  4022d2:	6053      	str	r3, [r2, #4]
	HSMCI->HSMCI_DTOR = dtor;
  4022d4:	4a0a      	ldr	r2, [pc, #40]	; (402300 <hsmci_reset+0x5c>)
  4022d6:	693b      	ldr	r3, [r7, #16]
  4022d8:	6093      	str	r3, [r2, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  4022da:	4a09      	ldr	r2, [pc, #36]	; (402300 <hsmci_reset+0x5c>)
  4022dc:	68fb      	ldr	r3, [r7, #12]
  4022de:	60d3      	str	r3, [r2, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  4022e0:	4a07      	ldr	r2, [pc, #28]	; (402300 <hsmci_reset+0x5c>)
  4022e2:	68bb      	ldr	r3, [r7, #8]
  4022e4:	61d3      	str	r3, [r2, #28]
	HSMCI->HSMCI_CFG = cfg;
  4022e6:	4a06      	ldr	r2, [pc, #24]	; (402300 <hsmci_reset+0x5c>)
  4022e8:	687b      	ldr	r3, [r7, #4]
  4022ea:	6553      	str	r3, [r2, #84]	; 0x54
#ifdef HSMCI_DMA_DMAEN
	HSMCI->HSMCI_DMA = 0;
#endif
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  4022ec:	4b04      	ldr	r3, [pc, #16]	; (402300 <hsmci_reset+0x5c>)
  4022ee:	2205      	movs	r2, #5
  4022f0:	601a      	str	r2, [r3, #0]
}
  4022f2:	bf00      	nop
  4022f4:	371c      	adds	r7, #28
  4022f6:	46bd      	mov	sp, r7
  4022f8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4022fc:	4770      	bx	lr
  4022fe:	bf00      	nop
  402300:	40080000 	.word	0x40080000

00402304 <hsmci_set_speed>:
 *
 * \param speed    HSMCI clock speed in Hz.
 * \param mck      MCK clock speed in Hz.
 */
static void hsmci_set_speed(uint32_t speed, uint32_t mck)
{
  402304:	b480      	push	{r7}
  402306:	b087      	sub	sp, #28
  402308:	af00      	add	r7, sp, #0
  40230a:	6078      	str	r0, [r7, #4]
  40230c:	6039      	str	r1, [r7, #0]
#if (SAM4E || SAMV70 || SAMV71 || SAME70 || SAMS70)
	uint32_t clkdiv = 0;
  40230e:	2300      	movs	r3, #0
  402310:	617b      	str	r3, [r7, #20]
	uint32_t clkodd = 0;
  402312:	2300      	movs	r3, #0
  402314:	613b      	str	r3, [r7, #16]
	// clock divider, represent (((clkdiv << 1) + clkodd) + 2)
	uint32_t div = 0;
  402316:	2300      	movs	r3, #0
  402318:	60fb      	str	r3, [r7, #12]

	// Speed = MCK clock / (((clkdiv << 1) + clkodd) + 2)
	if ((speed * 2) < mck) {
  40231a:	687b      	ldr	r3, [r7, #4]
  40231c:	005a      	lsls	r2, r3, #1
  40231e:	683b      	ldr	r3, [r7, #0]
  402320:	429a      	cmp	r2, r3
  402322:	d21a      	bcs.n	40235a <hsmci_set_speed+0x56>
		div = (mck / speed) - 2;
  402324:	683a      	ldr	r2, [r7, #0]
  402326:	687b      	ldr	r3, [r7, #4]
  402328:	fbb2 f3f3 	udiv	r3, r2, r3
  40232c:	3b02      	subs	r3, #2
  40232e:	60fb      	str	r3, [r7, #12]
		if (mck % speed) {
  402330:	683b      	ldr	r3, [r7, #0]
  402332:	687a      	ldr	r2, [r7, #4]
  402334:	fbb3 f2f2 	udiv	r2, r3, r2
  402338:	6879      	ldr	r1, [r7, #4]
  40233a:	fb01 f202 	mul.w	r2, r1, r2
  40233e:	1a9b      	subs	r3, r3, r2
  402340:	2b00      	cmp	r3, #0
  402342:	d002      	beq.n	40234a <hsmci_set_speed+0x46>
			// Ensure that the card speed not be higher than expected.
			div++;
  402344:	68fb      	ldr	r3, [r7, #12]
  402346:	3301      	adds	r3, #1
  402348:	60fb      	str	r3, [r7, #12]
		}
		clkdiv = div >> 1;
  40234a:	68fb      	ldr	r3, [r7, #12]
  40234c:	085b      	lsrs	r3, r3, #1
  40234e:	617b      	str	r3, [r7, #20]
		// clkodd is the last significant bit of the clock divider (div).
		clkodd = div % 2;
  402350:	68fb      	ldr	r3, [r7, #12]
  402352:	f003 0301 	and.w	r3, r3, #1
  402356:	613b      	str	r3, [r7, #16]
  402358:	e003      	b.n	402362 <hsmci_set_speed+0x5e>
	} else {
		clkdiv = 0;
  40235a:	2300      	movs	r3, #0
  40235c:	617b      	str	r3, [r7, #20]
		clkodd = 0;
  40235e:	2300      	movs	r3, #0
  402360:	613b      	str	r3, [r7, #16]
	}

	HSMCI->HSMCI_MR &= ~HSMCI_MR_CLKDIV_Msk;
  402362:	4a11      	ldr	r2, [pc, #68]	; (4023a8 <hsmci_set_speed+0xa4>)
  402364:	4b10      	ldr	r3, [pc, #64]	; (4023a8 <hsmci_set_speed+0xa4>)
  402366:	685b      	ldr	r3, [r3, #4]
  402368:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
  40236c:	6053      	str	r3, [r2, #4]
	HSMCI->HSMCI_MR |= HSMCI_MR_CLKDIV(clkdiv);
  40236e:	490e      	ldr	r1, [pc, #56]	; (4023a8 <hsmci_set_speed+0xa4>)
  402370:	4b0d      	ldr	r3, [pc, #52]	; (4023a8 <hsmci_set_speed+0xa4>)
  402372:	685a      	ldr	r2, [r3, #4]
  402374:	697b      	ldr	r3, [r7, #20]
  402376:	b2db      	uxtb	r3, r3
  402378:	4313      	orrs	r3, r2
  40237a:	604b      	str	r3, [r1, #4]
	if (clkodd) {
  40237c:	693b      	ldr	r3, [r7, #16]
  40237e:	2b00      	cmp	r3, #0
  402380:	d006      	beq.n	402390 <hsmci_set_speed+0x8c>
		HSMCI->HSMCI_MR |= HSMCI_MR_CLKODD;
  402382:	4a09      	ldr	r2, [pc, #36]	; (4023a8 <hsmci_set_speed+0xa4>)
  402384:	4b08      	ldr	r3, [pc, #32]	; (4023a8 <hsmci_set_speed+0xa4>)
  402386:	685b      	ldr	r3, [r3, #4]
  402388:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  40238c:	6053      	str	r3, [r2, #4]
	}
	HSMCI->HSMCI_MR &= ~HSMCI_MR_CLKDIV_Msk;
	HSMCI->HSMCI_MR |= HSMCI_MR_CLKDIV(clkdiv);
#endif

}
  40238e:	e005      	b.n	40239c <hsmci_set_speed+0x98>
		HSMCI->HSMCI_MR &= ~HSMCI_MR_CLKODD;
  402390:	4a05      	ldr	r2, [pc, #20]	; (4023a8 <hsmci_set_speed+0xa4>)
  402392:	4b05      	ldr	r3, [pc, #20]	; (4023a8 <hsmci_set_speed+0xa4>)
  402394:	685b      	ldr	r3, [r3, #4]
  402396:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  40239a:	6053      	str	r3, [r2, #4]
}
  40239c:	bf00      	nop
  40239e:	371c      	adds	r7, #28
  4023a0:	46bd      	mov	sp, r7
  4023a2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4023a6:	4770      	bx	lr
  4023a8:	40080000 	.word	0x40080000

004023ac <hsmci_wait_busy>:
/** \brief Wait the end of busy signal on data line
 *
 * \return true if success, otherwise false
 */
static bool hsmci_wait_busy(void)
{
  4023ac:	b580      	push	{r7, lr}
  4023ae:	b082      	sub	sp, #8
  4023b0:	af00      	add	r7, sp, #0
	uint32_t busy_wait = 0xFFFFFFFF;
  4023b2:	f04f 33ff 	mov.w	r3, #4294967295
  4023b6:	607b      	str	r3, [r7, #4]
	uint32_t sr;

	do {
		sr = HSMCI->HSMCI_SR;
  4023b8:	4b0d      	ldr	r3, [pc, #52]	; (4023f0 <hsmci_wait_busy+0x44>)
  4023ba:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4023bc:	603b      	str	r3, [r7, #0]
		if (busy_wait-- == 0) {
  4023be:	687b      	ldr	r3, [r7, #4]
  4023c0:	1e5a      	subs	r2, r3, #1
  4023c2:	607a      	str	r2, [r7, #4]
  4023c4:	2b00      	cmp	r3, #0
  4023c6:	d103      	bne.n	4023d0 <hsmci_wait_busy+0x24>
			hsmci_debug("%s: timeout\n\r", __func__);
			hsmci_reset();
  4023c8:	4b0a      	ldr	r3, [pc, #40]	; (4023f4 <hsmci_wait_busy+0x48>)
  4023ca:	4798      	blx	r3
			return false;
  4023cc:	2300      	movs	r3, #0
  4023ce:	e00a      	b.n	4023e6 <hsmci_wait_busy+0x3a>
		}
	} while (!((sr & HSMCI_SR_NOTBUSY) && ((sr & HSMCI_SR_DTIP) == 0)));
  4023d0:	683b      	ldr	r3, [r7, #0]
  4023d2:	f003 0320 	and.w	r3, r3, #32
  4023d6:	2b00      	cmp	r3, #0
  4023d8:	d0ee      	beq.n	4023b8 <hsmci_wait_busy+0xc>
  4023da:	683b      	ldr	r3, [r7, #0]
  4023dc:	f003 0310 	and.w	r3, r3, #16
  4023e0:	2b00      	cmp	r3, #0
  4023e2:	d1e9      	bne.n	4023b8 <hsmci_wait_busy+0xc>
	return true;
  4023e4:	2301      	movs	r3, #1
}
  4023e6:	4618      	mov	r0, r3
  4023e8:	3708      	adds	r7, #8
  4023ea:	46bd      	mov	sp, r7
  4023ec:	bd80      	pop	{r7, pc}
  4023ee:	bf00      	nop
  4023f0:	40080000 	.word	0x40080000
  4023f4:	004022a5 	.word	0x004022a5

004023f8 <hsmci_send_cmd_execute>:
 *
 * \return true if success, otherwise false
 */
static bool hsmci_send_cmd_execute(uint32_t cmdr, sdmmc_cmd_def_t cmd,
		uint32_t arg)
{
  4023f8:	b580      	push	{r7, lr}
  4023fa:	b086      	sub	sp, #24
  4023fc:	af00      	add	r7, sp, #0
  4023fe:	60f8      	str	r0, [r7, #12]
  402400:	60b9      	str	r1, [r7, #8]
  402402:	607a      	str	r2, [r7, #4]
	uint32_t sr;

	cmdr |= HSMCI_CMDR_CMDNB(cmd) | HSMCI_CMDR_SPCMD_STD;
  402404:	68bb      	ldr	r3, [r7, #8]
  402406:	f003 033f 	and.w	r3, r3, #63	; 0x3f
  40240a:	68fa      	ldr	r2, [r7, #12]
  40240c:	4313      	orrs	r3, r2
  40240e:	60fb      	str	r3, [r7, #12]
	if (cmd & SDMMC_RESP_PRESENT) {
  402410:	68bb      	ldr	r3, [r7, #8]
  402412:	f403 7380 	and.w	r3, r3, #256	; 0x100
  402416:	2b00      	cmp	r3, #0
  402418:	d01b      	beq.n	402452 <hsmci_send_cmd_execute+0x5a>
		cmdr |= HSMCI_CMDR_MAXLAT;
  40241a:	68fb      	ldr	r3, [r7, #12]
  40241c:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
  402420:	60fb      	str	r3, [r7, #12]
		if (cmd & SDMMC_RESP_136) {
  402422:	68bb      	ldr	r3, [r7, #8]
  402424:	f403 6300 	and.w	r3, r3, #2048	; 0x800
  402428:	2b00      	cmp	r3, #0
  40242a:	d004      	beq.n	402436 <hsmci_send_cmd_execute+0x3e>
			cmdr |= HSMCI_CMDR_RSPTYP_136_BIT;
  40242c:	68fb      	ldr	r3, [r7, #12]
  40242e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  402432:	60fb      	str	r3, [r7, #12]
  402434:	e00d      	b.n	402452 <hsmci_send_cmd_execute+0x5a>
		} else if (cmd & SDMMC_RESP_BUSY) {
  402436:	68bb      	ldr	r3, [r7, #8]
  402438:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  40243c:	2b00      	cmp	r3, #0
  40243e:	d004      	beq.n	40244a <hsmci_send_cmd_execute+0x52>
			cmdr |= HSMCI_CMDR_RSPTYP_R1B;
  402440:	68fb      	ldr	r3, [r7, #12]
  402442:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
  402446:	60fb      	str	r3, [r7, #12]
  402448:	e003      	b.n	402452 <hsmci_send_cmd_execute+0x5a>
		} else {
			cmdr |= HSMCI_CMDR_RSPTYP_48_BIT;
  40244a:	68fb      	ldr	r3, [r7, #12]
  40244c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  402450:	60fb      	str	r3, [r7, #12]
		}
	}
	if (cmd & SDMMC_CMD_OPENDRAIN) {
  402452:	68bb      	ldr	r3, [r7, #8]
  402454:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
  402458:	2b00      	cmp	r3, #0
  40245a:	d003      	beq.n	402464 <hsmci_send_cmd_execute+0x6c>
		cmdr |= HSMCI_CMDR_OPDCMD_OPENDRAIN;
  40245c:	68fb      	ldr	r3, [r7, #12]
  40245e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
  402462:	60fb      	str	r3, [r7, #12]
	}

	// Write argument
	HSMCI->HSMCI_ARGR = arg;
  402464:	4a1c      	ldr	r2, [pc, #112]	; (4024d8 <hsmci_send_cmd_execute+0xe0>)
  402466:	687b      	ldr	r3, [r7, #4]
  402468:	6113      	str	r3, [r2, #16]
	// Write and start command
	HSMCI->HSMCI_CMDR = cmdr;
  40246a:	4a1b      	ldr	r2, [pc, #108]	; (4024d8 <hsmci_send_cmd_execute+0xe0>)
  40246c:	68fb      	ldr	r3, [r7, #12]
  40246e:	6153      	str	r3, [r2, #20]

	// Wait end of command
	do {
		sr = HSMCI->HSMCI_SR;
  402470:	4b19      	ldr	r3, [pc, #100]	; (4024d8 <hsmci_send_cmd_execute+0xe0>)
  402472:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  402474:	617b      	str	r3, [r7, #20]
		if (cmd & SDMMC_RESP_CRC) {
  402476:	68bb      	ldr	r3, [r7, #8]
  402478:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
  40247c:	2b00      	cmp	r3, #0
  40247e:	d008      	beq.n	402492 <hsmci_send_cmd_execute+0x9a>
			if (sr & (HSMCI_SR_CSTOE | HSMCI_SR_RTOE
  402480:	697b      	ldr	r3, [r7, #20]
  402482:	f403 031f 	and.w	r3, r3, #10420224	; 0x9f0000
  402486:	2b00      	cmp	r3, #0
  402488:	d00c      	beq.n	4024a4 <hsmci_send_cmd_execute+0xac>
					| HSMCI_SR_RENDE | HSMCI_SR_RCRCE
					| HSMCI_SR_RDIRE | HSMCI_SR_RINDE)) {
				hsmci_debug("%s: CMD 0x%08x sr 0x%08x error\n\r",
						__func__, cmd, sr);
				hsmci_reset();
  40248a:	4b14      	ldr	r3, [pc, #80]	; (4024dc <hsmci_send_cmd_execute+0xe4>)
  40248c:	4798      	blx	r3
				return false;
  40248e:	2300      	movs	r3, #0
  402490:	e01d      	b.n	4024ce <hsmci_send_cmd_execute+0xd6>
			}
		} else {
			if (sr & (HSMCI_SR_CSTOE | HSMCI_SR_RTOE
  402492:	697b      	ldr	r3, [r7, #20]
  402494:	f403 031b 	and.w	r3, r3, #10158080	; 0x9b0000
  402498:	2b00      	cmp	r3, #0
  40249a:	d003      	beq.n	4024a4 <hsmci_send_cmd_execute+0xac>
					| HSMCI_SR_RENDE
					| HSMCI_SR_RDIRE | HSMCI_SR_RINDE)) {
				hsmci_debug("%s: CMD 0x%08x sr 0x%08x error\n\r",
						__func__, cmd, sr);
				hsmci_reset();
  40249c:	4b0f      	ldr	r3, [pc, #60]	; (4024dc <hsmci_send_cmd_execute+0xe4>)
  40249e:	4798      	blx	r3
				return false;
  4024a0:	2300      	movs	r3, #0
  4024a2:	e014      	b.n	4024ce <hsmci_send_cmd_execute+0xd6>
			}
		}
	} while (!(sr & HSMCI_SR_CMDRDY));
  4024a4:	697b      	ldr	r3, [r7, #20]
  4024a6:	f003 0301 	and.w	r3, r3, #1
  4024aa:	2b00      	cmp	r3, #0
  4024ac:	d0e0      	beq.n	402470 <hsmci_send_cmd_execute+0x78>

	if (cmd & SDMMC_RESP_BUSY) {
  4024ae:	68bb      	ldr	r3, [r7, #8]
  4024b0:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
  4024b4:	2b00      	cmp	r3, #0
  4024b6:	d009      	beq.n	4024cc <hsmci_send_cmd_execute+0xd4>
		if (!hsmci_wait_busy()) {
  4024b8:	4b09      	ldr	r3, [pc, #36]	; (4024e0 <hsmci_send_cmd_execute+0xe8>)
  4024ba:	4798      	blx	r3
  4024bc:	4603      	mov	r3, r0
  4024be:	f083 0301 	eor.w	r3, r3, #1
  4024c2:	b2db      	uxtb	r3, r3
  4024c4:	2b00      	cmp	r3, #0
  4024c6:	d001      	beq.n	4024cc <hsmci_send_cmd_execute+0xd4>
			return false;
  4024c8:	2300      	movs	r3, #0
  4024ca:	e000      	b.n	4024ce <hsmci_send_cmd_execute+0xd6>
		}
	}
	return true;
  4024cc:	2301      	movs	r3, #1
}
  4024ce:	4618      	mov	r0, r3
  4024d0:	3718      	adds	r7, #24
  4024d2:	46bd      	mov	sp, r7
  4024d4:	bd80      	pop	{r7, pc}
  4024d6:	bf00      	nop
  4024d8:	40080000 	.word	0x40080000
  4024dc:	004022a5 	.word	0x004022a5
  4024e0:	004023ad 	.word	0x004023ad

004024e4 <hsmci_init>:

//-------------------------------------------------------------------
//--------------------- PUBLIC FUNCTIONS ----------------------------

void hsmci_init(void)
{
  4024e4:	b580      	push	{r7, lr}
  4024e6:	af00      	add	r7, sp, #0
	pmc_enable_periph_clk(ID_HSMCI);
  4024e8:	2010      	movs	r0, #16
  4024ea:	4b0a      	ldr	r3, [pc, #40]	; (402514 <hsmci_init+0x30>)
  4024ec:	4798      	blx	r3
	pmc_enable_periph_clk(ID_XDMAC);
#endif
#endif

	// Set the Data Timeout Register to 2 Mega Cycles
	HSMCI->HSMCI_DTOR = HSMCI_DTOR_DTOMUL_1048576 | HSMCI_DTOR_DTOCYC(2);
  4024ee:	4b0a      	ldr	r3, [pc, #40]	; (402518 <hsmci_init+0x34>)
  4024f0:	2272      	movs	r2, #114	; 0x72
  4024f2:	609a      	str	r2, [r3, #8]
	// Set Completion Signal Timeout to 2 Mega Cycles
	HSMCI->HSMCI_CSTOR = HSMCI_CSTOR_CSTOMUL_1048576 | HSMCI_CSTOR_CSTOCYC(2);
  4024f4:	4b08      	ldr	r3, [pc, #32]	; (402518 <hsmci_init+0x34>)
  4024f6:	2272      	movs	r2, #114	; 0x72
  4024f8:	61da      	str	r2, [r3, #28]
	// Set Configuration Register
	HSMCI->HSMCI_CFG = HSMCI_CFG_FIFOMODE | HSMCI_CFG_FERRCTRL;
  4024fa:	4b07      	ldr	r3, [pc, #28]	; (402518 <hsmci_init+0x34>)
  4024fc:	2211      	movs	r2, #17
  4024fe:	655a      	str	r2, [r3, #84]	; 0x54
	// Set power saving to maximum value
	HSMCI->HSMCI_MR = HSMCI_MR_PWSDIV_Msk;
  402500:	4b05      	ldr	r3, [pc, #20]	; (402518 <hsmci_init+0x34>)
  402502:	f44f 62e0 	mov.w	r2, #1792	; 0x700
  402506:	605a      	str	r2, [r3, #4]

	// Enable the HSMCI and the Power Saving
	HSMCI->HSMCI_CR = HSMCI_CR_MCIEN | HSMCI_CR_PWSEN;
  402508:	4b03      	ldr	r3, [pc, #12]	; (402518 <hsmci_init+0x34>)
  40250a:	2205      	movs	r2, #5
  40250c:	601a      	str	r2, [r3, #0]
}
  40250e:	bf00      	nop
  402510:	bd80      	pop	{r7, pc}
  402512:	bf00      	nop
  402514:	00403215 	.word	0x00403215
  402518:	40080000 	.word	0x40080000

0040251c <hsmci_get_bus_width>:

uint8_t hsmci_get_bus_width(uint8_t slot)
{
  40251c:	b480      	push	{r7}
  40251e:	b083      	sub	sp, #12
  402520:	af00      	add	r7, sp, #0
  402522:	4603      	mov	r3, r0
  402524:	71fb      	strb	r3, [r7, #7]
	switch (slot) {
  402526:	79fb      	ldrb	r3, [r7, #7]
  402528:	2b00      	cmp	r3, #0
  40252a:	d101      	bne.n	402530 <hsmci_get_bus_width+0x14>
	case 0:
		return SD_MMC_HSMCI_SLOT_0_SIZE;
  40252c:	2304      	movs	r3, #4
  40252e:	e000      	b.n	402532 <hsmci_get_bus_width+0x16>
#if (SD_MMC_HSMCI_MEM_CNT == 2)
	case 1:
		return SD_MMC_HSMCI_SLOT_1_SIZE;
#endif
	default:
		return 0; // Slot number wrong
  402530:	2300      	movs	r3, #0
	}
}
  402532:	4618      	mov	r0, r3
  402534:	370c      	adds	r7, #12
  402536:	46bd      	mov	sp, r7
  402538:	f85d 7b04 	ldr.w	r7, [sp], #4
  40253c:	4770      	bx	lr

0040253e <hsmci_is_high_speed_capable>:

bool hsmci_is_high_speed_capable(void)
{
  40253e:	b480      	push	{r7}
  402540:	af00      	add	r7, sp, #0
	return true;
  402542:	2301      	movs	r3, #1
}
  402544:	4618      	mov	r0, r3
  402546:	46bd      	mov	sp, r7
  402548:	f85d 7b04 	ldr.w	r7, [sp], #4
  40254c:	4770      	bx	lr
	...

00402550 <hsmci_select_device>:

void hsmci_select_device(uint8_t slot, uint32_t clock, uint8_t bus_width, bool high_speed)
{
  402550:	b580      	push	{r7, lr}
  402552:	b084      	sub	sp, #16
  402554:	af00      	add	r7, sp, #0
  402556:	6039      	str	r1, [r7, #0]
  402558:	4611      	mov	r1, r2
  40255a:	461a      	mov	r2, r3
  40255c:	4603      	mov	r3, r0
  40255e:	71fb      	strb	r3, [r7, #7]
  402560:	460b      	mov	r3, r1
  402562:	71bb      	strb	r3, [r7, #6]
  402564:	4613      	mov	r3, r2
  402566:	717b      	strb	r3, [r7, #5]
	uint32_t hsmci_slot = HSMCI_SDCR_SDCSEL_SLOTA;
  402568:	2300      	movs	r3, #0
  40256a:	60fb      	str	r3, [r7, #12]
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;
  40256c:	2300      	movs	r3, #0
  40256e:	60bb      	str	r3, [r7, #8]

	if (high_speed) {
  402570:	797b      	ldrb	r3, [r7, #5]
  402572:	2b00      	cmp	r3, #0
  402574:	d006      	beq.n	402584 <hsmci_select_device+0x34>
		HSMCI->HSMCI_CFG |= HSMCI_CFG_HSMODE;
  402576:	4a19      	ldr	r2, [pc, #100]	; (4025dc <hsmci_select_device+0x8c>)
  402578:	4b18      	ldr	r3, [pc, #96]	; (4025dc <hsmci_select_device+0x8c>)
  40257a:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  40257c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  402580:	6553      	str	r3, [r2, #84]	; 0x54
  402582:	e005      	b.n	402590 <hsmci_select_device+0x40>
	} else {
		HSMCI->HSMCI_CFG &= ~HSMCI_CFG_HSMODE;
  402584:	4a15      	ldr	r2, [pc, #84]	; (4025dc <hsmci_select_device+0x8c>)
  402586:	4b15      	ldr	r3, [pc, #84]	; (4025dc <hsmci_select_device+0x8c>)
  402588:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  40258a:	f423 7380 	bic.w	r3, r3, #256	; 0x100
  40258e:	6553      	str	r3, [r2, #84]	; 0x54
	}

	hsmci_set_speed(clock, sysclk_get_peripheral_hz());
  402590:	4b13      	ldr	r3, [pc, #76]	; (4025e0 <hsmci_select_device+0x90>)
  402592:	4798      	blx	r3
  402594:	4603      	mov	r3, r0
  402596:	4619      	mov	r1, r3
  402598:	6838      	ldr	r0, [r7, #0]
  40259a:	4b12      	ldr	r3, [pc, #72]	; (4025e4 <hsmci_select_device+0x94>)
  40259c:	4798      	blx	r3

	switch (slot) {
  40259e:	79fb      	ldrb	r3, [r7, #7]
  4025a0:	2b00      	cmp	r3, #0
  4025a2:	d102      	bne.n	4025aa <hsmci_select_device+0x5a>
	case 0:
		hsmci_slot = HSMCI_SDCR_SDCSEL_SLOTA;
  4025a4:	2300      	movs	r3, #0
  4025a6:	60fb      	str	r3, [r7, #12]
		break;
  4025a8:	bf00      	nop
#endif
	default:
		Assert(false); // Slot number wrong
	}

	switch (bus_width) {
  4025aa:	79bb      	ldrb	r3, [r7, #6]
  4025ac:	2b04      	cmp	r3, #4
  4025ae:	d006      	beq.n	4025be <hsmci_select_device+0x6e>
  4025b0:	2b08      	cmp	r3, #8
  4025b2:	d007      	beq.n	4025c4 <hsmci_select_device+0x74>
  4025b4:	2b01      	cmp	r3, #1
  4025b6:	d108      	bne.n	4025ca <hsmci_select_device+0x7a>
	case 1:
		hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;
  4025b8:	2300      	movs	r3, #0
  4025ba:	60bb      	str	r3, [r7, #8]
		break;
  4025bc:	e005      	b.n	4025ca <hsmci_select_device+0x7a>

	case 4:
		hsmci_bus_width = HSMCI_SDCR_SDCBUS_4;
  4025be:	2380      	movs	r3, #128	; 0x80
  4025c0:	60bb      	str	r3, [r7, #8]
		break;
  4025c2:	e002      	b.n	4025ca <hsmci_select_device+0x7a>

	case 8:
		hsmci_bus_width = HSMCI_SDCR_SDCBUS_8;
  4025c4:	23c0      	movs	r3, #192	; 0xc0
  4025c6:	60bb      	str	r3, [r7, #8]
		break;
  4025c8:	bf00      	nop

	default:
		Assert(false); // Bus width wrong
	}
	HSMCI->HSMCI_SDCR = hsmci_slot | hsmci_bus_width;
  4025ca:	4904      	ldr	r1, [pc, #16]	; (4025dc <hsmci_select_device+0x8c>)
  4025cc:	68fa      	ldr	r2, [r7, #12]
  4025ce:	68bb      	ldr	r3, [r7, #8]
  4025d0:	4313      	orrs	r3, r2
  4025d2:	60cb      	str	r3, [r1, #12]
}
  4025d4:	bf00      	nop
  4025d6:	3710      	adds	r7, #16
  4025d8:	46bd      	mov	sp, r7
  4025da:	bd80      	pop	{r7, pc}
  4025dc:	40080000 	.word	0x40080000
  4025e0:	00402291 	.word	0x00402291
  4025e4:	00402305 	.word	0x00402305

004025e8 <hsmci_deselect_device>:

void hsmci_deselect_device(uint8_t slot)
{
  4025e8:	b480      	push	{r7}
  4025ea:	b083      	sub	sp, #12
  4025ec:	af00      	add	r7, sp, #0
  4025ee:	4603      	mov	r3, r0
  4025f0:	71fb      	strb	r3, [r7, #7]
	UNUSED(slot);
	// Nothing to do
}
  4025f2:	bf00      	nop
  4025f4:	370c      	adds	r7, #12
  4025f6:	46bd      	mov	sp, r7
  4025f8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4025fc:	4770      	bx	lr
	...

00402600 <hsmci_send_clock>:

void hsmci_send_clock(void)
{
  402600:	b480      	push	{r7}
  402602:	af00      	add	r7, sp, #0
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  402604:	4a0c      	ldr	r2, [pc, #48]	; (402638 <hsmci_send_clock+0x38>)
  402606:	4b0c      	ldr	r3, [pc, #48]	; (402638 <hsmci_send_clock+0x38>)
  402608:	685b      	ldr	r3, [r3, #4]
  40260a:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
  40260e:	6053      	str	r3, [r2, #4]
	// Write argument
	HSMCI->HSMCI_ARGR = 0;
  402610:	4b09      	ldr	r3, [pc, #36]	; (402638 <hsmci_send_clock+0x38>)
  402612:	2200      	movs	r2, #0
  402614:	611a      	str	r2, [r3, #16]
	// Write and start initialization command
	HSMCI->HSMCI_CMDR = HSMCI_CMDR_RSPTYP_NORESP
  402616:	4b08      	ldr	r3, [pc, #32]	; (402638 <hsmci_send_clock+0x38>)
  402618:	f44f 6210 	mov.w	r2, #2304	; 0x900
  40261c:	615a      	str	r2, [r3, #20]
			| HSMCI_CMDR_SPCMD_INIT
			| HSMCI_CMDR_OPDCMD_OPENDRAIN;
	// Wait end of initialization command
	while (!(HSMCI->HSMCI_SR & HSMCI_SR_CMDRDY));
  40261e:	bf00      	nop
  402620:	4b05      	ldr	r3, [pc, #20]	; (402638 <hsmci_send_clock+0x38>)
  402622:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  402624:	f003 0301 	and.w	r3, r3, #1
  402628:	2b00      	cmp	r3, #0
  40262a:	d0f9      	beq.n	402620 <hsmci_send_clock+0x20>
}
  40262c:	bf00      	nop
  40262e:	46bd      	mov	sp, r7
  402630:	f85d 7b04 	ldr.w	r7, [sp], #4
  402634:	4770      	bx	lr
  402636:	bf00      	nop
  402638:	40080000 	.word	0x40080000

0040263c <hsmci_send_cmd>:

bool hsmci_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
  40263c:	b580      	push	{r7, lr}
  40263e:	b082      	sub	sp, #8
  402640:	af00      	add	r7, sp, #0
  402642:	6078      	str	r0, [r7, #4]
  402644:	6039      	str	r1, [r7, #0]
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  402646:	4a0c      	ldr	r2, [pc, #48]	; (402678 <hsmci_send_cmd+0x3c>)
  402648:	4b0b      	ldr	r3, [pc, #44]	; (402678 <hsmci_send_cmd+0x3c>)
  40264a:	685b      	ldr	r3, [r3, #4]
  40264c:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
  402650:	6053      	str	r3, [r2, #4]
	// Disable DMA for HSMCI
	HSMCI->HSMCI_DMA = 0;
#endif
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
  402652:	4a09      	ldr	r2, [pc, #36]	; (402678 <hsmci_send_cmd+0x3c>)
  402654:	4b08      	ldr	r3, [pc, #32]	; (402678 <hsmci_send_cmd+0x3c>)
  402656:	685b      	ldr	r3, [r3, #4]
  402658:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
  40265c:	6053      	str	r3, [r2, #4]
#ifdef HSMCI_DMA_DMAEN
	// Disable DMA for HSMCI
	HSMCI->HSMCI_DMA = 0;
#endif
#endif
	HSMCI->HSMCI_BLKR = 0;
  40265e:	4b06      	ldr	r3, [pc, #24]	; (402678 <hsmci_send_cmd+0x3c>)
  402660:	2200      	movs	r2, #0
  402662:	619a      	str	r2, [r3, #24]
	return hsmci_send_cmd_execute(0, cmd, arg);
  402664:	683a      	ldr	r2, [r7, #0]
  402666:	6879      	ldr	r1, [r7, #4]
  402668:	2000      	movs	r0, #0
  40266a:	4b04      	ldr	r3, [pc, #16]	; (40267c <hsmci_send_cmd+0x40>)
  40266c:	4798      	blx	r3
  40266e:	4603      	mov	r3, r0
}
  402670:	4618      	mov	r0, r3
  402672:	3708      	adds	r7, #8
  402674:	46bd      	mov	sp, r7
  402676:	bd80      	pop	{r7, pc}
  402678:	40080000 	.word	0x40080000
  40267c:	004023f9 	.word	0x004023f9

00402680 <hsmci_get_response>:

uint32_t hsmci_get_response(void)
{
  402680:	b480      	push	{r7}
  402682:	af00      	add	r7, sp, #0
	return HSMCI->HSMCI_RSPR[0];
  402684:	4b03      	ldr	r3, [pc, #12]	; (402694 <hsmci_get_response+0x14>)
  402686:	6a1b      	ldr	r3, [r3, #32]
}
  402688:	4618      	mov	r0, r3
  40268a:	46bd      	mov	sp, r7
  40268c:	f85d 7b04 	ldr.w	r7, [sp], #4
  402690:	4770      	bx	lr
  402692:	bf00      	nop
  402694:	40080000 	.word	0x40080000

00402698 <hsmci_get_response_128>:

void hsmci_get_response_128(uint8_t* response)
{
  402698:	b480      	push	{r7}
  40269a:	b085      	sub	sp, #20
  40269c:	af00      	add	r7, sp, #0
  40269e:	6078      	str	r0, [r7, #4]
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
  4026a0:	2300      	movs	r3, #0
  4026a2:	73fb      	strb	r3, [r7, #15]
  4026a4:	e024      	b.n	4026f0 <hsmci_get_response_128+0x58>
		response_32 = HSMCI->HSMCI_RSPR[0];
  4026a6:	4b17      	ldr	r3, [pc, #92]	; (402704 <hsmci_get_response_128+0x6c>)
  4026a8:	6a1b      	ldr	r3, [r3, #32]
  4026aa:	60bb      	str	r3, [r7, #8]
		*response = (response_32 >> 24) & 0xFF;
  4026ac:	68bb      	ldr	r3, [r7, #8]
  4026ae:	0e1b      	lsrs	r3, r3, #24
  4026b0:	b2da      	uxtb	r2, r3
  4026b2:	687b      	ldr	r3, [r7, #4]
  4026b4:	701a      	strb	r2, [r3, #0]
		response++;
  4026b6:	687b      	ldr	r3, [r7, #4]
  4026b8:	3301      	adds	r3, #1
  4026ba:	607b      	str	r3, [r7, #4]
		*response = (response_32 >> 16) & 0xFF;
  4026bc:	68bb      	ldr	r3, [r7, #8]
  4026be:	0c1b      	lsrs	r3, r3, #16
  4026c0:	b2da      	uxtb	r2, r3
  4026c2:	687b      	ldr	r3, [r7, #4]
  4026c4:	701a      	strb	r2, [r3, #0]
		response++;
  4026c6:	687b      	ldr	r3, [r7, #4]
  4026c8:	3301      	adds	r3, #1
  4026ca:	607b      	str	r3, [r7, #4]
		*response = (response_32 >>  8) & 0xFF;
  4026cc:	68bb      	ldr	r3, [r7, #8]
  4026ce:	0a1b      	lsrs	r3, r3, #8
  4026d0:	b2da      	uxtb	r2, r3
  4026d2:	687b      	ldr	r3, [r7, #4]
  4026d4:	701a      	strb	r2, [r3, #0]
		response++;
  4026d6:	687b      	ldr	r3, [r7, #4]
  4026d8:	3301      	adds	r3, #1
  4026da:	607b      	str	r3, [r7, #4]
		*response = (response_32 >>  0) & 0xFF;
  4026dc:	68bb      	ldr	r3, [r7, #8]
  4026de:	b2da      	uxtb	r2, r3
  4026e0:	687b      	ldr	r3, [r7, #4]
  4026e2:	701a      	strb	r2, [r3, #0]
		response++;
  4026e4:	687b      	ldr	r3, [r7, #4]
  4026e6:	3301      	adds	r3, #1
  4026e8:	607b      	str	r3, [r7, #4]
	for (uint8_t i = 0; i < 4; i++) {
  4026ea:	7bfb      	ldrb	r3, [r7, #15]
  4026ec:	3301      	adds	r3, #1
  4026ee:	73fb      	strb	r3, [r7, #15]
  4026f0:	7bfb      	ldrb	r3, [r7, #15]
  4026f2:	2b03      	cmp	r3, #3
  4026f4:	d9d7      	bls.n	4026a6 <hsmci_get_response_128+0xe>
	}
}
  4026f6:	bf00      	nop
  4026f8:	3714      	adds	r7, #20
  4026fa:	46bd      	mov	sp, r7
  4026fc:	f85d 7b04 	ldr.w	r7, [sp], #4
  402700:	4770      	bx	lr
  402702:	bf00      	nop
  402704:	40080000 	.word	0x40080000

00402708 <hsmci_adtc_start>:

bool hsmci_adtc_start(sdmmc_cmd_def_t cmd, uint32_t arg, uint16_t block_size, uint16_t nb_block, bool access_block)
{
  402708:	b580      	push	{r7, lr}
  40270a:	b086      	sub	sp, #24
  40270c:	af00      	add	r7, sp, #0
  40270e:	60f8      	str	r0, [r7, #12]
  402710:	60b9      	str	r1, [r7, #8]
  402712:	4611      	mov	r1, r2
  402714:	461a      	mov	r2, r3
  402716:	460b      	mov	r3, r1
  402718:	80fb      	strh	r3, [r7, #6]
  40271a:	4613      	mov	r3, r2
  40271c:	80bb      	strh	r3, [r7, #4]
		HSMCI->HSMCI_DMA = 0;
	}
#endif

#ifdef HSMCI_MR_PDCMODE
	if (access_block) {
  40271e:	f897 3020 	ldrb.w	r3, [r7, #32]
  402722:	2b00      	cmp	r3, #0
  402724:	d006      	beq.n	402734 <hsmci_adtc_start+0x2c>
		// Enable PDC for HSMCI
		HSMCI->HSMCI_MR |= HSMCI_MR_PDCMODE;
  402726:	4a3d      	ldr	r2, [pc, #244]	; (40281c <hsmci_adtc_start+0x114>)
  402728:	4b3c      	ldr	r3, [pc, #240]	; (40281c <hsmci_adtc_start+0x114>)
  40272a:	685b      	ldr	r3, [r3, #4]
  40272c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  402730:	6053      	str	r3, [r2, #4]
  402732:	e005      	b.n	402740 <hsmci_adtc_start+0x38>
	} else {
		// Disable PDC for HSMCI
		HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
  402734:	4a39      	ldr	r2, [pc, #228]	; (40281c <hsmci_adtc_start+0x114>)
  402736:	4b39      	ldr	r3, [pc, #228]	; (40281c <hsmci_adtc_start+0x114>)
  402738:	685b      	ldr	r3, [r3, #4]
  40273a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
  40273e:	6053      	str	r3, [r2, #4]
#endif
#endif
	// Enabling Read/Write Proof allows to stop the HSMCI Clock during
	// read/write  access if the internal FIFO is full.
	// This will guarantee data integrity, not bandwidth.
	HSMCI->HSMCI_MR |= HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF;
  402740:	4a36      	ldr	r2, [pc, #216]	; (40281c <hsmci_adtc_start+0x114>)
  402742:	4b36      	ldr	r3, [pc, #216]	; (40281c <hsmci_adtc_start+0x114>)
  402744:	685b      	ldr	r3, [r3, #4]
  402746:	f443 53c0 	orr.w	r3, r3, #6144	; 0x1800
  40274a:	6053      	str	r3, [r2, #4]
	// Force byte transfer if needed
	if (block_size & 0x3) {
  40274c:	88fb      	ldrh	r3, [r7, #6]
  40274e:	f003 0303 	and.w	r3, r3, #3
  402752:	2b00      	cmp	r3, #0
  402754:	d006      	beq.n	402764 <hsmci_adtc_start+0x5c>
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
  402756:	4a31      	ldr	r2, [pc, #196]	; (40281c <hsmci_adtc_start+0x114>)
  402758:	4b30      	ldr	r3, [pc, #192]	; (40281c <hsmci_adtc_start+0x114>)
  40275a:	685b      	ldr	r3, [r3, #4]
  40275c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
  402760:	6053      	str	r3, [r2, #4]
  402762:	e005      	b.n	402770 <hsmci_adtc_start+0x68>
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  402764:	4a2d      	ldr	r2, [pc, #180]	; (40281c <hsmci_adtc_start+0x114>)
  402766:	4b2d      	ldr	r3, [pc, #180]	; (40281c <hsmci_adtc_start+0x114>)
  402768:	685b      	ldr	r3, [r3, #4]
  40276a:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  40276e:	6053      	str	r3, [r2, #4]
	}

	if (cmd & SDMMC_CMD_WRITE) {
  402770:	68fb      	ldr	r3, [r7, #12]
  402772:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
  402776:	2b00      	cmp	r3, #0
  402778:	d003      	beq.n	402782 <hsmci_adtc_start+0x7a>
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_WRITE;
  40277a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
  40277e:	617b      	str	r3, [r7, #20]
  402780:	e002      	b.n	402788 <hsmci_adtc_start+0x80>
	} else {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_READ;
  402782:	f44f 23a0 	mov.w	r3, #327680	; 0x50000
  402786:	617b      	str	r3, [r7, #20]
	}

	if (cmd & SDMMC_CMD_SDIO_BYTE) {
  402788:	68fb      	ldr	r3, [r7, #12]
  40278a:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
  40278e:	2b00      	cmp	r3, #0
  402790:	d009      	beq.n	4027a6 <hsmci_adtc_start+0x9e>
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
  402792:	697b      	ldr	r3, [r7, #20]
  402794:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
  402798:	617b      	str	r3, [r7, #20]
			// Value 0 corresponds to a 512-byte transfer
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
  40279a:	4a20      	ldr	r2, [pc, #128]	; (40281c <hsmci_adtc_start+0x114>)
  40279c:	88fb      	ldrh	r3, [r7, #6]
  40279e:	f3c3 0308 	ubfx	r3, r3, #0, #9
  4027a2:	6193      	str	r3, [r2, #24]
  4027a4:	e027      	b.n	4027f6 <hsmci_adtc_start+0xee>
	} else {
		HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BLKLEN_Pos) |
  4027a6:	491d      	ldr	r1, [pc, #116]	; (40281c <hsmci_adtc_start+0x114>)
  4027a8:	88fb      	ldrh	r3, [r7, #6]
  4027aa:	041a      	lsls	r2, r3, #16
				(nb_block << HSMCI_BLKR_BCNT_Pos);
  4027ac:	88bb      	ldrh	r3, [r7, #4]
		HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BLKLEN_Pos) |
  4027ae:	4313      	orrs	r3, r2
  4027b0:	618b      	str	r3, [r1, #24]
		if (cmd & SDMMC_CMD_SDIO_BLOCK) {
  4027b2:	68fb      	ldr	r3, [r7, #12]
  4027b4:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  4027b8:	2b00      	cmp	r3, #0
  4027ba:	d004      	beq.n	4027c6 <hsmci_adtc_start+0xbe>
			cmdr |= HSMCI_CMDR_TRTYP_BLOCK;
  4027bc:	697b      	ldr	r3, [r7, #20]
  4027be:	f443 1320 	orr.w	r3, r3, #2621440	; 0x280000
  4027c2:	617b      	str	r3, [r7, #20]
  4027c4:	e017      	b.n	4027f6 <hsmci_adtc_start+0xee>
		} else if (cmd & SDMMC_CMD_STREAM) {
  4027c6:	68fb      	ldr	r3, [r7, #12]
  4027c8:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
  4027cc:	2b00      	cmp	r3, #0
  4027ce:	d004      	beq.n	4027da <hsmci_adtc_start+0xd2>
			cmdr |= HSMCI_CMDR_TRTYP_STREAM;
  4027d0:	697b      	ldr	r3, [r7, #20]
  4027d2:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  4027d6:	617b      	str	r3, [r7, #20]
  4027d8:	e00d      	b.n	4027f6 <hsmci_adtc_start+0xee>
		} else if (cmd & SDMMC_CMD_SINGLE_BLOCK) {
  4027da:	68fb      	ldr	r3, [r7, #12]
  4027dc:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
  4027e0:	2b00      	cmp	r3, #0
  4027e2:	d108      	bne.n	4027f6 <hsmci_adtc_start+0xee>
			cmdr |= HSMCI_CMDR_TRTYP_SINGLE;
		} else if (cmd & SDMMC_CMD_MULTI_BLOCK) {
  4027e4:	68fb      	ldr	r3, [r7, #12]
  4027e6:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
  4027ea:	2b00      	cmp	r3, #0
  4027ec:	d003      	beq.n	4027f6 <hsmci_adtc_start+0xee>
			cmdr |= HSMCI_CMDR_TRTYP_MULTIPLE;
  4027ee:	697b      	ldr	r3, [r7, #20]
  4027f0:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
  4027f4:	617b      	str	r3, [r7, #20]
		} else {
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
  4027f6:	4b0a      	ldr	r3, [pc, #40]	; (402820 <hsmci_adtc_start+0x118>)
  4027f8:	2200      	movs	r2, #0
  4027fa:	601a      	str	r2, [r3, #0]
	hsmci_block_size = block_size;
  4027fc:	4a09      	ldr	r2, [pc, #36]	; (402824 <hsmci_adtc_start+0x11c>)
  4027fe:	88fb      	ldrh	r3, [r7, #6]
  402800:	8013      	strh	r3, [r2, #0]
	hsmci_nb_block = nb_block;
  402802:	4a09      	ldr	r2, [pc, #36]	; (402828 <hsmci_adtc_start+0x120>)
  402804:	88bb      	ldrh	r3, [r7, #4]
  402806:	8013      	strh	r3, [r2, #0]

	return hsmci_send_cmd_execute(cmdr, cmd, arg);
  402808:	68ba      	ldr	r2, [r7, #8]
  40280a:	68f9      	ldr	r1, [r7, #12]
  40280c:	6978      	ldr	r0, [r7, #20]
  40280e:	4b07      	ldr	r3, [pc, #28]	; (40282c <hsmci_adtc_start+0x124>)
  402810:	4798      	blx	r3
  402812:	4603      	mov	r3, r0
}
  402814:	4618      	mov	r0, r3
  402816:	3718      	adds	r7, #24
  402818:	46bd      	mov	sp, r7
  40281a:	bd80      	pop	{r7, pc}
  40281c:	40080000 	.word	0x40080000
  402820:	20000484 	.word	0x20000484
  402824:	20000488 	.word	0x20000488
  402828:	2000048a 	.word	0x2000048a
  40282c:	004023f9 	.word	0x004023f9

00402830 <hsmci_read_word>:
{
	return hsmci_send_cmd_execute(HSMCI_CMDR_TRCMD_STOP_DATA, cmd, arg);
}

bool hsmci_read_word(uint32_t* value)
{
  402830:	b580      	push	{r7, lr}
  402832:	b084      	sub	sp, #16
  402834:	af00      	add	r7, sp, #0
  402836:	6078      	str	r0, [r7, #4]

	Assert(((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos);

	// Wait data available
	do {
		sr = HSMCI->HSMCI_SR;
  402838:	4b1e      	ldr	r3, [pc, #120]	; (4028b4 <hsmci_read_word+0x84>)
  40283a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  40283c:	60fb      	str	r3, [r7, #12]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  40283e:	68fa      	ldr	r2, [r7, #12]
  402840:	4b1d      	ldr	r3, [pc, #116]	; (4028b8 <hsmci_read_word+0x88>)
  402842:	4013      	ands	r3, r2
  402844:	2b00      	cmp	r3, #0
  402846:	d003      	beq.n	402850 <hsmci_read_word+0x20>
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
  402848:	4b1c      	ldr	r3, [pc, #112]	; (4028bc <hsmci_read_word+0x8c>)
  40284a:	4798      	blx	r3
			return false;
  40284c:	2300      	movs	r3, #0
  40284e:	e02c      	b.n	4028aa <hsmci_read_word+0x7a>
		}
	} while (!(sr & HSMCI_SR_RXRDY));
  402850:	68fb      	ldr	r3, [r7, #12]
  402852:	f003 0302 	and.w	r3, r3, #2
  402856:	2b00      	cmp	r3, #0
  402858:	d0ee      	beq.n	402838 <hsmci_read_word+0x8>

	// Read data
	*value = HSMCI->HSMCI_RDR;
  40285a:	4b16      	ldr	r3, [pc, #88]	; (4028b4 <hsmci_read_word+0x84>)
  40285c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  40285e:	687b      	ldr	r3, [r7, #4]
  402860:	601a      	str	r2, [r3, #0]
	hsmci_transfert_pos += 4;
  402862:	4b17      	ldr	r3, [pc, #92]	; (4028c0 <hsmci_read_word+0x90>)
  402864:	681b      	ldr	r3, [r3, #0]
  402866:	3304      	adds	r3, #4
  402868:	4a15      	ldr	r2, [pc, #84]	; (4028c0 <hsmci_read_word+0x90>)
  40286a:	6013      	str	r3, [r2, #0]
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
  40286c:	4b15      	ldr	r3, [pc, #84]	; (4028c4 <hsmci_read_word+0x94>)
  40286e:	881b      	ldrh	r3, [r3, #0]
  402870:	461a      	mov	r2, r3
  402872:	4b15      	ldr	r3, [pc, #84]	; (4028c8 <hsmci_read_word+0x98>)
  402874:	881b      	ldrh	r3, [r3, #0]
  402876:	fb03 f202 	mul.w	r2, r3, r2
  40287a:	4b11      	ldr	r3, [pc, #68]	; (4028c0 <hsmci_read_word+0x90>)
  40287c:	681b      	ldr	r3, [r3, #0]
  40287e:	429a      	cmp	r2, r3
  402880:	d901      	bls.n	402886 <hsmci_read_word+0x56>
		return true;
  402882:	2301      	movs	r3, #1
  402884:	e011      	b.n	4028aa <hsmci_read_word+0x7a>
	}

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI
	do {
		sr = HSMCI->HSMCI_SR;
  402886:	4b0b      	ldr	r3, [pc, #44]	; (4028b4 <hsmci_read_word+0x84>)
  402888:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  40288a:	60fb      	str	r3, [r7, #12]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  40288c:	68fa      	ldr	r2, [r7, #12]
  40288e:	4b0a      	ldr	r3, [pc, #40]	; (4028b8 <hsmci_read_word+0x88>)
  402890:	4013      	ands	r3, r2
  402892:	2b00      	cmp	r3, #0
  402894:	d003      	beq.n	40289e <hsmci_read_word+0x6e>
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
  402896:	4b09      	ldr	r3, [pc, #36]	; (4028bc <hsmci_read_word+0x8c>)
  402898:	4798      	blx	r3
			return false;
  40289a:	2300      	movs	r3, #0
  40289c:	e005      	b.n	4028aa <hsmci_read_word+0x7a>
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
  40289e:	68fb      	ldr	r3, [r7, #12]
  4028a0:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
  4028a4:	2b00      	cmp	r3, #0
  4028a6:	d0ee      	beq.n	402886 <hsmci_read_word+0x56>
	return true;
  4028a8:	2301      	movs	r3, #1
}
  4028aa:	4618      	mov	r0, r3
  4028ac:	3710      	adds	r7, #16
  4028ae:	46bd      	mov	sp, r7
  4028b0:	bd80      	pop	{r7, pc}
  4028b2:	bf00      	nop
  4028b4:	40080000 	.word	0x40080000
  4028b8:	c0600000 	.word	0xc0600000
  4028bc:	004022a5 	.word	0x004022a5
  4028c0:	20000484 	.word	0x20000484
  4028c4:	20000488 	.word	0x20000488
  4028c8:	2000048a 	.word	0x2000048a

004028cc <hsmci_start_read_blocks>:
}
#endif // HSMCI_SR_DMADONE

#ifdef HSMCI_MR_PDCMODE
bool hsmci_start_read_blocks(void *dest, uint16_t nb_block)
{
  4028cc:	b480      	push	{r7}
  4028ce:	b085      	sub	sp, #20
  4028d0:	af00      	add	r7, sp, #0
  4028d2:	6078      	str	r0, [r7, #4]
  4028d4:	460b      	mov	r3, r1
  4028d6:	807b      	strh	r3, [r7, #2]
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  4028d8:	887b      	ldrh	r3, [r7, #2]
  4028da:	4a21      	ldr	r2, [pc, #132]	; (402960 <hsmci_start_read_blocks+0x94>)
  4028dc:	8812      	ldrh	r2, [r2, #0]
  4028de:	fb02 f303 	mul.w	r3, r2, r3
  4028e2:	60fb      	str	r3, [r7, #12]
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_RCR_RXCTR_Msk >> PERIPH_RCR_RXCTR_Pos));

	// Handle unaligned memory address
	if (((uint32_t)dest & 0x3) || (hsmci_block_size & 0x3)) {
  4028e4:	687b      	ldr	r3, [r7, #4]
  4028e6:	f003 0303 	and.w	r3, r3, #3
  4028ea:	2b00      	cmp	r3, #0
  4028ec:	d105      	bne.n	4028fa <hsmci_start_read_blocks+0x2e>
  4028ee:	4b1c      	ldr	r3, [pc, #112]	; (402960 <hsmci_start_read_blocks+0x94>)
  4028f0:	881b      	ldrh	r3, [r3, #0]
  4028f2:	f003 0303 	and.w	r3, r3, #3
  4028f6:	2b00      	cmp	r3, #0
  4028f8:	d006      	beq.n	402908 <hsmci_start_read_blocks+0x3c>
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
  4028fa:	4a1a      	ldr	r2, [pc, #104]	; (402964 <hsmci_start_read_blocks+0x98>)
  4028fc:	4b19      	ldr	r3, [pc, #100]	; (402964 <hsmci_start_read_blocks+0x98>)
  4028fe:	685b      	ldr	r3, [r3, #4]
  402900:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
  402904:	6053      	str	r3, [r2, #4]
  402906:	e005      	b.n	402914 <hsmci_start_read_blocks+0x48>
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  402908:	4a16      	ldr	r2, [pc, #88]	; (402964 <hsmci_start_read_blocks+0x98>)
  40290a:	4b16      	ldr	r3, [pc, #88]	; (402964 <hsmci_start_read_blocks+0x98>)
  40290c:	685b      	ldr	r3, [r3, #4]
  40290e:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
  402912:	6053      	str	r3, [r2, #4]
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
  402914:	4a13      	ldr	r2, [pc, #76]	; (402964 <hsmci_start_read_blocks+0x98>)
  402916:	687b      	ldr	r3, [r7, #4]
  402918:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  40291c:	4a11      	ldr	r2, [pc, #68]	; (402964 <hsmci_start_read_blocks+0x98>)
  40291e:	4b11      	ldr	r3, [pc, #68]	; (402964 <hsmci_start_read_blocks+0x98>)
  402920:	685b      	ldr	r3, [r3, #4]
  402922:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
			nb_data : nb_data / 4;
  402926:	2b00      	cmp	r3, #0
  402928:	d102      	bne.n	402930 <hsmci_start_read_blocks+0x64>
  40292a:	68fb      	ldr	r3, [r7, #12]
  40292c:	089b      	lsrs	r3, r3, #2
  40292e:	e000      	b.n	402932 <hsmci_start_read_blocks+0x66>
  402930:	68fb      	ldr	r3, [r7, #12]
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  402932:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
	HSMCI->HSMCI_RNCR = 0;
  402936:	4b0b      	ldr	r3, [pc, #44]	; (402964 <hsmci_start_read_blocks+0x98>)
  402938:	2200      	movs	r2, #0
  40293a:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTEN;
  40293e:	4b09      	ldr	r3, [pc, #36]	; (402964 <hsmci_start_read_blocks+0x98>)
  402940:	2201      	movs	r2, #1
  402942:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
	hsmci_transfert_pos += nb_data;
  402946:	4b08      	ldr	r3, [pc, #32]	; (402968 <hsmci_start_read_blocks+0x9c>)
  402948:	681a      	ldr	r2, [r3, #0]
  40294a:	68fb      	ldr	r3, [r7, #12]
  40294c:	4413      	add	r3, r2
  40294e:	4a06      	ldr	r2, [pc, #24]	; (402968 <hsmci_start_read_blocks+0x9c>)
  402950:	6013      	str	r3, [r2, #0]
	return true;
  402952:	2301      	movs	r3, #1
}
  402954:	4618      	mov	r0, r3
  402956:	3714      	adds	r7, #20
  402958:	46bd      	mov	sp, r7
  40295a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40295e:	4770      	bx	lr
  402960:	20000488 	.word	0x20000488
  402964:	40080000 	.word	0x40080000
  402968:	20000484 	.word	0x20000484

0040296c <hsmci_wait_end_of_read_blocks>:

bool hsmci_wait_end_of_read_blocks(void)
{
  40296c:	b580      	push	{r7, lr}
  40296e:	b082      	sub	sp, #8
  402970:	af00      	add	r7, sp, #0
	uint32_t sr;
	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  402972:	4b1c      	ldr	r3, [pc, #112]	; (4029e4 <hsmci_wait_end_of_read_blocks+0x78>)
  402974:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  402976:	607b      	str	r3, [r7, #4]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  402978:	687a      	ldr	r2, [r7, #4]
  40297a:	4b1b      	ldr	r3, [pc, #108]	; (4029e8 <hsmci_wait_end_of_read_blocks+0x7c>)
  40297c:	4013      	ands	r3, r2
  40297e:	2b00      	cmp	r3, #0
  402980:	d008      	beq.n	402994 <hsmci_wait_end_of_read_blocks+0x28>
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x error\n\r",
					__func__, sr);
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
  402982:	4b18      	ldr	r3, [pc, #96]	; (4029e4 <hsmci_wait_end_of_read_blocks+0x78>)
  402984:	f240 2202 	movw	r2, #514	; 0x202
  402988:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
			hsmci_reset();
  40298c:	4b17      	ldr	r3, [pc, #92]	; (4029ec <hsmci_wait_end_of_read_blocks+0x80>)
  40298e:	4798      	blx	r3
			return false;
  402990:	2300      	movs	r3, #0
  402992:	e023      	b.n	4029dc <hsmci_wait_end_of_read_blocks+0x70>
		}

	} while (!(sr & HSMCI_SR_RXBUFF));
  402994:	687b      	ldr	r3, [r7, #4]
  402996:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
  40299a:	2b00      	cmp	r3, #0
  40299c:	d0e9      	beq.n	402972 <hsmci_wait_end_of_read_blocks+0x6>

	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
  40299e:	4b14      	ldr	r3, [pc, #80]	; (4029f0 <hsmci_wait_end_of_read_blocks+0x84>)
  4029a0:	881b      	ldrh	r3, [r3, #0]
  4029a2:	461a      	mov	r2, r3
  4029a4:	4b13      	ldr	r3, [pc, #76]	; (4029f4 <hsmci_wait_end_of_read_blocks+0x88>)
  4029a6:	881b      	ldrh	r3, [r3, #0]
  4029a8:	fb03 f202 	mul.w	r2, r3, r2
  4029ac:	4b12      	ldr	r3, [pc, #72]	; (4029f8 <hsmci_wait_end_of_read_blocks+0x8c>)
  4029ae:	681b      	ldr	r3, [r3, #0]
  4029b0:	429a      	cmp	r2, r3
  4029b2:	d901      	bls.n	4029b8 <hsmci_wait_end_of_read_blocks+0x4c>
		return true;
  4029b4:	2301      	movs	r3, #1
  4029b6:	e011      	b.n	4029dc <hsmci_wait_end_of_read_blocks+0x70>
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  4029b8:	4b0a      	ldr	r3, [pc, #40]	; (4029e4 <hsmci_wait_end_of_read_blocks+0x78>)
  4029ba:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4029bc:	607b      	str	r3, [r7, #4]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  4029be:	687a      	ldr	r2, [r7, #4]
  4029c0:	4b09      	ldr	r3, [pc, #36]	; (4029e8 <hsmci_wait_end_of_read_blocks+0x7c>)
  4029c2:	4013      	ands	r3, r2
  4029c4:	2b00      	cmp	r3, #0
  4029c6:	d003      	beq.n	4029d0 <hsmci_wait_end_of_read_blocks+0x64>
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
  4029c8:	4b08      	ldr	r3, [pc, #32]	; (4029ec <hsmci_wait_end_of_read_blocks+0x80>)
  4029ca:	4798      	blx	r3
			return false;
  4029cc:	2300      	movs	r3, #0
  4029ce:	e005      	b.n	4029dc <hsmci_wait_end_of_read_blocks+0x70>
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
  4029d0:	687b      	ldr	r3, [r7, #4]
  4029d2:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
  4029d6:	2b00      	cmp	r3, #0
  4029d8:	d0ee      	beq.n	4029b8 <hsmci_wait_end_of_read_blocks+0x4c>
	return true;
  4029da:	2301      	movs	r3, #1
}
  4029dc:	4618      	mov	r0, r3
  4029de:	3708      	adds	r7, #8
  4029e0:	46bd      	mov	sp, r7
  4029e2:	bd80      	pop	{r7, pc}
  4029e4:	40080000 	.word	0x40080000
  4029e8:	c0600000 	.word	0xc0600000
  4029ec:	004022a5 	.word	0x004022a5
  4029f0:	20000488 	.word	0x20000488
  4029f4:	2000048a 	.word	0x2000048a
  4029f8:	20000484 	.word	0x20000484

004029fc <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  4029fc:	e7fe      	b.n	4029fc <Dummy_Handler>
	...

00402a00 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  402a00:	b500      	push	{lr}
  402a02:	b083      	sub	sp, #12

	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
  402a04:	4b25      	ldr	r3, [pc, #148]	; (402a9c <Reset_Handler+0x9c>)
  402a06:	4a26      	ldr	r2, [pc, #152]	; (402aa0 <Reset_Handler+0xa0>)
  402a08:	429a      	cmp	r2, r3
  402a0a:	d010      	beq.n	402a2e <Reset_Handler+0x2e>
		for (; pDest < &_erelocate;) {
  402a0c:	4b25      	ldr	r3, [pc, #148]	; (402aa4 <Reset_Handler+0xa4>)
  402a0e:	4a23      	ldr	r2, [pc, #140]	; (402a9c <Reset_Handler+0x9c>)
  402a10:	429a      	cmp	r2, r3
  402a12:	d20c      	bcs.n	402a2e <Reset_Handler+0x2e>
  402a14:	3b01      	subs	r3, #1
  402a16:	1a9b      	subs	r3, r3, r2
  402a18:	f023 0303 	bic.w	r3, r3, #3
  402a1c:	3304      	adds	r3, #4
  402a1e:	4413      	add	r3, r2
  402a20:	491f      	ldr	r1, [pc, #124]	; (402aa0 <Reset_Handler+0xa0>)
			*pDest++ = *pSrc++;
  402a22:	f851 0b04 	ldr.w	r0, [r1], #4
  402a26:	f842 0b04 	str.w	r0, [r2], #4
		for (; pDest < &_erelocate;) {
  402a2a:	429a      	cmp	r2, r3
  402a2c:	d1f9      	bne.n	402a22 <Reset_Handler+0x22>
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  402a2e:	4b1e      	ldr	r3, [pc, #120]	; (402aa8 <Reset_Handler+0xa8>)
  402a30:	4a1e      	ldr	r2, [pc, #120]	; (402aac <Reset_Handler+0xac>)
  402a32:	429a      	cmp	r2, r3
  402a34:	d20a      	bcs.n	402a4c <Reset_Handler+0x4c>
  402a36:	3b01      	subs	r3, #1
  402a38:	1a9b      	subs	r3, r3, r2
  402a3a:	f023 0303 	bic.w	r3, r3, #3
  402a3e:	3304      	adds	r3, #4
  402a40:	4413      	add	r3, r2
		*pDest++ = 0;
  402a42:	2100      	movs	r1, #0
  402a44:	f842 1b04 	str.w	r1, [r2], #4
	for (pDest = &_szero; pDest < &_ezero;) {
  402a48:	4293      	cmp	r3, r2
  402a4a:	d1fb      	bne.n	402a44 <Reset_Handler+0x44>
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) & _sfixed;
	SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  402a4c:	4a18      	ldr	r2, [pc, #96]	; (402ab0 <Reset_Handler+0xb0>)
  402a4e:	4b19      	ldr	r3, [pc, #100]	; (402ab4 <Reset_Handler+0xb4>)
  402a50:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  402a54:	6093      	str	r3, [r2, #8]
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
  402a56:	f3ef 8310 	mrs	r3, PRIMASK
static volatile uint32_t cpu_irq_critical_section_counter;
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = cpu_irq_is_enabled();
  402a5a:	fab3 f383 	clz	r3, r3
  402a5e:	095b      	lsrs	r3, r3, #5
  402a60:	9301      	str	r3, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
  402a62:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
  402a64:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
  402a68:	2200      	movs	r2, #0
  402a6a:	4b13      	ldr	r3, [pc, #76]	; (402ab8 <Reset_Handler+0xb8>)
  402a6c:	701a      	strb	r2, [r3, #0]
	return flags;
  402a6e:	9901      	ldr	r1, [sp, #4]
 */
__always_inline static void fpu_enable(void)
{
	irqflags_t flags;
	flags = cpu_irq_save();
	REG_CPACR |=  (0xFu << 20);
  402a70:	4a12      	ldr	r2, [pc, #72]	; (402abc <Reset_Handler+0xbc>)
  402a72:	6813      	ldr	r3, [r2, #0]
  402a74:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
  402a78:	6013      	str	r3, [r2, #0]
  __ASM volatile ("dsb 0xF":::"memory");
  402a7a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  402a7e:	f3bf 8f6f 	isb	sy
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
  402a82:	b129      	cbz	r1, 402a90 <Reset_Handler+0x90>
		cpu_irq_enable();
  402a84:	2201      	movs	r2, #1
  402a86:	4b0c      	ldr	r3, [pc, #48]	; (402ab8 <Reset_Handler+0xb8>)
  402a88:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("dmb 0xF":::"memory");
  402a8a:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  402a8e:	b662      	cpsie	i
#if __FPU_USED
	fpu_enable();
#endif

	/* Initialize the C library */
	__libc_init_array();
  402a90:	4b0b      	ldr	r3, [pc, #44]	; (402ac0 <Reset_Handler+0xc0>)
  402a92:	4798      	blx	r3

	/* Branch to main function */
	main();
  402a94:	4b0b      	ldr	r3, [pc, #44]	; (402ac4 <Reset_Handler+0xc4>)
  402a96:	4798      	blx	r3
  402a98:	e7fe      	b.n	402a98 <Reset_Handler+0x98>
  402a9a:	bf00      	nop
  402a9c:	20000000 	.word	0x20000000
  402aa0:	004040f4 	.word	0x004040f4
  402aa4:	2000043c 	.word	0x2000043c
  402aa8:	20000558 	.word	0x20000558
  402aac:	2000043c 	.word	0x2000043c
  402ab0:	e000ed00 	.word	0xe000ed00
  402ab4:	00400000 	.word	0x00400000
  402ab8:	2000000a 	.word	0x2000000a
  402abc:	e000ed88 	.word	0xe000ed88
  402ac0:	0040371d 	.word	0x0040371d
  402ac4:	00402c49 	.word	0x00402c49

00402ac8 <SystemCoreClockUpdate>:
}

void SystemCoreClockUpdate( void )
{
	/* Determine clock frequency according to clock register values */
	switch (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) {
  402ac8:	4b3b      	ldr	r3, [pc, #236]	; (402bb8 <SystemCoreClockUpdate+0xf0>)
  402aca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  402acc:	f003 0303 	and.w	r3, r3, #3
  402ad0:	2b01      	cmp	r3, #1
  402ad2:	d01d      	beq.n	402b10 <SystemCoreClockUpdate+0x48>
  402ad4:	b183      	cbz	r3, 402af8 <SystemCoreClockUpdate+0x30>
  402ad6:	2b02      	cmp	r3, #2
  402ad8:	d036      	beq.n	402b48 <SystemCoreClockUpdate+0x80>

	default:
		break;
	}

	if ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3) {
  402ada:	4b37      	ldr	r3, [pc, #220]	; (402bb8 <SystemCoreClockUpdate+0xf0>)
  402adc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  402ade:	f003 0370 	and.w	r3, r3, #112	; 0x70
  402ae2:	2b70      	cmp	r3, #112	; 0x70
  402ae4:	d05f      	beq.n	402ba6 <SystemCoreClockUpdate+0xde>
		SystemCoreClock /= 3U;
	} else {
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >>
  402ae6:	4b34      	ldr	r3, [pc, #208]	; (402bb8 <SystemCoreClockUpdate+0xf0>)
  402ae8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  402aea:	4934      	ldr	r1, [pc, #208]	; (402bbc <SystemCoreClockUpdate+0xf4>)
  402aec:	f3c2 1202 	ubfx	r2, r2, #4, #3
  402af0:	680b      	ldr	r3, [r1, #0]
  402af2:	40d3      	lsrs	r3, r2
  402af4:	600b      	str	r3, [r1, #0]
  402af6:	4770      	bx	lr
		if ( SUPC->SUPC_SR & SUPC_SR_OSCSEL ) {
  402af8:	4b31      	ldr	r3, [pc, #196]	; (402bc0 <SystemCoreClockUpdate+0xf8>)
  402afa:	695b      	ldr	r3, [r3, #20]
  402afc:	f013 0f80 	tst.w	r3, #128	; 0x80
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
  402b00:	bf14      	ite	ne
  402b02:	f44f 4200 	movne.w	r2, #32768	; 0x8000
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
  402b06:	f44f 42fa 	moveq.w	r2, #32000	; 0x7d00
  402b0a:	4b2c      	ldr	r3, [pc, #176]	; (402bbc <SystemCoreClockUpdate+0xf4>)
  402b0c:	601a      	str	r2, [r3, #0]
  402b0e:	e7e4      	b.n	402ada <SystemCoreClockUpdate+0x12>
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  402b10:	4b29      	ldr	r3, [pc, #164]	; (402bb8 <SystemCoreClockUpdate+0xf0>)
  402b12:	6a1b      	ldr	r3, [r3, #32]
  402b14:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
  402b18:	d003      	beq.n	402b22 <SystemCoreClockUpdate+0x5a>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
  402b1a:	4a2a      	ldr	r2, [pc, #168]	; (402bc4 <SystemCoreClockUpdate+0xfc>)
  402b1c:	4b27      	ldr	r3, [pc, #156]	; (402bbc <SystemCoreClockUpdate+0xf4>)
  402b1e:	601a      	str	r2, [r3, #0]
  402b20:	e7db      	b.n	402ada <SystemCoreClockUpdate+0x12>
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  402b22:	4a29      	ldr	r2, [pc, #164]	; (402bc8 <SystemCoreClockUpdate+0x100>)
  402b24:	4b25      	ldr	r3, [pc, #148]	; (402bbc <SystemCoreClockUpdate+0xf4>)
  402b26:	601a      	str	r2, [r3, #0]
			switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  402b28:	4b23      	ldr	r3, [pc, #140]	; (402bb8 <SystemCoreClockUpdate+0xf0>)
  402b2a:	6a1b      	ldr	r3, [r3, #32]
  402b2c:	f003 0370 	and.w	r3, r3, #112	; 0x70
  402b30:	2b10      	cmp	r3, #16
  402b32:	d005      	beq.n	402b40 <SystemCoreClockUpdate+0x78>
  402b34:	2b20      	cmp	r3, #32
  402b36:	d1d0      	bne.n	402ada <SystemCoreClockUpdate+0x12>
				SystemCoreClock *= 3U;
  402b38:	4a22      	ldr	r2, [pc, #136]	; (402bc4 <SystemCoreClockUpdate+0xfc>)
  402b3a:	4b20      	ldr	r3, [pc, #128]	; (402bbc <SystemCoreClockUpdate+0xf4>)
  402b3c:	601a      	str	r2, [r3, #0]
				break;
  402b3e:	e7cc      	b.n	402ada <SystemCoreClockUpdate+0x12>
				SystemCoreClock *= 2U;
  402b40:	4a22      	ldr	r2, [pc, #136]	; (402bcc <SystemCoreClockUpdate+0x104>)
  402b42:	4b1e      	ldr	r3, [pc, #120]	; (402bbc <SystemCoreClockUpdate+0xf4>)
  402b44:	601a      	str	r2, [r3, #0]
				break;
  402b46:	e7c8      	b.n	402ada <SystemCoreClockUpdate+0x12>
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  402b48:	4b1b      	ldr	r3, [pc, #108]	; (402bb8 <SystemCoreClockUpdate+0xf0>)
  402b4a:	6a1b      	ldr	r3, [r3, #32]
  402b4c:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
  402b50:	d016      	beq.n	402b80 <SystemCoreClockUpdate+0xb8>
			SystemCoreClock = CHIP_FREQ_XTAL_12M ;
  402b52:	4a1c      	ldr	r2, [pc, #112]	; (402bc4 <SystemCoreClockUpdate+0xfc>)
  402b54:	4b19      	ldr	r3, [pc, #100]	; (402bbc <SystemCoreClockUpdate+0xf4>)
  402b56:	601a      	str	r2, [r3, #0]
		if ((uint32_t) (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK)
  402b58:	4b17      	ldr	r3, [pc, #92]	; (402bb8 <SystemCoreClockUpdate+0xf0>)
  402b5a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  402b5c:	f003 0303 	and.w	r3, r3, #3
  402b60:	2b02      	cmp	r3, #2
  402b62:	d1ba      	bne.n	402ada <SystemCoreClockUpdate+0x12>
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> CKGR_PLLAR_MULA_Pos) + 1U);
  402b64:	4a14      	ldr	r2, [pc, #80]	; (402bb8 <SystemCoreClockUpdate+0xf0>)
  402b66:	6a91      	ldr	r1, [r2, #40]	; 0x28
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos));
  402b68:	6a92      	ldr	r2, [r2, #40]	; 0x28
  402b6a:	4814      	ldr	r0, [pc, #80]	; (402bbc <SystemCoreClockUpdate+0xf4>)
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> CKGR_PLLAR_MULA_Pos) + 1U);
  402b6c:	f3c1 410a 	ubfx	r1, r1, #16, #11
  402b70:	6803      	ldr	r3, [r0, #0]
  402b72:	fb01 3303 	mla	r3, r1, r3, r3
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos));
  402b76:	b2d2      	uxtb	r2, r2
  402b78:	fbb3 f3f2 	udiv	r3, r3, r2
  402b7c:	6003      	str	r3, [r0, #0]
  402b7e:	e7ac      	b.n	402ada <SystemCoreClockUpdate+0x12>
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  402b80:	4a11      	ldr	r2, [pc, #68]	; (402bc8 <SystemCoreClockUpdate+0x100>)
  402b82:	4b0e      	ldr	r3, [pc, #56]	; (402bbc <SystemCoreClockUpdate+0xf4>)
  402b84:	601a      	str	r2, [r3, #0]
			switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  402b86:	4b0c      	ldr	r3, [pc, #48]	; (402bb8 <SystemCoreClockUpdate+0xf0>)
  402b88:	6a1b      	ldr	r3, [r3, #32]
  402b8a:	f003 0370 	and.w	r3, r3, #112	; 0x70
  402b8e:	2b10      	cmp	r3, #16
  402b90:	d005      	beq.n	402b9e <SystemCoreClockUpdate+0xd6>
  402b92:	2b20      	cmp	r3, #32
  402b94:	d1e0      	bne.n	402b58 <SystemCoreClockUpdate+0x90>
				SystemCoreClock *= 3U;
  402b96:	4a0b      	ldr	r2, [pc, #44]	; (402bc4 <SystemCoreClockUpdate+0xfc>)
  402b98:	4b08      	ldr	r3, [pc, #32]	; (402bbc <SystemCoreClockUpdate+0xf4>)
  402b9a:	601a      	str	r2, [r3, #0]
				break;
  402b9c:	e7dc      	b.n	402b58 <SystemCoreClockUpdate+0x90>
				SystemCoreClock *= 2U;
  402b9e:	4a0b      	ldr	r2, [pc, #44]	; (402bcc <SystemCoreClockUpdate+0x104>)
  402ba0:	4b06      	ldr	r3, [pc, #24]	; (402bbc <SystemCoreClockUpdate+0xf4>)
  402ba2:	601a      	str	r2, [r3, #0]
				break;
  402ba4:	e7d8      	b.n	402b58 <SystemCoreClockUpdate+0x90>
		SystemCoreClock /= 3U;
  402ba6:	4a05      	ldr	r2, [pc, #20]	; (402bbc <SystemCoreClockUpdate+0xf4>)
  402ba8:	6813      	ldr	r3, [r2, #0]
  402baa:	4909      	ldr	r1, [pc, #36]	; (402bd0 <SystemCoreClockUpdate+0x108>)
  402bac:	fba1 1303 	umull	r1, r3, r1, r3
  402bb0:	085b      	lsrs	r3, r3, #1
  402bb2:	6013      	str	r3, [r2, #0]
  402bb4:	4770      	bx	lr
  402bb6:	bf00      	nop
  402bb8:	400e0400 	.word	0x400e0400
  402bbc:	2000000c 	.word	0x2000000c
  402bc0:	400e1810 	.word	0x400e1810
  402bc4:	00b71b00 	.word	0x00b71b00
  402bc8:	003d0900 	.word	0x003d0900
  402bcc:	007a1200 	.word	0x007a1200
  402bd0:	aaaaaaab 	.word	0xaaaaaaab

00402bd4 <system_init_flash>:
 * Initialize flash.
 */
void system_init_flash( uint32_t ul_clk )
{
	/* Set FWS for embedded Flash access according to operating frequency */
	if ( ul_clk < CHIP_FREQ_FWS_0 ) {
  402bd4:	4b12      	ldr	r3, [pc, #72]	; (402c20 <system_init_flash+0x4c>)
  402bd6:	4298      	cmp	r0, r3
  402bd8:	d911      	bls.n	402bfe <system_init_flash+0x2a>
		EFC->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
	} else {
		if (ul_clk < CHIP_FREQ_FWS_1) {
  402bda:	4b12      	ldr	r3, [pc, #72]	; (402c24 <system_init_flash+0x50>)
  402bdc:	4298      	cmp	r0, r3
  402bde:	d913      	bls.n	402c08 <system_init_flash+0x34>
			EFC->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
		} else {
			if (ul_clk < CHIP_FREQ_FWS_2) {
  402be0:	4b11      	ldr	r3, [pc, #68]	; (402c28 <system_init_flash+0x54>)
  402be2:	4298      	cmp	r0, r3
  402be4:	d914      	bls.n	402c10 <system_init_flash+0x3c>
				EFC->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
			} else {
				if ( ul_clk < CHIP_FREQ_FWS_3 ) {
  402be6:	4b11      	ldr	r3, [pc, #68]	; (402c2c <system_init_flash+0x58>)
  402be8:	4298      	cmp	r0, r3
  402bea:	d915      	bls.n	402c18 <system_init_flash+0x44>
					EFC->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
				} else {
					if ( ul_clk < CHIP_FREQ_FWS_4 ) {
  402bec:	4b10      	ldr	r3, [pc, #64]	; (402c30 <system_init_flash+0x5c>)
  402bee:	4298      	cmp	r0, r3
						EFC->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  402bf0:	bf94      	ite	ls
  402bf2:	f04f 2204 	movls.w	r2, #67109888	; 0x4000400
					} else {
						EFC->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  402bf6:	4a0f      	ldrhi	r2, [pc, #60]	; (402c34 <system_init_flash+0x60>)
  402bf8:	4b0f      	ldr	r3, [pc, #60]	; (402c38 <system_init_flash+0x64>)
  402bfa:	601a      	str	r2, [r3, #0]
  402bfc:	4770      	bx	lr
		EFC->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  402bfe:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
  402c02:	4b0d      	ldr	r3, [pc, #52]	; (402c38 <system_init_flash+0x64>)
  402c04:	601a      	str	r2, [r3, #0]
  402c06:	4770      	bx	lr
			EFC->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
  402c08:	4a0c      	ldr	r2, [pc, #48]	; (402c3c <system_init_flash+0x68>)
  402c0a:	4b0b      	ldr	r3, [pc, #44]	; (402c38 <system_init_flash+0x64>)
  402c0c:	601a      	str	r2, [r3, #0]
  402c0e:	4770      	bx	lr
				EFC->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
  402c10:	4a0b      	ldr	r2, [pc, #44]	; (402c40 <system_init_flash+0x6c>)
  402c12:	4b09      	ldr	r3, [pc, #36]	; (402c38 <system_init_flash+0x64>)
  402c14:	601a      	str	r2, [r3, #0]
  402c16:	4770      	bx	lr
					EFC->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
  402c18:	4a0a      	ldr	r2, [pc, #40]	; (402c44 <system_init_flash+0x70>)
  402c1a:	4b07      	ldr	r3, [pc, #28]	; (402c38 <system_init_flash+0x64>)
  402c1c:	601a      	str	r2, [r3, #0]
  402c1e:	4770      	bx	lr
  402c20:	01312cff 	.word	0x01312cff
  402c24:	026259ff 	.word	0x026259ff
  402c28:	039386ff 	.word	0x039386ff
  402c2c:	04c4b3ff 	.word	0x04c4b3ff
  402c30:	05f5e0ff 	.word	0x05f5e0ff
  402c34:	04000500 	.word	0x04000500
  402c38:	400e0a00 	.word	0x400e0a00
  402c3c:	04000100 	.word	0x04000100
  402c40:	04000200 	.word	0x04000200
  402c44:	04000300 	.word	0x04000300

00402c48 <main>:
/* Function definitions ----------------------------------------------- */
/**
 * @brief Entry
 */
int main(void)
{
  402c48:	b508      	push	{r3, lr}
  sys_init();
  402c4a:	4b02      	ldr	r3, [pc, #8]	; (402c54 <main+0xc>)
  402c4c:	4798      	blx	r3

  while (1)
  {
    sys_run();
  402c4e:	4c02      	ldr	r4, [pc, #8]	; (402c58 <main+0x10>)
  402c50:	47a0      	blx	r4
  402c52:	e7fd      	b.n	402c50 <main+0x8>
  402c54:	00400a39 	.word	0x00400a39
  402c58:	00400a69 	.word	0x00400a69

00402c5c <sysclk_init>:
	pmc_disable_udpck();
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
  402c5c:	b510      	push	{r4, lr}
	/* Set flash wait state to max in case the below clock switching. */
	system_init_flash(CHIP_FREQ_CPU_MAX);
  402c5e:	480e      	ldr	r0, [pc, #56]	; (402c98 <sysclk_init+0x3c>)
  402c60:	4b0e      	ldr	r3, [pc, #56]	; (402c9c <sysclk_init+0x40>)
  402c62:	4798      	blx	r3
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL,
  402c64:	213e      	movs	r1, #62	; 0x3e
  402c66:	2000      	movs	r0, #0
  402c68:	4b0d      	ldr	r3, [pc, #52]	; (402ca0 <sysclk_init+0x44>)
  402c6a:	4798      	blx	r3
		return pmc_osc_is_ready_mainck();
  402c6c:	4c0d      	ldr	r4, [pc, #52]	; (402ca4 <sysclk_init+0x48>)
  402c6e:	47a0      	blx	r4
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
  402c70:	2800      	cmp	r0, #0
  402c72:	d0fc      	beq.n	402c6e <sysclk_init+0x12>
static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		pmc_disable_pllack(); // Always stop PLL first!
  402c74:	4b0c      	ldr	r3, [pc, #48]	; (402ca8 <sysclk_init+0x4c>)
  402c76:	4798      	blx	r3
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
  402c78:	4a0c      	ldr	r2, [pc, #48]	; (402cac <sysclk_init+0x50>)
  402c7a:	4b0d      	ldr	r3, [pc, #52]	; (402cb0 <sysclk_init+0x54>)
  402c7c:	629a      	str	r2, [r3, #40]	; 0x28
static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	UNUSED(ul_pll_id);
	return pmc_is_locked_pllack();
  402c7e:	4c0d      	ldr	r4, [pc, #52]	; (402cb4 <sysclk_init+0x58>)
  402c80:	47a0      	blx	r4
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  402c82:	2800      	cmp	r0, #0
  402c84:	d0fc      	beq.n	402c80 <sysclk_init+0x24>

		pll_enable_source(CONFIG_PLL0_SOURCE);
		pll_config_defaults(&pllcfg, 0);
		pll_enable(&pllcfg, 0);
		pll_wait_for_lock(0);
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  402c86:	2010      	movs	r0, #16
  402c88:	4b0b      	ldr	r3, [pc, #44]	; (402cb8 <sysclk_init+0x5c>)
  402c8a:	4798      	blx	r3
	}
#endif

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  402c8c:	4b0b      	ldr	r3, [pc, #44]	; (402cbc <sysclk_init+0x60>)
  402c8e:	4798      	blx	r3

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  402c90:	480b      	ldr	r0, [pc, #44]	; (402cc0 <sysclk_init+0x64>)
  402c92:	4b02      	ldr	r3, [pc, #8]	; (402c9c <sysclk_init+0x40>)
  402c94:	4798      	blx	r3
  402c96:	bd10      	pop	{r4, pc}
  402c98:	07270e00 	.word	0x07270e00
  402c9c:	00402bd5 	.word	0x00402bd5
  402ca0:	00403191 	.word	0x00403191
  402ca4:	004031e5 	.word	0x004031e5
  402ca8:	004031f5 	.word	0x004031f5
  402cac:	200f3f01 	.word	0x200f3f01
  402cb0:	400e0400 	.word	0x400e0400
  402cb4:	00403205 	.word	0x00403205
  402cb8:	0040312d 	.word	0x0040312d
  402cbc:	00402ac9 	.word	0x00402ac9
  402cc0:	05b8d800 	.word	0x05b8d800

00402cc4 <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  402cc4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  402cc8:	4681      	mov	r9, r0
  402cca:	460f      	mov	r7, r1
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  402ccc:	4b12      	ldr	r3, [pc, #72]	; (402d18 <pio_handler_process+0x54>)
  402cce:	4798      	blx	r3
  402cd0:	4605      	mov	r5, r0
	status &= pio_get_interrupt_mask(p_pio);
  402cd2:	4648      	mov	r0, r9
  402cd4:	4b11      	ldr	r3, [pc, #68]	; (402d1c <pio_handler_process+0x58>)
  402cd6:	4798      	blx	r3

	/* Check pending events */
	if (status != 0) {
  402cd8:	4005      	ands	r5, r0
  402cda:	d013      	beq.n	402d04 <pio_handler_process+0x40>
  402cdc:	4c10      	ldr	r4, [pc, #64]	; (402d20 <pio_handler_process+0x5c>)
  402cde:	f104 0660 	add.w	r6, r4, #96	; 0x60
  402ce2:	e003      	b.n	402cec <pio_handler_process+0x28>
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
				}
			}
			i++;
			if (i >= MAX_INTERRUPT_SOURCES) {
  402ce4:	42b4      	cmp	r4, r6
  402ce6:	d00d      	beq.n	402d04 <pio_handler_process+0x40>
  402ce8:	3410      	adds	r4, #16
		while (status != 0) {
  402cea:	b15d      	cbz	r5, 402d04 <pio_handler_process+0x40>
			if (gs_interrupt_sources[i].id == ul_id) {
  402cec:	6820      	ldr	r0, [r4, #0]
  402cee:	42b8      	cmp	r0, r7
  402cf0:	d1f8      	bne.n	402ce4 <pio_handler_process+0x20>
				if ((status & gs_interrupt_sources[i].mask) != 0) {
  402cf2:	6861      	ldr	r1, [r4, #4]
  402cf4:	4229      	tst	r1, r5
  402cf6:	d0f5      	beq.n	402ce4 <pio_handler_process+0x20>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
  402cf8:	68e3      	ldr	r3, [r4, #12]
  402cfa:	4798      	blx	r3
					status &= ~(gs_interrupt_sources[i].mask);
  402cfc:	6863      	ldr	r3, [r4, #4]
  402cfe:	ea25 0503 	bic.w	r5, r5, r3
  402d02:	e7ef      	b.n	402ce4 <pio_handler_process+0x20>
		}
	}

	/* Check capture events */
#if (SAM3S || SAM4S || SAM4E)
	if (pio_capture_enable_flag) {
  402d04:	4b07      	ldr	r3, [pc, #28]	; (402d24 <pio_handler_process+0x60>)
  402d06:	681b      	ldr	r3, [r3, #0]
  402d08:	b123      	cbz	r3, 402d14 <pio_handler_process+0x50>
		if (pio_capture_handler) {
  402d0a:	4b07      	ldr	r3, [pc, #28]	; (402d28 <pio_handler_process+0x64>)
  402d0c:	681b      	ldr	r3, [r3, #0]
  402d0e:	b10b      	cbz	r3, 402d14 <pio_handler_process+0x50>
			pio_capture_handler(p_pio);
  402d10:	4648      	mov	r0, r9
  402d12:	4798      	blx	r3
  402d14:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  402d18:	0040310b 	.word	0x0040310b
  402d1c:	0040310f 	.word	0x0040310f
  402d20:	2000048c 	.word	0x2000048c
  402d24:	20000530 	.word	0x20000530
  402d28:	20000500 	.word	0x20000500

00402d2c <pio_handler_set>:
 *
 * \return 0 if successful, 1 if the maximum number of sources has been defined.
 */
uint32_t pio_handler_set(Pio *p_pio, uint32_t ul_id, uint32_t ul_mask,
		uint32_t ul_attr, void (*p_handler) (uint32_t, uint32_t))
{
  402d2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint8_t i;
	struct s_interrupt_source *pSource;

	if (gs_ul_nb_sources >= MAX_INTERRUPT_SOURCES)
  402d2e:	4c18      	ldr	r4, [pc, #96]	; (402d90 <pio_handler_set+0x64>)
  402d30:	6826      	ldr	r6, [r4, #0]
  402d32:	2e06      	cmp	r6, #6
  402d34:	d829      	bhi.n	402d8a <pio_handler_set+0x5e>
  402d36:	f04f 0c00 	mov.w	ip, #0
  402d3a:	4664      	mov	r4, ip
		return 1;

    /* Check interrupt for this pin, if already defined, redefine it. */
	for (i = 0; i <= gs_ul_nb_sources; i++) {
		pSource = &(gs_interrupt_sources[i]);
		if (pSource->id == ul_id && pSource->mask == ul_mask) {
  402d3c:	4f15      	ldr	r7, [pc, #84]	; (402d94 <pio_handler_set+0x68>)
  402d3e:	e004      	b.n	402d4a <pio_handler_set+0x1e>
	for (i = 0; i <= gs_ul_nb_sources; i++) {
  402d40:	3401      	adds	r4, #1
  402d42:	b2e4      	uxtb	r4, r4
  402d44:	46a4      	mov	ip, r4
  402d46:	42a6      	cmp	r6, r4
  402d48:	d309      	bcc.n	402d5e <pio_handler_set+0x32>
		pSource = &(gs_interrupt_sources[i]);
  402d4a:	46a6      	mov	lr, r4
		if (pSource->id == ul_id && pSource->mask == ul_mask) {
  402d4c:	0125      	lsls	r5, r4, #4
  402d4e:	597d      	ldr	r5, [r7, r5]
  402d50:	428d      	cmp	r5, r1
  402d52:	d1f5      	bne.n	402d40 <pio_handler_set+0x14>
  402d54:	eb07 1504 	add.w	r5, r7, r4, lsl #4
  402d58:	686d      	ldr	r5, [r5, #4]
  402d5a:	4295      	cmp	r5, r2
  402d5c:	d1f0      	bne.n	402d40 <pio_handler_set+0x14>
			break;
		}
	}

	/* Define new source */
	pSource->id = ul_id;
  402d5e:	4d0d      	ldr	r5, [pc, #52]	; (402d94 <pio_handler_set+0x68>)
  402d60:	ea4f 1e0e 	mov.w	lr, lr, lsl #4
  402d64:	eb05 040e 	add.w	r4, r5, lr
  402d68:	f845 100e 	str.w	r1, [r5, lr]
	pSource->mask = ul_mask;
  402d6c:	6062      	str	r2, [r4, #4]
	pSource->attr = ul_attr;
  402d6e:	60a3      	str	r3, [r4, #8]
	pSource->handler = p_handler;
  402d70:	9906      	ldr	r1, [sp, #24]
  402d72:	60e1      	str	r1, [r4, #12]
	if (i == gs_ul_nb_sources + 1) {
  402d74:	3601      	adds	r6, #1
  402d76:	4566      	cmp	r6, ip
		gs_ul_nb_sources++;
  402d78:	bf04      	itt	eq
  402d7a:	4905      	ldreq	r1, [pc, #20]	; (402d90 <pio_handler_set+0x64>)
  402d7c:	600e      	streq	r6, [r1, #0]
  402d7e:	4611      	mov	r1, r2
	}

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);
  402d80:	461a      	mov	r2, r3
  402d82:	4b05      	ldr	r3, [pc, #20]	; (402d98 <pio_handler_set+0x6c>)
  402d84:	4798      	blx	r3

	return 0;
  402d86:	2000      	movs	r0, #0
  402d88:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return 1;
  402d8a:	2001      	movs	r0, #1
}
  402d8c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  402d8e:	bf00      	nop
  402d90:	200004fc 	.word	0x200004fc
  402d94:	2000048c 	.word	0x2000048c
  402d98:	004030dd 	.word	0x004030dd

00402d9c <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
  402d9c:	b508      	push	{r3, lr}
	pio_handler_process(PIOA, ID_PIOA);
  402d9e:	2109      	movs	r1, #9
  402da0:	4801      	ldr	r0, [pc, #4]	; (402da8 <PIOA_Handler+0xc>)
  402da2:	4b02      	ldr	r3, [pc, #8]	; (402dac <PIOA_Handler+0x10>)
  402da4:	4798      	blx	r3
  402da6:	bd08      	pop	{r3, pc}
  402da8:	400e0e00 	.word	0x400e0e00
  402dac:	00402cc5 	.word	0x00402cc5

00402db0 <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
  402db0:	b508      	push	{r3, lr}
    pio_handler_process(PIOB, ID_PIOB);
  402db2:	210a      	movs	r1, #10
  402db4:	4801      	ldr	r0, [pc, #4]	; (402dbc <PIOB_Handler+0xc>)
  402db6:	4b02      	ldr	r3, [pc, #8]	; (402dc0 <PIOB_Handler+0x10>)
  402db8:	4798      	blx	r3
  402dba:	bd08      	pop	{r3, pc}
  402dbc:	400e1000 	.word	0x400e1000
  402dc0:	00402cc5 	.word	0x00402cc5

00402dc4 <PIOC_Handler>:
/**
 * \brief Parallel IO Controller C interrupt handler.
 * Redefined PIOC interrupt handler for NVIC interrupt table.
 */
void PIOC_Handler(void)
{
  402dc4:	b508      	push	{r3, lr}
	pio_handler_process(PIOC, ID_PIOC);
  402dc6:	210b      	movs	r1, #11
  402dc8:	4801      	ldr	r0, [pc, #4]	; (402dd0 <PIOC_Handler+0xc>)
  402dca:	4b02      	ldr	r3, [pc, #8]	; (402dd4 <PIOC_Handler+0x10>)
  402dcc:	4798      	blx	r3
  402dce:	bd08      	pop	{r3, pc}
  402dd0:	400e1200 	.word	0x400e1200
  402dd4:	00402cc5 	.word	0x00402cc5

00402dd8 <PIOD_Handler>:
/**
 * \brief Parallel IO Controller D interrupt handler.
 * Redefined PIOD interrupt handler for NVIC interrupt table.
 */
void PIOD_Handler(void)
{
  402dd8:	b508      	push	{r3, lr}
	pio_handler_process(PIOD, ID_PIOD);
  402dda:	210c      	movs	r1, #12
  402ddc:	4801      	ldr	r0, [pc, #4]	; (402de4 <PIOD_Handler+0xc>)
  402dde:	4b02      	ldr	r3, [pc, #8]	; (402de8 <PIOD_Handler+0x10>)
  402de0:	4798      	blx	r3
  402de2:	bd08      	pop	{r3, pc}
  402de4:	400e1400 	.word	0x400e1400
  402de8:	00402cc5 	.word	0x00402cc5

00402dec <PIOE_Handler>:
/**
 * \brief Parallel IO Controller E interrupt handler.
 * Redefined PIOE interrupt handler for NVIC interrupt table.
 */
void PIOE_Handler(void)
{
  402dec:	b508      	push	{r3, lr}
	pio_handler_process(PIOE, ID_PIOE);
  402dee:	210d      	movs	r1, #13
  402df0:	4801      	ldr	r0, [pc, #4]	; (402df8 <PIOE_Handler+0xc>)
  402df2:	4b02      	ldr	r3, [pc, #8]	; (402dfc <PIOE_Handler+0x10>)
  402df4:	4798      	blx	r3
  402df6:	bd08      	pop	{r3, pc}
  402df8:	400e1600 	.word	0x400e1600
  402dfc:	00402cc5 	.word	0x00402cc5

00402e00 <can_global_send_transfer_cmd>:
 */
void can_global_send_transfer_cmd(Can *p_can, uint8_t uc_mask)
{
	uint32_t ul_reg;

	ul_reg = p_can->CAN_TCR & ((uint32_t) ~GLOBAL_MAILBOX_MASK);
  402e00:	6a43      	ldr	r3, [r0, #36]	; 0x24
  402e02:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
	p_can->CAN_TCR = ul_reg | uc_mask;
  402e06:	4319      	orrs	r1, r3
  402e08:	6241      	str	r1, [r0, #36]	; 0x24
  402e0a:	4770      	bx	lr

00402e0c <can_mailbox_init>:
 */
void can_mailbox_init(Can *p_can, can_mb_conf_t *p_mailbox)
{
	uint8_t uc_index;

	uc_index = (uint8_t)p_mailbox->ul_mb_idx;
  402e0c:	680b      	ldr	r3, [r1, #0]
	/* Check the object type of the mailbox. If it's used to disable the
	 * mailbox, reset the whole mailbox. */
	if (!p_mailbox->uc_obj_type) {
  402e0e:	790a      	ldrb	r2, [r1, #4]
  402e10:	b31a      	cbz	r2, 402e5a <can_mailbox_init+0x4e>
{
  402e12:	b430      	push	{r4, r5}
  402e14:	b2db      	uxtb	r3, r3
  402e16:	eb00 1243 	add.w	r2, r0, r3, lsl #5
		p_can->CAN_MB[uc_index].CAN_MCR = 0;
		return;
	}

	/* Set the priority in Transmit mode. */
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  402e1a:	f8d2 4200 	ldr.w	r4, [r2, #512]	; 0x200
			~CAN_MMR_PRIOR_Msk) |
			(p_mailbox->uc_tx_prio << CAN_MMR_PRIOR_Pos);
  402e1e:	79cd      	ldrb	r5, [r1, #7]
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  402e20:	f424 2470 	bic.w	r4, r4, #983040	; 0xf0000
			~CAN_MMR_PRIOR_Msk) |
  402e24:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  402e28:	f8c2 4200 	str.w	r4, [r2, #512]	; 0x200

	/* Set the message ID and message acceptance mask for the mailbox in
	 * other modes. */
	if (p_mailbox->uc_id_ver) {
  402e2c:	794c      	ldrb	r4, [r1, #5]
  402e2e:	b32c      	cbz	r4, 402e7c <can_mailbox_init+0x70>
		p_can->CAN_MB[uc_index].CAN_MAM = p_mailbox->ul_id_msk |
  402e30:	68cc      	ldr	r4, [r1, #12]
  402e32:	f044 5400 	orr.w	r4, r4, #536870912	; 0x20000000
  402e36:	f8c2 4204 	str.w	r4, [r2, #516]	; 0x204
				CAN_MAM_MIDE;
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id |
  402e3a:	690c      	ldr	r4, [r1, #16]
  402e3c:	f044 5400 	orr.w	r4, r4, #536870912	; 0x20000000
  402e40:	f8c2 4208 	str.w	r4, [r2, #520]	; 0x208
		p_can->CAN_MB[uc_index].CAN_MAM = p_mailbox->ul_id_msk;
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id;
	}

	/* Set up mailbox in one of the five different modes. */
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  402e44:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
			~CAN_MMR_MOT_Msk) |
			(p_mailbox->uc_obj_type << CAN_MMR_MOT_Pos);
  402e48:	7909      	ldrb	r1, [r1, #4]
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  402e4a:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
			~CAN_MMR_MOT_Msk) |
  402e4e:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  402e52:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
  402e56:	bc30      	pop	{r4, r5}
  402e58:	4770      	bx	lr
  402e5a:	b2db      	uxtb	r3, r3
  402e5c:	eb00 1043 	add.w	r0, r0, r3, lsl #5
		p_can->CAN_MB[uc_index].CAN_MMR = 0;
  402e60:	2300      	movs	r3, #0
  402e62:	f8c0 3200 	str.w	r3, [r0, #512]	; 0x200
		p_can->CAN_MB[uc_index].CAN_MAM = 0;
  402e66:	f8c0 3204 	str.w	r3, [r0, #516]	; 0x204
		p_can->CAN_MB[uc_index].CAN_MID = 0;
  402e6a:	f8c0 3208 	str.w	r3, [r0, #520]	; 0x208
		p_can->CAN_MB[uc_index].CAN_MDL = 0;
  402e6e:	f8c0 3214 	str.w	r3, [r0, #532]	; 0x214
		p_can->CAN_MB[uc_index].CAN_MDH = 0;
  402e72:	f8c0 3218 	str.w	r3, [r0, #536]	; 0x218
		p_can->CAN_MB[uc_index].CAN_MCR = 0;
  402e76:	f8c0 321c 	str.w	r3, [r0, #540]	; 0x21c
		return;
  402e7a:	4770      	bx	lr
		p_can->CAN_MB[uc_index].CAN_MAM = p_mailbox->ul_id_msk;
  402e7c:	68cc      	ldr	r4, [r1, #12]
  402e7e:	f8c2 4204 	str.w	r4, [r2, #516]	; 0x204
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id;
  402e82:	690c      	ldr	r4, [r1, #16]
  402e84:	eb00 1343 	add.w	r3, r0, r3, lsl #5
  402e88:	f8c3 4208 	str.w	r4, [r3, #520]	; 0x208
  402e8c:	e7da      	b.n	402e44 <can_mailbox_init+0x38>

00402e8e <can_mailbox_write>:
	return (p_can->CAN_MB[uc_index].CAN_MSR);
  402e8e:	780b      	ldrb	r3, [r1, #0]
  402e90:	eb00 1243 	add.w	r2, r0, r3, lsl #5
  402e94:	f8d2 2210 	ldr.w	r2, [r2, #528]	; 0x210
	uint8_t uc_index;

	uc_index = (uint8_t)p_mailbox->ul_mb_idx;
	/* Read the mailbox status firstly to check whether the mailbox is ready
	 *or not. */
	p_mailbox->ul_status = can_mailbox_get_status(p_can, uc_index);
  402e98:	608a      	str	r2, [r1, #8]
	ul_status = p_mailbox->ul_status;
	if (!(ul_status & CAN_MSR_MRDY)) {
  402e9a:	f412 0f00 	tst.w	r2, #8388608	; 0x800000
  402e9e:	d028      	beq.n	402ef2 <can_mailbox_write+0x64>
{
  402ea0:	b410      	push	{r4}
		return CAN_MAILBOX_NOT_READY;
	}

	/* Write transmit identifier. */
	if (p_mailbox->uc_id_ver) {
  402ea2:	794a      	ldrb	r2, [r1, #5]
  402ea4:	b1fa      	cbz	r2, 402ee6 <can_mailbox_write+0x58>
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id |
  402ea6:	690a      	ldr	r2, [r1, #16]
  402ea8:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
  402eac:	eb00 1443 	add.w	r4, r0, r3, lsl #5
  402eb0:	f8c4 2208 	str.w	r2, [r4, #520]	; 0x208
	} else {
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id;
	}

	/* Write transmit data into mailbox data register. */
	p_can->CAN_MB[uc_index].CAN_MDL = p_mailbox->ul_datal;
  402eb4:	698c      	ldr	r4, [r1, #24]
  402eb6:	eb00 1243 	add.w	r2, r0, r3, lsl #5
  402eba:	f8c2 4214 	str.w	r4, [r2, #532]	; 0x214
	if (p_mailbox->uc_length > 4) {
  402ebe:	798a      	ldrb	r2, [r1, #6]
  402ec0:	2a04      	cmp	r2, #4
  402ec2:	d904      	bls.n	402ece <can_mailbox_write+0x40>
		p_can->CAN_MB[uc_index].CAN_MDH = p_mailbox->ul_datah;
  402ec4:	69cc      	ldr	r4, [r1, #28]
  402ec6:	eb00 1243 	add.w	r2, r0, r3, lsl #5
  402eca:	f8c2 4218 	str.w	r4, [r2, #536]	; 0x218
	}

	/* Write transmit data length into mailbox control register. */
	p_can->CAN_MB[uc_index].CAN_MCR = CAN_MCR_MDLC(p_mailbox->uc_length);
  402ece:	798a      	ldrb	r2, [r1, #6]
  402ed0:	0412      	lsls	r2, r2, #16
  402ed2:	f402 2270 	and.w	r2, r2, #983040	; 0xf0000
  402ed6:	eb00 1043 	add.w	r0, r0, r3, lsl #5
  402eda:	f8c0 221c 	str.w	r2, [r0, #540]	; 0x21c

	return CAN_MAILBOX_TRANSFER_OK;
  402ede:	2000      	movs	r0, #0
}
  402ee0:	f85d 4b04 	ldr.w	r4, [sp], #4
  402ee4:	4770      	bx	lr
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id;
  402ee6:	690c      	ldr	r4, [r1, #16]
  402ee8:	eb00 1243 	add.w	r2, r0, r3, lsl #5
  402eec:	f8c2 4208 	str.w	r4, [r2, #520]	; 0x208
  402ef0:	e7e0      	b.n	402eb4 <can_mailbox_write+0x26>
		return CAN_MAILBOX_NOT_READY;
  402ef2:	2001      	movs	r0, #1
  402ef4:	4770      	bx	lr
	...

00402ef8 <can_reset_all_mailbox>:
 * \brief Reset the eight mailboxes.
 *
 * \param p_can Pointer to a CAN peripheral instance.
 */
void can_reset_all_mailbox(Can *p_can)
{
  402ef8:	b570      	push	{r4, r5, r6, lr}
  402efa:	b088      	sub	sp, #32
  402efc:	4606      	mov	r6, r0
	can_mb_conf_t mb_config_t;

	/* Set the mailbox object type parameter to disable the mailbox. */
	mb_config_t.uc_obj_type = CAN_MB_DISABLE_MODE;
  402efe:	2400      	movs	r4, #0
  402f00:	f88d 4004 	strb.w	r4, [sp, #4]

	for (uint8_t i = 0; i < CANMB_NUMBER; i++) {
		mb_config_t.ul_mb_idx = i;
		can_mailbox_init(p_can, &mb_config_t);
  402f04:	4d04      	ldr	r5, [pc, #16]	; (402f18 <can_reset_all_mailbox+0x20>)
		mb_config_t.ul_mb_idx = i;
  402f06:	9400      	str	r4, [sp, #0]
		can_mailbox_init(p_can, &mb_config_t);
  402f08:	4669      	mov	r1, sp
  402f0a:	4630      	mov	r0, r6
  402f0c:	47a8      	blx	r5
  402f0e:	3401      	adds	r4, #1
	for (uint8_t i = 0; i < CANMB_NUMBER; i++) {
  402f10:	2c08      	cmp	r4, #8
  402f12:	d1f8      	bne.n	402f06 <can_reset_all_mailbox+0xe>
	}
}
  402f14:	b008      	add	sp, #32
  402f16:	bd70      	pop	{r4, r5, r6, pc}
  402f18:	00402e0d 	.word	0x00402e0d

00402f1c <can_init>:
{
  402f1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (((ul_mck + (ul_baudrate * CAN_MAX_TQ_NUM * 1000 - 1)) /
  402f1e:	f246 13a8 	movw	r3, #25000	; 0x61a8
  402f22:	fb03 f402 	mul.w	r4, r3, r2
  402f26:	190b      	adds	r3, r1, r4
  402f28:	3b01      	subs	r3, #1
  402f2a:	fbb3 f3f4 	udiv	r3, r3, r4
  402f2e:	2b80      	cmp	r3, #128	; 0x80
  402f30:	d866      	bhi.n	403000 <can_init+0xe4>
	if ((ul_mck / 2)  < ul_baudrate * CAN_MIN_TQ_NUM * 1000) {
  402f32:	f44f 54fa 	mov.w	r4, #8000	; 0x1f40
  402f36:	fb04 f402 	mul.w	r4, r4, r2
  402f3a:	ebb4 0f51 	cmp.w	r4, r1, lsr #1
  402f3e:	d861      	bhi.n	403004 <can_init+0xe8>
  402f40:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
  402f44:	fb03 f202 	mul.w	r2, r3, r2
  402f48:	2708      	movs	r7, #8
  402f4a:	f04f 36ff 	mov.w	r6, #4294967295
  402f4e:	463b      	mov	r3, r7
  402f50:	e004      	b.n	402f5c <can_init+0x40>
	for (uint8_t i = CAN_MIN_TQ_NUM; i <= CAN_MAX_TQ_NUM; i++) {
  402f52:	3301      	adds	r3, #1
  402f54:	b2db      	uxtb	r3, r3
  402f56:	4414      	add	r4, r2
  402f58:	2b1a      	cmp	r3, #26
  402f5a:	d00c      	beq.n	402f76 <can_init+0x5a>
		if ((ul_mck / (ul_baudrate * i * 1000)) <=
  402f5c:	fbb1 f5f4 	udiv	r5, r1, r4
  402f60:	2d80      	cmp	r5, #128	; 0x80
  402f62:	d8f6      	bhi.n	402f52 <can_init+0x36>
			ul_cur_mod = ul_mck % (ul_baudrate * i * 1000);
  402f64:	fb04 1515 	mls	r5, r4, r5, r1
			if (ul_cur_mod < ul_mod) {
  402f68:	42b5      	cmp	r5, r6
  402f6a:	d2f2      	bcs.n	402f52 <can_init+0x36>
				if (!ul_mod) {
  402f6c:	b115      	cbz	r5, 402f74 <can_init+0x58>
				ul_mod = ul_cur_mod;
  402f6e:	462e      	mov	r6, r5
				if (!ul_mod) {
  402f70:	461f      	mov	r7, r3
  402f72:	e7ee      	b.n	402f52 <can_init+0x36>
  402f74:	461f      	mov	r7, r3
	uc_prescale = ul_mck / (ul_baudrate * uc_tq * 1000);
  402f76:	fb02 f207 	mul.w	r2, r2, r7
  402f7a:	fbb1 f1f2 	udiv	r1, r1, r2
	if (uc_prescale < 2) {
  402f7e:	b2cb      	uxtb	r3, r1
  402f80:	2b01      	cmp	r3, #1
  402f82:	d941      	bls.n	403008 <can_init+0xec>
  402f84:	4604      	mov	r4, r0
	p_bit_time = (can_bit_timing_t *)&can_bit_time[uc_tq - CAN_MIN_TQ_NUM];
  402f86:	f1a7 0208 	sub.w	r2, r7, #8
	p_can->CAN_MR &= ~CAN_MR_CANEN;
  402f8a:	6803      	ldr	r3, [r0, #0]
  402f8c:	f023 0301 	bic.w	r3, r3, #1
  402f90:	6003      	str	r3, [r0, #0]
			CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
  402f92:	4d1e      	ldr	r5, [pc, #120]	; (40300c <can_init+0xf0>)
  402f94:	0056      	lsls	r6, r2, #1
  402f96:	18b7      	adds	r7, r6, r2
  402f98:	eb05 0747 	add.w	r7, r5, r7, lsl #1
  402f9c:	78bb      	ldrb	r3, [r7, #2]
  402f9e:	3b01      	subs	r3, #1
  402fa0:	011b      	lsls	r3, r3, #4
  402fa2:	f003 0370 	and.w	r3, r3, #112	; 0x70
			CAN_BR_PROPAG(p_bit_time->uc_prog - 1) |
  402fa6:	7878      	ldrb	r0, [r7, #1]
  402fa8:	3801      	subs	r0, #1
  402faa:	0200      	lsls	r0, r0, #8
  402fac:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
			CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
  402fb0:	4303      	orrs	r3, r0
	p_can->CAN_BR = CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
  402fb2:	78f8      	ldrb	r0, [r7, #3]
  402fb4:	3801      	subs	r0, #1
  402fb6:	f000 0007 	and.w	r0, r0, #7
			CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
  402fba:	4303      	orrs	r3, r0
			CAN_BR_SJW(p_bit_time->uc_sjw - 1) |
  402fbc:	793a      	ldrb	r2, [r7, #4]
  402fbe:	3a01      	subs	r2, #1
  402fc0:	0312      	lsls	r2, r2, #12
  402fc2:	f402 5240 	and.w	r2, r2, #12288	; 0x3000
			CAN_BR_PROPAG(p_bit_time->uc_prog - 1) |
  402fc6:	4313      	orrs	r3, r2
			CAN_BR_BRP(uc_prescale - 1);
  402fc8:	b2ca      	uxtb	r2, r1
  402fca:	3a01      	subs	r2, #1
  402fcc:	0412      	lsls	r2, r2, #16
  402fce:	f402 02fe 	and.w	r2, r2, #8323072	; 0x7f0000
			CAN_BR_SJW(p_bit_time->uc_sjw - 1) |
  402fd2:	4313      	orrs	r3, r2
	p_can->CAN_BR = CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
  402fd4:	6163      	str	r3, [r4, #20]
	can_reset_all_mailbox(p_can);
  402fd6:	4620      	mov	r0, r4
  402fd8:	4b0d      	ldr	r3, [pc, #52]	; (403010 <can_init+0xf4>)
  402fda:	4798      	blx	r3
	p_can->CAN_MR |= CAN_MR_CANEN;
  402fdc:	6823      	ldr	r3, [r4, #0]
  402fde:	f043 0301 	orr.w	r3, r3, #1
  402fe2:	6023      	str	r3, [r4, #0]
  402fe4:	2300      	movs	r3, #0
	while (!(ul_flag & CAN_SR_WAKEUP) && (ul_tick < CAN_TIMEOUT)) {
  402fe6:	490b      	ldr	r1, [pc, #44]	; (403014 <can_init+0xf8>)
	return (p_can->CAN_SR);
  402fe8:	6922      	ldr	r2, [r4, #16]
		ul_tick++;
  402fea:	3301      	adds	r3, #1
	while (!(ul_flag & CAN_SR_WAKEUP) && (ul_tick < CAN_TIMEOUT)) {
  402fec:	f412 1f00 	tst.w	r2, #2097152	; 0x200000
  402ff0:	d101      	bne.n	402ff6 <can_init+0xda>
  402ff2:	428b      	cmp	r3, r1
  402ff4:	d1f8      	bne.n	402fe8 <can_init+0xcc>
	if (CAN_TIMEOUT == ul_tick) {
  402ff6:	4807      	ldr	r0, [pc, #28]	; (403014 <can_init+0xf8>)
  402ff8:	1a18      	subs	r0, r3, r0
  402ffa:	bf18      	it	ne
  402ffc:	2001      	movne	r0, #1
  402ffe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return 0;
  403000:	2000      	movs	r0, #0
  403002:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  403004:	2000      	movs	r0, #0
  403006:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  403008:	2000      	movs	r0, #0
}
  40300a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40300c:	00404058 	.word	0x00404058
  403010:	00402ef9 	.word	0x00402ef9
  403014:	000186a0 	.word	0x000186a0

00403018 <pio_set_peripheral>:
		const uint32_t ul_mask)
{
	uint32_t ul_sr;

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;
  403018:	6442      	str	r2, [r0, #68]	; 0x44

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  40301a:	f1b1 5fc0 	cmp.w	r1, #402653184	; 0x18000000
  40301e:	d03a      	beq.n	403096 <pio_set_peripheral+0x7e>
  403020:	d813      	bhi.n	40304a <pio_set_peripheral+0x32>
  403022:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
  403026:	d025      	beq.n	403074 <pio_set_peripheral+0x5c>
  403028:	f1b1 5f80 	cmp.w	r1, #268435456	; 0x10000000
  40302c:	d10a      	bne.n	403044 <pio_set_peripheral+0x2c>

		ul_sr = p_pio->PIO_ABCDSR[1];
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
		break;
	case PIO_PERIPH_B:
		ul_sr = p_pio->PIO_ABCDSR[0];
  40302e:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  403030:	4313      	orrs	r3, r2
  403032:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  403034:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  403036:	6f41      	ldr	r1, [r0, #116]	; 0x74
  403038:	400b      	ands	r3, r1
  40303a:	ea23 0302 	bic.w	r3, r3, r2
  40303e:	6743      	str	r3, [r0, #116]	; 0x74
#else
#error "Unsupported device"
#endif

	/* Remove the pins from under the control of PIO */
	p_pio->PIO_PDR = ul_mask;
  403040:	6042      	str	r2, [r0, #4]
  403042:	4770      	bx	lr
	switch (ul_type) {
  403044:	2900      	cmp	r1, #0
  403046:	d1fb      	bne.n	403040 <pio_set_peripheral+0x28>
  403048:	4770      	bx	lr
  40304a:	f1b1 5f20 	cmp.w	r1, #671088640	; 0x28000000
  40304e:	d021      	beq.n	403094 <pio_set_peripheral+0x7c>
  403050:	d809      	bhi.n	403066 <pio_set_peripheral+0x4e>
  403052:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
  403056:	d1f3      	bne.n	403040 <pio_set_peripheral+0x28>
		ul_sr = p_pio->PIO_ABCDSR[0];
  403058:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  40305a:	4313      	orrs	r3, r2
  40305c:	6703      	str	r3, [r0, #112]	; 0x70
		ul_sr = p_pio->PIO_ABCDSR[1];
  40305e:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  403060:	4313      	orrs	r3, r2
  403062:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  403064:	e7ec      	b.n	403040 <pio_set_peripheral+0x28>
	switch (ul_type) {
  403066:	f1b1 5f40 	cmp.w	r1, #805306368	; 0x30000000
  40306a:	d013      	beq.n	403094 <pio_set_peripheral+0x7c>
  40306c:	f1b1 5f60 	cmp.w	r1, #939524096	; 0x38000000
  403070:	d010      	beq.n	403094 <pio_set_peripheral+0x7c>
  403072:	e7e5      	b.n	403040 <pio_set_peripheral+0x28>
{
  403074:	b410      	push	{r4}
		ul_sr = p_pio->PIO_ABCDSR[0];
  403076:	6f01      	ldr	r1, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  403078:	6f04      	ldr	r4, [r0, #112]	; 0x70
  40307a:	43d3      	mvns	r3, r2
  40307c:	4021      	ands	r1, r4
  40307e:	461c      	mov	r4, r3
  403080:	4019      	ands	r1, r3
  403082:	6701      	str	r1, [r0, #112]	; 0x70
		ul_sr = p_pio->PIO_ABCDSR[1];
  403084:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  403086:	6f41      	ldr	r1, [r0, #116]	; 0x74
  403088:	400b      	ands	r3, r1
  40308a:	4023      	ands	r3, r4
  40308c:	6743      	str	r3, [r0, #116]	; 0x74
	p_pio->PIO_PDR = ul_mask;
  40308e:	6042      	str	r2, [r0, #4]
}
  403090:	f85d 4b04 	ldr.w	r4, [sp], #4
  403094:	4770      	bx	lr
		ul_sr = p_pio->PIO_ABCDSR[0];
  403096:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  403098:	6f01      	ldr	r1, [r0, #112]	; 0x70
  40309a:	400b      	ands	r3, r1
  40309c:	ea23 0302 	bic.w	r3, r3, r2
  4030a0:	6703      	str	r3, [r0, #112]	; 0x70
		ul_sr = p_pio->PIO_ABCDSR[1];
  4030a2:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  4030a4:	4313      	orrs	r3, r2
  4030a6:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  4030a8:	e7ca      	b.n	403040 <pio_set_peripheral+0x28>

004030aa <pio_set_input>:
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  4030aa:	6441      	str	r1, [r0, #68]	; 0x44
	if (ul_pull_up_enable) {
  4030ac:	f012 0f01 	tst.w	r2, #1
		p_pio->PIO_PUER = ul_mask;
  4030b0:	bf14      	ite	ne
  4030b2:	6641      	strne	r1, [r0, #100]	; 0x64
		p_pio->PIO_PUDR = ul_mask;
  4030b4:	6601      	streq	r1, [r0, #96]	; 0x60
	if (ul_attribute & (PIO_DEGLITCH | PIO_DEBOUNCE)) {
  4030b6:	f012 0f0a 	tst.w	r2, #10
		p_pio->PIO_IFER = ul_mask;
  4030ba:	bf14      	ite	ne
  4030bc:	6201      	strne	r1, [r0, #32]
		p_pio->PIO_IFDR = ul_mask;
  4030be:	6241      	streq	r1, [r0, #36]	; 0x24
	if (ul_attribute & PIO_DEGLITCH) {
  4030c0:	f012 0f02 	tst.w	r2, #2
  4030c4:	d107      	bne.n	4030d6 <pio_set_input+0x2c>
		if (ul_attribute & PIO_DEBOUNCE) {
  4030c6:	f012 0f08 	tst.w	r2, #8
			p_pio->PIO_IFSCER = ul_mask;
  4030ca:	bf18      	it	ne
  4030cc:	f8c0 1084 	strne.w	r1, [r0, #132]	; 0x84
	p_pio->PIO_ODR = ul_mask;
  4030d0:	6141      	str	r1, [r0, #20]
	p_pio->PIO_PER = ul_mask;
  4030d2:	6001      	str	r1, [r0, #0]
  4030d4:	4770      	bx	lr
		p_pio->PIO_IFSCDR = ul_mask;
  4030d6:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
  4030da:	e7f9      	b.n	4030d0 <pio_set_input+0x26>

004030dc <pio_configure_interrupt>:
	if (ul_attr & PIO_IT_AIME) {
  4030dc:	f012 0f10 	tst.w	r2, #16
  4030e0:	d010      	beq.n	403104 <pio_configure_interrupt+0x28>
		p_pio->PIO_AIMER = ul_mask;
  4030e2:	f8c0 10b0 	str.w	r1, [r0, #176]	; 0xb0
		if (ul_attr & PIO_IT_RE_OR_HL) {
  4030e6:	f012 0f20 	tst.w	r2, #32
			p_pio->PIO_REHLSR = ul_mask;
  4030ea:	bf14      	ite	ne
  4030ec:	f8c0 10d4 	strne.w	r1, [r0, #212]	; 0xd4
			p_pio->PIO_FELLSR = ul_mask;
  4030f0:	f8c0 10d0 	streq.w	r1, [r0, #208]	; 0xd0
		if (ul_attr & PIO_IT_EDGE) {
  4030f4:	f012 0f40 	tst.w	r2, #64	; 0x40
			p_pio->PIO_ESR = ul_mask;
  4030f8:	bf14      	ite	ne
  4030fa:	f8c0 10c0 	strne.w	r1, [r0, #192]	; 0xc0
			p_pio->PIO_LSR = ul_mask;
  4030fe:	f8c0 10c4 	streq.w	r1, [r0, #196]	; 0xc4
  403102:	4770      	bx	lr
		p_pio->PIO_AIMDR = ul_mask;
  403104:	f8c0 10b4 	str.w	r1, [r0, #180]	; 0xb4
  403108:	4770      	bx	lr

0040310a <pio_get_interrupt_status>:
 *
 * \return The interrupt status value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
	return p_pio->PIO_ISR;
  40310a:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
}
  40310c:	4770      	bx	lr

0040310e <pio_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
	return p_pio->PIO_IMR;
  40310e:	6c80      	ldr	r0, [r0, #72]	; 0x48
}
  403110:	4770      	bx	lr

00403112 <pio_enable_pin_interrupt>:
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  403112:	0943      	lsrs	r3, r0, #5
  403114:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  403118:	f203 7307 	addw	r3, r3, #1799	; 0x707
  40311c:	025b      	lsls	r3, r3, #9
	p_pio->PIO_IER = 1 << (ul_pin & 0x1F);
  40311e:	f000 001f 	and.w	r0, r0, #31
  403122:	2201      	movs	r2, #1
  403124:	fa02 f000 	lsl.w	r0, r2, r0
  403128:	6418      	str	r0, [r3, #64]	; 0x40
  40312a:	4770      	bx	lr

0040312c <pmc_switch_mck_to_pllack>:
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  40312c:	4a17      	ldr	r2, [pc, #92]	; (40318c <pmc_switch_mck_to_pllack+0x60>)
  40312e:	6b13      	ldr	r3, [r2, #48]	; 0x30
  403130:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  403134:	4318      	orrs	r0, r3
  403136:	6310      	str	r0, [r2, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  403138:	6e93      	ldr	r3, [r2, #104]	; 0x68
  40313a:	f013 0f08 	tst.w	r3, #8
  40313e:	d10a      	bne.n	403156 <pmc_switch_mck_to_pllack+0x2a>
  403140:	f44f 6300 	mov.w	r3, #2048	; 0x800
  403144:	4911      	ldr	r1, [pc, #68]	; (40318c <pmc_switch_mck_to_pllack+0x60>)
  403146:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  403148:	f012 0f08 	tst.w	r2, #8
  40314c:	d103      	bne.n	403156 <pmc_switch_mck_to_pllack+0x2a>
			--ul_timeout) {
		if (ul_timeout == 0) {
  40314e:	3b01      	subs	r3, #1
  403150:	d1f9      	bne.n	403146 <pmc_switch_mck_to_pllack+0x1a>
			return 1;
  403152:	2001      	movs	r0, #1
  403154:	4770      	bx	lr
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  403156:	4a0d      	ldr	r2, [pc, #52]	; (40318c <pmc_switch_mck_to_pllack+0x60>)
  403158:	6b13      	ldr	r3, [r2, #48]	; 0x30
  40315a:	f023 0303 	bic.w	r3, r3, #3
  40315e:	f043 0302 	orr.w	r3, r3, #2
  403162:	6313      	str	r3, [r2, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  403164:	6e93      	ldr	r3, [r2, #104]	; 0x68
  403166:	f013 0f08 	tst.w	r3, #8
  40316a:	d10a      	bne.n	403182 <pmc_switch_mck_to_pllack+0x56>
  40316c:	f44f 6300 	mov.w	r3, #2048	; 0x800
  403170:	4906      	ldr	r1, [pc, #24]	; (40318c <pmc_switch_mck_to_pllack+0x60>)
  403172:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  403174:	f012 0f08 	tst.w	r2, #8
  403178:	d105      	bne.n	403186 <pmc_switch_mck_to_pllack+0x5a>
			--ul_timeout) {
		if (ul_timeout == 0) {
  40317a:	3b01      	subs	r3, #1
  40317c:	d1f9      	bne.n	403172 <pmc_switch_mck_to_pllack+0x46>
			return 1;
  40317e:	2001      	movs	r0, #1
		}
	}

	return 0;
}
  403180:	4770      	bx	lr
	return 0;
  403182:	2000      	movs	r0, #0
  403184:	4770      	bx	lr
  403186:	2000      	movs	r0, #0
  403188:	4770      	bx	lr
  40318a:	bf00      	nop
  40318c:	400e0400 	.word	0x400e0400

00403190 <pmc_switch_mainck_to_xtal>:
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
  403190:	b9c8      	cbnz	r0, 4031c6 <pmc_switch_mainck_to_xtal+0x36>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  403192:	4a11      	ldr	r2, [pc, #68]	; (4031d8 <pmc_switch_mainck_to_xtal+0x48>)
  403194:	6a13      	ldr	r3, [r2, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
  403196:	0209      	lsls	r1, r1, #8
  403198:	b289      	uxth	r1, r1
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  40319a:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  40319e:	f023 0303 	bic.w	r3, r3, #3
  4031a2:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  4031a6:	f043 0301 	orr.w	r3, r3, #1
  4031aa:	430b      	orrs	r3, r1
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  4031ac:	6213      	str	r3, [r2, #32]
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
  4031ae:	6e93      	ldr	r3, [r2, #104]	; 0x68
  4031b0:	f013 0f01 	tst.w	r3, #1
  4031b4:	d0fb      	beq.n	4031ae <pmc_switch_mainck_to_xtal+0x1e>

		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
  4031b6:	4a08      	ldr	r2, [pc, #32]	; (4031d8 <pmc_switch_mainck_to_xtal+0x48>)
  4031b8:	6a13      	ldr	r3, [r2, #32]
  4031ba:	f043 739b 	orr.w	r3, r3, #20316160	; 0x1360000
  4031be:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  4031c2:	6213      	str	r3, [r2, #32]
  4031c4:	4770      	bx	lr
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  4031c6:	4904      	ldr	r1, [pc, #16]	; (4031d8 <pmc_switch_mainck_to_xtal+0x48>)
  4031c8:	6a0b      	ldr	r3, [r1, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
  4031ca:	4a04      	ldr	r2, [pc, #16]	; (4031dc <pmc_switch_mainck_to_xtal+0x4c>)
  4031cc:	401a      	ands	r2, r3
  4031ce:	4b04      	ldr	r3, [pc, #16]	; (4031e0 <pmc_switch_mainck_to_xtal+0x50>)
  4031d0:	4313      	orrs	r3, r2
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  4031d2:	620b      	str	r3, [r1, #32]
  4031d4:	4770      	bx	lr
  4031d6:	bf00      	nop
  4031d8:	400e0400 	.word	0x400e0400
  4031dc:	fec8fffc 	.word	0xfec8fffc
  4031e0:	01370002 	.word	0x01370002

004031e4 <pmc_osc_is_ready_mainck>:
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
  4031e4:	4b02      	ldr	r3, [pc, #8]	; (4031f0 <pmc_osc_is_ready_mainck+0xc>)
  4031e6:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  4031e8:	f400 3080 	and.w	r0, r0, #65536	; 0x10000
  4031ec:	4770      	bx	lr
  4031ee:	bf00      	nop
  4031f0:	400e0400 	.word	0x400e0400

004031f4 <pmc_disable_pllack>:
void pmc_disable_pllack(void)
{
#if (SAM4C || SAM4CM || SAM4CP || SAMG)
	PMC->CKGR_PLLAR = CKGR_PLLAR_MULA(0);
#else
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
  4031f4:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  4031f8:	4b01      	ldr	r3, [pc, #4]	; (403200 <pmc_disable_pllack+0xc>)
  4031fa:	629a      	str	r2, [r3, #40]	; 0x28
  4031fc:	4770      	bx	lr
  4031fe:	bf00      	nop
  403200:	400e0400 	.word	0x400e0400

00403204 <pmc_is_locked_pllack>:
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  403204:	4b02      	ldr	r3, [pc, #8]	; (403210 <pmc_is_locked_pllack+0xc>)
  403206:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  403208:	f000 0002 	and.w	r0, r0, #2
  40320c:	4770      	bx	lr
  40320e:	bf00      	nop
  403210:	400e0400 	.word	0x400e0400

00403214 <pmc_enable_periph_clk>:
	PMC->PMC_PCR = ul_id & 0x7F;
	pcr = PMC->PMC_PCR | PMC_PCR_EN | PMC_PCR_CMD;
	PMC->PMC_PCR = pcr;
	return 0;
#else
	if (ul_id > MAX_PERIPH_ID) {
  403214:	282f      	cmp	r0, #47	; 0x2f
  403216:	d81e      	bhi.n	403256 <pmc_enable_periph_clk+0x42>
		return 1;
	}

	if (ul_id < 32) {
  403218:	281f      	cmp	r0, #31
  40321a:	d80c      	bhi.n	403236 <pmc_enable_periph_clk+0x22>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  40321c:	4b11      	ldr	r3, [pc, #68]	; (403264 <pmc_enable_periph_clk+0x50>)
  40321e:	699a      	ldr	r2, [r3, #24]
  403220:	2301      	movs	r3, #1
  403222:	4083      	lsls	r3, r0
  403224:	4393      	bics	r3, r2
  403226:	d018      	beq.n	40325a <pmc_enable_periph_clk+0x46>
			PMC->PMC_PCER0 = 1 << ul_id;
  403228:	2301      	movs	r3, #1
  40322a:	fa03 f000 	lsl.w	r0, r3, r0
  40322e:	4b0d      	ldr	r3, [pc, #52]	; (403264 <pmc_enable_periph_clk+0x50>)
  403230:	6118      	str	r0, [r3, #16]
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
  403232:	2000      	movs	r0, #0
  403234:	4770      	bx	lr
		ul_id -= 32;
  403236:	3820      	subs	r0, #32
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  403238:	4b0a      	ldr	r3, [pc, #40]	; (403264 <pmc_enable_periph_clk+0x50>)
  40323a:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
  40323e:	2301      	movs	r3, #1
  403240:	4083      	lsls	r3, r0
  403242:	4393      	bics	r3, r2
  403244:	d00b      	beq.n	40325e <pmc_enable_periph_clk+0x4a>
			PMC->PMC_PCER1 = 1 << ul_id;
  403246:	2301      	movs	r3, #1
  403248:	fa03 f000 	lsl.w	r0, r3, r0
  40324c:	4b05      	ldr	r3, [pc, #20]	; (403264 <pmc_enable_periph_clk+0x50>)
  40324e:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
	return 0;
  403252:	2000      	movs	r0, #0
  403254:	4770      	bx	lr
		return 1;
  403256:	2001      	movs	r0, #1
  403258:	4770      	bx	lr
	return 0;
  40325a:	2000      	movs	r0, #0
  40325c:	4770      	bx	lr
  40325e:	2000      	movs	r0, #0
#endif /* defined(REG_PMC_PCR) && !SAMG55 */
}
  403260:	4770      	bx	lr
  403262:	bf00      	nop
  403264:	400e0400 	.word	0x400e0400

00403268 <twi_set_speed>:
{
	uint32_t ckdiv = 0;
	uint32_t c_lh_div;
	uint32_t cldiv, chdiv;

	if (ul_speed > I2C_FAST_MODE_SPEED) {
  403268:	4b2a      	ldr	r3, [pc, #168]	; (403314 <twi_set_speed+0xac>)
  40326a:	4299      	cmp	r1, r3
  40326c:	d84a      	bhi.n	403304 <twi_set_speed+0x9c>
		return FAIL;
	}

	/* Low level time not less than 1.3us of I2C Fast Mode. */
	if (ul_speed > LOW_LEVEL_TIME_LIMIT) {
  40326e:	f5a3 537a 	sub.w	r3, r3, #16000	; 0x3e80
  403272:	4299      	cmp	r1, r3
  403274:	d92c      	bls.n	4032d0 <twi_set_speed+0x68>
{
  403276:	b410      	push	{r4}
		/* Low level of time fixed for 1.3us. */
		cldiv = ul_mck / (LOW_LEVEL_TIME_LIMIT * TWI_CLK_DIVIDER) - TWI_CLK_CALC_ARGU;
  403278:	4c27      	ldr	r4, [pc, #156]	; (403318 <twi_set_speed+0xb0>)
  40327a:	fba4 3402 	umull	r3, r4, r4, r2
  40327e:	0ba4      	lsrs	r4, r4, #14
  403280:	3c04      	subs	r4, #4
		chdiv = ul_mck / ((ul_speed + (ul_speed - LOW_LEVEL_TIME_LIMIT)) * TWI_CLK_DIVIDER) - TWI_CLK_CALC_ARGU;
  403282:	4b26      	ldr	r3, [pc, #152]	; (40331c <twi_set_speed+0xb4>)
  403284:	440b      	add	r3, r1
  403286:	009b      	lsls	r3, r3, #2
  403288:	fbb2 f2f3 	udiv	r2, r2, r3
  40328c:	3a04      	subs	r2, #4
		
		/* cldiv must fit in 8 bits, ckdiv must fit in 3 bits */
		while ((cldiv > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  40328e:	2cff      	cmp	r4, #255	; 0xff
  403290:	d93a      	bls.n	403308 <twi_set_speed+0xa0>
  403292:	2100      	movs	r1, #0
			/* Increase clock divider */
			ckdiv++;
  403294:	3101      	adds	r1, #1
			/* Divide cldiv value */
			cldiv /= TWI_CLK_DIVIDER;
  403296:	0864      	lsrs	r4, r4, #1
		while ((cldiv > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  403298:	2cff      	cmp	r4, #255	; 0xff
  40329a:	d90e      	bls.n	4032ba <twi_set_speed+0x52>
  40329c:	2907      	cmp	r1, #7
  40329e:	d1f9      	bne.n	403294 <twi_set_speed+0x2c>
			chdiv /= TWI_CLK_DIVIDER;
		}

		/* set clock waveform generator register */
		p_twi->TWI_CWGR =
				TWI_CWGR_CLDIV(cldiv) | TWI_CWGR_CHDIV(chdiv) |
  4032a0:	0213      	lsls	r3, r2, #8
  4032a2:	b29b      	uxth	r3, r3
				TWI_CWGR_CKDIV(ckdiv);		
  4032a4:	0409      	lsls	r1, r1, #16
  4032a6:	f401 21e0 	and.w	r1, r1, #458752	; 0x70000
				TWI_CWGR_CLDIV(cldiv) | TWI_CWGR_CHDIV(chdiv) |
  4032aa:	430b      	orrs	r3, r1
  4032ac:	b2e4      	uxtb	r4, r4
  4032ae:	4323      	orrs	r3, r4
		p_twi->TWI_CWGR =
  4032b0:	6103      	str	r3, [r0, #16]
		p_twi->TWI_CWGR =
				TWI_CWGR_CLDIV(c_lh_div) | TWI_CWGR_CHDIV(c_lh_div) |
				TWI_CWGR_CKDIV(ckdiv);
	}

	return PASS;
  4032b2:	2000      	movs	r0, #0
}
  4032b4:	f85d 4b04 	ldr.w	r4, [sp], #4
  4032b8:	4770      	bx	lr
		while ((chdiv > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  4032ba:	2aff      	cmp	r2, #255	; 0xff
  4032bc:	d9f0      	bls.n	4032a0 <twi_set_speed+0x38>
  4032be:	2906      	cmp	r1, #6
  4032c0:	d8ee      	bhi.n	4032a0 <twi_set_speed+0x38>
			ckdiv++;
  4032c2:	3101      	adds	r1, #1
			chdiv /= TWI_CLK_DIVIDER;
  4032c4:	0852      	lsrs	r2, r2, #1
		while ((chdiv > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  4032c6:	2aff      	cmp	r2, #255	; 0xff
  4032c8:	d9ea      	bls.n	4032a0 <twi_set_speed+0x38>
  4032ca:	2906      	cmp	r1, #6
  4032cc:	d9f9      	bls.n	4032c2 <twi_set_speed+0x5a>
  4032ce:	e7e7      	b.n	4032a0 <twi_set_speed+0x38>
		c_lh_div = ul_mck / (ul_speed * TWI_CLK_DIVIDER) - TWI_CLK_CALC_ARGU;
  4032d0:	0049      	lsls	r1, r1, #1
  4032d2:	fbb2 f2f1 	udiv	r2, r2, r1
  4032d6:	3a04      	subs	r2, #4
		while ((c_lh_div > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  4032d8:	2aff      	cmp	r2, #255	; 0xff
  4032da:	d911      	bls.n	403300 <twi_set_speed+0x98>
  4032dc:	2300      	movs	r3, #0
			ckdiv++;
  4032de:	3301      	adds	r3, #1
			c_lh_div /= TWI_CLK_DIVIDER;
  4032e0:	0852      	lsrs	r2, r2, #1
		while ((c_lh_div > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  4032e2:	2aff      	cmp	r2, #255	; 0xff
  4032e4:	d901      	bls.n	4032ea <twi_set_speed+0x82>
  4032e6:	2b07      	cmp	r3, #7
  4032e8:	d1f9      	bne.n	4032de <twi_set_speed+0x76>
				TWI_CWGR_CLDIV(c_lh_div) | TWI_CWGR_CHDIV(c_lh_div) |
  4032ea:	0211      	lsls	r1, r2, #8
  4032ec:	b289      	uxth	r1, r1
				TWI_CWGR_CKDIV(ckdiv);
  4032ee:	041b      	lsls	r3, r3, #16
  4032f0:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
				TWI_CWGR_CLDIV(c_lh_div) | TWI_CWGR_CHDIV(c_lh_div) |
  4032f4:	430b      	orrs	r3, r1
  4032f6:	b2d2      	uxtb	r2, r2
  4032f8:	431a      	orrs	r2, r3
		p_twi->TWI_CWGR =
  4032fa:	6102      	str	r2, [r0, #16]
	return PASS;
  4032fc:	2000      	movs	r0, #0
  4032fe:	4770      	bx	lr
	uint32_t ckdiv = 0;
  403300:	2300      	movs	r3, #0
  403302:	e7f2      	b.n	4032ea <twi_set_speed+0x82>
		return FAIL;
  403304:	2001      	movs	r0, #1
  403306:	4770      	bx	lr
		while ((chdiv > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  403308:	2aff      	cmp	r2, #255	; 0xff
	uint32_t ckdiv = 0;
  40330a:	bf88      	it	hi
  40330c:	2100      	movhi	r1, #0
		while ((chdiv > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  40330e:	d8d8      	bhi.n	4032c2 <twi_set_speed+0x5a>
	uint32_t ckdiv = 0;
  403310:	2100      	movs	r1, #0
  403312:	e7c5      	b.n	4032a0 <twi_set_speed+0x38>
  403314:	00061a80 	.word	0x00061a80
  403318:	057619f1 	.word	0x057619f1
  40331c:	3ffd1200 	.word	0x3ffd1200

00403320 <twi_master_init>:
{
  403320:	b538      	push	{r3, r4, r5, lr}
  403322:	4604      	mov	r4, r0
  403324:	460d      	mov	r5, r1
	p_twi->TWI_IDR = ~0UL;
  403326:	f04f 33ff 	mov.w	r3, #4294967295
  40332a:	6283      	str	r3, [r0, #40]	; 0x28
	p_twi->TWI_SR;
  40332c:	6a03      	ldr	r3, [r0, #32]
 * \param p_twi Pointer to a TWI instance.
 */
void twi_reset(Twi *p_twi)
{
	/* Set SWRST bit to reset TWI peripheral */
	p_twi->TWI_CR = TWI_CR_SWRST;
  40332e:	2380      	movs	r3, #128	; 0x80
  403330:	6003      	str	r3, [r0, #0]
	p_twi->TWI_RHR;
  403332:	6b03      	ldr	r3, [r0, #48]	; 0x30
	p_twi->TWI_CR = TWI_CR_MSDIS;
  403334:	2308      	movs	r3, #8
  403336:	6003      	str	r3, [r0, #0]
	p_twi->TWI_CR = TWI_CR_SVDIS;
  403338:	2320      	movs	r3, #32
  40333a:	6003      	str	r3, [r0, #0]
	p_twi->TWI_CR = TWI_CR_MSEN;
  40333c:	2304      	movs	r3, #4
  40333e:	6003      	str	r3, [r0, #0]
	if (twi_set_speed(p_twi, p_opt->speed, p_opt->master_clk) == FAIL) {
  403340:	680a      	ldr	r2, [r1, #0]
  403342:	6849      	ldr	r1, [r1, #4]
  403344:	4b05      	ldr	r3, [pc, #20]	; (40335c <twi_master_init+0x3c>)
  403346:	4798      	blx	r3
  403348:	2801      	cmp	r0, #1
  40334a:	bf14      	ite	ne
  40334c:	2000      	movne	r0, #0
  40334e:	2001      	moveq	r0, #1
	if (p_opt->smbus == 1) {
  403350:	7a6b      	ldrb	r3, [r5, #9]
  403352:	2b01      	cmp	r3, #1
		p_twi->TWI_CR = TWI_CR_QUICK;
  403354:	bf04      	itt	eq
  403356:	2340      	moveq	r3, #64	; 0x40
  403358:	6023      	streq	r3, [r4, #0]
}
  40335a:	bd38      	pop	{r3, r4, r5, pc}
  40335c:	00403269 	.word	0x00403269

00403360 <twi_mk_addr>:
	if (len == 0)
  403360:	460a      	mov	r2, r1
  403362:	b159      	cbz	r1, 40337c <twi_mk_addr+0x1c>
	val = addr[0];
  403364:	7803      	ldrb	r3, [r0, #0]
	if (len > 1) {
  403366:	2901      	cmp	r1, #1
		val |= addr[1];
  403368:	bfc4      	itt	gt
  40336a:	7841      	ldrbgt	r1, [r0, #1]
  40336c:	ea41 2303 	orrgt.w	r3, r1, r3, lsl #8
	if (len > 2) {
  403370:	2a02      	cmp	r2, #2
  403372:	dd04      	ble.n	40337e <twi_mk_addr+0x1e>
		val |= addr[2];
  403374:	7882      	ldrb	r2, [r0, #2]
  403376:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
  40337a:	e000      	b.n	40337e <twi_mk_addr+0x1e>
		return 0;
  40337c:	2300      	movs	r3, #0
}
  40337e:	4618      	mov	r0, r3
  403380:	4770      	bx	lr
	...

00403384 <twi_master_write>:
{
  403384:	b570      	push	{r4, r5, r6, lr}
	uint32_t cnt = p_packet->length;
  403386:	68cd      	ldr	r5, [r1, #12]
	if (cnt == 0) {
  403388:	2d00      	cmp	r5, #0
  40338a:	d035      	beq.n	4033f8 <twi_master_write+0x74>
  40338c:	460b      	mov	r3, r1
  40338e:	4604      	mov	r4, r0
	uint8_t *buffer = p_packet->buffer;
  403390:	688e      	ldr	r6, [r1, #8]
	p_twi->TWI_MMR = 0;
  403392:	2000      	movs	r0, #0
  403394:	6060      	str	r0, [r4, #4]
	p_twi->TWI_MMR = TWI_MMR_DADR(p_packet->chip) |
  403396:	7c0a      	ldrb	r2, [r1, #16]
  403398:	0412      	lsls	r2, r2, #16
  40339a:	f402 02fe 	and.w	r2, r2, #8323072	; 0x7f0000
			((p_packet->addr_length << TWI_MMR_IADRSZ_Pos) &
  40339e:	6849      	ldr	r1, [r1, #4]
  4033a0:	0209      	lsls	r1, r1, #8
  4033a2:	f401 7140 	and.w	r1, r1, #768	; 0x300
	p_twi->TWI_MMR = TWI_MMR_DADR(p_packet->chip) |
  4033a6:	430a      	orrs	r2, r1
  4033a8:	6062      	str	r2, [r4, #4]
	p_twi->TWI_IADR = 0;
  4033aa:	60e0      	str	r0, [r4, #12]
	p_twi->TWI_IADR = twi_mk_addr(p_packet->addr, p_packet->addr_length);
  4033ac:	6859      	ldr	r1, [r3, #4]
  4033ae:	4618      	mov	r0, r3
  4033b0:	4b15      	ldr	r3, [pc, #84]	; (403408 <twi_master_write+0x84>)
  4033b2:	4798      	blx	r3
  4033b4:	60e0      	str	r0, [r4, #12]
		status = p_twi->TWI_SR;
  4033b6:	6a23      	ldr	r3, [r4, #32]
		if (status & TWI_SR_NACK) {
  4033b8:	f413 7f80 	tst.w	r3, #256	; 0x100
  4033bc:	d006      	beq.n	4033cc <twi_master_write+0x48>
			return TWI_RECEIVE_NACK;
  4033be:	2505      	movs	r5, #5
  4033c0:	e01b      	b.n	4033fa <twi_master_write+0x76>
	while (cnt > 0) {
  4033c2:	b15d      	cbz	r5, 4033dc <twi_master_write+0x58>
		status = p_twi->TWI_SR;
  4033c4:	6a23      	ldr	r3, [r4, #32]
		if (status & TWI_SR_NACK) {
  4033c6:	f413 7f80 	tst.w	r3, #256	; 0x100
  4033ca:	d118      	bne.n	4033fe <twi_master_write+0x7a>
		if (!(status & TWI_SR_TXRDY)) {
  4033cc:	f013 0f04 	tst.w	r3, #4
  4033d0:	d0f7      	beq.n	4033c2 <twi_master_write+0x3e>
		p_twi->TWI_THR = *buffer++;
  4033d2:	7833      	ldrb	r3, [r6, #0]
  4033d4:	6363      	str	r3, [r4, #52]	; 0x34
		cnt--;
  4033d6:	3d01      	subs	r5, #1
		p_twi->TWI_THR = *buffer++;
  4033d8:	3601      	adds	r6, #1
  4033da:	e7f2      	b.n	4033c2 <twi_master_write+0x3e>
		status = p_twi->TWI_SR;
  4033dc:	6a23      	ldr	r3, [r4, #32]
		if (status & TWI_SR_NACK) {
  4033de:	f413 7f80 	tst.w	r3, #256	; 0x100
  4033e2:	d10e      	bne.n	403402 <twi_master_write+0x7e>
		if (status & TWI_SR_TXRDY) {
  4033e4:	f013 0f04 	tst.w	r3, #4
  4033e8:	d0f8      	beq.n	4033dc <twi_master_write+0x58>
	p_twi->TWI_CR = TWI_CR_STOP;
  4033ea:	2302      	movs	r3, #2
  4033ec:	6023      	str	r3, [r4, #0]
	while (!(p_twi->TWI_SR & TWI_SR_TXCOMP)) {
  4033ee:	6a23      	ldr	r3, [r4, #32]
  4033f0:	f013 0f01 	tst.w	r3, #1
  4033f4:	d0fb      	beq.n	4033ee <twi_master_write+0x6a>
  4033f6:	e000      	b.n	4033fa <twi_master_write+0x76>
		return TWI_INVALID_ARGUMENT;
  4033f8:	2501      	movs	r5, #1
}
  4033fa:	4628      	mov	r0, r5
  4033fc:	bd70      	pop	{r4, r5, r6, pc}
			return TWI_RECEIVE_NACK;
  4033fe:	2505      	movs	r5, #5
  403400:	e7fb      	b.n	4033fa <twi_master_write+0x76>
			return TWI_RECEIVE_NACK;
  403402:	2505      	movs	r5, #5
  403404:	e7f9      	b.n	4033fa <twi_master_write+0x76>
  403406:	bf00      	nop
  403408:	00403361 	.word	0x00403361

0040340c <__aeabi_uldivmod>:
  40340c:	b953      	cbnz	r3, 403424 <__aeabi_uldivmod+0x18>
  40340e:	b94a      	cbnz	r2, 403424 <__aeabi_uldivmod+0x18>
  403410:	2900      	cmp	r1, #0
  403412:	bf08      	it	eq
  403414:	2800      	cmpeq	r0, #0
  403416:	bf1c      	itt	ne
  403418:	f04f 31ff 	movne.w	r1, #4294967295
  40341c:	f04f 30ff 	movne.w	r0, #4294967295
  403420:	f000 b97a 	b.w	403718 <__aeabi_idiv0>
  403424:	f1ad 0c08 	sub.w	ip, sp, #8
  403428:	e96d ce04 	strd	ip, lr, [sp, #-16]!
  40342c:	f000 f806 	bl	40343c <__udivmoddi4>
  403430:	f8dd e004 	ldr.w	lr, [sp, #4]
  403434:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  403438:	b004      	add	sp, #16
  40343a:	4770      	bx	lr

0040343c <__udivmoddi4>:
  40343c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  403440:	468c      	mov	ip, r1
  403442:	460d      	mov	r5, r1
  403444:	4604      	mov	r4, r0
  403446:	9e08      	ldr	r6, [sp, #32]
  403448:	2b00      	cmp	r3, #0
  40344a:	d151      	bne.n	4034f0 <__udivmoddi4+0xb4>
  40344c:	428a      	cmp	r2, r1
  40344e:	4617      	mov	r7, r2
  403450:	d96d      	bls.n	40352e <__udivmoddi4+0xf2>
  403452:	fab2 fe82 	clz	lr, r2
  403456:	f1be 0f00 	cmp.w	lr, #0
  40345a:	d00b      	beq.n	403474 <__udivmoddi4+0x38>
  40345c:	f1ce 0c20 	rsb	ip, lr, #32
  403460:	fa01 f50e 	lsl.w	r5, r1, lr
  403464:	fa20 fc0c 	lsr.w	ip, r0, ip
  403468:	fa02 f70e 	lsl.w	r7, r2, lr
  40346c:	ea4c 0c05 	orr.w	ip, ip, r5
  403470:	fa00 f40e 	lsl.w	r4, r0, lr
  403474:	ea4f 4a17 	mov.w	sl, r7, lsr #16
  403478:	0c25      	lsrs	r5, r4, #16
  40347a:	fbbc f8fa 	udiv	r8, ip, sl
  40347e:	fa1f f987 	uxth.w	r9, r7
  403482:	fb0a cc18 	mls	ip, sl, r8, ip
  403486:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
  40348a:	fb08 f309 	mul.w	r3, r8, r9
  40348e:	42ab      	cmp	r3, r5
  403490:	d90a      	bls.n	4034a8 <__udivmoddi4+0x6c>
  403492:	19ed      	adds	r5, r5, r7
  403494:	f108 32ff 	add.w	r2, r8, #4294967295
  403498:	f080 8123 	bcs.w	4036e2 <__udivmoddi4+0x2a6>
  40349c:	42ab      	cmp	r3, r5
  40349e:	f240 8120 	bls.w	4036e2 <__udivmoddi4+0x2a6>
  4034a2:	f1a8 0802 	sub.w	r8, r8, #2
  4034a6:	443d      	add	r5, r7
  4034a8:	1aed      	subs	r5, r5, r3
  4034aa:	b2a4      	uxth	r4, r4
  4034ac:	fbb5 f0fa 	udiv	r0, r5, sl
  4034b0:	fb0a 5510 	mls	r5, sl, r0, r5
  4034b4:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
  4034b8:	fb00 f909 	mul.w	r9, r0, r9
  4034bc:	45a1      	cmp	r9, r4
  4034be:	d909      	bls.n	4034d4 <__udivmoddi4+0x98>
  4034c0:	19e4      	adds	r4, r4, r7
  4034c2:	f100 33ff 	add.w	r3, r0, #4294967295
  4034c6:	f080 810a 	bcs.w	4036de <__udivmoddi4+0x2a2>
  4034ca:	45a1      	cmp	r9, r4
  4034cc:	f240 8107 	bls.w	4036de <__udivmoddi4+0x2a2>
  4034d0:	3802      	subs	r0, #2
  4034d2:	443c      	add	r4, r7
  4034d4:	eba4 0409 	sub.w	r4, r4, r9
  4034d8:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
  4034dc:	2100      	movs	r1, #0
  4034de:	2e00      	cmp	r6, #0
  4034e0:	d061      	beq.n	4035a6 <__udivmoddi4+0x16a>
  4034e2:	fa24 f40e 	lsr.w	r4, r4, lr
  4034e6:	2300      	movs	r3, #0
  4034e8:	6034      	str	r4, [r6, #0]
  4034ea:	6073      	str	r3, [r6, #4]
  4034ec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  4034f0:	428b      	cmp	r3, r1
  4034f2:	d907      	bls.n	403504 <__udivmoddi4+0xc8>
  4034f4:	2e00      	cmp	r6, #0
  4034f6:	d054      	beq.n	4035a2 <__udivmoddi4+0x166>
  4034f8:	2100      	movs	r1, #0
  4034fa:	e886 0021 	stmia.w	r6, {r0, r5}
  4034fe:	4608      	mov	r0, r1
  403500:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  403504:	fab3 f183 	clz	r1, r3
  403508:	2900      	cmp	r1, #0
  40350a:	f040 808e 	bne.w	40362a <__udivmoddi4+0x1ee>
  40350e:	42ab      	cmp	r3, r5
  403510:	d302      	bcc.n	403518 <__udivmoddi4+0xdc>
  403512:	4282      	cmp	r2, r0
  403514:	f200 80fa 	bhi.w	40370c <__udivmoddi4+0x2d0>
  403518:	1a84      	subs	r4, r0, r2
  40351a:	eb65 0503 	sbc.w	r5, r5, r3
  40351e:	2001      	movs	r0, #1
  403520:	46ac      	mov	ip, r5
  403522:	2e00      	cmp	r6, #0
  403524:	d03f      	beq.n	4035a6 <__udivmoddi4+0x16a>
  403526:	e886 1010 	stmia.w	r6, {r4, ip}
  40352a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  40352e:	b912      	cbnz	r2, 403536 <__udivmoddi4+0xfa>
  403530:	2701      	movs	r7, #1
  403532:	fbb7 f7f2 	udiv	r7, r7, r2
  403536:	fab7 fe87 	clz	lr, r7
  40353a:	f1be 0f00 	cmp.w	lr, #0
  40353e:	d134      	bne.n	4035aa <__udivmoddi4+0x16e>
  403540:	1beb      	subs	r3, r5, r7
  403542:	0c3a      	lsrs	r2, r7, #16
  403544:	fa1f fc87 	uxth.w	ip, r7
  403548:	2101      	movs	r1, #1
  40354a:	fbb3 f8f2 	udiv	r8, r3, r2
  40354e:	0c25      	lsrs	r5, r4, #16
  403550:	fb02 3318 	mls	r3, r2, r8, r3
  403554:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
  403558:	fb0c f308 	mul.w	r3, ip, r8
  40355c:	42ab      	cmp	r3, r5
  40355e:	d907      	bls.n	403570 <__udivmoddi4+0x134>
  403560:	19ed      	adds	r5, r5, r7
  403562:	f108 30ff 	add.w	r0, r8, #4294967295
  403566:	d202      	bcs.n	40356e <__udivmoddi4+0x132>
  403568:	42ab      	cmp	r3, r5
  40356a:	f200 80d1 	bhi.w	403710 <__udivmoddi4+0x2d4>
  40356e:	4680      	mov	r8, r0
  403570:	1aed      	subs	r5, r5, r3
  403572:	b2a3      	uxth	r3, r4
  403574:	fbb5 f0f2 	udiv	r0, r5, r2
  403578:	fb02 5510 	mls	r5, r2, r0, r5
  40357c:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
  403580:	fb0c fc00 	mul.w	ip, ip, r0
  403584:	45a4      	cmp	ip, r4
  403586:	d907      	bls.n	403598 <__udivmoddi4+0x15c>
  403588:	19e4      	adds	r4, r4, r7
  40358a:	f100 33ff 	add.w	r3, r0, #4294967295
  40358e:	d202      	bcs.n	403596 <__udivmoddi4+0x15a>
  403590:	45a4      	cmp	ip, r4
  403592:	f200 80b8 	bhi.w	403706 <__udivmoddi4+0x2ca>
  403596:	4618      	mov	r0, r3
  403598:	eba4 040c 	sub.w	r4, r4, ip
  40359c:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
  4035a0:	e79d      	b.n	4034de <__udivmoddi4+0xa2>
  4035a2:	4631      	mov	r1, r6
  4035a4:	4630      	mov	r0, r6
  4035a6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  4035aa:	f1ce 0420 	rsb	r4, lr, #32
  4035ae:	fa05 f30e 	lsl.w	r3, r5, lr
  4035b2:	fa07 f70e 	lsl.w	r7, r7, lr
  4035b6:	fa20 f804 	lsr.w	r8, r0, r4
  4035ba:	0c3a      	lsrs	r2, r7, #16
  4035bc:	fa25 f404 	lsr.w	r4, r5, r4
  4035c0:	ea48 0803 	orr.w	r8, r8, r3
  4035c4:	fbb4 f1f2 	udiv	r1, r4, r2
  4035c8:	ea4f 4518 	mov.w	r5, r8, lsr #16
  4035cc:	fb02 4411 	mls	r4, r2, r1, r4
  4035d0:	fa1f fc87 	uxth.w	ip, r7
  4035d4:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
  4035d8:	fb01 f30c 	mul.w	r3, r1, ip
  4035dc:	42ab      	cmp	r3, r5
  4035de:	fa00 f40e 	lsl.w	r4, r0, lr
  4035e2:	d909      	bls.n	4035f8 <__udivmoddi4+0x1bc>
  4035e4:	19ed      	adds	r5, r5, r7
  4035e6:	f101 30ff 	add.w	r0, r1, #4294967295
  4035ea:	f080 808a 	bcs.w	403702 <__udivmoddi4+0x2c6>
  4035ee:	42ab      	cmp	r3, r5
  4035f0:	f240 8087 	bls.w	403702 <__udivmoddi4+0x2c6>
  4035f4:	3902      	subs	r1, #2
  4035f6:	443d      	add	r5, r7
  4035f8:	1aeb      	subs	r3, r5, r3
  4035fa:	fa1f f588 	uxth.w	r5, r8
  4035fe:	fbb3 f0f2 	udiv	r0, r3, r2
  403602:	fb02 3310 	mls	r3, r2, r0, r3
  403606:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
  40360a:	fb00 f30c 	mul.w	r3, r0, ip
  40360e:	42ab      	cmp	r3, r5
  403610:	d907      	bls.n	403622 <__udivmoddi4+0x1e6>
  403612:	19ed      	adds	r5, r5, r7
  403614:	f100 38ff 	add.w	r8, r0, #4294967295
  403618:	d26f      	bcs.n	4036fa <__udivmoddi4+0x2be>
  40361a:	42ab      	cmp	r3, r5
  40361c:	d96d      	bls.n	4036fa <__udivmoddi4+0x2be>
  40361e:	3802      	subs	r0, #2
  403620:	443d      	add	r5, r7
  403622:	1aeb      	subs	r3, r5, r3
  403624:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
  403628:	e78f      	b.n	40354a <__udivmoddi4+0x10e>
  40362a:	f1c1 0720 	rsb	r7, r1, #32
  40362e:	fa22 f807 	lsr.w	r8, r2, r7
  403632:	408b      	lsls	r3, r1
  403634:	fa05 f401 	lsl.w	r4, r5, r1
  403638:	ea48 0303 	orr.w	r3, r8, r3
  40363c:	fa20 fe07 	lsr.w	lr, r0, r7
  403640:	ea4f 4c13 	mov.w	ip, r3, lsr #16
  403644:	40fd      	lsrs	r5, r7
  403646:	ea4e 0e04 	orr.w	lr, lr, r4
  40364a:	fbb5 f9fc 	udiv	r9, r5, ip
  40364e:	ea4f 441e 	mov.w	r4, lr, lsr #16
  403652:	fb0c 5519 	mls	r5, ip, r9, r5
  403656:	fa1f f883 	uxth.w	r8, r3
  40365a:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
  40365e:	fb09 f408 	mul.w	r4, r9, r8
  403662:	42ac      	cmp	r4, r5
  403664:	fa02 f201 	lsl.w	r2, r2, r1
  403668:	fa00 fa01 	lsl.w	sl, r0, r1
  40366c:	d908      	bls.n	403680 <__udivmoddi4+0x244>
  40366e:	18ed      	adds	r5, r5, r3
  403670:	f109 30ff 	add.w	r0, r9, #4294967295
  403674:	d243      	bcs.n	4036fe <__udivmoddi4+0x2c2>
  403676:	42ac      	cmp	r4, r5
  403678:	d941      	bls.n	4036fe <__udivmoddi4+0x2c2>
  40367a:	f1a9 0902 	sub.w	r9, r9, #2
  40367e:	441d      	add	r5, r3
  403680:	1b2d      	subs	r5, r5, r4
  403682:	fa1f fe8e 	uxth.w	lr, lr
  403686:	fbb5 f0fc 	udiv	r0, r5, ip
  40368a:	fb0c 5510 	mls	r5, ip, r0, r5
  40368e:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
  403692:	fb00 f808 	mul.w	r8, r0, r8
  403696:	45a0      	cmp	r8, r4
  403698:	d907      	bls.n	4036aa <__udivmoddi4+0x26e>
  40369a:	18e4      	adds	r4, r4, r3
  40369c:	f100 35ff 	add.w	r5, r0, #4294967295
  4036a0:	d229      	bcs.n	4036f6 <__udivmoddi4+0x2ba>
  4036a2:	45a0      	cmp	r8, r4
  4036a4:	d927      	bls.n	4036f6 <__udivmoddi4+0x2ba>
  4036a6:	3802      	subs	r0, #2
  4036a8:	441c      	add	r4, r3
  4036aa:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
  4036ae:	eba4 0408 	sub.w	r4, r4, r8
  4036b2:	fba0 8902 	umull	r8, r9, r0, r2
  4036b6:	454c      	cmp	r4, r9
  4036b8:	46c6      	mov	lr, r8
  4036ba:	464d      	mov	r5, r9
  4036bc:	d315      	bcc.n	4036ea <__udivmoddi4+0x2ae>
  4036be:	d012      	beq.n	4036e6 <__udivmoddi4+0x2aa>
  4036c0:	b156      	cbz	r6, 4036d8 <__udivmoddi4+0x29c>
  4036c2:	ebba 030e 	subs.w	r3, sl, lr
  4036c6:	eb64 0405 	sbc.w	r4, r4, r5
  4036ca:	fa04 f707 	lsl.w	r7, r4, r7
  4036ce:	40cb      	lsrs	r3, r1
  4036d0:	431f      	orrs	r7, r3
  4036d2:	40cc      	lsrs	r4, r1
  4036d4:	6037      	str	r7, [r6, #0]
  4036d6:	6074      	str	r4, [r6, #4]
  4036d8:	2100      	movs	r1, #0
  4036da:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  4036de:	4618      	mov	r0, r3
  4036e0:	e6f8      	b.n	4034d4 <__udivmoddi4+0x98>
  4036e2:	4690      	mov	r8, r2
  4036e4:	e6e0      	b.n	4034a8 <__udivmoddi4+0x6c>
  4036e6:	45c2      	cmp	sl, r8
  4036e8:	d2ea      	bcs.n	4036c0 <__udivmoddi4+0x284>
  4036ea:	ebb8 0e02 	subs.w	lr, r8, r2
  4036ee:	eb69 0503 	sbc.w	r5, r9, r3
  4036f2:	3801      	subs	r0, #1
  4036f4:	e7e4      	b.n	4036c0 <__udivmoddi4+0x284>
  4036f6:	4628      	mov	r0, r5
  4036f8:	e7d7      	b.n	4036aa <__udivmoddi4+0x26e>
  4036fa:	4640      	mov	r0, r8
  4036fc:	e791      	b.n	403622 <__udivmoddi4+0x1e6>
  4036fe:	4681      	mov	r9, r0
  403700:	e7be      	b.n	403680 <__udivmoddi4+0x244>
  403702:	4601      	mov	r1, r0
  403704:	e778      	b.n	4035f8 <__udivmoddi4+0x1bc>
  403706:	3802      	subs	r0, #2
  403708:	443c      	add	r4, r7
  40370a:	e745      	b.n	403598 <__udivmoddi4+0x15c>
  40370c:	4608      	mov	r0, r1
  40370e:	e708      	b.n	403522 <__udivmoddi4+0xe6>
  403710:	f1a8 0802 	sub.w	r8, r8, #2
  403714:	443d      	add	r5, r7
  403716:	e72b      	b.n	403570 <__udivmoddi4+0x134>

00403718 <__aeabi_idiv0>:
  403718:	4770      	bx	lr
  40371a:	bf00      	nop

0040371c <__libc_init_array>:
  40371c:	b570      	push	{r4, r5, r6, lr}
  40371e:	4e0f      	ldr	r6, [pc, #60]	; (40375c <__libc_init_array+0x40>)
  403720:	4d0f      	ldr	r5, [pc, #60]	; (403760 <__libc_init_array+0x44>)
  403722:	1b76      	subs	r6, r6, r5
  403724:	10b6      	asrs	r6, r6, #2
  403726:	bf18      	it	ne
  403728:	2400      	movne	r4, #0
  40372a:	d005      	beq.n	403738 <__libc_init_array+0x1c>
  40372c:	3401      	adds	r4, #1
  40372e:	f855 3b04 	ldr.w	r3, [r5], #4
  403732:	4798      	blx	r3
  403734:	42a6      	cmp	r6, r4
  403736:	d1f9      	bne.n	40372c <__libc_init_array+0x10>
  403738:	4e0a      	ldr	r6, [pc, #40]	; (403764 <__libc_init_array+0x48>)
  40373a:	4d0b      	ldr	r5, [pc, #44]	; (403768 <__libc_init_array+0x4c>)
  40373c:	1b76      	subs	r6, r6, r5
  40373e:	f000 fcc3 	bl	4040c8 <_init>
  403742:	10b6      	asrs	r6, r6, #2
  403744:	bf18      	it	ne
  403746:	2400      	movne	r4, #0
  403748:	d006      	beq.n	403758 <__libc_init_array+0x3c>
  40374a:	3401      	adds	r4, #1
  40374c:	f855 3b04 	ldr.w	r3, [r5], #4
  403750:	4798      	blx	r3
  403752:	42a6      	cmp	r6, r4
  403754:	d1f9      	bne.n	40374a <__libc_init_array+0x2e>
  403756:	bd70      	pop	{r4, r5, r6, pc}
  403758:	bd70      	pop	{r4, r5, r6, pc}
  40375a:	bf00      	nop
  40375c:	004040d4 	.word	0x004040d4
  403760:	004040d4 	.word	0x004040d4
  403764:	004040dc 	.word	0x004040dc
  403768:	004040d4 	.word	0x004040d4

0040376c <memset>:
  40376c:	b470      	push	{r4, r5, r6}
  40376e:	0786      	lsls	r6, r0, #30
  403770:	d046      	beq.n	403800 <memset+0x94>
  403772:	1e54      	subs	r4, r2, #1
  403774:	2a00      	cmp	r2, #0
  403776:	d041      	beq.n	4037fc <memset+0x90>
  403778:	b2ca      	uxtb	r2, r1
  40377a:	4603      	mov	r3, r0
  40377c:	e002      	b.n	403784 <memset+0x18>
  40377e:	f114 34ff 	adds.w	r4, r4, #4294967295
  403782:	d33b      	bcc.n	4037fc <memset+0x90>
  403784:	f803 2b01 	strb.w	r2, [r3], #1
  403788:	079d      	lsls	r5, r3, #30
  40378a:	d1f8      	bne.n	40377e <memset+0x12>
  40378c:	2c03      	cmp	r4, #3
  40378e:	d92e      	bls.n	4037ee <memset+0x82>
  403790:	b2cd      	uxtb	r5, r1
  403792:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
  403796:	2c0f      	cmp	r4, #15
  403798:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
  40379c:	d919      	bls.n	4037d2 <memset+0x66>
  40379e:	f103 0210 	add.w	r2, r3, #16
  4037a2:	4626      	mov	r6, r4
  4037a4:	3e10      	subs	r6, #16
  4037a6:	2e0f      	cmp	r6, #15
  4037a8:	f842 5c10 	str.w	r5, [r2, #-16]
  4037ac:	f842 5c0c 	str.w	r5, [r2, #-12]
  4037b0:	f842 5c08 	str.w	r5, [r2, #-8]
  4037b4:	f842 5c04 	str.w	r5, [r2, #-4]
  4037b8:	f102 0210 	add.w	r2, r2, #16
  4037bc:	d8f2      	bhi.n	4037a4 <memset+0x38>
  4037be:	f1a4 0210 	sub.w	r2, r4, #16
  4037c2:	f022 020f 	bic.w	r2, r2, #15
  4037c6:	f004 040f 	and.w	r4, r4, #15
  4037ca:	3210      	adds	r2, #16
  4037cc:	2c03      	cmp	r4, #3
  4037ce:	4413      	add	r3, r2
  4037d0:	d90d      	bls.n	4037ee <memset+0x82>
  4037d2:	461e      	mov	r6, r3
  4037d4:	4622      	mov	r2, r4
  4037d6:	3a04      	subs	r2, #4
  4037d8:	2a03      	cmp	r2, #3
  4037da:	f846 5b04 	str.w	r5, [r6], #4
  4037de:	d8fa      	bhi.n	4037d6 <memset+0x6a>
  4037e0:	1f22      	subs	r2, r4, #4
  4037e2:	f022 0203 	bic.w	r2, r2, #3
  4037e6:	3204      	adds	r2, #4
  4037e8:	4413      	add	r3, r2
  4037ea:	f004 0403 	and.w	r4, r4, #3
  4037ee:	b12c      	cbz	r4, 4037fc <memset+0x90>
  4037f0:	b2c9      	uxtb	r1, r1
  4037f2:	441c      	add	r4, r3
  4037f4:	f803 1b01 	strb.w	r1, [r3], #1
  4037f8:	429c      	cmp	r4, r3
  4037fa:	d1fb      	bne.n	4037f4 <memset+0x88>
  4037fc:	bc70      	pop	{r4, r5, r6}
  4037fe:	4770      	bx	lr
  403800:	4614      	mov	r4, r2
  403802:	4603      	mov	r3, r0
  403804:	e7c2      	b.n	40378c <memset+0x20>
  403806:	bf00      	nop

00403808 <register_fini>:
  403808:	4b02      	ldr	r3, [pc, #8]	; (403814 <register_fini+0xc>)
  40380a:	b113      	cbz	r3, 403812 <register_fini+0xa>
  40380c:	4802      	ldr	r0, [pc, #8]	; (403818 <register_fini+0x10>)
  40380e:	f000 b805 	b.w	40381c <atexit>
  403812:	4770      	bx	lr
  403814:	00000000 	.word	0x00000000
  403818:	00403829 	.word	0x00403829

0040381c <atexit>:
  40381c:	2300      	movs	r3, #0
  40381e:	4601      	mov	r1, r0
  403820:	461a      	mov	r2, r3
  403822:	4618      	mov	r0, r3
  403824:	f000 b81e 	b.w	403864 <__register_exitproc>

00403828 <__libc_fini_array>:
  403828:	b538      	push	{r3, r4, r5, lr}
  40382a:	4c0a      	ldr	r4, [pc, #40]	; (403854 <__libc_fini_array+0x2c>)
  40382c:	4d0a      	ldr	r5, [pc, #40]	; (403858 <__libc_fini_array+0x30>)
  40382e:	1b64      	subs	r4, r4, r5
  403830:	10a4      	asrs	r4, r4, #2
  403832:	d00a      	beq.n	40384a <__libc_fini_array+0x22>
  403834:	f104 4380 	add.w	r3, r4, #1073741824	; 0x40000000
  403838:	3b01      	subs	r3, #1
  40383a:	eb05 0583 	add.w	r5, r5, r3, lsl #2
  40383e:	3c01      	subs	r4, #1
  403840:	f855 3904 	ldr.w	r3, [r5], #-4
  403844:	4798      	blx	r3
  403846:	2c00      	cmp	r4, #0
  403848:	d1f9      	bne.n	40383e <__libc_fini_array+0x16>
  40384a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  40384e:	f000 bc45 	b.w	4040dc <_fini>
  403852:	bf00      	nop
  403854:	004040ec 	.word	0x004040ec
  403858:	004040e8 	.word	0x004040e8

0040385c <__retarget_lock_acquire_recursive>:
  40385c:	4770      	bx	lr
  40385e:	bf00      	nop

00403860 <__retarget_lock_release_recursive>:
  403860:	4770      	bx	lr
  403862:	bf00      	nop

00403864 <__register_exitproc>:
  403864:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  403868:	4d2c      	ldr	r5, [pc, #176]	; (40391c <__register_exitproc+0xb8>)
  40386a:	4606      	mov	r6, r0
  40386c:	6828      	ldr	r0, [r5, #0]
  40386e:	4698      	mov	r8, r3
  403870:	460f      	mov	r7, r1
  403872:	4691      	mov	r9, r2
  403874:	f7ff fff2 	bl	40385c <__retarget_lock_acquire_recursive>
  403878:	4b29      	ldr	r3, [pc, #164]	; (403920 <__register_exitproc+0xbc>)
  40387a:	681c      	ldr	r4, [r3, #0]
  40387c:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
  403880:	2b00      	cmp	r3, #0
  403882:	d03e      	beq.n	403902 <__register_exitproc+0x9e>
  403884:	685a      	ldr	r2, [r3, #4]
  403886:	2a1f      	cmp	r2, #31
  403888:	dc1c      	bgt.n	4038c4 <__register_exitproc+0x60>
  40388a:	f102 0e01 	add.w	lr, r2, #1
  40388e:	b176      	cbz	r6, 4038ae <__register_exitproc+0x4a>
  403890:	eb03 0182 	add.w	r1, r3, r2, lsl #2
  403894:	2401      	movs	r4, #1
  403896:	f8c1 9088 	str.w	r9, [r1, #136]	; 0x88
  40389a:	f8d3 0188 	ldr.w	r0, [r3, #392]	; 0x188
  40389e:	4094      	lsls	r4, r2
  4038a0:	4320      	orrs	r0, r4
  4038a2:	2e02      	cmp	r6, #2
  4038a4:	f8c3 0188 	str.w	r0, [r3, #392]	; 0x188
  4038a8:	f8c1 8108 	str.w	r8, [r1, #264]	; 0x108
  4038ac:	d023      	beq.n	4038f6 <__register_exitproc+0x92>
  4038ae:	3202      	adds	r2, #2
  4038b0:	f8c3 e004 	str.w	lr, [r3, #4]
  4038b4:	6828      	ldr	r0, [r5, #0]
  4038b6:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
  4038ba:	f7ff ffd1 	bl	403860 <__retarget_lock_release_recursive>
  4038be:	2000      	movs	r0, #0
  4038c0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  4038c4:	4b17      	ldr	r3, [pc, #92]	; (403924 <__register_exitproc+0xc0>)
  4038c6:	b30b      	cbz	r3, 40390c <__register_exitproc+0xa8>
  4038c8:	f44f 70c8 	mov.w	r0, #400	; 0x190
  4038cc:	f3af 8000 	nop.w
  4038d0:	4603      	mov	r3, r0
  4038d2:	b1d8      	cbz	r0, 40390c <__register_exitproc+0xa8>
  4038d4:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
  4038d8:	6002      	str	r2, [r0, #0]
  4038da:	2100      	movs	r1, #0
  4038dc:	6041      	str	r1, [r0, #4]
  4038de:	460a      	mov	r2, r1
  4038e0:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
  4038e4:	f04f 0e01 	mov.w	lr, #1
  4038e8:	f8c0 1188 	str.w	r1, [r0, #392]	; 0x188
  4038ec:	f8c0 118c 	str.w	r1, [r0, #396]	; 0x18c
  4038f0:	2e00      	cmp	r6, #0
  4038f2:	d0dc      	beq.n	4038ae <__register_exitproc+0x4a>
  4038f4:	e7cc      	b.n	403890 <__register_exitproc+0x2c>
  4038f6:	f8d3 118c 	ldr.w	r1, [r3, #396]	; 0x18c
  4038fa:	430c      	orrs	r4, r1
  4038fc:	f8c3 418c 	str.w	r4, [r3, #396]	; 0x18c
  403900:	e7d5      	b.n	4038ae <__register_exitproc+0x4a>
  403902:	f504 73a6 	add.w	r3, r4, #332	; 0x14c
  403906:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
  40390a:	e7bb      	b.n	403884 <__register_exitproc+0x20>
  40390c:	6828      	ldr	r0, [r5, #0]
  40390e:	f7ff ffa7 	bl	403860 <__retarget_lock_release_recursive>
  403912:	f04f 30ff 	mov.w	r0, #4294967295
  403916:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  40391a:	bf00      	nop
  40391c:	20000438 	.word	0x20000438
  403920:	004040c4 	.word	0x004040c4
  403924:	00000000 	.word	0x00000000

00403928 <IO_SENSOR>:
	...
  403938:	400e1000 0000000a 00004000 0000002e     ...@.....@......
  403948:	400e1000 0000000a 00002000 0000002d     ...@..... ..-...
  403958:	400e1400 0000000c 00000001 00000060     ...@........`...
  403968:	400e1400 0000000c 80000000 0000007f     ...@............
  403978:	400e1600 0000000d 00000008 00000083     ...@............
  403988:	400e1600 0000000d 00000001 00000080     ...@............
  403998:	400e1600 0000000d 00000002 00000081     ...@............
  4039a8:	400e1600 0000000d 00000004 00000082     ...@............
  4039b8:	400e1200 0000000b 08000000 0000005b     ...@........[...
  4039c8:	400e1200 0000000b 00000001 00000040     ...@........@...
  4039d8:	400e1200 0000000b 04000000 0000005a     ...@........Z...
  4039e8:	400e1200 0000000b 80000000 0000005f     ...@........_...
  4039f8:	400e1200 0000000b 40000000 0000005e     ...@.......@^...
  403a08:	400e1200 0000000b 20000000 0000005d     ...@....... ]...
  403a18:	400e1200 0000000b 00002000 0000004d     ...@..... ..M...
  403a28:	400e1000 0000000a 00000001 00000020     ...@........ ...
  403a38:	400e1000 0000000a 00000002 00000021     ...@........!...
  403a48:	400e0e00 00000009 00100000 00000014     ...@............
  403a58:	400e0e00 00000009 00020000 00000011     ...@............
  403a68:	400e1600 0000000d 00000010 00000084     ...@............
  403a78:	400e0e00 00000009 00080000 00000013     ...@............
  403a88:	400e1600 0000000d 00000020 00000085     ...@.... .......
  403a98:	400e1000 0000000a 00000004 00000022     ...@........"...
  403aa8:	400e0e00 00000009 00040000 00000012     ...@............
  403ab8:	400e0e00 00000009 00200000 00000015     ...@...... .....
  403ac8:	400e1000 0000000a 00000008 00000023     ...@........#...
  403ad8:	400e1400 0000000c 04000000 0000007a     ...@........z...
  403ae8:	400e1400 0000000c 40000000 0000007e     ...@.......@~...
  403af8:	400e0e00 00000009 00800000 00000017     ...@............
  403b08:	400e0e00 00000009 00004000 0000000e     ...@.....@......
  403b18:	400e1400 0000000c 00200000 00000075     ...@...... .u...
  403b28:	400e1400 0000000c 02000000 00000079     ...@........y...
  403b38:	400e0e00 00000009 00010000 00000010     ...@............
  403b48:	400e1400 0000000c 00100000 00000074     ...@........t...
  403b58:	400e0e00 00000009 00008000 0000000f     ...@............
  403b68:	400e1200 0000000b 00000080 00000047     ...@........G...
  403b78:	400e1400 0000000c 08000000 0000007b     ...@........{...
  403b88:	400e0e00 00000009 00400000 00000016     ...@......@.....
  403b98:	400e1200 0000000b 00000002 00000041     ...@........A...
  403ba8:	400e1200 0000000b 00000004 00000042     ...@........B...
  403bb8:	400e1200 0000000b 00000008 00000043     ...@........C...
  403bc8:	400e1200 0000000b 00000010 00000044     ...@........D...
  403bd8:	400e0e00 00000009 00002000 0000000d     ...@..... ......
  403be8:	400e1200 0000000b 00000020 00000045     ...@.... ...E...
  403bf8:	400e1200 0000000b 00000040 00000046     ...@....@...F...
  403c08:	400e1400 0000000c 01000000 00000078     ...@........x...
  403c18:	400e0e00 00000009 01000000 00000018     ...@............
  403c28:	400e1400 0000000c 00800000 00000077     ...@........w...
  403c38:	400e0e00 00000009 02000000 00000019     ...@............
  403c48:	400e1400 0000000c 00400000 00000076     ...@......@.v...
  403c58:	400e1400 0000000c 00080000 00000073     ...@........s...
  403c68:	400e0e00 00000009 00001000 0000000c     ...@............
  403c78:	400e1400 0000000c 00040000 00000072     ...@........r...
  403c88:	400e0e00 00000009 00000800 0000000b     ...@............
  403c98:	400e1400 0000000c 00002000 0000006d     ...@..... ..m...
  403ca8:	400e1200 0000000b 00000200 00000049     ...@........I...
  403cb8:	400e1400 0000000c 00004000 0000006e     ...@.....@..n...
  403cc8:	400e1400 0000000c 10000000 0000007c     ...@........|...
  403cd8:	400e1200 0000000b 10000000 0000005c     ...@........\...
  403ce8:	400e1000 0000000a 00000040 00000026     ...@....@...&...
  403cf8:	400e0e00 00000009 00000040 00000006     ...@....@.......
  403d08:	400e1400 0000000c 00020000 00000071     ...@........q...
  403d18:	400e1400 0000000c 00010000 00000070     ...@........p...
  403d28:	400e1200 0000000b 00000100 00000048     ...@........H...
  403d38:	400e1400 0000000c 00001000 0000006c     ...@........l...
  403d48:	400e1200 0000000b 00000800 0000004b     ...@........K...
  403d58:	400e0e00 00000009 00000004 00000002     ...@............
  403d68:	400e1000 0000000a 00001000 0000002c     ...@........,...
  403d78:	400e1200 0000000b 00004000 0000004e     ...@.....@..N...
  403d88:	400e1400 0000000c 00000080 00000067     ...@........g...
  403d98:	400e1000 0000000a 00000080 00000027     ...@........'...
  403da8:	400e1200 0000000b 00000400 0000004a     ...@........J...
  403db8:	400e1400 0000000c 00000800 0000006b     ...@........k...
  403dc8:	400e0e00 00000009 00000002 00000001     ...@............
  403dd8:	400e1200 0000000b 00010000 00000050     ...@........P...
  403de8:	400e1400 0000000c 00000400 0000006a     ...@........j...
  403df8:	400e0e00 00000009 00000001 00000000     ...@............
  403e08:	400e1200 0000000b 00020000 00000051     ...@........Q...
  403e18:	400e1200 0000000b 00080000 00000053     ...@........S...
  403e28:	400e1000 0000000a 00000010 00000024     ...@........$...
  403e38:	400e1400 0000000c 00008000 0000006f     ...@........o...
  403e48:	400e1400 0000000c 20000000 0000007d     ...@....... }...
  403e58:	400e1000 0000000a 00000020 00000025     ...@.... ...%...
  403e68:	400e1400 0000000c 00000200 00000069     ...@........i...
  403e78:	400e1200 0000000b 00040000 00000052     ...@........R...
  403e88:	400e1400 0000000c 00000100 00000068     ...@........h...
  403e98:	400e0e00 00000009 00000040 00000006     ...@....@.......
  403ea8:	400e1200 0000000b 00100000 00000054     ...@........T...
  403eb8:	400e1200 0000000b 00400000 00000056     ...@......@.V...
  403ec8:	400e1400 0000000c 00000040 00000066     ...@....@...f...
  403ed8:	400e1200 0000000b 00200000 00000055     ...@...... .U...
  403ee8:	400e1200 0000000b 01000000 00000058     ...@........X...
  403ef8:	400e1400 0000000c 00000020 00000065     ...@.... ...e...
  403f08:	400e1400 0000000c 00000010 00000064     ...@........d...
  403f18:	400e1400 0000000c 00000008 00000063     ...@........c...
  403f28:	400e1200 0000000b 00800000 00000057     ...@........W...
  403f38:	400e1400 0000000c 00000004 00000062     ...@........b...
  403f48:	400e1400 0000000c 00000002 00000061     ...@........a...
  403f58:	400e1200 0000000b 02000000 00000059     ...@........Y...
  403f68:	706d6554 00000000                       Temp....

00403f70 <SSD1311_CFG_SCRIPT>:
  403f70:	64040000 71022a02 28025c02 2a020802     ...d.*.q.\.(...*
  403f80:	d5027902 78027002 06020802 79022a02     .y...p.x.....*.y
  403f90:	00027202 1002da02 ff028102 3002db02     .r.............0
  403fa0:	0302dc02 28027802 06022a02 28020802     .....x.(.*.....(
  403fb0:	80020102 0c026404 00000101              .....d......

00403fbc <sd_mmc_trans_units>:
  403fbc:	0000000a 00000064 000003e8 00002710     ....d........'..
	...

00403fd8 <sd_trans_multipliers>:
  403fd8:	00000000 0000000a 0000000c 0000000d     ................
  403fe8:	0000000f 00000014 00000019 0000001e     ................
  403ff8:	00000023 00000028 0000002d 00000032     #...(...-...2...
  404008:	00000037 0000003c 00000046 00000050     7...<...F...P...

00404018 <mmc_trans_multipliers>:
  404018:	00000000 0000000a 0000000c 0000000d     ................
  404028:	0000000f 00000014 0000001a 0000001e     ................
  404038:	00000023 00000028 0000002d 00000034     #...(...-...4...
  404048:	00000037 0000003c 00000046 00000050     7...<...F...P...

00404058 <can_bit_time>:
  404058:	02020308 02094b03 43020303 0303030a     .....K.....C....
  404068:	040b4603 48040303 0404030c 040d4304     .F.....H.....C..
  404078:	4d040404 0504040e 040f4004 43040505     ...M.....@.....C
  404088:	05050510 06114504 47040505 06060512     .....E.....G....
  404098:	06134304 44040606 06060714 08154604     .C.....D.....F..
  4040a8:	47040606 07070716 08174404 46040708     ...G.....D.....F
  4040b8:	08080718 08194304 44040808              .....C.....D

004040c4 <_global_impure_ptr>:
  4040c4:	20000010                                ... 

004040c8 <_init>:
  4040c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4040ca:	bf00      	nop
  4040cc:	bcf8      	pop	{r3, r4, r5, r6, r7}
  4040ce:	bc08      	pop	{r3}
  4040d0:	469e      	mov	lr, r3
  4040d2:	4770      	bx	lr

004040d4 <__init_array_start>:
  4040d4:	00403809 	.word	0x00403809

004040d8 <__frame_dummy_init_array_entry>:
  4040d8:	0040011d                                ..@.

004040dc <_fini>:
  4040dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4040de:	bf00      	nop
  4040e0:	bcf8      	pop	{r3, r4, r5, r6, r7}
  4040e2:	bc08      	pop	{r3}
  4040e4:	469e      	mov	lr, r3
  4040e6:	4770      	bx	lr

004040e8 <__fini_array_start>:
  4040e8:	004000f9 	.word	0x004000f9

Disassembly of section .relocate:

20000000 <portable_delay_cycles>:
RAMFUNC
void portable_delay_cycles(unsigned long n)
{
	UNUSED(n);

	__asm (
20000000:	f3bf 8f5f 	dmb	sy
20000004:	3801      	subs	r0, #1
20000006:	d1fb      	bne.n	20000000 <portable_delay_cycles>
20000008:	4770      	bx	lr

2000000a <g_interrupt_enabled>:
2000000a:	0001                                        ..

2000000c <SystemCoreClock>:
2000000c:	0900 003d                                   ..=.

20000010 <impure_data>:
20000010:	0000 0000 02fc 2000 0364 2000 03cc 2000     ....... d.. ... 
	...
200000b8:	0001 0000 0000 0000 330e abcd 1234 e66d     .........3..4.m.
200000c8:	deec 0005 000b 0000 0000 0000 0000 0000     ................
	...

20000438 <__atexit_recursive_mutex>:
20000438:	0534 2000                                   4.. 
