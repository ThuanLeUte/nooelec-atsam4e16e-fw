
arm.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000039c4  00400000  00400000  00010000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  004039c4  004039c4  000139c4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     0000044c  20000000  004039cc  00020000  2**3
                  CONTENTS, ALLOC, LOAD, CODE
  3 .bss          0000a390  20000450  00403e20  00020450  2**3
                  ALLOC
  4 .stack        00003000  2000a7e0  0040e1b0  00020450  2**0
                  ALLOC
  5 .ARM.attributes 0000002e  00000000  00000000  0002044c  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  0002047a  2**0
                  CONTENTS, READONLY
  7 .debug_info   0002123a  00000000  00000000  000204d3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000459c  00000000  00000000  0004170d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    000081a5  00000000  00000000  00045ca9  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00000f78  00000000  00000000  0004de4e  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000e58  00000000  00000000  0004edc6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  0001d305  00000000  00000000  0004fc1e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   0001666a  00000000  00000000  0006cf23  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00071faa  00000000  00000000  0008358d  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00003f00  00000000  00000000  000f5538  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <exception_table>:
  400000:	e0 d7 00 20 01 1b 40 00 73 1a 40 00 73 1a 40 00     ... ..@.s.@.s.@.
  400010:	73 1a 40 00 73 1a 40 00 73 1a 40 00 00 00 00 00     s.@.s.@.s.@.....
	...
  40002c:	41 03 40 00 73 1a 40 00 00 00 00 00 e1 03 40 00     A.@.s.@.......@.
  40003c:	35 04 40 00 73 1a 40 00 73 1a 40 00 73 1a 40 00     5.@.s.@.s.@.s.@.
  40004c:	73 1a 40 00 73 1a 40 00 73 1a 40 00 73 1a 40 00     s.@.s.@.s.@.s.@.
  40005c:	f9 0e 40 00 73 1a 40 00 c9 21 40 00 e1 21 40 00     ..@.s.@..!@..!@.
  40006c:	f9 21 40 00 11 22 40 00 29 22 40 00 73 1a 40 00     .!@.."@.)"@.s.@.
  40007c:	73 1a 40 00 73 1a 40 00 73 1a 40 00 73 1a 40 00     s.@.s.@.s.@.s.@.
  40008c:	73 1a 40 00 73 1a 40 00 73 1a 40 00 73 1a 40 00     s.@.s.@.s.@.s.@.
  40009c:	73 1a 40 00 73 1a 40 00 73 1a 40 00 73 1a 40 00     s.@.s.@.s.@.s.@.
  4000ac:	73 1a 40 00 73 1a 40 00 73 1a 40 00 73 1a 40 00     s.@.s.@.s.@.s.@.
  4000bc:	73 1a 40 00 73 1a 40 00 73 1a 40 00 73 1a 40 00     s.@.s.@.s.@.s.@.
  4000cc:	73 1a 40 00 73 1a 40 00 73 1a 40 00 73 1a 40 00     s.@.s.@.s.@.s.@.
  4000dc:	73 1a 40 00 73 1a 40 00 73 1a 40 00 73 1a 40 00     s.@.s.@.s.@.s.@.
  4000ec:	73 1a 40 00 73 1a 40 00 73 1a 40 00                 s.@.s.@.s.@.

004000f8 <__do_global_dtors_aux>:
  4000f8:	b510      	push	{r4, lr}
  4000fa:	4c05      	ldr	r4, [pc, #20]	; (400110 <__do_global_dtors_aux+0x18>)
  4000fc:	7823      	ldrb	r3, [r4, #0]
  4000fe:	b933      	cbnz	r3, 40010e <__do_global_dtors_aux+0x16>
  400100:	4b04      	ldr	r3, [pc, #16]	; (400114 <__do_global_dtors_aux+0x1c>)
  400102:	b113      	cbz	r3, 40010a <__do_global_dtors_aux+0x12>
  400104:	4804      	ldr	r0, [pc, #16]	; (400118 <__do_global_dtors_aux+0x20>)
  400106:	f3af 8000 	nop.w
  40010a:	2301      	movs	r3, #1
  40010c:	7023      	strb	r3, [r4, #0]
  40010e:	bd10      	pop	{r4, pc}
  400110:	20000450 	.word	0x20000450
  400114:	00000000 	.word	0x00000000
  400118:	004039cc 	.word	0x004039cc

0040011c <frame_dummy>:
  40011c:	4b0c      	ldr	r3, [pc, #48]	; (400150 <frame_dummy+0x34>)
  40011e:	b143      	cbz	r3, 400132 <frame_dummy+0x16>
  400120:	480c      	ldr	r0, [pc, #48]	; (400154 <frame_dummy+0x38>)
  400122:	490d      	ldr	r1, [pc, #52]	; (400158 <frame_dummy+0x3c>)
  400124:	b510      	push	{r4, lr}
  400126:	f3af 8000 	nop.w
  40012a:	480c      	ldr	r0, [pc, #48]	; (40015c <frame_dummy+0x40>)
  40012c:	6803      	ldr	r3, [r0, #0]
  40012e:	b923      	cbnz	r3, 40013a <frame_dummy+0x1e>
  400130:	bd10      	pop	{r4, pc}
  400132:	480a      	ldr	r0, [pc, #40]	; (40015c <frame_dummy+0x40>)
  400134:	6803      	ldr	r3, [r0, #0]
  400136:	b933      	cbnz	r3, 400146 <frame_dummy+0x2a>
  400138:	4770      	bx	lr
  40013a:	4b09      	ldr	r3, [pc, #36]	; (400160 <frame_dummy+0x44>)
  40013c:	2b00      	cmp	r3, #0
  40013e:	d0f7      	beq.n	400130 <frame_dummy+0x14>
  400140:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  400144:	4718      	bx	r3
  400146:	4b06      	ldr	r3, [pc, #24]	; (400160 <frame_dummy+0x44>)
  400148:	2b00      	cmp	r3, #0
  40014a:	d0f5      	beq.n	400138 <frame_dummy+0x1c>
  40014c:	4718      	bx	r3
  40014e:	bf00      	nop
  400150:	00000000 	.word	0x00000000
  400154:	004039cc 	.word	0x004039cc
  400158:	20000454 	.word	0x20000454
  40015c:	004039cc 	.word	0x004039cc
  400160:	00000000 	.word	0x00000000

00400164 <uart_init>:
 *
 * \retval 0 Success.
 * \retval 1 Bad baud rate generator value.
 */
uint32_t uart_init(Uart *p_uart, const sam_uart_opt_t *p_uart_opt)
{
  400164:	b480      	push	{r7}
  400166:	b085      	sub	sp, #20
  400168:	af00      	add	r7, sp, #0
  40016a:	6078      	str	r0, [r7, #4]
  40016c:	6039      	str	r1, [r7, #0]
	uint32_t cd = 0;
  40016e:	2300      	movs	r3, #0
  400170:	60fb      	str	r3, [r7, #12]

	/* Reset and disable receiver & transmitter */
	p_uart->UART_CR = UART_CR_RSTRX | UART_CR_RSTTX
  400172:	687b      	ldr	r3, [r7, #4]
  400174:	22ac      	movs	r2, #172	; 0xac
  400176:	601a      	str	r2, [r3, #0]
			| UART_CR_RXDIS | UART_CR_TXDIS;

	/* Check and configure baudrate */
	/* Asynchronous, no oversampling */
	cd = (p_uart_opt->ul_mck / p_uart_opt->ul_baudrate) / UART_MCK_DIV;
  400178:	683b      	ldr	r3, [r7, #0]
  40017a:	681a      	ldr	r2, [r3, #0]
  40017c:	683b      	ldr	r3, [r7, #0]
  40017e:	685b      	ldr	r3, [r3, #4]
  400180:	fbb2 f3f3 	udiv	r3, r2, r3
  400184:	091b      	lsrs	r3, r3, #4
  400186:	60fb      	str	r3, [r7, #12]
	if (cd < UART_MCK_DIV_MIN_FACTOR || cd > UART_MCK_DIV_MAX_FACTOR)
  400188:	68fb      	ldr	r3, [r7, #12]
  40018a:	2b00      	cmp	r3, #0
  40018c:	d003      	beq.n	400196 <uart_init+0x32>
  40018e:	68fb      	ldr	r3, [r7, #12]
  400190:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
  400194:	d301      	bcc.n	40019a <uart_init+0x36>
		return 1;
  400196:	2301      	movs	r3, #1
  400198:	e00f      	b.n	4001ba <uart_init+0x56>

	p_uart->UART_BRGR = cd;
  40019a:	687b      	ldr	r3, [r7, #4]
  40019c:	68fa      	ldr	r2, [r7, #12]
  40019e:	621a      	str	r2, [r3, #32]
	/* Configure mode */
	p_uart->UART_MR = p_uart_opt->ul_mode;
  4001a0:	683b      	ldr	r3, [r7, #0]
  4001a2:	689a      	ldr	r2, [r3, #8]
  4001a4:	687b      	ldr	r3, [r7, #4]
  4001a6:	605a      	str	r2, [r3, #4]

#if (!SAMV71 && !SAMV70 && !SAME70 && !SAMS70)
	/* Disable PDC channel */
	p_uart->UART_PTCR = UART_PTCR_RXTDIS | UART_PTCR_TXTDIS;
  4001a8:	687b      	ldr	r3, [r7, #4]
  4001aa:	f240 2202 	movw	r2, #514	; 0x202
  4001ae:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
#endif

	/* Enable receiver and transmitter */
	p_uart->UART_CR = UART_CR_RXEN | UART_CR_TXEN;
  4001b2:	687b      	ldr	r3, [r7, #4]
  4001b4:	2250      	movs	r2, #80	; 0x50
  4001b6:	601a      	str	r2, [r3, #0]

	return 0;
  4001b8:	2300      	movs	r3, #0
}
  4001ba:	4618      	mov	r0, r3
  4001bc:	3714      	adds	r7, #20
  4001be:	46bd      	mov	sp, r7
  4001c0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4001c4:	4770      	bx	lr

004001c6 <uart_enable_interrupt>:
 *
 * \param p_uart Pointer to a UART instance.
 *  \param ul_sources Interrupts to be enabled.
 */
void uart_enable_interrupt(Uart *p_uart, uint32_t ul_sources)
{
  4001c6:	b480      	push	{r7}
  4001c8:	b083      	sub	sp, #12
  4001ca:	af00      	add	r7, sp, #0
  4001cc:	6078      	str	r0, [r7, #4]
  4001ce:	6039      	str	r1, [r7, #0]
	p_uart->UART_IER = ul_sources;
  4001d0:	687b      	ldr	r3, [r7, #4]
  4001d2:	683a      	ldr	r2, [r7, #0]
  4001d4:	609a      	str	r2, [r3, #8]
}
  4001d6:	bf00      	nop
  4001d8:	370c      	adds	r7, #12
  4001da:	46bd      	mov	sp, r7
  4001dc:	f85d 7b04 	ldr.w	r7, [sp], #4
  4001e0:	4770      	bx	lr

004001e2 <uart_get_status>:
 * \param p_uart Pointer to a UART instance.
 *
 * \return The current UART status.
 */
uint32_t uart_get_status(Uart *p_uart)
{
  4001e2:	b480      	push	{r7}
  4001e4:	b083      	sub	sp, #12
  4001e6:	af00      	add	r7, sp, #0
  4001e8:	6078      	str	r0, [r7, #4]
	return p_uart->UART_SR;
  4001ea:	687b      	ldr	r3, [r7, #4]
  4001ec:	695b      	ldr	r3, [r3, #20]
}
  4001ee:	4618      	mov	r0, r3
  4001f0:	370c      	adds	r7, #12
  4001f2:	46bd      	mov	sp, r7
  4001f4:	f85d 7b04 	ldr.w	r7, [sp], #4
  4001f8:	4770      	bx	lr

004001fa <uart_write>:
 *
 * \retval 0 Success.
 * \retval 1 I/O Failure, UART is not ready.
 */
uint32_t uart_write(Uart *p_uart, const uint8_t uc_data)
{
  4001fa:	b480      	push	{r7}
  4001fc:	b083      	sub	sp, #12
  4001fe:	af00      	add	r7, sp, #0
  400200:	6078      	str	r0, [r7, #4]
  400202:	460b      	mov	r3, r1
  400204:	70fb      	strb	r3, [r7, #3]
	/* Check if the transmitter is ready */
	if (!(p_uart->UART_SR & UART_SR_TXRDY))
  400206:	687b      	ldr	r3, [r7, #4]
  400208:	695b      	ldr	r3, [r3, #20]
  40020a:	f003 0302 	and.w	r3, r3, #2
  40020e:	2b00      	cmp	r3, #0
  400210:	d101      	bne.n	400216 <uart_write+0x1c>
		return 1;
  400212:	2301      	movs	r3, #1
  400214:	e003      	b.n	40021e <uart_write+0x24>

	/* Send character */
	p_uart->UART_THR = uc_data;
  400216:	78fa      	ldrb	r2, [r7, #3]
  400218:	687b      	ldr	r3, [r7, #4]
  40021a:	61da      	str	r2, [r3, #28]
	return 0;
  40021c:	2300      	movs	r3, #0
}
  40021e:	4618      	mov	r0, r3
  400220:	370c      	adds	r7, #12
  400222:	46bd      	mov	sp, r7
  400224:	f85d 7b04 	ldr.w	r7, [sp], #4
  400228:	4770      	bx	lr

0040022a <uart_read>:
 *
 * \retval 0 Success.
 * \retval 1 I/O Failure, UART is not ready.
 */
uint32_t uart_read(Uart *p_uart, uint8_t *puc_data)
{
  40022a:	b480      	push	{r7}
  40022c:	b083      	sub	sp, #12
  40022e:	af00      	add	r7, sp, #0
  400230:	6078      	str	r0, [r7, #4]
  400232:	6039      	str	r1, [r7, #0]
	/* Check if the receiver is ready */
	if ((p_uart->UART_SR & UART_SR_RXRDY) == 0)
  400234:	687b      	ldr	r3, [r7, #4]
  400236:	695b      	ldr	r3, [r3, #20]
  400238:	f003 0301 	and.w	r3, r3, #1
  40023c:	2b00      	cmp	r3, #0
  40023e:	d101      	bne.n	400244 <uart_read+0x1a>
		return 1;
  400240:	2301      	movs	r3, #1
  400242:	e005      	b.n	400250 <uart_read+0x26>

	/* Read character */
	*puc_data = (uint8_t) p_uart->UART_RHR;
  400244:	687b      	ldr	r3, [r7, #4]
  400246:	699b      	ldr	r3, [r3, #24]
  400248:	b2da      	uxtb	r2, r3
  40024a:	683b      	ldr	r3, [r7, #0]
  40024c:	701a      	strb	r2, [r3, #0]
	return 0;
  40024e:	2300      	movs	r3, #0
}
  400250:	4618      	mov	r0, r3
  400252:	370c      	adds	r7, #12
  400254:	46bd      	mov	sp, r7
  400256:	f85d 7b04 	ldr.w	r7, [sp], #4
  40025a:	4770      	bx	lr

0040025c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
  40025c:	b480      	push	{r7}
  40025e:	b083      	sub	sp, #12
  400260:	af00      	add	r7, sp, #0
  400262:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
  400264:	687b      	ldr	r3, [r7, #4]
  400266:	f103 0208 	add.w	r2, r3, #8
  40026a:	687b      	ldr	r3, [r7, #4]
  40026c:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  40026e:	687b      	ldr	r3, [r7, #4]
  400270:	f04f 32ff 	mov.w	r2, #4294967295
  400274:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
  400276:	687b      	ldr	r3, [r7, #4]
  400278:	f103 0208 	add.w	r2, r3, #8
  40027c:	687b      	ldr	r3, [r7, #4]
  40027e:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
  400280:	687b      	ldr	r3, [r7, #4]
  400282:	f103 0208 	add.w	r2, r3, #8
  400286:	687b      	ldr	r3, [r7, #4]
  400288:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
  40028a:	687b      	ldr	r3, [r7, #4]
  40028c:	2200      	movs	r2, #0
  40028e:	601a      	str	r2, [r3, #0]
}
  400290:	bf00      	nop
  400292:	370c      	adds	r7, #12
  400294:	46bd      	mov	sp, r7
  400296:	f85d 7b04 	ldr.w	r7, [sp], #4
  40029a:	4770      	bx	lr

0040029c <vListInsertEnd>:
	pxItem->pvContainer = NULL;
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
  40029c:	b480      	push	{r7}
  40029e:	b085      	sub	sp, #20
  4002a0:	af00      	add	r7, sp, #0
  4002a2:	6078      	str	r0, [r7, #4]
  4002a4:	6039      	str	r1, [r7, #0]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
  4002a6:	687b      	ldr	r3, [r7, #4]
  4002a8:	685b      	ldr	r3, [r3, #4]
  4002aa:	60fb      	str	r3, [r7, #12]

	pxNewListItem->pxNext = pxIndex->pxNext;
  4002ac:	68fb      	ldr	r3, [r7, #12]
  4002ae:	685a      	ldr	r2, [r3, #4]
  4002b0:	683b      	ldr	r3, [r7, #0]
  4002b2:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
  4002b4:	687b      	ldr	r3, [r7, #4]
  4002b6:	685a      	ldr	r2, [r3, #4]
  4002b8:	683b      	ldr	r3, [r7, #0]
  4002ba:	609a      	str	r2, [r3, #8]
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
  4002bc:	68fb      	ldr	r3, [r7, #12]
  4002be:	685b      	ldr	r3, [r3, #4]
  4002c0:	683a      	ldr	r2, [r7, #0]
  4002c2:	609a      	str	r2, [r3, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
  4002c4:	68fb      	ldr	r3, [r7, #12]
  4002c6:	683a      	ldr	r2, [r7, #0]
  4002c8:	605a      	str	r2, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
  4002ca:	687b      	ldr	r3, [r7, #4]
  4002cc:	683a      	ldr	r2, [r7, #0]
  4002ce:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  4002d0:	683b      	ldr	r3, [r7, #0]
  4002d2:	687a      	ldr	r2, [r7, #4]
  4002d4:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
  4002d6:	687b      	ldr	r3, [r7, #4]
  4002d8:	681b      	ldr	r3, [r3, #0]
  4002da:	1c5a      	adds	r2, r3, #1
  4002dc:	687b      	ldr	r3, [r7, #4]
  4002de:	601a      	str	r2, [r3, #0]
}
  4002e0:	bf00      	nop
  4002e2:	3714      	adds	r7, #20
  4002e4:	46bd      	mov	sp, r7
  4002e6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4002ea:	4770      	bx	lr

004002ec <uxListRemove>:
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
  4002ec:	b480      	push	{r7}
  4002ee:	b085      	sub	sp, #20
  4002f0:	af00      	add	r7, sp, #0
  4002f2:	6078      	str	r0, [r7, #4]
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  4002f4:	687b      	ldr	r3, [r7, #4]
  4002f6:	685b      	ldr	r3, [r3, #4]
  4002f8:	687a      	ldr	r2, [r7, #4]
  4002fa:	6892      	ldr	r2, [r2, #8]
  4002fc:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  4002fe:	687b      	ldr	r3, [r7, #4]
  400300:	689b      	ldr	r3, [r3, #8]
  400302:	687a      	ldr	r2, [r7, #4]
  400304:	6852      	ldr	r2, [r2, #4]
  400306:	605a      	str	r2, [r3, #4]

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
  400308:	687b      	ldr	r3, [r7, #4]
  40030a:	691b      	ldr	r3, [r3, #16]
  40030c:	60fb      	str	r3, [r7, #12]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
  40030e:	68fb      	ldr	r3, [r7, #12]
  400310:	685a      	ldr	r2, [r3, #4]
  400312:	687b      	ldr	r3, [r7, #4]
  400314:	429a      	cmp	r2, r3
  400316:	d103      	bne.n	400320 <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
  400318:	687b      	ldr	r3, [r7, #4]
  40031a:	689a      	ldr	r2, [r3, #8]
  40031c:	68fb      	ldr	r3, [r7, #12]
  40031e:	605a      	str	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
  400320:	687b      	ldr	r3, [r7, #4]
  400322:	2200      	movs	r2, #0
  400324:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
  400326:	68fb      	ldr	r3, [r7, #12]
  400328:	681b      	ldr	r3, [r3, #0]
  40032a:	1e5a      	subs	r2, r3, #1
  40032c:	68fb      	ldr	r3, [r7, #12]
  40032e:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
  400330:	68fb      	ldr	r3, [r7, #12]
  400332:	681b      	ldr	r3, [r3, #0]
}
  400334:	4618      	mov	r0, r3
  400336:	3714      	adds	r7, #20
  400338:	46bd      	mov	sp, r7
  40033a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40033e:	4770      	bx	lr

00400340 <SVC_Handler>:
/*-----------------------------------------------------------*/

/*void vPortSVCHandler( void )*/ /* ATMEL */
__attribute__ ((naked)) void SVC_Handler( void )
{
	__asm volatile (
  400340:	4b05      	ldr	r3, [pc, #20]	; (400358 <pxCurrentTCBConst2>)
  400342:	6819      	ldr	r1, [r3, #0]
  400344:	6808      	ldr	r0, [r1, #0]
  400346:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40034a:	f380 8809 	msr	PSP, r0
  40034e:	f04f 0000 	mov.w	r0, #0
  400352:	f380 8811 	msr	BASEPRI, r0
  400356:	4770      	bx	lr

00400358 <pxCurrentTCBConst2>:
  400358:	2000a47c 	.word	0x2000a47c
		" bx r14                          \n"
		"                                   \n"
		" .align 2                        \n"
		"pxCurrentTCBConst2: .word pxCurrentTCB \n"
		);
}
  40035c:	bf00      	nop
  40035e:	bf00      	nop

00400360 <vPortYieldFromISR>:
}

/*-----------------------------------------------------------*/

void vPortYieldFromISR( void )
{
  400360:	b480      	push	{r7}
  400362:	af00      	add	r7, sp, #0
	/* Set a PendSV to request a context switch. */
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
  400364:	4b04      	ldr	r3, [pc, #16]	; (400378 <vPortYieldFromISR+0x18>)
  400366:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  40036a:	601a      	str	r2, [r3, #0]
}
  40036c:	bf00      	nop
  40036e:	46bd      	mov	sp, r7
  400370:	f85d 7b04 	ldr.w	r7, [sp], #4
  400374:	4770      	bx	lr
  400376:	bf00      	nop
  400378:	e000ed04 	.word	0xe000ed04

0040037c <vPortEnterCritical>:

/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
  40037c:	b580      	push	{r7, lr}
  40037e:	af00      	add	r7, sp, #0
	portDISABLE_INTERRUPTS();
  400380:	4b04      	ldr	r3, [pc, #16]	; (400394 <vPortEnterCritical+0x18>)
  400382:	4798      	blx	r3
	uxCriticalNesting++;
  400384:	4b04      	ldr	r3, [pc, #16]	; (400398 <vPortEnterCritical+0x1c>)
  400386:	681b      	ldr	r3, [r3, #0]
  400388:	3301      	adds	r3, #1
  40038a:	4a03      	ldr	r2, [pc, #12]	; (400398 <vPortEnterCritical+0x1c>)
  40038c:	6013      	str	r3, [r2, #0]
}
  40038e:	bf00      	nop
  400390:	bd80      	pop	{r7, pc}
  400392:	bf00      	nop
  400394:	004003c5 	.word	0x004003c5
  400398:	2000000c 	.word	0x2000000c

0040039c <vPortExitCritical>:

/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
  40039c:	b580      	push	{r7, lr}
  40039e:	af00      	add	r7, sp, #0
	uxCriticalNesting--;
  4003a0:	4b06      	ldr	r3, [pc, #24]	; (4003bc <vPortExitCritical+0x20>)
  4003a2:	681b      	ldr	r3, [r3, #0]
  4003a4:	3b01      	subs	r3, #1
  4003a6:	4a05      	ldr	r2, [pc, #20]	; (4003bc <vPortExitCritical+0x20>)
  4003a8:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 0) {
  4003aa:	4b04      	ldr	r3, [pc, #16]	; (4003bc <vPortExitCritical+0x20>)
  4003ac:	681b      	ldr	r3, [r3, #0]
  4003ae:	2b00      	cmp	r3, #0
  4003b0:	d102      	bne.n	4003b8 <vPortExitCritical+0x1c>
		portENABLE_INTERRUPTS();
  4003b2:	2000      	movs	r0, #0
  4003b4:	4b02      	ldr	r3, [pc, #8]	; (4003c0 <vPortExitCritical+0x24>)
  4003b6:	4798      	blx	r3
	}
}
  4003b8:	bf00      	nop
  4003ba:	bd80      	pop	{r7, pc}
  4003bc:	2000000c 	.word	0x2000000c
  4003c0:	004003d7 	.word	0x004003d7

004003c4 <ulPortSetInterruptMask>:

/*-----------------------------------------------------------*/

__attribute__((naked)) unsigned long ulPortSetInterruptMask( void )
{
	__asm volatile \
  4003c4:	f3ef 8011 	mrs	r0, BASEPRI
  4003c8:	f04f 01a0 	mov.w	r1, #160	; 0xa0
  4003cc:	f381 8811 	msr	BASEPRI, r1
  4003d0:	4770      	bx	lr
		:: "i" (configMAX_SYSCALL_INTERRUPT_PRIORITY) : "r0", "r1" \
	);

	/* This return will not be reached but is necessary to prevent compiler
	 * warnings. */
	return 0;
  4003d2:	2300      	movs	r3, #0
}
  4003d4:	4618      	mov	r0, r3

004003d6 <vPortClearInterruptMask>:
/*-----------------------------------------------------------*/

__attribute__((naked)) void vPortClearInterruptMask(
		unsigned long ulNewMaskValue )
{
	__asm volatile \
  4003d6:	f380 8811 	msr	BASEPRI, r0
  4003da:	4770      	bx	lr
	( \
		" msr basepri, r0                            \n" \
		" bx lr                                      \n" \
		::: "r0" \
	);
}
  4003dc:	bf00      	nop
	...

004003e0 <PendSV_Handler>:
/*void xPortPendSVHandler( void )*/
__attribute__((naked)) void PendSV_Handler( void )   /* ATMEL */
{
	/* This is a naked function. */

	__asm volatile
  4003e0:	f3ef 8009 	mrs	r0, PSP
  4003e4:	4b11      	ldr	r3, [pc, #68]	; (40042c <pxCurrentTCBConst>)
  4003e6:	681a      	ldr	r2, [r3, #0]
  4003e8:	f01e 0f10 	tst.w	lr, #16
  4003ec:	bf08      	it	eq
  4003ee:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
  4003f2:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4003f6:	6010      	str	r0, [r2, #0]
  4003f8:	e92d 4008 	stmdb	sp!, {r3, lr}
  4003fc:	f04f 00a0 	mov.w	r0, #160	; 0xa0
  400400:	f380 8811 	msr	BASEPRI, r0
  400404:	f000 fb6c 	bl	400ae0 <vTaskSwitchContext>
  400408:	f04f 0000 	mov.w	r0, #0
  40040c:	f380 8811 	msr	BASEPRI, r0
  400410:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  400414:	6819      	ldr	r1, [r3, #0]
  400416:	6808      	ldr	r0, [r1, #0]
  400418:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40041c:	f01e 0f10 	tst.w	lr, #16
  400420:	bf08      	it	eq
  400422:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
  400426:	f380 8809 	msr	PSP, r0
  40042a:	4770      	bx	lr

0040042c <pxCurrentTCBConst>:
  40042c:	2000a47c 	.word	0x2000a47c
		"                                       \n"
		"   .align 2                            \n"
		"pxCurrentTCBConst: .word pxCurrentTCB    \n"
		::"i" (configMAX_SYSCALL_INTERRUPT_PRIORITY)
	);
}
  400430:	bf00      	nop
  400432:	bf00      	nop

00400434 <SysTick_Handler>:

/*-----------------------------------------------------------*/
void SysTick_Handler( void ) /* ATMEL */
{
  400434:	b580      	push	{r7, lr}
  400436:	af00      	add	r7, sp, #0
	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
  400438:	4b06      	ldr	r3, [pc, #24]	; (400454 <SysTick_Handler+0x20>)
  40043a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  40043e:	601a      	str	r2, [r3, #0]
	#endif

	(void)portSET_INTERRUPT_MASK_FROM_ISR();
  400440:	4b05      	ldr	r3, [pc, #20]	; (400458 <SysTick_Handler+0x24>)
  400442:	4798      	blx	r3
	{
		vTaskIncrementTick();
  400444:	4b05      	ldr	r3, [pc, #20]	; (40045c <SysTick_Handler+0x28>)
  400446:	4798      	blx	r3
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
  400448:	2000      	movs	r0, #0
  40044a:	4b05      	ldr	r3, [pc, #20]	; (400460 <SysTick_Handler+0x2c>)
  40044c:	4798      	blx	r3
}
  40044e:	bf00      	nop
  400450:	bd80      	pop	{r7, pc}
  400452:	bf00      	nop
  400454:	e000ed04 	.word	0xe000ed04
  400458:	004003c5 	.word	0x004003c5
  40045c:	00400995 	.word	0x00400995
  400460:	004003d7 	.word	0x004003d7

00400464 <pvPortMalloc>:
/* STATIC FUNCTIONS ARE DEFINED AS MACROS TO MINIMIZE THE FUNCTION CALL DEPTH. */

/*-----------------------------------------------------------*/
extern void vApplicationMallocFailedHook( void );
void *pvPortMalloc( size_t xWantedSize )
{
  400464:	b580      	push	{r7, lr}
  400466:	b086      	sub	sp, #24
  400468:	af00      	add	r7, sp, #0
  40046a:	6078      	str	r0, [r7, #4]
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
  40046c:	2300      	movs	r3, #0
  40046e:	60fb      	str	r3, [r7, #12]

	vTaskSuspendAll();
  400470:	4b34      	ldr	r3, [pc, #208]	; (400544 <pvPortMalloc+0xe0>)
  400472:	4798      	blx	r3
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
  400474:	4b34      	ldr	r3, [pc, #208]	; (400548 <pvPortMalloc+0xe4>)
  400476:	681b      	ldr	r3, [r3, #0]
  400478:	2b00      	cmp	r3, #0
  40047a:	d101      	bne.n	400480 <pvPortMalloc+0x1c>
		{
			prvHeapInit();
  40047c:	4b33      	ldr	r3, [pc, #204]	; (40054c <pvPortMalloc+0xe8>)
  40047e:	4798      	blx	r3
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
  400480:	687b      	ldr	r3, [r7, #4]
  400482:	2b00      	cmp	r3, #0
  400484:	d00e      	beq.n	4004a4 <pvPortMalloc+0x40>
		{
			xWantedSize += heapSTRUCT_SIZE;
  400486:	2310      	movs	r3, #16
  400488:	461a      	mov	r2, r3
  40048a:	687b      	ldr	r3, [r7, #4]
  40048c:	4413      	add	r3, r2
  40048e:	607b      	str	r3, [r7, #4]

			/* Ensure that blocks are always aligned to the required number of 
			bytes. */
			if( xWantedSize & portBYTE_ALIGNMENT_MASK )
  400490:	687b      	ldr	r3, [r7, #4]
  400492:	f003 0307 	and.w	r3, r3, #7
  400496:	2b00      	cmp	r3, #0
  400498:	d004      	beq.n	4004a4 <pvPortMalloc+0x40>
			{
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
  40049a:	687b      	ldr	r3, [r7, #4]
  40049c:	f023 0307 	bic.w	r3, r3, #7
  4004a0:	3308      	adds	r3, #8
  4004a2:	607b      	str	r3, [r7, #4]
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < xTotalHeapSize ) )
  4004a4:	687b      	ldr	r3, [r7, #4]
  4004a6:	2b00      	cmp	r3, #0
  4004a8:	d045      	beq.n	400536 <pvPortMalloc+0xd2>
  4004aa:	f44f 4220 	mov.w	r2, #40960	; 0xa000
  4004ae:	687b      	ldr	r3, [r7, #4]
  4004b0:	4293      	cmp	r3, r2
  4004b2:	d240      	bcs.n	400536 <pvPortMalloc+0xd2>
		{
			/* Traverse the list from the start	(lowest address) block until one
			of adequate size is found. */
			pxPreviousBlock = &xStart;
  4004b4:	4b26      	ldr	r3, [pc, #152]	; (400550 <pvPortMalloc+0xec>)
  4004b6:	613b      	str	r3, [r7, #16]
			pxBlock = xStart.pxNextFreeBlock;
  4004b8:	4b25      	ldr	r3, [pc, #148]	; (400550 <pvPortMalloc+0xec>)
  4004ba:	681b      	ldr	r3, [r3, #0]
  4004bc:	617b      	str	r3, [r7, #20]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  4004be:	e004      	b.n	4004ca <pvPortMalloc+0x66>
			{
				pxPreviousBlock = pxBlock;
  4004c0:	697b      	ldr	r3, [r7, #20]
  4004c2:	613b      	str	r3, [r7, #16]
				pxBlock = pxBlock->pxNextFreeBlock;
  4004c4:	697b      	ldr	r3, [r7, #20]
  4004c6:	681b      	ldr	r3, [r3, #0]
  4004c8:	617b      	str	r3, [r7, #20]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  4004ca:	697b      	ldr	r3, [r7, #20]
  4004cc:	685a      	ldr	r2, [r3, #4]
  4004ce:	687b      	ldr	r3, [r7, #4]
  4004d0:	429a      	cmp	r2, r3
  4004d2:	d203      	bcs.n	4004dc <pvPortMalloc+0x78>
  4004d4:	697b      	ldr	r3, [r7, #20]
  4004d6:	681b      	ldr	r3, [r3, #0]
  4004d8:	2b00      	cmp	r3, #0
  4004da:	d1f1      	bne.n	4004c0 <pvPortMalloc+0x5c>
			}

			/* If the end marker was reached then a block of adequate size was
			not found. */
			if( pxBlock != pxEnd )
  4004dc:	4b1a      	ldr	r3, [pc, #104]	; (400548 <pvPortMalloc+0xe4>)
  4004de:	681b      	ldr	r3, [r3, #0]
  4004e0:	697a      	ldr	r2, [r7, #20]
  4004e2:	429a      	cmp	r2, r3
  4004e4:	d027      	beq.n	400536 <pvPortMalloc+0xd2>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
  4004e6:	693b      	ldr	r3, [r7, #16]
  4004e8:	681b      	ldr	r3, [r3, #0]
  4004ea:	2210      	movs	r2, #16
  4004ec:	4413      	add	r3, r2
  4004ee:	60fb      	str	r3, [r7, #12]

				/* This block is being returned for use so must be taken out of
				the	list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
  4004f0:	697b      	ldr	r3, [r7, #20]
  4004f2:	681a      	ldr	r2, [r3, #0]
  4004f4:	693b      	ldr	r3, [r7, #16]
  4004f6:	601a      	str	r2, [r3, #0]

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
  4004f8:	697b      	ldr	r3, [r7, #20]
  4004fa:	685a      	ldr	r2, [r3, #4]
  4004fc:	687b      	ldr	r3, [r7, #4]
  4004fe:	1ad3      	subs	r3, r2, r3
  400500:	2210      	movs	r2, #16
  400502:	0052      	lsls	r2, r2, #1
  400504:	4293      	cmp	r3, r2
  400506:	d90f      	bls.n	400528 <pvPortMalloc+0xc4>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
  400508:	697a      	ldr	r2, [r7, #20]
  40050a:	687b      	ldr	r3, [r7, #4]
  40050c:	4413      	add	r3, r2
  40050e:	60bb      	str	r3, [r7, #8]

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
  400510:	697b      	ldr	r3, [r7, #20]
  400512:	685a      	ldr	r2, [r3, #4]
  400514:	687b      	ldr	r3, [r7, #4]
  400516:	1ad2      	subs	r2, r2, r3
  400518:	68bb      	ldr	r3, [r7, #8]
  40051a:	605a      	str	r2, [r3, #4]
					pxBlock->xBlockSize = xWantedSize;
  40051c:	697b      	ldr	r3, [r7, #20]
  40051e:	687a      	ldr	r2, [r7, #4]
  400520:	605a      	str	r2, [r3, #4]

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
  400522:	68b8      	ldr	r0, [r7, #8]
  400524:	4b0b      	ldr	r3, [pc, #44]	; (400554 <pvPortMalloc+0xf0>)
  400526:	4798      	blx	r3
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
  400528:	4b0b      	ldr	r3, [pc, #44]	; (400558 <pvPortMalloc+0xf4>)
  40052a:	681a      	ldr	r2, [r3, #0]
  40052c:	697b      	ldr	r3, [r7, #20]
  40052e:	685b      	ldr	r3, [r3, #4]
  400530:	1ad3      	subs	r3, r2, r3
  400532:	4a09      	ldr	r2, [pc, #36]	; (400558 <pvPortMalloc+0xf4>)
  400534:	6013      	str	r3, [r2, #0]
			}
		}
	}
	xTaskResumeAll();
  400536:	4b09      	ldr	r3, [pc, #36]	; (40055c <pvPortMalloc+0xf8>)
  400538:	4798      	blx	r3
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
  40053a:	68fb      	ldr	r3, [r7, #12]
}
  40053c:	4618      	mov	r0, r3
  40053e:	3718      	adds	r7, #24
  400540:	46bd      	mov	sp, r7
  400542:	bd80      	pop	{r7, pc}
  400544:	00400859 	.word	0x00400859
  400548:	2000a478 	.word	0x2000a478
  40054c:	004005b5 	.word	0x004005b5
  400550:	2000a470 	.word	0x2000a470
  400554:	00400645 	.word	0x00400645
  400558:	20000010 	.word	0x20000010
  40055c:	00400875 	.word	0x00400875

00400560 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
  400560:	b580      	push	{r7, lr}
  400562:	b084      	sub	sp, #16
  400564:	af00      	add	r7, sp, #0
  400566:	6078      	str	r0, [r7, #4]
unsigned char *puc = ( unsigned char * ) pv;
  400568:	687b      	ldr	r3, [r7, #4]
  40056a:	60fb      	str	r3, [r7, #12]
xBlockLink *pxLink;

	if( pv != NULL )
  40056c:	687b      	ldr	r3, [r7, #4]
  40056e:	2b00      	cmp	r3, #0
  400570:	d014      	beq.n	40059c <vPortFree+0x3c>
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
  400572:	2310      	movs	r3, #16
  400574:	425b      	negs	r3, r3
  400576:	68fa      	ldr	r2, [r7, #12]
  400578:	4413      	add	r3, r2
  40057a:	60fb      	str	r3, [r7, #12]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
  40057c:	68fb      	ldr	r3, [r7, #12]
  40057e:	60bb      	str	r3, [r7, #8]

		vTaskSuspendAll();
  400580:	4b08      	ldr	r3, [pc, #32]	; (4005a4 <vPortFree+0x44>)
  400582:	4798      	blx	r3
		{
			/* Add this block to the list of free blocks. */
			xFreeBytesRemaining += pxLink->xBlockSize;
  400584:	68bb      	ldr	r3, [r7, #8]
  400586:	685a      	ldr	r2, [r3, #4]
  400588:	4b07      	ldr	r3, [pc, #28]	; (4005a8 <vPortFree+0x48>)
  40058a:	681b      	ldr	r3, [r3, #0]
  40058c:	4413      	add	r3, r2
  40058e:	4a06      	ldr	r2, [pc, #24]	; (4005a8 <vPortFree+0x48>)
  400590:	6013      	str	r3, [r2, #0]
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );			
  400592:	68b8      	ldr	r0, [r7, #8]
  400594:	4b05      	ldr	r3, [pc, #20]	; (4005ac <vPortFree+0x4c>)
  400596:	4798      	blx	r3
		}
		xTaskResumeAll();
  400598:	4b05      	ldr	r3, [pc, #20]	; (4005b0 <vPortFree+0x50>)
  40059a:	4798      	blx	r3
	}
}
  40059c:	bf00      	nop
  40059e:	3710      	adds	r7, #16
  4005a0:	46bd      	mov	sp, r7
  4005a2:	bd80      	pop	{r7, pc}
  4005a4:	00400859 	.word	0x00400859
  4005a8:	20000010 	.word	0x20000010
  4005ac:	00400645 	.word	0x00400645
  4005b0:	00400875 	.word	0x00400875

004005b4 <prvHeapInit>:
	/* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
  4005b4:	b580      	push	{r7, lr}
  4005b6:	b082      	sub	sp, #8
  4005b8:	af00      	add	r7, sp, #0
	/* Ensure the start of the heap is aligned. */
	configASSERT( ( ( ( unsigned long ) xHeap.ucHeap ) & ( ( unsigned long ) portBYTE_ALIGNMENT_MASK ) ) == 0UL );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) xHeap.ucHeap;
  4005ba:	4b1d      	ldr	r3, [pc, #116]	; (400630 <prvHeapInit+0x7c>)
  4005bc:	4a1d      	ldr	r2, [pc, #116]	; (400634 <prvHeapInit+0x80>)
  4005be:	601a      	str	r2, [r3, #0]
	xStart.xBlockSize = ( size_t ) 0;
  4005c0:	4b1b      	ldr	r3, [pc, #108]	; (400630 <prvHeapInit+0x7c>)
  4005c2:	2200      	movs	r2, #0
  4005c4:	605a      	str	r2, [r3, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	pucHeapEnd = xHeap.ucHeap + xTotalHeapSize;
  4005c6:	f44f 4220 	mov.w	r2, #40960	; 0xa000
  4005ca:	4b1a      	ldr	r3, [pc, #104]	; (400634 <prvHeapInit+0x80>)
  4005cc:	4413      	add	r3, r2
  4005ce:	607b      	str	r3, [r7, #4]
	pucHeapEnd -= heapSTRUCT_SIZE;
  4005d0:	2310      	movs	r3, #16
  4005d2:	425b      	negs	r3, r3
  4005d4:	687a      	ldr	r2, [r7, #4]
  4005d6:	4413      	add	r3, r2
  4005d8:	607b      	str	r3, [r7, #4]
	pxEnd = ( void * ) pucHeapEnd;
  4005da:	4a17      	ldr	r2, [pc, #92]	; (400638 <prvHeapInit+0x84>)
  4005dc:	687b      	ldr	r3, [r7, #4]
  4005de:	6013      	str	r3, [r2, #0]
	configASSERT( ( ( ( unsigned long ) pxEnd ) & ( ( unsigned long ) portBYTE_ALIGNMENT_MASK ) ) == 0UL );
  4005e0:	4b15      	ldr	r3, [pc, #84]	; (400638 <prvHeapInit+0x84>)
  4005e2:	681b      	ldr	r3, [r3, #0]
  4005e4:	f003 0307 	and.w	r3, r3, #7
  4005e8:	2b00      	cmp	r3, #0
  4005ea:	d003      	beq.n	4005f4 <prvHeapInit+0x40>
  4005ec:	4b13      	ldr	r3, [pc, #76]	; (40063c <prvHeapInit+0x88>)
  4005ee:	4798      	blx	r3
  4005f0:	bf00      	nop
  4005f2:	e7fd      	b.n	4005f0 <prvHeapInit+0x3c>
	pxEnd->xBlockSize = 0;
  4005f4:	4b10      	ldr	r3, [pc, #64]	; (400638 <prvHeapInit+0x84>)
  4005f6:	681b      	ldr	r3, [r3, #0]
  4005f8:	2200      	movs	r2, #0
  4005fa:	605a      	str	r2, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
  4005fc:	4b0e      	ldr	r3, [pc, #56]	; (400638 <prvHeapInit+0x84>)
  4005fe:	681b      	ldr	r3, [r3, #0]
  400600:	2200      	movs	r2, #0
  400602:	601a      	str	r2, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) xHeap.ucHeap;
  400604:	4b0b      	ldr	r3, [pc, #44]	; (400634 <prvHeapInit+0x80>)
  400606:	603b      	str	r3, [r7, #0]
	pxFirstFreeBlock->xBlockSize = xTotalHeapSize - heapSTRUCT_SIZE;
  400608:	f44f 4320 	mov.w	r3, #40960	; 0xa000
  40060c:	2210      	movs	r2, #16
  40060e:	1a9a      	subs	r2, r3, r2
  400610:	683b      	ldr	r3, [r7, #0]
  400612:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
  400614:	4b08      	ldr	r3, [pc, #32]	; (400638 <prvHeapInit+0x84>)
  400616:	681a      	ldr	r2, [r3, #0]
  400618:	683b      	ldr	r3, [r7, #0]
  40061a:	601a      	str	r2, [r3, #0]

	/* The heap now contains pxEnd. */
	xFreeBytesRemaining -= heapSTRUCT_SIZE;
  40061c:	4b08      	ldr	r3, [pc, #32]	; (400640 <prvHeapInit+0x8c>)
  40061e:	681b      	ldr	r3, [r3, #0]
  400620:	2210      	movs	r2, #16
  400622:	1a9b      	subs	r3, r3, r2
  400624:	4a06      	ldr	r2, [pc, #24]	; (400640 <prvHeapInit+0x8c>)
  400626:	6013      	str	r3, [r2, #0]
}
  400628:	bf00      	nop
  40062a:	3708      	adds	r7, #8
  40062c:	46bd      	mov	sp, r7
  40062e:	bd80      	pop	{r7, pc}
  400630:	2000a470 	.word	0x2000a470
  400634:	20000470 	.word	0x20000470
  400638:	2000a478 	.word	0x2000a478
  40063c:	004003c5 	.word	0x004003c5
  400640:	20000010 	.word	0x20000010

00400644 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( xBlockLink *pxBlockToInsert )
{
  400644:	b480      	push	{r7}
  400646:	b085      	sub	sp, #20
  400648:	af00      	add	r7, sp, #0
  40064a:	6078      	str	r0, [r7, #4]
xBlockLink *pxIterator;
unsigned char *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
  40064c:	4b28      	ldr	r3, [pc, #160]	; (4006f0 <prvInsertBlockIntoFreeList+0xac>)
  40064e:	60fb      	str	r3, [r7, #12]
  400650:	e002      	b.n	400658 <prvInsertBlockIntoFreeList+0x14>
  400652:	68fb      	ldr	r3, [r7, #12]
  400654:	681b      	ldr	r3, [r3, #0]
  400656:	60fb      	str	r3, [r7, #12]
  400658:	68fb      	ldr	r3, [r7, #12]
  40065a:	681a      	ldr	r2, [r3, #0]
  40065c:	687b      	ldr	r3, [r7, #4]
  40065e:	429a      	cmp	r2, r3
  400660:	d3f7      	bcc.n	400652 <prvInsertBlockIntoFreeList+0xe>
		/* Nothing to do here, just iterate to the right position. */
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */	
	puc = ( unsigned char * ) pxIterator;
  400662:	68fb      	ldr	r3, [r7, #12]
  400664:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxIterator->xBlockSize ) == ( unsigned char * ) pxBlockToInsert )
  400666:	68fb      	ldr	r3, [r7, #12]
  400668:	685b      	ldr	r3, [r3, #4]
  40066a:	68ba      	ldr	r2, [r7, #8]
  40066c:	441a      	add	r2, r3
  40066e:	687b      	ldr	r3, [r7, #4]
  400670:	429a      	cmp	r2, r3
  400672:	d108      	bne.n	400686 <prvInsertBlockIntoFreeList+0x42>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
  400674:	68fb      	ldr	r3, [r7, #12]
  400676:	685a      	ldr	r2, [r3, #4]
  400678:	687b      	ldr	r3, [r7, #4]
  40067a:	685b      	ldr	r3, [r3, #4]
  40067c:	441a      	add	r2, r3
  40067e:	68fb      	ldr	r3, [r7, #12]
  400680:	605a      	str	r2, [r3, #4]
		pxBlockToInsert = pxIterator;
  400682:	68fb      	ldr	r3, [r7, #12]
  400684:	607b      	str	r3, [r7, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( unsigned char * ) pxBlockToInsert;
  400686:	687b      	ldr	r3, [r7, #4]
  400688:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( unsigned char * ) pxIterator->pxNextFreeBlock )
  40068a:	687b      	ldr	r3, [r7, #4]
  40068c:	685b      	ldr	r3, [r3, #4]
  40068e:	68ba      	ldr	r2, [r7, #8]
  400690:	441a      	add	r2, r3
  400692:	68fb      	ldr	r3, [r7, #12]
  400694:	681b      	ldr	r3, [r3, #0]
  400696:	429a      	cmp	r2, r3
  400698:	d118      	bne.n	4006cc <prvInsertBlockIntoFreeList+0x88>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
  40069a:	68fb      	ldr	r3, [r7, #12]
  40069c:	681a      	ldr	r2, [r3, #0]
  40069e:	4b15      	ldr	r3, [pc, #84]	; (4006f4 <prvInsertBlockIntoFreeList+0xb0>)
  4006a0:	681b      	ldr	r3, [r3, #0]
  4006a2:	429a      	cmp	r2, r3
  4006a4:	d00d      	beq.n	4006c2 <prvInsertBlockIntoFreeList+0x7e>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
  4006a6:	687b      	ldr	r3, [r7, #4]
  4006a8:	685a      	ldr	r2, [r3, #4]
  4006aa:	68fb      	ldr	r3, [r7, #12]
  4006ac:	681b      	ldr	r3, [r3, #0]
  4006ae:	685b      	ldr	r3, [r3, #4]
  4006b0:	441a      	add	r2, r3
  4006b2:	687b      	ldr	r3, [r7, #4]
  4006b4:	605a      	str	r2, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
  4006b6:	68fb      	ldr	r3, [r7, #12]
  4006b8:	681b      	ldr	r3, [r3, #0]
  4006ba:	681a      	ldr	r2, [r3, #0]
  4006bc:	687b      	ldr	r3, [r7, #4]
  4006be:	601a      	str	r2, [r3, #0]
  4006c0:	e008      	b.n	4006d4 <prvInsertBlockIntoFreeList+0x90>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
  4006c2:	4b0c      	ldr	r3, [pc, #48]	; (4006f4 <prvInsertBlockIntoFreeList+0xb0>)
  4006c4:	681a      	ldr	r2, [r3, #0]
  4006c6:	687b      	ldr	r3, [r7, #4]
  4006c8:	601a      	str	r2, [r3, #0]
  4006ca:	e003      	b.n	4006d4 <prvInsertBlockIntoFreeList+0x90>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;		
  4006cc:	68fb      	ldr	r3, [r7, #12]
  4006ce:	681a      	ldr	r2, [r3, #0]
  4006d0:	687b      	ldr	r3, [r7, #4]
  4006d2:	601a      	str	r2, [r3, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
  4006d4:	68fa      	ldr	r2, [r7, #12]
  4006d6:	687b      	ldr	r3, [r7, #4]
  4006d8:	429a      	cmp	r2, r3
  4006da:	d002      	beq.n	4006e2 <prvInsertBlockIntoFreeList+0x9e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
  4006dc:	68fb      	ldr	r3, [r7, #12]
  4006de:	687a      	ldr	r2, [r7, #4]
  4006e0:	601a      	str	r2, [r3, #0]
	}
}
  4006e2:	bf00      	nop
  4006e4:	3714      	adds	r7, #20
  4006e6:	46bd      	mov	sp, r7
  4006e8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4006ec:	4770      	bx	lr
  4006ee:	bf00      	nop
  4006f0:	2000a470 	.word	0x2000a470
  4006f4:	2000a478 	.word	0x2000a478

004006f8 <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
  4006f8:	b580      	push	{r7, lr}
  4006fa:	b082      	sub	sp, #8
  4006fc:	af00      	add	r7, sp, #0
  4006fe:	6078      	str	r0, [r7, #4]
  400700:	6039      	str	r1, [r7, #0]
	configASSERT( pxQueue );
  400702:	687b      	ldr	r3, [r7, #4]
  400704:	2b00      	cmp	r3, #0
  400706:	d103      	bne.n	400710 <xQueueGenericReset+0x18>
  400708:	4b27      	ldr	r3, [pc, #156]	; (4007a8 <xQueueGenericReset+0xb0>)
  40070a:	4798      	blx	r3
  40070c:	bf00      	nop
  40070e:	e7fd      	b.n	40070c <xQueueGenericReset+0x14>

	taskENTER_CRITICAL();
  400710:	4b26      	ldr	r3, [pc, #152]	; (4007ac <xQueueGenericReset+0xb4>)
  400712:	4798      	blx	r3
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
  400714:	687b      	ldr	r3, [r7, #4]
  400716:	681a      	ldr	r2, [r3, #0]
  400718:	687b      	ldr	r3, [r7, #4]
  40071a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  40071c:	6879      	ldr	r1, [r7, #4]
  40071e:	6c09      	ldr	r1, [r1, #64]	; 0x40
  400720:	fb01 f303 	mul.w	r3, r1, r3
  400724:	441a      	add	r2, r3
  400726:	687b      	ldr	r3, [r7, #4]
  400728:	605a      	str	r2, [r3, #4]
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
  40072a:	687b      	ldr	r3, [r7, #4]
  40072c:	2200      	movs	r2, #0
  40072e:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
  400730:	687b      	ldr	r3, [r7, #4]
  400732:	681a      	ldr	r2, [r3, #0]
  400734:	687b      	ldr	r3, [r7, #4]
  400736:	609a      	str	r2, [r3, #8]
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
  400738:	687b      	ldr	r3, [r7, #4]
  40073a:	681a      	ldr	r2, [r3, #0]
  40073c:	687b      	ldr	r3, [r7, #4]
  40073e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  400740:	3b01      	subs	r3, #1
  400742:	6879      	ldr	r1, [r7, #4]
  400744:	6c09      	ldr	r1, [r1, #64]	; 0x40
  400746:	fb01 f303 	mul.w	r3, r1, r3
  40074a:	441a      	add	r2, r3
  40074c:	687b      	ldr	r3, [r7, #4]
  40074e:	60da      	str	r2, [r3, #12]
		pxQueue->xRxLock = queueUNLOCKED;
  400750:	687b      	ldr	r3, [r7, #4]
  400752:	f04f 32ff 	mov.w	r2, #4294967295
  400756:	645a      	str	r2, [r3, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
  400758:	687b      	ldr	r3, [r7, #4]
  40075a:	f04f 32ff 	mov.w	r2, #4294967295
  40075e:	649a      	str	r2, [r3, #72]	; 0x48

		if( xNewQueue == pdFALSE )
  400760:	683b      	ldr	r3, [r7, #0]
  400762:	2b00      	cmp	r3, #0
  400764:	d10e      	bne.n	400784 <xQueueGenericReset+0x8c>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  400766:	687b      	ldr	r3, [r7, #4]
  400768:	691b      	ldr	r3, [r3, #16]
  40076a:	2b00      	cmp	r3, #0
  40076c:	d014      	beq.n	400798 <xQueueGenericReset+0xa0>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
  40076e:	687b      	ldr	r3, [r7, #4]
  400770:	3310      	adds	r3, #16
  400772:	4618      	mov	r0, r3
  400774:	4b0e      	ldr	r3, [pc, #56]	; (4007b0 <xQueueGenericReset+0xb8>)
  400776:	4798      	blx	r3
  400778:	4603      	mov	r3, r0
  40077a:	2b01      	cmp	r3, #1
  40077c:	d10c      	bne.n	400798 <xQueueGenericReset+0xa0>
				{
					portYIELD_WITHIN_API();
  40077e:	4b0d      	ldr	r3, [pc, #52]	; (4007b4 <xQueueGenericReset+0xbc>)
  400780:	4798      	blx	r3
  400782:	e009      	b.n	400798 <xQueueGenericReset+0xa0>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
  400784:	687b      	ldr	r3, [r7, #4]
  400786:	3310      	adds	r3, #16
  400788:	4618      	mov	r0, r3
  40078a:	4b0b      	ldr	r3, [pc, #44]	; (4007b8 <xQueueGenericReset+0xc0>)
  40078c:	4798      	blx	r3
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
  40078e:	687b      	ldr	r3, [r7, #4]
  400790:	3324      	adds	r3, #36	; 0x24
  400792:	4618      	mov	r0, r3
  400794:	4b08      	ldr	r3, [pc, #32]	; (4007b8 <xQueueGenericReset+0xc0>)
  400796:	4798      	blx	r3
		}
	}
	taskEXIT_CRITICAL();
  400798:	4b08      	ldr	r3, [pc, #32]	; (4007bc <xQueueGenericReset+0xc4>)
  40079a:	4798      	blx	r3

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
  40079c:	2301      	movs	r3, #1
}
  40079e:	4618      	mov	r0, r3
  4007a0:	3708      	adds	r7, #8
  4007a2:	46bd      	mov	sp, r7
  4007a4:	bd80      	pop	{r7, pc}
  4007a6:	bf00      	nop
  4007a8:	004003c5 	.word	0x004003c5
  4007ac:	0040037d 	.word	0x0040037d
  4007b0:	00400b85 	.word	0x00400b85
  4007b4:	00400361 	.word	0x00400361
  4007b8:	0040025d 	.word	0x0040025d
  4007bc:	0040039d 	.word	0x0040039d

004007c0 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
  4007c0:	b580      	push	{r7, lr}
  4007c2:	b088      	sub	sp, #32
  4007c4:	af00      	add	r7, sp, #0
  4007c6:	60f8      	str	r0, [r7, #12]
  4007c8:	60b9      	str	r1, [r7, #8]
  4007ca:	4613      	mov	r3, r2
  4007cc:	71fb      	strb	r3, [r7, #7]
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
  4007ce:	2300      	movs	r3, #0
  4007d0:	61fb      	str	r3, [r7, #28]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
  4007d2:	68fb      	ldr	r3, [r7, #12]
  4007d4:	2b00      	cmp	r3, #0
  4007d6:	d02a      	beq.n	40082e <xQueueGenericCreate+0x6e>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
  4007d8:	2050      	movs	r0, #80	; 0x50
  4007da:	4b1b      	ldr	r3, [pc, #108]	; (400848 <xQueueGenericCreate+0x88>)
  4007dc:	4798      	blx	r3
  4007de:	61b8      	str	r0, [r7, #24]
		if( pxNewQueue != NULL )
  4007e0:	69bb      	ldr	r3, [r7, #24]
  4007e2:	2b00      	cmp	r3, #0
  4007e4:	d023      	beq.n	40082e <xQueueGenericCreate+0x6e>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
  4007e6:	68fb      	ldr	r3, [r7, #12]
  4007e8:	68ba      	ldr	r2, [r7, #8]
  4007ea:	fb02 f303 	mul.w	r3, r2, r3
  4007ee:	3301      	adds	r3, #1
  4007f0:	617b      	str	r3, [r7, #20]

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
  4007f2:	6978      	ldr	r0, [r7, #20]
  4007f4:	4b14      	ldr	r3, [pc, #80]	; (400848 <xQueueGenericCreate+0x88>)
  4007f6:	4798      	blx	r3
  4007f8:	4602      	mov	r2, r0
  4007fa:	69bb      	ldr	r3, [r7, #24]
  4007fc:	601a      	str	r2, [r3, #0]
			if( pxNewQueue->pcHead != NULL )
  4007fe:	69bb      	ldr	r3, [r7, #24]
  400800:	681b      	ldr	r3, [r3, #0]
  400802:	2b00      	cmp	r3, #0
  400804:	d010      	beq.n	400828 <xQueueGenericCreate+0x68>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
  400806:	69bb      	ldr	r3, [r7, #24]
  400808:	68fa      	ldr	r2, [r7, #12]
  40080a:	63da      	str	r2, [r3, #60]	; 0x3c
				pxNewQueue->uxItemSize = uxItemSize;
  40080c:	69bb      	ldr	r3, [r7, #24]
  40080e:	68ba      	ldr	r2, [r7, #8]
  400810:	641a      	str	r2, [r3, #64]	; 0x40
				xQueueGenericReset( pxNewQueue, pdTRUE );
  400812:	2101      	movs	r1, #1
  400814:	69b8      	ldr	r0, [r7, #24]
  400816:	4b0d      	ldr	r3, [pc, #52]	; (40084c <xQueueGenericCreate+0x8c>)
  400818:	4798      	blx	r3
				#if ( configUSE_TRACE_FACILITY == 1 )
				{
					pxNewQueue->ucQueueType = ucQueueType;
  40081a:	69bb      	ldr	r3, [r7, #24]
  40081c:	79fa      	ldrb	r2, [r7, #7]
  40081e:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
				}
				#endif /* configUSE_TRACE_FACILITY */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
  400822:	69bb      	ldr	r3, [r7, #24]
  400824:	61fb      	str	r3, [r7, #28]
  400826:	e002      	b.n	40082e <xQueueGenericCreate+0x6e>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
  400828:	69b8      	ldr	r0, [r7, #24]
  40082a:	4b09      	ldr	r3, [pc, #36]	; (400850 <xQueueGenericCreate+0x90>)
  40082c:	4798      	blx	r3
			}
		}
	}

	configASSERT( xReturn );
  40082e:	69fb      	ldr	r3, [r7, #28]
  400830:	2b00      	cmp	r3, #0
  400832:	d103      	bne.n	40083c <xQueueGenericCreate+0x7c>
  400834:	4b07      	ldr	r3, [pc, #28]	; (400854 <xQueueGenericCreate+0x94>)
  400836:	4798      	blx	r3
  400838:	bf00      	nop
  40083a:	e7fd      	b.n	400838 <xQueueGenericCreate+0x78>

	return xReturn;
  40083c:	69fb      	ldr	r3, [r7, #28]
}
  40083e:	4618      	mov	r0, r3
  400840:	3720      	adds	r7, #32
  400842:	46bd      	mov	sp, r7
  400844:	bd80      	pop	{r7, pc}
  400846:	bf00      	nop
  400848:	00400465 	.word	0x00400465
  40084c:	004006f9 	.word	0x004006f9
  400850:	00400561 	.word	0x00400561
  400854:	004003c5 	.word	0x004003c5

00400858 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
  400858:	b480      	push	{r7}
  40085a:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
  40085c:	4b04      	ldr	r3, [pc, #16]	; (400870 <vTaskSuspendAll+0x18>)
  40085e:	681b      	ldr	r3, [r3, #0]
  400860:	3301      	adds	r3, #1
  400862:	4a03      	ldr	r2, [pc, #12]	; (400870 <vTaskSuspendAll+0x18>)
  400864:	6013      	str	r3, [r2, #0]
}
  400866:	bf00      	nop
  400868:	46bd      	mov	sp, r7
  40086a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40086e:	4770      	bx	lr
  400870:	2000a50c 	.word	0x2000a50c

00400874 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
  400874:	b590      	push	{r4, r7, lr}
  400876:	b083      	sub	sp, #12
  400878:	af00      	add	r7, sp, #0
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
  40087a:	2300      	movs	r3, #0
  40087c:	607b      	str	r3, [r7, #4]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
  40087e:	4b36      	ldr	r3, [pc, #216]	; (400958 <xTaskResumeAll+0xe4>)
  400880:	681b      	ldr	r3, [r3, #0]
  400882:	2b00      	cmp	r3, #0
  400884:	d103      	bne.n	40088e <xTaskResumeAll+0x1a>
  400886:	4b35      	ldr	r3, [pc, #212]	; (40095c <xTaskResumeAll+0xe8>)
  400888:	4798      	blx	r3
  40088a:	bf00      	nop
  40088c:	e7fd      	b.n	40088a <xTaskResumeAll+0x16>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
  40088e:	4b34      	ldr	r3, [pc, #208]	; (400960 <xTaskResumeAll+0xec>)
  400890:	4798      	blx	r3
	{
		--uxSchedulerSuspended;
  400892:	4b31      	ldr	r3, [pc, #196]	; (400958 <xTaskResumeAll+0xe4>)
  400894:	681b      	ldr	r3, [r3, #0]
  400896:	3b01      	subs	r3, #1
  400898:	4a2f      	ldr	r2, [pc, #188]	; (400958 <xTaskResumeAll+0xe4>)
  40089a:	6013      	str	r3, [r2, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  40089c:	4b2e      	ldr	r3, [pc, #184]	; (400958 <xTaskResumeAll+0xe4>)
  40089e:	681b      	ldr	r3, [r3, #0]
  4008a0:	2b00      	cmp	r3, #0
  4008a2:	d152      	bne.n	40094a <xTaskResumeAll+0xd6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
  4008a4:	4b2f      	ldr	r3, [pc, #188]	; (400964 <xTaskResumeAll+0xf0>)
  4008a6:	681b      	ldr	r3, [r3, #0]
  4008a8:	2b00      	cmp	r3, #0
  4008aa:	d04e      	beq.n	40094a <xTaskResumeAll+0xd6>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
  4008ac:	2300      	movs	r3, #0
  4008ae:	603b      	str	r3, [r7, #0]

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
  4008b0:	e027      	b.n	400902 <xTaskResumeAll+0x8e>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
  4008b2:	4b2d      	ldr	r3, [pc, #180]	; (400968 <xTaskResumeAll+0xf4>)
  4008b4:	68db      	ldr	r3, [r3, #12]
  4008b6:	68dc      	ldr	r4, [r3, #12]
					uxListRemove( &( pxTCB->xEventListItem ) );
  4008b8:	f104 0318 	add.w	r3, r4, #24
  4008bc:	4618      	mov	r0, r3
  4008be:	4b2b      	ldr	r3, [pc, #172]	; (40096c <xTaskResumeAll+0xf8>)
  4008c0:	4798      	blx	r3
					uxListRemove( &( pxTCB->xGenericListItem ) );
  4008c2:	1d23      	adds	r3, r4, #4
  4008c4:	4618      	mov	r0, r3
  4008c6:	4b29      	ldr	r3, [pc, #164]	; (40096c <xTaskResumeAll+0xf8>)
  4008c8:	4798      	blx	r3
					prvAddTaskToReadyQueue( pxTCB );
  4008ca:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  4008cc:	4b28      	ldr	r3, [pc, #160]	; (400970 <xTaskResumeAll+0xfc>)
  4008ce:	681b      	ldr	r3, [r3, #0]
  4008d0:	429a      	cmp	r2, r3
  4008d2:	d902      	bls.n	4008da <xTaskResumeAll+0x66>
  4008d4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  4008d6:	4a26      	ldr	r2, [pc, #152]	; (400970 <xTaskResumeAll+0xfc>)
  4008d8:	6013      	str	r3, [r2, #0]
  4008da:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  4008dc:	4613      	mov	r3, r2
  4008de:	009b      	lsls	r3, r3, #2
  4008e0:	4413      	add	r3, r2
  4008e2:	009b      	lsls	r3, r3, #2
  4008e4:	4a23      	ldr	r2, [pc, #140]	; (400974 <xTaskResumeAll+0x100>)
  4008e6:	4413      	add	r3, r2
  4008e8:	1d22      	adds	r2, r4, #4
  4008ea:	4611      	mov	r1, r2
  4008ec:	4618      	mov	r0, r3
  4008ee:	4b22      	ldr	r3, [pc, #136]	; (400978 <xTaskResumeAll+0x104>)
  4008f0:	4798      	blx	r3

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  4008f2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  4008f4:	4b21      	ldr	r3, [pc, #132]	; (40097c <xTaskResumeAll+0x108>)
  4008f6:	681b      	ldr	r3, [r3, #0]
  4008f8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4008fa:	429a      	cmp	r2, r3
  4008fc:	d301      	bcc.n	400902 <xTaskResumeAll+0x8e>
					{
						xYieldRequired = pdTRUE;
  4008fe:	2301      	movs	r3, #1
  400900:	603b      	str	r3, [r7, #0]
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
  400902:	4b19      	ldr	r3, [pc, #100]	; (400968 <xTaskResumeAll+0xf4>)
  400904:	681b      	ldr	r3, [r3, #0]
  400906:	2b00      	cmp	r3, #0
  400908:	d1d3      	bne.n	4008b2 <xTaskResumeAll+0x3e>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
  40090a:	4b1d      	ldr	r3, [pc, #116]	; (400980 <xTaskResumeAll+0x10c>)
  40090c:	681b      	ldr	r3, [r3, #0]
  40090e:	2b00      	cmp	r3, #0
  400910:	d00d      	beq.n	40092e <xTaskResumeAll+0xba>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
  400912:	e006      	b.n	400922 <xTaskResumeAll+0xae>
					{
						vTaskIncrementTick();
  400914:	4b1b      	ldr	r3, [pc, #108]	; (400984 <xTaskResumeAll+0x110>)
  400916:	4798      	blx	r3
						--uxMissedTicks;
  400918:	4b19      	ldr	r3, [pc, #100]	; (400980 <xTaskResumeAll+0x10c>)
  40091a:	681b      	ldr	r3, [r3, #0]
  40091c:	3b01      	subs	r3, #1
  40091e:	4a18      	ldr	r2, [pc, #96]	; (400980 <xTaskResumeAll+0x10c>)
  400920:	6013      	str	r3, [r2, #0]
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
  400922:	4b17      	ldr	r3, [pc, #92]	; (400980 <xTaskResumeAll+0x10c>)
  400924:	681b      	ldr	r3, [r3, #0]
  400926:	2b00      	cmp	r3, #0
  400928:	d1f4      	bne.n	400914 <xTaskResumeAll+0xa0>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
  40092a:	2301      	movs	r3, #1
  40092c:	603b      	str	r3, [r7, #0]
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
  40092e:	683b      	ldr	r3, [r7, #0]
  400930:	2b01      	cmp	r3, #1
  400932:	d003      	beq.n	40093c <xTaskResumeAll+0xc8>
  400934:	4b14      	ldr	r3, [pc, #80]	; (400988 <xTaskResumeAll+0x114>)
  400936:	681b      	ldr	r3, [r3, #0]
  400938:	2b01      	cmp	r3, #1
  40093a:	d106      	bne.n	40094a <xTaskResumeAll+0xd6>
				{
					xAlreadyYielded = pdTRUE;
  40093c:	2301      	movs	r3, #1
  40093e:	607b      	str	r3, [r7, #4]
					xMissedYield = pdFALSE;
  400940:	4b11      	ldr	r3, [pc, #68]	; (400988 <xTaskResumeAll+0x114>)
  400942:	2200      	movs	r2, #0
  400944:	601a      	str	r2, [r3, #0]
					portYIELD_WITHIN_API();
  400946:	4b11      	ldr	r3, [pc, #68]	; (40098c <xTaskResumeAll+0x118>)
  400948:	4798      	blx	r3
				}
			}
		}
	}
	taskEXIT_CRITICAL();
  40094a:	4b11      	ldr	r3, [pc, #68]	; (400990 <xTaskResumeAll+0x11c>)
  40094c:	4798      	blx	r3

	return xAlreadyYielded;
  40094e:	687b      	ldr	r3, [r7, #4]
}
  400950:	4618      	mov	r0, r3
  400952:	370c      	adds	r7, #12
  400954:	46bd      	mov	sp, r7
  400956:	bd90      	pop	{r4, r7, pc}
  400958:	2000a50c 	.word	0x2000a50c
  40095c:	004003c5 	.word	0x004003c5
  400960:	0040037d 	.word	0x0040037d
  400964:	2000a500 	.word	0x2000a500
  400968:	2000a4ec 	.word	0x2000a4ec
  40096c:	004002ed 	.word	0x004002ed
  400970:	2000a508 	.word	0x2000a508
  400974:	2000a480 	.word	0x2000a480
  400978:	0040029d 	.word	0x0040029d
  40097c:	2000a47c 	.word	0x2000a47c
  400980:	2000a510 	.word	0x2000a510
  400984:	00400995 	.word	0x00400995
  400988:	2000a514 	.word	0x2000a514
  40098c:	00400361 	.word	0x00400361
  400990:	0040039d 	.word	0x0040039d

00400994 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
  400994:	b580      	push	{r7, lr}
  400996:	b084      	sub	sp, #16
  400998:	af00      	add	r7, sp, #0

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  40099a:	4b45      	ldr	r3, [pc, #276]	; (400ab0 <vTaskIncrementTick+0x11c>)
  40099c:	681b      	ldr	r3, [r3, #0]
  40099e:	2b00      	cmp	r3, #0
  4009a0:	d17b      	bne.n	400a9a <vTaskIncrementTick+0x106>
	{
		++xTickCount;
  4009a2:	4b44      	ldr	r3, [pc, #272]	; (400ab4 <vTaskIncrementTick+0x120>)
  4009a4:	681b      	ldr	r3, [r3, #0]
  4009a6:	3301      	adds	r3, #1
  4009a8:	4a42      	ldr	r2, [pc, #264]	; (400ab4 <vTaskIncrementTick+0x120>)
  4009aa:	6013      	str	r3, [r2, #0]
		if( xTickCount == ( portTickType ) 0U )
  4009ac:	4b41      	ldr	r3, [pc, #260]	; (400ab4 <vTaskIncrementTick+0x120>)
  4009ae:	681b      	ldr	r3, [r3, #0]
  4009b0:	2b00      	cmp	r3, #0
  4009b2:	d12a      	bne.n	400a0a <vTaskIncrementTick+0x76>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
  4009b4:	4b40      	ldr	r3, [pc, #256]	; (400ab8 <vTaskIncrementTick+0x124>)
  4009b6:	681b      	ldr	r3, [r3, #0]
  4009b8:	681b      	ldr	r3, [r3, #0]
  4009ba:	2b00      	cmp	r3, #0
  4009bc:	d003      	beq.n	4009c6 <vTaskIncrementTick+0x32>
  4009be:	4b3f      	ldr	r3, [pc, #252]	; (400abc <vTaskIncrementTick+0x128>)
  4009c0:	4798      	blx	r3
  4009c2:	bf00      	nop
  4009c4:	e7fd      	b.n	4009c2 <vTaskIncrementTick+0x2e>

			pxTemp = pxDelayedTaskList;
  4009c6:	4b3c      	ldr	r3, [pc, #240]	; (400ab8 <vTaskIncrementTick+0x124>)
  4009c8:	681b      	ldr	r3, [r3, #0]
  4009ca:	60fb      	str	r3, [r7, #12]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
  4009cc:	4b3c      	ldr	r3, [pc, #240]	; (400ac0 <vTaskIncrementTick+0x12c>)
  4009ce:	681b      	ldr	r3, [r3, #0]
  4009d0:	4a39      	ldr	r2, [pc, #228]	; (400ab8 <vTaskIncrementTick+0x124>)
  4009d2:	6013      	str	r3, [r2, #0]
			pxOverflowDelayedTaskList = pxTemp;
  4009d4:	4a3a      	ldr	r2, [pc, #232]	; (400ac0 <vTaskIncrementTick+0x12c>)
  4009d6:	68fb      	ldr	r3, [r7, #12]
  4009d8:	6013      	str	r3, [r2, #0]
			xNumOfOverflows++;
  4009da:	4b3a      	ldr	r3, [pc, #232]	; (400ac4 <vTaskIncrementTick+0x130>)
  4009dc:	681b      	ldr	r3, [r3, #0]
  4009de:	3301      	adds	r3, #1
  4009e0:	4a38      	ldr	r2, [pc, #224]	; (400ac4 <vTaskIncrementTick+0x130>)
  4009e2:	6013      	str	r3, [r2, #0]

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  4009e4:	4b34      	ldr	r3, [pc, #208]	; (400ab8 <vTaskIncrementTick+0x124>)
  4009e6:	681b      	ldr	r3, [r3, #0]
  4009e8:	681b      	ldr	r3, [r3, #0]
  4009ea:	2b00      	cmp	r3, #0
  4009ec:	d104      	bne.n	4009f8 <vTaskIncrementTick+0x64>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
  4009ee:	4b36      	ldr	r3, [pc, #216]	; (400ac8 <vTaskIncrementTick+0x134>)
  4009f0:	f04f 32ff 	mov.w	r2, #4294967295
  4009f4:	601a      	str	r2, [r3, #0]
  4009f6:	e008      	b.n	400a0a <vTaskIncrementTick+0x76>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  4009f8:	4b2f      	ldr	r3, [pc, #188]	; (400ab8 <vTaskIncrementTick+0x124>)
  4009fa:	681b      	ldr	r3, [r3, #0]
  4009fc:	68db      	ldr	r3, [r3, #12]
  4009fe:	68db      	ldr	r3, [r3, #12]
  400a00:	60bb      	str	r3, [r7, #8]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
  400a02:	68bb      	ldr	r3, [r7, #8]
  400a04:	685b      	ldr	r3, [r3, #4]
  400a06:	4a30      	ldr	r2, [pc, #192]	; (400ac8 <vTaskIncrementTick+0x134>)
  400a08:	6013      	str	r3, [r2, #0]
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
  400a0a:	4b2a      	ldr	r3, [pc, #168]	; (400ab4 <vTaskIncrementTick+0x120>)
  400a0c:	681a      	ldr	r2, [r3, #0]
  400a0e:	4b2e      	ldr	r3, [pc, #184]	; (400ac8 <vTaskIncrementTick+0x134>)
  400a10:	681b      	ldr	r3, [r3, #0]
  400a12:	429a      	cmp	r2, r3
  400a14:	d347      	bcc.n	400aa6 <vTaskIncrementTick+0x112>
  400a16:	4b28      	ldr	r3, [pc, #160]	; (400ab8 <vTaskIncrementTick+0x124>)
  400a18:	681b      	ldr	r3, [r3, #0]
  400a1a:	681b      	ldr	r3, [r3, #0]
  400a1c:	2b00      	cmp	r3, #0
  400a1e:	d104      	bne.n	400a2a <vTaskIncrementTick+0x96>
  400a20:	4b29      	ldr	r3, [pc, #164]	; (400ac8 <vTaskIncrementTick+0x134>)
  400a22:	f04f 32ff 	mov.w	r2, #4294967295
  400a26:	601a      	str	r2, [r3, #0]
  400a28:	e03d      	b.n	400aa6 <vTaskIncrementTick+0x112>
  400a2a:	4b23      	ldr	r3, [pc, #140]	; (400ab8 <vTaskIncrementTick+0x124>)
  400a2c:	681b      	ldr	r3, [r3, #0]
  400a2e:	68db      	ldr	r3, [r3, #12]
  400a30:	68db      	ldr	r3, [r3, #12]
  400a32:	60bb      	str	r3, [r7, #8]
  400a34:	68bb      	ldr	r3, [r7, #8]
  400a36:	685b      	ldr	r3, [r3, #4]
  400a38:	607b      	str	r3, [r7, #4]
  400a3a:	4b1e      	ldr	r3, [pc, #120]	; (400ab4 <vTaskIncrementTick+0x120>)
  400a3c:	681a      	ldr	r2, [r3, #0]
  400a3e:	687b      	ldr	r3, [r7, #4]
  400a40:	429a      	cmp	r2, r3
  400a42:	d203      	bcs.n	400a4c <vTaskIncrementTick+0xb8>
  400a44:	4a20      	ldr	r2, [pc, #128]	; (400ac8 <vTaskIncrementTick+0x134>)
  400a46:	687b      	ldr	r3, [r7, #4]
  400a48:	6013      	str	r3, [r2, #0]
  400a4a:	e02c      	b.n	400aa6 <vTaskIncrementTick+0x112>
  400a4c:	68bb      	ldr	r3, [r7, #8]
  400a4e:	3304      	adds	r3, #4
  400a50:	4618      	mov	r0, r3
  400a52:	4b1e      	ldr	r3, [pc, #120]	; (400acc <vTaskIncrementTick+0x138>)
  400a54:	4798      	blx	r3
  400a56:	68bb      	ldr	r3, [r7, #8]
  400a58:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  400a5a:	2b00      	cmp	r3, #0
  400a5c:	d004      	beq.n	400a68 <vTaskIncrementTick+0xd4>
  400a5e:	68bb      	ldr	r3, [r7, #8]
  400a60:	3318      	adds	r3, #24
  400a62:	4618      	mov	r0, r3
  400a64:	4b19      	ldr	r3, [pc, #100]	; (400acc <vTaskIncrementTick+0x138>)
  400a66:	4798      	blx	r3
  400a68:	68bb      	ldr	r3, [r7, #8]
  400a6a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  400a6c:	4b18      	ldr	r3, [pc, #96]	; (400ad0 <vTaskIncrementTick+0x13c>)
  400a6e:	681b      	ldr	r3, [r3, #0]
  400a70:	429a      	cmp	r2, r3
  400a72:	d903      	bls.n	400a7c <vTaskIncrementTick+0xe8>
  400a74:	68bb      	ldr	r3, [r7, #8]
  400a76:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  400a78:	4a15      	ldr	r2, [pc, #84]	; (400ad0 <vTaskIncrementTick+0x13c>)
  400a7a:	6013      	str	r3, [r2, #0]
  400a7c:	68bb      	ldr	r3, [r7, #8]
  400a7e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  400a80:	4613      	mov	r3, r2
  400a82:	009b      	lsls	r3, r3, #2
  400a84:	4413      	add	r3, r2
  400a86:	009b      	lsls	r3, r3, #2
  400a88:	4a12      	ldr	r2, [pc, #72]	; (400ad4 <vTaskIncrementTick+0x140>)
  400a8a:	441a      	add	r2, r3
  400a8c:	68bb      	ldr	r3, [r7, #8]
  400a8e:	3304      	adds	r3, #4
  400a90:	4619      	mov	r1, r3
  400a92:	4610      	mov	r0, r2
  400a94:	4b10      	ldr	r3, [pc, #64]	; (400ad8 <vTaskIncrementTick+0x144>)
  400a96:	4798      	blx	r3
  400a98:	e7bd      	b.n	400a16 <vTaskIncrementTick+0x82>
	}
	else
	{
		++uxMissedTicks;
  400a9a:	4b10      	ldr	r3, [pc, #64]	; (400adc <vTaskIncrementTick+0x148>)
  400a9c:	681b      	ldr	r3, [r3, #0]
  400a9e:	3301      	adds	r3, #1
  400aa0:	4a0e      	ldr	r2, [pc, #56]	; (400adc <vTaskIncrementTick+0x148>)
  400aa2:	6013      	str	r3, [r2, #0]
		{
			vApplicationTickHook();
		}
	}
	#endif
}
  400aa4:	e7ff      	b.n	400aa6 <vTaskIncrementTick+0x112>
  400aa6:	bf00      	nop
  400aa8:	3710      	adds	r7, #16
  400aaa:	46bd      	mov	sp, r7
  400aac:	bd80      	pop	{r7, pc}
  400aae:	bf00      	nop
  400ab0:	2000a50c 	.word	0x2000a50c
  400ab4:	2000a504 	.word	0x2000a504
  400ab8:	2000a4e4 	.word	0x2000a4e4
  400abc:	004003c5 	.word	0x004003c5
  400ac0:	2000a4e8 	.word	0x2000a4e8
  400ac4:	2000a518 	.word	0x2000a518
  400ac8:	20000014 	.word	0x20000014
  400acc:	004002ed 	.word	0x004002ed
  400ad0:	2000a508 	.word	0x2000a508
  400ad4:	2000a480 	.word	0x2000a480
  400ad8:	0040029d 	.word	0x0040029d
  400adc:	2000a510 	.word	0x2000a510

00400ae0 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
  400ae0:	b580      	push	{r7, lr}
  400ae2:	b082      	sub	sp, #8
  400ae4:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
  400ae6:	4b21      	ldr	r3, [pc, #132]	; (400b6c <vTaskSwitchContext+0x8c>)
  400ae8:	681b      	ldr	r3, [r3, #0]
  400aea:	2b00      	cmp	r3, #0
  400aec:	d010      	beq.n	400b10 <vTaskSwitchContext+0x30>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
  400aee:	4b20      	ldr	r3, [pc, #128]	; (400b70 <vTaskSwitchContext+0x90>)
  400af0:	2201      	movs	r2, #1
  400af2:	601a      	str	r2, [r3, #0]

		taskSELECT_HIGHEST_PRIORITY_TASK();

		traceTASK_SWITCHED_IN();
	}
}
  400af4:	e035      	b.n	400b62 <vTaskSwitchContext+0x82>
		taskSELECT_HIGHEST_PRIORITY_TASK();
  400af6:	4b1f      	ldr	r3, [pc, #124]	; (400b74 <vTaskSwitchContext+0x94>)
  400af8:	681b      	ldr	r3, [r3, #0]
  400afa:	2b00      	cmp	r3, #0
  400afc:	d103      	bne.n	400b06 <vTaskSwitchContext+0x26>
  400afe:	4b1e      	ldr	r3, [pc, #120]	; (400b78 <vTaskSwitchContext+0x98>)
  400b00:	4798      	blx	r3
  400b02:	bf00      	nop
  400b04:	e7fd      	b.n	400b02 <vTaskSwitchContext+0x22>
  400b06:	4b1b      	ldr	r3, [pc, #108]	; (400b74 <vTaskSwitchContext+0x94>)
  400b08:	681b      	ldr	r3, [r3, #0]
  400b0a:	3b01      	subs	r3, #1
  400b0c:	4a19      	ldr	r2, [pc, #100]	; (400b74 <vTaskSwitchContext+0x94>)
  400b0e:	6013      	str	r3, [r2, #0]
  400b10:	4b18      	ldr	r3, [pc, #96]	; (400b74 <vTaskSwitchContext+0x94>)
  400b12:	681a      	ldr	r2, [r3, #0]
  400b14:	4919      	ldr	r1, [pc, #100]	; (400b7c <vTaskSwitchContext+0x9c>)
  400b16:	4613      	mov	r3, r2
  400b18:	009b      	lsls	r3, r3, #2
  400b1a:	4413      	add	r3, r2
  400b1c:	009b      	lsls	r3, r3, #2
  400b1e:	440b      	add	r3, r1
  400b20:	681b      	ldr	r3, [r3, #0]
  400b22:	2b00      	cmp	r3, #0
  400b24:	d0e7      	beq.n	400af6 <vTaskSwitchContext+0x16>
  400b26:	4b13      	ldr	r3, [pc, #76]	; (400b74 <vTaskSwitchContext+0x94>)
  400b28:	681a      	ldr	r2, [r3, #0]
  400b2a:	4613      	mov	r3, r2
  400b2c:	009b      	lsls	r3, r3, #2
  400b2e:	4413      	add	r3, r2
  400b30:	009b      	lsls	r3, r3, #2
  400b32:	4a12      	ldr	r2, [pc, #72]	; (400b7c <vTaskSwitchContext+0x9c>)
  400b34:	4413      	add	r3, r2
  400b36:	607b      	str	r3, [r7, #4]
  400b38:	687b      	ldr	r3, [r7, #4]
  400b3a:	685b      	ldr	r3, [r3, #4]
  400b3c:	685a      	ldr	r2, [r3, #4]
  400b3e:	687b      	ldr	r3, [r7, #4]
  400b40:	605a      	str	r2, [r3, #4]
  400b42:	687b      	ldr	r3, [r7, #4]
  400b44:	685a      	ldr	r2, [r3, #4]
  400b46:	687b      	ldr	r3, [r7, #4]
  400b48:	3308      	adds	r3, #8
  400b4a:	429a      	cmp	r2, r3
  400b4c:	d104      	bne.n	400b58 <vTaskSwitchContext+0x78>
  400b4e:	687b      	ldr	r3, [r7, #4]
  400b50:	685b      	ldr	r3, [r3, #4]
  400b52:	685a      	ldr	r2, [r3, #4]
  400b54:	687b      	ldr	r3, [r7, #4]
  400b56:	605a      	str	r2, [r3, #4]
  400b58:	687b      	ldr	r3, [r7, #4]
  400b5a:	685b      	ldr	r3, [r3, #4]
  400b5c:	68db      	ldr	r3, [r3, #12]
  400b5e:	4a08      	ldr	r2, [pc, #32]	; (400b80 <vTaskSwitchContext+0xa0>)
  400b60:	6013      	str	r3, [r2, #0]
}
  400b62:	bf00      	nop
  400b64:	3708      	adds	r7, #8
  400b66:	46bd      	mov	sp, r7
  400b68:	bd80      	pop	{r7, pc}
  400b6a:	bf00      	nop
  400b6c:	2000a50c 	.word	0x2000a50c
  400b70:	2000a514 	.word	0x2000a514
  400b74:	2000a508 	.word	0x2000a508
  400b78:	004003c5 	.word	0x004003c5
  400b7c:	2000a480 	.word	0x2000a480
  400b80:	2000a47c 	.word	0x2000a47c

00400b84 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
  400b84:	b580      	push	{r7, lr}
  400b86:	b084      	sub	sp, #16
  400b88:	af00      	add	r7, sp, #0
  400b8a:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
  400b8c:	687b      	ldr	r3, [r7, #4]
  400b8e:	68db      	ldr	r3, [r3, #12]
  400b90:	68db      	ldr	r3, [r3, #12]
  400b92:	60bb      	str	r3, [r7, #8]
	configASSERT( pxUnblockedTCB );
  400b94:	68bb      	ldr	r3, [r7, #8]
  400b96:	2b00      	cmp	r3, #0
  400b98:	d103      	bne.n	400ba2 <xTaskRemoveFromEventList+0x1e>
  400b9a:	4b21      	ldr	r3, [pc, #132]	; (400c20 <xTaskRemoveFromEventList+0x9c>)
  400b9c:	4798      	blx	r3
  400b9e:	bf00      	nop
  400ba0:	e7fd      	b.n	400b9e <xTaskRemoveFromEventList+0x1a>
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
  400ba2:	68bb      	ldr	r3, [r7, #8]
  400ba4:	3318      	adds	r3, #24
  400ba6:	4618      	mov	r0, r3
  400ba8:	4b1e      	ldr	r3, [pc, #120]	; (400c24 <xTaskRemoveFromEventList+0xa0>)
  400baa:	4798      	blx	r3

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  400bac:	4b1e      	ldr	r3, [pc, #120]	; (400c28 <xTaskRemoveFromEventList+0xa4>)
  400bae:	681b      	ldr	r3, [r3, #0]
  400bb0:	2b00      	cmp	r3, #0
  400bb2:	d11d      	bne.n	400bf0 <xTaskRemoveFromEventList+0x6c>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
  400bb4:	68bb      	ldr	r3, [r7, #8]
  400bb6:	3304      	adds	r3, #4
  400bb8:	4618      	mov	r0, r3
  400bba:	4b1a      	ldr	r3, [pc, #104]	; (400c24 <xTaskRemoveFromEventList+0xa0>)
  400bbc:	4798      	blx	r3
		prvAddTaskToReadyQueue( pxUnblockedTCB );
  400bbe:	68bb      	ldr	r3, [r7, #8]
  400bc0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  400bc2:	4b1a      	ldr	r3, [pc, #104]	; (400c2c <xTaskRemoveFromEventList+0xa8>)
  400bc4:	681b      	ldr	r3, [r3, #0]
  400bc6:	429a      	cmp	r2, r3
  400bc8:	d903      	bls.n	400bd2 <xTaskRemoveFromEventList+0x4e>
  400bca:	68bb      	ldr	r3, [r7, #8]
  400bcc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  400bce:	4a17      	ldr	r2, [pc, #92]	; (400c2c <xTaskRemoveFromEventList+0xa8>)
  400bd0:	6013      	str	r3, [r2, #0]
  400bd2:	68bb      	ldr	r3, [r7, #8]
  400bd4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  400bd6:	4613      	mov	r3, r2
  400bd8:	009b      	lsls	r3, r3, #2
  400bda:	4413      	add	r3, r2
  400bdc:	009b      	lsls	r3, r3, #2
  400bde:	4a14      	ldr	r2, [pc, #80]	; (400c30 <xTaskRemoveFromEventList+0xac>)
  400be0:	441a      	add	r2, r3
  400be2:	68bb      	ldr	r3, [r7, #8]
  400be4:	3304      	adds	r3, #4
  400be6:	4619      	mov	r1, r3
  400be8:	4610      	mov	r0, r2
  400bea:	4b12      	ldr	r3, [pc, #72]	; (400c34 <xTaskRemoveFromEventList+0xb0>)
  400bec:	4798      	blx	r3
  400bee:	e005      	b.n	400bfc <xTaskRemoveFromEventList+0x78>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
  400bf0:	68bb      	ldr	r3, [r7, #8]
  400bf2:	3318      	adds	r3, #24
  400bf4:	4619      	mov	r1, r3
  400bf6:	4810      	ldr	r0, [pc, #64]	; (400c38 <xTaskRemoveFromEventList+0xb4>)
  400bf8:	4b0e      	ldr	r3, [pc, #56]	; (400c34 <xTaskRemoveFromEventList+0xb0>)
  400bfa:	4798      	blx	r3
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
  400bfc:	68bb      	ldr	r3, [r7, #8]
  400bfe:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  400c00:	4b0e      	ldr	r3, [pc, #56]	; (400c3c <xTaskRemoveFromEventList+0xb8>)
  400c02:	681b      	ldr	r3, [r3, #0]
  400c04:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  400c06:	429a      	cmp	r2, r3
  400c08:	d302      	bcc.n	400c10 <xTaskRemoveFromEventList+0x8c>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
  400c0a:	2301      	movs	r3, #1
  400c0c:	60fb      	str	r3, [r7, #12]
  400c0e:	e001      	b.n	400c14 <xTaskRemoveFromEventList+0x90>
	}
	else
	{
		xReturn = pdFALSE;
  400c10:	2300      	movs	r3, #0
  400c12:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
  400c14:	68fb      	ldr	r3, [r7, #12]
}
  400c16:	4618      	mov	r0, r3
  400c18:	3710      	adds	r7, #16
  400c1a:	46bd      	mov	sp, r7
  400c1c:	bd80      	pop	{r7, pc}
  400c1e:	bf00      	nop
  400c20:	004003c5 	.word	0x004003c5
  400c24:	004002ed 	.word	0x004002ed
  400c28:	2000a50c 	.word	0x2000a50c
  400c2c:	2000a508 	.word	0x2000a508
  400c30:	2000a480 	.word	0x2000a480
  400c34:	0040029d 	.word	0x0040029d
  400c38:	2000a4ec 	.word	0x2000a4ec
  400c3c:	2000a47c 	.word	0x2000a47c

00400c40 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  400c40:	b480      	push	{r7}
  400c42:	b083      	sub	sp, #12
  400c44:	af00      	add	r7, sp, #0
  400c46:	4603      	mov	r3, r0
  400c48:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
  400c4a:	f997 3007 	ldrsb.w	r3, [r7, #7]
  400c4e:	2b00      	cmp	r3, #0
  400c50:	db0b      	blt.n	400c6a <__NVIC_EnableIRQ+0x2a>
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  400c52:	4909      	ldr	r1, [pc, #36]	; (400c78 <__NVIC_EnableIRQ+0x38>)
  400c54:	f997 3007 	ldrsb.w	r3, [r7, #7]
  400c58:	095b      	lsrs	r3, r3, #5
  400c5a:	79fa      	ldrb	r2, [r7, #7]
  400c5c:	f002 021f 	and.w	r2, r2, #31
  400c60:	2001      	movs	r0, #1
  400c62:	fa00 f202 	lsl.w	r2, r0, r2
  400c66:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
  400c6a:	bf00      	nop
  400c6c:	370c      	adds	r7, #12
  400c6e:	46bd      	mov	sp, r7
  400c70:	f85d 7b04 	ldr.w	r7, [sp], #4
  400c74:	4770      	bx	lr
  400c76:	bf00      	nop
  400c78:	e000e100 	.word	0xe000e100

00400c7c <osc_get_rate>:

	return 0;
}

static inline uint32_t osc_get_rate(uint32_t ul_id)
{
  400c7c:	b480      	push	{r7}
  400c7e:	b083      	sub	sp, #12
  400c80:	af00      	add	r7, sp, #0
  400c82:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  400c84:	687b      	ldr	r3, [r7, #4]
  400c86:	2b07      	cmp	r3, #7
  400c88:	d825      	bhi.n	400cd6 <osc_get_rate+0x5a>
  400c8a:	a201      	add	r2, pc, #4	; (adr r2, 400c90 <osc_get_rate+0x14>)
  400c8c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  400c90:	00400cb1 	.word	0x00400cb1
  400c94:	00400cb7 	.word	0x00400cb7
  400c98:	00400cbd 	.word	0x00400cbd
  400c9c:	00400cc3 	.word	0x00400cc3
  400ca0:	00400cc7 	.word	0x00400cc7
  400ca4:	00400ccb 	.word	0x00400ccb
  400ca8:	00400ccf 	.word	0x00400ccf
  400cac:	00400cd3 	.word	0x00400cd3
	case OSC_SLCK_32K_RC:
		return OSC_SLCK_32K_RC_HZ;
  400cb0:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  400cb4:	e010      	b.n	400cd8 <osc_get_rate+0x5c>

	case OSC_SLCK_32K_XTAL:
		return BOARD_FREQ_SLCK_XTAL;
  400cb6:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  400cba:	e00d      	b.n	400cd8 <osc_get_rate+0x5c>

	case OSC_SLCK_32K_BYPASS:
		return BOARD_FREQ_SLCK_BYPASS;
  400cbc:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  400cc0:	e00a      	b.n	400cd8 <osc_get_rate+0x5c>

	case OSC_MAINCK_4M_RC:
		return OSC_MAINCK_4M_RC_HZ;
  400cc2:	4b08      	ldr	r3, [pc, #32]	; (400ce4 <osc_get_rate+0x68>)
  400cc4:	e008      	b.n	400cd8 <osc_get_rate+0x5c>

	case OSC_MAINCK_8M_RC:
		return OSC_MAINCK_8M_RC_HZ;
  400cc6:	4b08      	ldr	r3, [pc, #32]	; (400ce8 <osc_get_rate+0x6c>)
  400cc8:	e006      	b.n	400cd8 <osc_get_rate+0x5c>

	case OSC_MAINCK_12M_RC:
		return OSC_MAINCK_12M_RC_HZ;
  400cca:	4b08      	ldr	r3, [pc, #32]	; (400cec <osc_get_rate+0x70>)
  400ccc:	e004      	b.n	400cd8 <osc_get_rate+0x5c>

	case OSC_MAINCK_XTAL:
		return BOARD_FREQ_MAINCK_XTAL;
  400cce:	4b07      	ldr	r3, [pc, #28]	; (400cec <osc_get_rate+0x70>)
  400cd0:	e002      	b.n	400cd8 <osc_get_rate+0x5c>

	case OSC_MAINCK_BYPASS:
		return BOARD_FREQ_MAINCK_BYPASS;
  400cd2:	4b06      	ldr	r3, [pc, #24]	; (400cec <osc_get_rate+0x70>)
  400cd4:	e000      	b.n	400cd8 <osc_get_rate+0x5c>
	}

	return 0;
  400cd6:	2300      	movs	r3, #0
}
  400cd8:	4618      	mov	r0, r3
  400cda:	370c      	adds	r7, #12
  400cdc:	46bd      	mov	sp, r7
  400cde:	f85d 7b04 	ldr.w	r7, [sp], #4
  400ce2:	4770      	bx	lr
  400ce4:	003d0900 	.word	0x003d0900
  400ce8:	007a1200 	.word	0x007a1200
  400cec:	00b71b00 	.word	0x00b71b00

00400cf0 <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern uint32_t sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
  400cf0:	b580      	push	{r7, lr}
  400cf2:	af00      	add	r7, sp, #0
	} else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_MAINCK_BYPASS) {
		return OSC_MAINCK_BYPASS_HZ;
	}
#ifdef CONFIG_PLL0_SOURCE
	else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_PLLACK) {
		return pll_get_default_rate(0);
  400cf4:	2006      	movs	r0, #6
  400cf6:	4b03      	ldr	r3, [pc, #12]	; (400d04 <sysclk_get_main_hz+0x14>)
  400cf8:	4798      	blx	r3
  400cfa:	4603      	mov	r3, r0
  400cfc:	011b      	lsls	r3, r3, #4

	else {
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
  400cfe:	4618      	mov	r0, r3
  400d00:	bd80      	pop	{r7, pc}
  400d02:	bf00      	nop
  400d04:	00400c7d 	.word	0x00400c7d

00400d08 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
  400d08:	b580      	push	{r7, lr}
  400d0a:	af00      	add	r7, sp, #0
	/* CONFIG_SYSCLK_PRES is the register value for setting the expected */
	/* prescaler, not an immediate value. */
	return sysclk_get_main_hz() /
  400d0c:	4b02      	ldr	r3, [pc, #8]	; (400d18 <sysclk_get_cpu_hz+0x10>)
  400d0e:	4798      	blx	r3
  400d10:	4603      	mov	r3, r0
  400d12:	085b      	lsrs	r3, r3, #1
		((CONFIG_SYSCLK_PRES == SYSCLK_PRES_3) ? 3 :
			(1 << (CONFIG_SYSCLK_PRES >> PMC_MCKR_PRES_Pos)));
}
  400d14:	4618      	mov	r0, r3
  400d16:	bd80      	pop	{r7, pc}
  400d18:	00400cf1 	.word	0x00400cf1

00400d1c <sysclk_get_peripheral_hz>:
 * \brief Retrieves the current rate in Hz of the peripheral clocks.
 *
 * \return Frequency of the peripheral clocks, in Hz.
 */
static inline uint32_t sysclk_get_peripheral_hz(void)
{
  400d1c:	b580      	push	{r7, lr}
  400d1e:	af00      	add	r7, sp, #0
	/* CONFIG_SYSCLK_PRES is the register value for setting the expected */
	/* prescaler, not an immediate value. */
	return sysclk_get_main_hz() /
  400d20:	4b02      	ldr	r3, [pc, #8]	; (400d2c <sysclk_get_peripheral_hz+0x10>)
  400d22:	4798      	blx	r3
  400d24:	4603      	mov	r3, r0
  400d26:	085b      	lsrs	r3, r3, #1
		((CONFIG_SYSCLK_PRES == SYSCLK_PRES_3) ? 3 :
			(1 << (CONFIG_SYSCLK_PRES >> PMC_MCKR_PRES_Pos)));
}
  400d28:	4618      	mov	r0, r3
  400d2a:	bd80      	pop	{r7, pc}
  400d2c:	00400cf1 	.word	0x00400cf1

00400d30 <sysclk_enable_peripheral_clock>:
 * \brief Enable a peripheral's clock.
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
  400d30:	b580      	push	{r7, lr}
  400d32:	b082      	sub	sp, #8
  400d34:	af00      	add	r7, sp, #0
  400d36:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  400d38:	6878      	ldr	r0, [r7, #4]
  400d3a:	4b03      	ldr	r3, [pc, #12]	; (400d48 <sysclk_enable_peripheral_clock+0x18>)
  400d3c:	4798      	blx	r3
}
  400d3e:	bf00      	nop
  400d40:	3708      	adds	r7, #8
  400d42:	46bd      	mov	sp, r7
  400d44:	bd80      	pop	{r7, pc}
  400d46:	bf00      	nop
  400d48:	00402945 	.word	0x00402945

00400d4c <twi_master_setup>:
typedef twi_options_t twi_master_options_t;
typedef twi_packet_t twi_package_t;

static inline uint32_t twi_master_setup(twi_master_t p_twi,
		twi_master_options_t *p_opt)
{
  400d4c:	b580      	push	{r7, lr}
  400d4e:	b082      	sub	sp, #8
  400d50:	af00      	add	r7, sp, #0
  400d52:	6078      	str	r0, [r7, #4]
  400d54:	6039      	str	r1, [r7, #0]
	p_opt->master_clk = sysclk_get_peripheral_hz();
  400d56:	4b10      	ldr	r3, [pc, #64]	; (400d98 <twi_master_setup+0x4c>)
  400d58:	4798      	blx	r3
  400d5a:	4602      	mov	r2, r0
  400d5c:	683b      	ldr	r3, [r7, #0]
  400d5e:	601a      	str	r2, [r3, #0]
	p_opt->smbus      = 0;
  400d60:	683b      	ldr	r3, [r7, #0]
  400d62:	2200      	movs	r2, #0
  400d64:	725a      	strb	r2, [r3, #9]
	} else {
		// Do Nothing
	}
#else
#if (!(SAMG51 || SAMG53 || SAMG54))
	if (p_twi == TWI0) {
  400d66:	687b      	ldr	r3, [r7, #4]
  400d68:	4a0c      	ldr	r2, [pc, #48]	; (400d9c <twi_master_setup+0x50>)
  400d6a:	4293      	cmp	r3, r2
  400d6c:	d103      	bne.n	400d76 <twi_master_setup+0x2a>
		sysclk_enable_peripheral_clock(ID_TWI0);
  400d6e:	2011      	movs	r0, #17
  400d70:	4b0b      	ldr	r3, [pc, #44]	; (400da0 <twi_master_setup+0x54>)
  400d72:	4798      	blx	r3
  400d74:	e006      	b.n	400d84 <twi_master_setup+0x38>
	} else
#endif
	if (p_twi == TWI1) {
  400d76:	687b      	ldr	r3, [r7, #4]
  400d78:	4a0a      	ldr	r2, [pc, #40]	; (400da4 <twi_master_setup+0x58>)
  400d7a:	4293      	cmp	r3, r2
  400d7c:	d102      	bne.n	400d84 <twi_master_setup+0x38>
		sysclk_enable_peripheral_clock(ID_TWI1);
  400d7e:	2012      	movs	r0, #18
  400d80:	4b07      	ldr	r3, [pc, #28]	; (400da0 <twi_master_setup+0x54>)
  400d82:	4798      	blx	r3
	} else {
		// Do Nothing
	}
#endif

	return (twi_master_init(p_twi, p_opt));
  400d84:	6839      	ldr	r1, [r7, #0]
  400d86:	6878      	ldr	r0, [r7, #4]
  400d88:	4b07      	ldr	r3, [pc, #28]	; (400da8 <twi_master_setup+0x5c>)
  400d8a:	4798      	blx	r3
  400d8c:	4603      	mov	r3, r0
}
  400d8e:	4618      	mov	r0, r3
  400d90:	3708      	adds	r7, #8
  400d92:	46bd      	mov	sp, r7
  400d94:	bd80      	pop	{r7, pc}
  400d96:	bf00      	nop
  400d98:	00400d1d 	.word	0x00400d1d
  400d9c:	400a8000 	.word	0x400a8000
  400da0:	00400d31 	.word	0x00400d31
  400da4:	400ac000 	.word	0x400ac000
  400da8:	004029f1 	.word	0x004029f1

00400dac <bsp_hw_init>:
static void m_bsp_uart_init(void);
static void m_bsp_sdcard_init(void);

/* Function definitions ----------------------------------------------- */
void bsp_hw_init(void)
{
  400dac:	b580      	push	{r7, lr}
  400dae:	af00      	add	r7, sp, #0
  m_bsp_i2c_init();
  400db0:	4b04      	ldr	r3, [pc, #16]	; (400dc4 <bsp_hw_init+0x18>)
  400db2:	4798      	blx	r3
  m_bsp_uart_init();
  400db4:	4b04      	ldr	r3, [pc, #16]	; (400dc8 <bsp_hw_init+0x1c>)
  400db6:	4798      	blx	r3
  bsp_rtc_init();
  400db8:	4b04      	ldr	r3, [pc, #16]	; (400dcc <bsp_hw_init+0x20>)
  400dba:	4798      	blx	r3
#if (_CONFIG_ELEVATOR_BOARD) // {
#else // }{
  m_bsp_sdcard_init();
#endif // }

  bsp_gpio_init();
  400dbc:	4b04      	ldr	r3, [pc, #16]	; (400dd0 <bsp_hw_init+0x24>)
  400dbe:	4798      	blx	r3
}
  400dc0:	bf00      	nop
  400dc2:	bd80      	pop	{r7, pc}
  400dc4:	00400f5d 	.word	0x00400f5d
  400dc8:	00400f91 	.word	0x00400f91
  400dcc:	004013fd 	.word	0x004013fd
  400dd0:	0040133d 	.word	0x0040133d

00400dd4 <bsp_i2c_write>:

int bsp_i2c_write(uint8_t slave_addr, uint8_t reg_addr, uint8_t *p_data, uint32_t len)
{
  400dd4:	b580      	push	{r7, lr}
  400dd6:	b08a      	sub	sp, #40	; 0x28
  400dd8:	af00      	add	r7, sp, #0
  400dda:	60ba      	str	r2, [r7, #8]
  400ddc:	607b      	str	r3, [r7, #4]
  400dde:	4603      	mov	r3, r0
  400de0:	73fb      	strb	r3, [r7, #15]
  400de2:	460b      	mov	r3, r1
  400de4:	73bb      	strb	r3, [r7, #14]
  twi_package_t packet_write;

  packet_write.chip        = slave_addr;        // TWI slave bus address
  400de6:	7bfb      	ldrb	r3, [r7, #15]
  400de8:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
  packet_write.addr[0]     = reg_addr;          // TWI slave memory address data
  400dec:	7bbb      	ldrb	r3, [r7, #14]
  400dee:	753b      	strb	r3, [r7, #20]
  packet_write.addr_length = sizeof(reg_addr);  // TWI slave memory address data size
  400df0:	2301      	movs	r3, #1
  400df2:	61bb      	str	r3, [r7, #24]
  packet_write.buffer      = (void *)p_data;    // Transfer data source buffer
  400df4:	68bb      	ldr	r3, [r7, #8]
  400df6:	61fb      	str	r3, [r7, #28]
  packet_write.length      = len;               // Transfer data size (bytes)
  400df8:	687b      	ldr	r3, [r7, #4]
  400dfa:	623b      	str	r3, [r7, #32]

  return twi_master_write(TWI0, &packet_write);
  400dfc:	f107 0314 	add.w	r3, r7, #20
  400e00:	4619      	mov	r1, r3
  400e02:	4804      	ldr	r0, [pc, #16]	; (400e14 <bsp_i2c_write+0x40>)
  400e04:	4b04      	ldr	r3, [pc, #16]	; (400e18 <bsp_i2c_write+0x44>)
  400e06:	4798      	blx	r3
  400e08:	4603      	mov	r3, r0
}
  400e0a:	4618      	mov	r0, r3
  400e0c:	3728      	adds	r7, #40	; 0x28
  400e0e:	46bd      	mov	sp, r7
  400e10:	bd80      	pop	{r7, pc}
  400e12:	bf00      	nop
  400e14:	400a8000 	.word	0x400a8000
  400e18:	00402ba5 	.word	0x00402ba5

00400e1c <bsp_uart_write>:

uint32_t bsp_uart_write(uint8_t p_data)
{
  400e1c:	b580      	push	{r7, lr}
  400e1e:	b082      	sub	sp, #8
  400e20:	af00      	add	r7, sp, #0
  400e22:	4603      	mov	r3, r0
  400e24:	71fb      	strb	r3, [r7, #7]
  return uart_write(UART0, p_data);
  400e26:	79fb      	ldrb	r3, [r7, #7]
  400e28:	4619      	mov	r1, r3
  400e2a:	4804      	ldr	r0, [pc, #16]	; (400e3c <bsp_uart_write+0x20>)
  400e2c:	4b04      	ldr	r3, [pc, #16]	; (400e40 <bsp_uart_write+0x24>)
  400e2e:	4798      	blx	r3
  400e30:	4603      	mov	r3, r0
}
  400e32:	4618      	mov	r0, r3
  400e34:	3708      	adds	r7, #8
  400e36:	46bd      	mov	sp, r7
  400e38:	bd80      	pop	{r7, pc}
  400e3a:	bf00      	nop
  400e3c:	400e0600 	.word	0x400e0600
  400e40:	004001fb 	.word	0x004001fb
  400e44:	00000000 	.word	0x00000000

00400e48 <bsp_delay>:

void bsp_delay(uint32_t ms)
{
  400e48:	b5f0      	push	{r4, r5, r6, r7, lr}
  400e4a:	b083      	sub	sp, #12
  400e4c:	af00      	add	r7, sp, #0
  400e4e:	6078      	str	r0, [r7, #4]
  delay_ms(ms);
  400e50:	687b      	ldr	r3, [r7, #4]
  400e52:	2b00      	cmp	r3, #0
  400e54:	d026      	beq.n	400ea4 <bsp_delay+0x5c>
  400e56:	687b      	ldr	r3, [r7, #4]
  400e58:	461d      	mov	r5, r3
  400e5a:	f04f 0600 	mov.w	r6, #0
  400e5e:	4b22      	ldr	r3, [pc, #136]	; (400ee8 <bsp_delay+0xa0>)
  400e60:	4798      	blx	r3
  400e62:	4603      	mov	r3, r0
  400e64:	f04f 0400 	mov.w	r4, #0
  400e68:	fb03 f106 	mul.w	r1, r3, r6
  400e6c:	fb05 f204 	mul.w	r2, r5, r4
  400e70:	440a      	add	r2, r1
  400e72:	fba5 3403 	umull	r3, r4, r5, r3
  400e76:	4422      	add	r2, r4
  400e78:	4614      	mov	r4, r2
  400e7a:	f243 61af 	movw	r1, #13999	; 0x36af
  400e7e:	f04f 0200 	mov.w	r2, #0
  400e82:	185d      	adds	r5, r3, r1
  400e84:	eb44 0602 	adc.w	r6, r4, r2
  400e88:	4628      	mov	r0, r5
  400e8a:	4631      	mov	r1, r6
  400e8c:	4c17      	ldr	r4, [pc, #92]	; (400eec <bsp_delay+0xa4>)
  400e8e:	f243 62b0 	movw	r2, #14000	; 0x36b0
  400e92:	f04f 0300 	mov.w	r3, #0
  400e96:	47a0      	blx	r4
  400e98:	4603      	mov	r3, r0
  400e9a:	460c      	mov	r4, r1
  400e9c:	4618      	mov	r0, r3
  400e9e:	4b14      	ldr	r3, [pc, #80]	; (400ef0 <bsp_delay+0xa8>)
  400ea0:	4798      	blx	r3
}
  400ea2:	e016      	b.n	400ed2 <bsp_delay+0x8a>
  delay_ms(ms);
  400ea4:	4b10      	ldr	r3, [pc, #64]	; (400ee8 <bsp_delay+0xa0>)
  400ea6:	4798      	blx	r3
  400ea8:	4603      	mov	r3, r0
  400eaa:	f04f 0400 	mov.w	r4, #0
  400eae:	a20c      	add	r2, pc, #48	; (adr r2, 400ee0 <bsp_delay+0x98>)
  400eb0:	e9d2 1200 	ldrd	r1, r2, [r2]
  400eb4:	185d      	adds	r5, r3, r1
  400eb6:	eb44 0602 	adc.w	r6, r4, r2
  400eba:	4628      	mov	r0, r5
  400ebc:	4631      	mov	r1, r6
  400ebe:	4c0b      	ldr	r4, [pc, #44]	; (400eec <bsp_delay+0xa4>)
  400ec0:	4a0c      	ldr	r2, [pc, #48]	; (400ef4 <bsp_delay+0xac>)
  400ec2:	f04f 0300 	mov.w	r3, #0
  400ec6:	47a0      	blx	r4
  400ec8:	4603      	mov	r3, r0
  400eca:	460c      	mov	r4, r1
  400ecc:	4618      	mov	r0, r3
  400ece:	4b08      	ldr	r3, [pc, #32]	; (400ef0 <bsp_delay+0xa8>)
  400ed0:	4798      	blx	r3
}
  400ed2:	bf00      	nop
  400ed4:	370c      	adds	r7, #12
  400ed6:	46bd      	mov	sp, r7
  400ed8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  400eda:	bf00      	nop
  400edc:	f3af 8000 	nop.w
  400ee0:	00d59f7f 	.word	0x00d59f7f
  400ee4:	00000000 	.word	0x00000000
  400ee8:	00400d09 	.word	0x00400d09
  400eec:	00402ca1 	.word	0x00402ca1
  400ef0:	20000001 	.word	0x20000001
  400ef4:	00d59f80 	.word	0x00d59f80

00400ef8 <UART0_Handler>:

void UART0_Handler()
{
  400ef8:	b580      	push	{r7, lr}
  400efa:	b082      	sub	sp, #8
  400efc:	af00      	add	r7, sp, #0
  uint32_t dw_status = uart_get_status(UART0);
  400efe:	4812      	ldr	r0, [pc, #72]	; (400f48 <UART0_Handler+0x50>)
  400f00:	4b12      	ldr	r3, [pc, #72]	; (400f4c <UART0_Handler+0x54>)
  400f02:	4798      	blx	r3
  400f04:	6078      	str	r0, [r7, #4]

  if (dw_status & UART_SR_RXRDY)
  400f06:	687b      	ldr	r3, [r7, #4]
  400f08:	f003 0301 	and.w	r3, r3, #1
  400f0c:	2b00      	cmp	r3, #0
  400f0e:	d017      	beq.n	400f40 <UART0_Handler+0x48>
  {
    uint8_t received_byte;
    uart_read(UART0, &received_byte);
  400f10:	1cfb      	adds	r3, r7, #3
  400f12:	4619      	mov	r1, r3
  400f14:	480c      	ldr	r0, [pc, #48]	; (400f48 <UART0_Handler+0x50>)
  400f16:	4b0e      	ldr	r3, [pc, #56]	; (400f50 <UART0_Handler+0x58>)
  400f18:	4798      	blx	r3
    m_read_buffer[m_read_buffer_index] = received_byte;
  400f1a:	4b0e      	ldr	r3, [pc, #56]	; (400f54 <UART0_Handler+0x5c>)
  400f1c:	881b      	ldrh	r3, [r3, #0]
  400f1e:	461a      	mov	r2, r3
  400f20:	78f9      	ldrb	r1, [r7, #3]
  400f22:	4b0d      	ldr	r3, [pc, #52]	; (400f58 <UART0_Handler+0x60>)
  400f24:	5499      	strb	r1, [r3, r2]
    m_read_buffer_index++;
  400f26:	4b0b      	ldr	r3, [pc, #44]	; (400f54 <UART0_Handler+0x5c>)
  400f28:	881b      	ldrh	r3, [r3, #0]
  400f2a:	3301      	adds	r3, #1
  400f2c:	b29a      	uxth	r2, r3
  400f2e:	4b09      	ldr	r3, [pc, #36]	; (400f54 <UART0_Handler+0x5c>)
  400f30:	801a      	strh	r2, [r3, #0]
    if (m_read_buffer_index == 10)
  400f32:	4b08      	ldr	r3, [pc, #32]	; (400f54 <UART0_Handler+0x5c>)
  400f34:	881b      	ldrh	r3, [r3, #0]
  400f36:	2b0a      	cmp	r3, #10
  400f38:	d102      	bne.n	400f40 <UART0_Handler+0x48>
      m_read_buffer_index = 0;
  400f3a:	4b06      	ldr	r3, [pc, #24]	; (400f54 <UART0_Handler+0x5c>)
  400f3c:	2200      	movs	r2, #0
  400f3e:	801a      	strh	r2, [r3, #0]
  }
}
  400f40:	bf00      	nop
  400f42:	3708      	adds	r7, #8
  400f44:	46bd      	mov	sp, r7
  400f46:	bd80      	pop	{r7, pc}
  400f48:	400e0600 	.word	0x400e0600
  400f4c:	004001e3 	.word	0x004001e3
  400f50:	0040022b 	.word	0x0040022b
  400f54:	2000a710 	.word	0x2000a710
  400f58:	2000a51c 	.word	0x2000a51c

00400f5c <m_bsp_i2c_init>:
/* Private function definitions ---------------------------------------- */
/**
 * @brief I2C init
 */
static void m_bsp_i2c_init(void)
{
  400f5c:	b580      	push	{r7, lr}
  400f5e:	b084      	sub	sp, #16
  400f60:	af00      	add	r7, sp, #0
  twi_master_options_t opt = {
  400f62:	1d3b      	adds	r3, r7, #4
  400f64:	2200      	movs	r2, #0
  400f66:	601a      	str	r2, [r3, #0]
  400f68:	605a      	str	r2, [r3, #4]
  400f6a:	609a      	str	r2, [r3, #8]
  400f6c:	4b05      	ldr	r3, [pc, #20]	; (400f84 <m_bsp_i2c_init+0x28>)
  400f6e:	60bb      	str	r3, [r7, #8]
      .speed = 100000
  };

  twi_master_setup(TWI0, &opt);
  400f70:	1d3b      	adds	r3, r7, #4
  400f72:	4619      	mov	r1, r3
  400f74:	4804      	ldr	r0, [pc, #16]	; (400f88 <m_bsp_i2c_init+0x2c>)
  400f76:	4b05      	ldr	r3, [pc, #20]	; (400f8c <m_bsp_i2c_init+0x30>)
  400f78:	4798      	blx	r3
}
  400f7a:	bf00      	nop
  400f7c:	3710      	adds	r7, #16
  400f7e:	46bd      	mov	sp, r7
  400f80:	bd80      	pop	{r7, pc}
  400f82:	bf00      	nop
  400f84:	000186a0 	.word	0x000186a0
  400f88:	400a8000 	.word	0x400a8000
  400f8c:	00400d4d 	.word	0x00400d4d

00400f90 <m_bsp_uart_init>:

/**
 * @brief Uart init
 */
static void m_bsp_uart_init(void)
{
  400f90:	b580      	push	{r7, lr}
  400f92:	b084      	sub	sp, #16
  400f94:	af00      	add	r7, sp, #0
  const sam_uart_opt_t uart_settings = { sysclk_get_cpu_hz(), UART_SERIAL_BAUDRATE, UART_SERIAL_MODE };
  400f96:	4b12      	ldr	r3, [pc, #72]	; (400fe0 <m_bsp_uart_init+0x50>)
  400f98:	4798      	blx	r3
  400f9a:	4603      	mov	r3, r0
  400f9c:	607b      	str	r3, [r7, #4]
  400f9e:	f44f 5316 	mov.w	r3, #9600	; 0x2580
  400fa2:	60bb      	str	r3, [r7, #8]
  400fa4:	f44f 6300 	mov.w	r3, #2048	; 0x800
  400fa8:	60fb      	str	r3, [r7, #12]

  // Enable the uart peripheral clock
  sysclk_enable_peripheral_clock(ID_UART0);
  400faa:	2007      	movs	r0, #7
  400fac:	4b0d      	ldr	r3, [pc, #52]	; (400fe4 <m_bsp_uart_init+0x54>)
  400fae:	4798      	blx	r3

  // Set the pins to use the uart peripheral
  pio_set_peripheral(PIOA, PIO_TYPE_PIO_PERIPH_A, PINS_UART0);
  400fb0:	f44f 62c0 	mov.w	r2, #1536	; 0x600
  400fb4:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  400fb8:	480b      	ldr	r0, [pc, #44]	; (400fe8 <m_bsp_uart_init+0x58>)
  400fba:	4b0c      	ldr	r3, [pc, #48]	; (400fec <m_bsp_uart_init+0x5c>)
  400fbc:	4798      	blx	r3

  // Init UART0 and enable Rx and Tx
  uart_init(UART0, &uart_settings);
  400fbe:	1d3b      	adds	r3, r7, #4
  400fc0:	4619      	mov	r1, r3
  400fc2:	480b      	ldr	r0, [pc, #44]	; (400ff0 <m_bsp_uart_init+0x60>)
  400fc4:	4b0b      	ldr	r3, [pc, #44]	; (400ff4 <m_bsp_uart_init+0x64>)
  400fc6:	4798      	blx	r3

  // Interrupt reading ready
  uart_enable_interrupt(UART0, UART_IER_RXRDY);
  400fc8:	2101      	movs	r1, #1
  400fca:	4809      	ldr	r0, [pc, #36]	; (400ff0 <m_bsp_uart_init+0x60>)
  400fcc:	4b0a      	ldr	r3, [pc, #40]	; (400ff8 <m_bsp_uart_init+0x68>)
  400fce:	4798      	blx	r3
  NVIC_EnableIRQ(UART0_IRQn);
  400fd0:	2007      	movs	r0, #7
  400fd2:	4b0a      	ldr	r3, [pc, #40]	; (400ffc <m_bsp_uart_init+0x6c>)
  400fd4:	4798      	blx	r3
}
  400fd6:	bf00      	nop
  400fd8:	3710      	adds	r7, #16
  400fda:	46bd      	mov	sp, r7
  400fdc:	bd80      	pop	{r7, pc}
  400fde:	bf00      	nop
  400fe0:	00400d09 	.word	0x00400d09
  400fe4:	00400d31 	.word	0x00400d31
  400fe8:	400e0e00 	.word	0x400e0e00
  400fec:	004025d9 	.word	0x004025d9
  400ff0:	400e0600 	.word	0x400e0600
  400ff4:	00400165 	.word	0x00400165
  400ff8:	004001c7 	.word	0x004001c7
  400ffc:	00400c41 	.word	0x00400c41

00401000 <osc_get_rate>:
{
  401000:	b480      	push	{r7}
  401002:	b083      	sub	sp, #12
  401004:	af00      	add	r7, sp, #0
  401006:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  401008:	687b      	ldr	r3, [r7, #4]
  40100a:	2b07      	cmp	r3, #7
  40100c:	d825      	bhi.n	40105a <osc_get_rate+0x5a>
  40100e:	a201      	add	r2, pc, #4	; (adr r2, 401014 <osc_get_rate+0x14>)
  401010:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  401014:	00401035 	.word	0x00401035
  401018:	0040103b 	.word	0x0040103b
  40101c:	00401041 	.word	0x00401041
  401020:	00401047 	.word	0x00401047
  401024:	0040104b 	.word	0x0040104b
  401028:	0040104f 	.word	0x0040104f
  40102c:	00401053 	.word	0x00401053
  401030:	00401057 	.word	0x00401057
		return OSC_SLCK_32K_RC_HZ;
  401034:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  401038:	e010      	b.n	40105c <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_XTAL;
  40103a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  40103e:	e00d      	b.n	40105c <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_BYPASS;
  401040:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  401044:	e00a      	b.n	40105c <osc_get_rate+0x5c>
		return OSC_MAINCK_4M_RC_HZ;
  401046:	4b08      	ldr	r3, [pc, #32]	; (401068 <osc_get_rate+0x68>)
  401048:	e008      	b.n	40105c <osc_get_rate+0x5c>
		return OSC_MAINCK_8M_RC_HZ;
  40104a:	4b08      	ldr	r3, [pc, #32]	; (40106c <osc_get_rate+0x6c>)
  40104c:	e006      	b.n	40105c <osc_get_rate+0x5c>
		return OSC_MAINCK_12M_RC_HZ;
  40104e:	4b08      	ldr	r3, [pc, #32]	; (401070 <osc_get_rate+0x70>)
  401050:	e004      	b.n	40105c <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_XTAL;
  401052:	4b07      	ldr	r3, [pc, #28]	; (401070 <osc_get_rate+0x70>)
  401054:	e002      	b.n	40105c <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_BYPASS;
  401056:	4b06      	ldr	r3, [pc, #24]	; (401070 <osc_get_rate+0x70>)
  401058:	e000      	b.n	40105c <osc_get_rate+0x5c>
	return 0;
  40105a:	2300      	movs	r3, #0
}
  40105c:	4618      	mov	r0, r3
  40105e:	370c      	adds	r7, #12
  401060:	46bd      	mov	sp, r7
  401062:	f85d 7b04 	ldr.w	r7, [sp], #4
  401066:	4770      	bx	lr
  401068:	003d0900 	.word	0x003d0900
  40106c:	007a1200 	.word	0x007a1200
  401070:	00b71b00 	.word	0x00b71b00

00401074 <sysclk_get_main_hz>:
{
  401074:	b580      	push	{r7, lr}
  401076:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  401078:	2006      	movs	r0, #6
  40107a:	4b03      	ldr	r3, [pc, #12]	; (401088 <sysclk_get_main_hz+0x14>)
  40107c:	4798      	blx	r3
  40107e:	4603      	mov	r3, r0
  401080:	011b      	lsls	r3, r3, #4
}
  401082:	4618      	mov	r0, r3
  401084:	bd80      	pop	{r7, pc}
  401086:	bf00      	nop
  401088:	00401001 	.word	0x00401001

0040108c <sysclk_get_cpu_hz>:
{
  40108c:	b580      	push	{r7, lr}
  40108e:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  401090:	4b02      	ldr	r3, [pc, #8]	; (40109c <sysclk_get_cpu_hz+0x10>)
  401092:	4798      	blx	r3
  401094:	4603      	mov	r3, r0
  401096:	085b      	lsrs	r3, r3, #1
}
  401098:	4618      	mov	r0, r3
  40109a:	bd80      	pop	{r7, pc}
  40109c:	00401075 	.word	0x00401075

004010a0 <bsp_can_init>:
static void m_bsp_can_pack_msg_sensor(uint8_t *can_data);
static void m_bsp_can_unpack_msg_sensor(uint8_t *can_data);

/* Function definitions ----------------------------------------------- */
void bsp_can_init(void)
{
  4010a0:	b580      	push	{r7, lr}
  4010a2:	b082      	sub	sp, #8
  4010a4:	af00      	add	r7, sp, #0
  uint32_t ul_sysclk = sysclk_get_cpu_hz();
  4010a6:	4b14      	ldr	r3, [pc, #80]	; (4010f8 <bsp_can_init+0x58>)
  4010a8:	4798      	blx	r3
  4010aa:	6078      	str	r0, [r7, #4]

  pmc_enable_periph_clk(ID_CAN1);
  4010ac:	2026      	movs	r0, #38	; 0x26
  4010ae:	4b13      	ldr	r3, [pc, #76]	; (4010fc <bsp_can_init+0x5c>)
  4010b0:	4798      	blx	r3

  can_init(CAN1, ul_sysclk, CAN_BPS_250K);
  4010b2:	22fa      	movs	r2, #250	; 0xfa
  4010b4:	6879      	ldr	r1, [r7, #4]
  4010b6:	4812      	ldr	r0, [pc, #72]	; (401100 <bsp_can_init+0x60>)
  4010b8:	4b12      	ldr	r3, [pc, #72]	; (401104 <bsp_can_init+0x64>)
  4010ba:	4798      	blx	r3
  can_reset_all_mailbox(CAN1);
  4010bc:	4810      	ldr	r0, [pc, #64]	; (401100 <bsp_can_init+0x60>)
  4010be:	4b12      	ldr	r3, [pc, #72]	; (401108 <bsp_can_init+0x68>)
  4010c0:	4798      	blx	r3

  m_can1_mailbox.ul_mb_idx   = 0;
  4010c2:	4b12      	ldr	r3, [pc, #72]	; (40110c <bsp_can_init+0x6c>)
  4010c4:	2200      	movs	r2, #0
  4010c6:	601a      	str	r2, [r3, #0]
  m_can1_mailbox.uc_tx_prio  = 15;
  4010c8:	4b10      	ldr	r3, [pc, #64]	; (40110c <bsp_can_init+0x6c>)
  4010ca:	220f      	movs	r2, #15
  4010cc:	71da      	strb	r2, [r3, #7]
  m_can1_mailbox.uc_id_ver   = 0;
  4010ce:	4b0f      	ldr	r3, [pc, #60]	; (40110c <bsp_can_init+0x6c>)
  4010d0:	2200      	movs	r2, #0
  4010d2:	715a      	strb	r2, [r3, #5]
  m_can1_mailbox.uc_length   = 8;
  4010d4:	4b0d      	ldr	r3, [pc, #52]	; (40110c <bsp_can_init+0x6c>)
  4010d6:	2208      	movs	r2, #8
  4010d8:	719a      	strb	r2, [r3, #6]

#if (_CONFIG_ELEVATOR_BOARD) // {
  m_can1_mailbox.uc_obj_type = CAN_MB_TX_MODE;
  4010da:	4b0c      	ldr	r3, [pc, #48]	; (40110c <bsp_can_init+0x6c>)
  4010dc:	2203      	movs	r2, #3
  4010de:	711a      	strb	r2, [r3, #4]
  m_can1_mailbox.ul_id_msk   = 0;
  4010e0:	4b0a      	ldr	r3, [pc, #40]	; (40110c <bsp_can_init+0x6c>)
  4010e2:	2200      	movs	r2, #0
  4010e4:	60da      	str	r2, [r3, #12]
  m_can1_mailbox.uc_obj_type = CAN_MB_RX_MODE;
  m_can1_mailbox.ul_id_msk   = CAN_MAM_MIDvA_Msk | CAN_MAM_MIDvB_Msk;
  m_can1_mailbox.ul_id       = CAN_MID_MIDvA(0x07);
#endif // }

  can_mailbox_init(CAN1, &m_can1_mailbox);
  4010e6:	4909      	ldr	r1, [pc, #36]	; (40110c <bsp_can_init+0x6c>)
  4010e8:	4805      	ldr	r0, [pc, #20]	; (401100 <bsp_can_init+0x60>)
  4010ea:	4b09      	ldr	r3, [pc, #36]	; (401110 <bsp_can_init+0x70>)
  4010ec:	4798      	blx	r3
}
  4010ee:	bf00      	nop
  4010f0:	3708      	adds	r7, #8
  4010f2:	46bd      	mov	sp, r7
  4010f4:	bd80      	pop	{r7, pc}
  4010f6:	bf00      	nop
  4010f8:	0040108d 	.word	0x0040108d
  4010fc:	00402945 	.word	0x00402945
  401100:	40014000 	.word	0x40014000
  401104:	00402391 	.word	0x00402391
  401108:	00402595 	.word	0x00402595
  40110c:	2000a714 	.word	0x2000a714
  401110:	00402471 	.word	0x00402471

00401114 <ioport_set_pin_mode>:
 *
 * \param pin IOPORT pin to configure
 * \param mode Mode masks to configure for the specified pin (\ref ioport_modes)
 */
static inline void ioport_set_pin_mode(ioport_pin_t pin, ioport_mode_t mode)
{
  401114:	b480      	push	{r7}
  401116:	b08d      	sub	sp, #52	; 0x34
  401118:	af00      	add	r7, sp, #0
  40111a:	6078      	str	r0, [r7, #4]
  40111c:	6039      	str	r1, [r7, #0]
  40111e:	687b      	ldr	r3, [r7, #4]
  401120:	62fb      	str	r3, [r7, #44]	; 0x2c
  401122:	683b      	ldr	r3, [r7, #0]
  401124:	62bb      	str	r3, [r7, #40]	; 0x28
  401126:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401128:	627b      	str	r3, [r7, #36]	; 0x24
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  40112a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40112c:	095a      	lsrs	r2, r3, #5
  40112e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401130:	623b      	str	r3, [r7, #32]
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  401132:	6a3b      	ldr	r3, [r7, #32]
  401134:	f003 031f 	and.w	r3, r3, #31
  401138:	2101      	movs	r1, #1
  40113a:	fa01 f303 	lsl.w	r3, r1, r3
  40113e:	61fa      	str	r2, [r7, #28]
  401140:	61bb      	str	r3, [r7, #24]
  401142:	6abb      	ldr	r3, [r7, #40]	; 0x28
  401144:	617b      	str	r3, [r7, #20]
  401146:	69fb      	ldr	r3, [r7, #28]
  401148:	613b      	str	r3, [r7, #16]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  40114a:	693b      	ldr	r3, [r7, #16]
  40114c:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401150:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401154:	025b      	lsls	r3, r3, #9
}

__always_inline static void arch_ioport_set_port_mode(ioport_port_t port,
		ioport_port_mask_t mask, ioport_mode_t mode)
{
	Pio *base = arch_ioport_port_to_base(port);
  401156:	60fb      	str	r3, [r7, #12]

	if (mode & IOPORT_MODE_PULLUP) {
  401158:	697b      	ldr	r3, [r7, #20]
  40115a:	f003 0308 	and.w	r3, r3, #8
  40115e:	2b00      	cmp	r3, #0
  401160:	d003      	beq.n	40116a <ioport_set_pin_mode+0x56>
		base->PIO_PUER = mask;
  401162:	68fb      	ldr	r3, [r7, #12]
  401164:	69ba      	ldr	r2, [r7, #24]
  401166:	665a      	str	r2, [r3, #100]	; 0x64
  401168:	e002      	b.n	401170 <ioport_set_pin_mode+0x5c>
	} else {
		base->PIO_PUDR = mask;
  40116a:	68fb      	ldr	r3, [r7, #12]
  40116c:	69ba      	ldr	r2, [r7, #24]
  40116e:	661a      	str	r2, [r3, #96]	; 0x60
	}

#if defined(IOPORT_MODE_PULLDOWN)
	if (mode & IOPORT_MODE_PULLDOWN) {
  401170:	697b      	ldr	r3, [r7, #20]
  401172:	f003 0310 	and.w	r3, r3, #16
  401176:	2b00      	cmp	r3, #0
  401178:	d004      	beq.n	401184 <ioport_set_pin_mode+0x70>
		base->PIO_PPDER = mask;
  40117a:	68fb      	ldr	r3, [r7, #12]
  40117c:	69ba      	ldr	r2, [r7, #24]
  40117e:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  401182:	e003      	b.n	40118c <ioport_set_pin_mode+0x78>
	} else {
		base->PIO_PPDDR = mask;
  401184:	68fb      	ldr	r3, [r7, #12]
  401186:	69ba      	ldr	r2, [r7, #24]
  401188:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	}
#endif

	if (mode & IOPORT_MODE_OPEN_DRAIN) {
  40118c:	697b      	ldr	r3, [r7, #20]
  40118e:	f003 0320 	and.w	r3, r3, #32
  401192:	2b00      	cmp	r3, #0
  401194:	d003      	beq.n	40119e <ioport_set_pin_mode+0x8a>
		base->PIO_MDER = mask;
  401196:	68fb      	ldr	r3, [r7, #12]
  401198:	69ba      	ldr	r2, [r7, #24]
  40119a:	651a      	str	r2, [r3, #80]	; 0x50
  40119c:	e002      	b.n	4011a4 <ioport_set_pin_mode+0x90>
	} else {
		base->PIO_MDDR = mask;
  40119e:	68fb      	ldr	r3, [r7, #12]
  4011a0:	69ba      	ldr	r2, [r7, #24]
  4011a2:	655a      	str	r2, [r3, #84]	; 0x54
	}

	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
  4011a4:	697b      	ldr	r3, [r7, #20]
  4011a6:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
  4011aa:	2b00      	cmp	r3, #0
  4011ac:	d003      	beq.n	4011b6 <ioport_set_pin_mode+0xa2>
		base->PIO_IFER = mask;
  4011ae:	68fb      	ldr	r3, [r7, #12]
  4011b0:	69ba      	ldr	r2, [r7, #24]
  4011b2:	621a      	str	r2, [r3, #32]
  4011b4:	e002      	b.n	4011bc <ioport_set_pin_mode+0xa8>
	} else {
		base->PIO_IFDR = mask;
  4011b6:	68fb      	ldr	r3, [r7, #12]
  4011b8:	69ba      	ldr	r2, [r7, #24]
  4011ba:	625a      	str	r2, [r3, #36]	; 0x24
	}

	if (mode & IOPORT_MODE_DEBOUNCE) {
  4011bc:	697b      	ldr	r3, [r7, #20]
  4011be:	f003 0380 	and.w	r3, r3, #128	; 0x80
  4011c2:	2b00      	cmp	r3, #0
  4011c4:	d004      	beq.n	4011d0 <ioport_set_pin_mode+0xbc>
#if SAM3U || SAM3XA
		base->PIO_DIFSR = mask;
#else
		base->PIO_IFSCER = mask;
  4011c6:	68fb      	ldr	r3, [r7, #12]
  4011c8:	69ba      	ldr	r2, [r7, #24]
  4011ca:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  4011ce:	e003      	b.n	4011d8 <ioport_set_pin_mode+0xc4>
#endif
	} else {
#if SAM3U || SAM3XA
		base->PIO_SCIFSR = mask;
#else
		base->PIO_IFSCDR = mask;
  4011d0:	68fb      	ldr	r3, [r7, #12]
  4011d2:	69ba      	ldr	r2, [r7, #24]
  4011d4:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
		base->PIO_ABSR |= mask;
	} else {
		base->PIO_ABSR &= ~mask;
	}
#else
	if (mode & IOPORT_MODE_MUX_BIT0) {
  4011d8:	697b      	ldr	r3, [r7, #20]
  4011da:	f003 0301 	and.w	r3, r3, #1
  4011de:	2b00      	cmp	r3, #0
  4011e0:	d006      	beq.n	4011f0 <ioport_set_pin_mode+0xdc>
		base->PIO_ABCDSR[0] |= mask;
  4011e2:	68fb      	ldr	r3, [r7, #12]
  4011e4:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  4011e6:	69bb      	ldr	r3, [r7, #24]
  4011e8:	431a      	orrs	r2, r3
  4011ea:	68fb      	ldr	r3, [r7, #12]
  4011ec:	671a      	str	r2, [r3, #112]	; 0x70
  4011ee:	e006      	b.n	4011fe <ioport_set_pin_mode+0xea>
	} else {
		base->PIO_ABCDSR[0] &= ~mask;
  4011f0:	68fb      	ldr	r3, [r7, #12]
  4011f2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  4011f4:	69bb      	ldr	r3, [r7, #24]
  4011f6:	43db      	mvns	r3, r3
  4011f8:	401a      	ands	r2, r3
  4011fa:	68fb      	ldr	r3, [r7, #12]
  4011fc:	671a      	str	r2, [r3, #112]	; 0x70
	}

	if (mode & IOPORT_MODE_MUX_BIT1) {
  4011fe:	697b      	ldr	r3, [r7, #20]
  401200:	f003 0302 	and.w	r3, r3, #2
  401204:	2b00      	cmp	r3, #0
  401206:	d006      	beq.n	401216 <ioport_set_pin_mode+0x102>
		base->PIO_ABCDSR[1] |= mask;
  401208:	68fb      	ldr	r3, [r7, #12]
  40120a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  40120c:	69bb      	ldr	r3, [r7, #24]
  40120e:	431a      	orrs	r2, r3
  401210:	68fb      	ldr	r3, [r7, #12]
  401212:	675a      	str	r2, [r3, #116]	; 0x74
	arch_ioport_set_pin_mode(pin, mode);
}
  401214:	e006      	b.n	401224 <ioport_set_pin_mode+0x110>
	} else {
		base->PIO_ABCDSR[1] &= ~mask;
  401216:	68fb      	ldr	r3, [r7, #12]
  401218:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  40121a:	69bb      	ldr	r3, [r7, #24]
  40121c:	43db      	mvns	r3, r3
  40121e:	401a      	ands	r2, r3
  401220:	68fb      	ldr	r3, [r7, #12]
  401222:	675a      	str	r2, [r3, #116]	; 0x74
  401224:	bf00      	nop
  401226:	3734      	adds	r7, #52	; 0x34
  401228:	46bd      	mov	sp, r7
  40122a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40122e:	4770      	bx	lr

00401230 <ioport_set_pin_dir>:
 * \param pin IOPORT pin to configure
 * \param dir Direction to set for the specified pin (\ref ioport_direction)
 */
static inline void ioport_set_pin_dir(ioport_pin_t pin,
		enum ioport_direction dir)
{
  401230:	b480      	push	{r7}
  401232:	b08d      	sub	sp, #52	; 0x34
  401234:	af00      	add	r7, sp, #0
  401236:	6078      	str	r0, [r7, #4]
  401238:	460b      	mov	r3, r1
  40123a:	70fb      	strb	r3, [r7, #3]
  40123c:	687b      	ldr	r3, [r7, #4]
  40123e:	62fb      	str	r3, [r7, #44]	; 0x2c
  401240:	78fb      	ldrb	r3, [r7, #3]
  401242:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  401246:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401248:	627b      	str	r3, [r7, #36]	; 0x24
  40124a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40124c:	623b      	str	r3, [r7, #32]
	return pin >> 5;
  40124e:	6a3b      	ldr	r3, [r7, #32]
  401250:	095b      	lsrs	r3, r3, #5
  401252:	61fb      	str	r3, [r7, #28]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  401254:	69fb      	ldr	r3, [r7, #28]
  401256:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  40125a:	f203 7307 	addw	r3, r3, #1799	; 0x707
  40125e:	025b      	lsls	r3, r3, #9
}

__always_inline static void arch_ioport_set_pin_dir(ioport_pin_t pin,
		enum ioport_direction dir)
{
	Pio *base = arch_ioport_pin_to_base(pin);
  401260:	61bb      	str	r3, [r7, #24]

	if (dir == IOPORT_DIR_OUTPUT) {
  401262:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  401266:	2b01      	cmp	r3, #1
  401268:	d109      	bne.n	40127e <ioport_set_pin_dir+0x4e>
  40126a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40126c:	617b      	str	r3, [r7, #20]
	return 1U << (pin & 0x1F);
  40126e:	697b      	ldr	r3, [r7, #20]
  401270:	f003 031f 	and.w	r3, r3, #31
  401274:	2201      	movs	r2, #1
  401276:	409a      	lsls	r2, r3
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  401278:	69bb      	ldr	r3, [r7, #24]
  40127a:	611a      	str	r2, [r3, #16]
  40127c:	e00c      	b.n	401298 <ioport_set_pin_dir+0x68>
	} else if (dir == IOPORT_DIR_INPUT) {
  40127e:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  401282:	2b00      	cmp	r3, #0
  401284:	d108      	bne.n	401298 <ioport_set_pin_dir+0x68>
  401286:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401288:	613b      	str	r3, [r7, #16]
	return 1U << (pin & 0x1F);
  40128a:	693b      	ldr	r3, [r7, #16]
  40128c:	f003 031f 	and.w	r3, r3, #31
  401290:	2201      	movs	r2, #1
  401292:	409a      	lsls	r2, r3
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
  401294:	69bb      	ldr	r3, [r7, #24]
  401296:	615a      	str	r2, [r3, #20]
  401298:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40129a:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  40129c:	68fb      	ldr	r3, [r7, #12]
  40129e:	f003 031f 	and.w	r3, r3, #31
  4012a2:	2201      	movs	r2, #1
  4012a4:	409a      	lsls	r2, r3
	}

	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  4012a6:	69bb      	ldr	r3, [r7, #24]
  4012a8:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
	arch_ioport_set_pin_dir(pin, dir);
}
  4012ac:	bf00      	nop
  4012ae:	3734      	adds	r7, #52	; 0x34
  4012b0:	46bd      	mov	sp, r7
  4012b2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4012b6:	4770      	bx	lr

004012b8 <ioport_set_pin_level>:
 *
 * \param pin IOPORT pin to configure
 * \param level Logical value of the pin
 */
static inline void ioport_set_pin_level(ioport_pin_t pin, bool level)
{
  4012b8:	b480      	push	{r7}
  4012ba:	b08b      	sub	sp, #44	; 0x2c
  4012bc:	af00      	add	r7, sp, #0
  4012be:	6078      	str	r0, [r7, #4]
  4012c0:	460b      	mov	r3, r1
  4012c2:	70fb      	strb	r3, [r7, #3]
  4012c4:	687b      	ldr	r3, [r7, #4]
  4012c6:	627b      	str	r3, [r7, #36]	; 0x24
  4012c8:	78fb      	ldrb	r3, [r7, #3]
  4012ca:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  4012ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4012d0:	61fb      	str	r3, [r7, #28]
  4012d2:	69fb      	ldr	r3, [r7, #28]
  4012d4:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  4012d6:	69bb      	ldr	r3, [r7, #24]
  4012d8:	095b      	lsrs	r3, r3, #5
  4012da:	617b      	str	r3, [r7, #20]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  4012dc:	697b      	ldr	r3, [r7, #20]
  4012de:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4012e2:	f203 7307 	addw	r3, r3, #1799	; 0x707
  4012e6:	025b      	lsls	r3, r3, #9
}

__always_inline static void arch_ioport_set_pin_level(ioport_pin_t pin,
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);
  4012e8:	613b      	str	r3, [r7, #16]

	if (level) {
  4012ea:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  4012ee:	2b00      	cmp	r3, #0
  4012f0:	d009      	beq.n	401306 <ioport_set_pin_level+0x4e>
  4012f2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4012f4:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  4012f6:	68fb      	ldr	r3, [r7, #12]
  4012f8:	f003 031f 	and.w	r3, r3, #31
  4012fc:	2201      	movs	r2, #1
  4012fe:	409a      	lsls	r2, r3
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  401300:	693b      	ldr	r3, [r7, #16]
  401302:	631a      	str	r2, [r3, #48]	; 0x30
	arch_ioport_set_pin_level(pin, level);
}
  401304:	e008      	b.n	401318 <ioport_set_pin_level+0x60>
  401306:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401308:	60bb      	str	r3, [r7, #8]
	return 1U << (pin & 0x1F);
  40130a:	68bb      	ldr	r3, [r7, #8]
  40130c:	f003 031f 	and.w	r3, r3, #31
  401310:	2201      	movs	r2, #1
  401312:	409a      	lsls	r2, r3
	} else {
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  401314:	693b      	ldr	r3, [r7, #16]
  401316:	635a      	str	r2, [r3, #52]	; 0x34
  401318:	bf00      	nop
  40131a:	372c      	adds	r7, #44	; 0x2c
  40131c:	46bd      	mov	sp, r7
  40131e:	f85d 7b04 	ldr.w	r7, [sp], #4
  401322:	4770      	bx	lr

00401324 <bsp_io_get_pin_index>:
{
  return io->pin;
}

static inline uint32_t bsp_io_get_pin_index(const bsp_io_10_t *io)
{
  401324:	b480      	push	{r7}
  401326:	b083      	sub	sp, #12
  401328:	af00      	add	r7, sp, #0
  40132a:	6078      	str	r0, [r7, #4]
  return io->pin_index;
  40132c:	687b      	ldr	r3, [r7, #4]
  40132e:	68db      	ldr	r3, [r3, #12]
}
  401330:	4618      	mov	r0, r3
  401332:	370c      	adds	r7, #12
  401334:	46bd      	mov	sp, r7
  401336:	f85d 7b04 	ldr.w	r7, [sp], #4
  40133a:	4770      	bx	lr

0040133c <bsp_gpio_init>:
/* Public variables --------------------------------------------------- */
/* Private variables -------------------------------------------------- */
/* Private function prototypes ---------------------------------------- */
/* Function definitions ----------------------------------------------- */
void bsp_gpio_init(void)
{
  40133c:	b580      	push	{r7, lr}
  40133e:	b082      	sub	sp, #8
  401340:	af00      	add	r7, sp, #0
  for (uint8_t i = 1; i <= SENSOR_COUNT_MAX; i++)
  401342:	2301      	movs	r3, #1
  401344:	71fb      	strb	r3, [r7, #7]
  401346:	e02f      	b.n	4013a8 <bsp_gpio_init+0x6c>
  {
    ioport_set_pin_dir(PIN_INDEX(i), IOPORT_DIR_INPUT);
  401348:	79fa      	ldrb	r2, [r7, #7]
  40134a:	4613      	mov	r3, r2
  40134c:	009b      	lsls	r3, r3, #2
  40134e:	4413      	add	r3, r2
  401350:	009b      	lsls	r3, r3, #2
  401352:	4a19      	ldr	r2, [pc, #100]	; (4013b8 <bsp_gpio_init+0x7c>)
  401354:	4413      	add	r3, r2
  401356:	4618      	mov	r0, r3
  401358:	4b18      	ldr	r3, [pc, #96]	; (4013bc <bsp_gpio_init+0x80>)
  40135a:	4798      	blx	r3
  40135c:	4603      	mov	r3, r0
  40135e:	2100      	movs	r1, #0
  401360:	4618      	mov	r0, r3
  401362:	4b17      	ldr	r3, [pc, #92]	; (4013c0 <bsp_gpio_init+0x84>)
  401364:	4798      	blx	r3
    ioport_set_pin_level(PIN_INDEX(i), IOPORT_PIN_LEVEL_LOW);
  401366:	79fa      	ldrb	r2, [r7, #7]
  401368:	4613      	mov	r3, r2
  40136a:	009b      	lsls	r3, r3, #2
  40136c:	4413      	add	r3, r2
  40136e:	009b      	lsls	r3, r3, #2
  401370:	4a11      	ldr	r2, [pc, #68]	; (4013b8 <bsp_gpio_init+0x7c>)
  401372:	4413      	add	r3, r2
  401374:	4618      	mov	r0, r3
  401376:	4b11      	ldr	r3, [pc, #68]	; (4013bc <bsp_gpio_init+0x80>)
  401378:	4798      	blx	r3
  40137a:	4603      	mov	r3, r0
  40137c:	2100      	movs	r1, #0
  40137e:	4618      	mov	r0, r3
  401380:	4b10      	ldr	r3, [pc, #64]	; (4013c4 <bsp_gpio_init+0x88>)
  401382:	4798      	blx	r3
    ioport_set_pin_mode(PIN_INDEX(i), IOPORT_MODE_PULLDOWN);
  401384:	79fa      	ldrb	r2, [r7, #7]
  401386:	4613      	mov	r3, r2
  401388:	009b      	lsls	r3, r3, #2
  40138a:	4413      	add	r3, r2
  40138c:	009b      	lsls	r3, r3, #2
  40138e:	4a0a      	ldr	r2, [pc, #40]	; (4013b8 <bsp_gpio_init+0x7c>)
  401390:	4413      	add	r3, r2
  401392:	4618      	mov	r0, r3
  401394:	4b09      	ldr	r3, [pc, #36]	; (4013bc <bsp_gpio_init+0x80>)
  401396:	4798      	blx	r3
  401398:	4603      	mov	r3, r0
  40139a:	2110      	movs	r1, #16
  40139c:	4618      	mov	r0, r3
  40139e:	4b0a      	ldr	r3, [pc, #40]	; (4013c8 <bsp_gpio_init+0x8c>)
  4013a0:	4798      	blx	r3
  for (uint8_t i = 1; i <= SENSOR_COUNT_MAX; i++)
  4013a2:	79fb      	ldrb	r3, [r7, #7]
  4013a4:	3301      	adds	r3, #1
  4013a6:	71fb      	strb	r3, [r7, #7]
  4013a8:	79fb      	ldrb	r3, [r7, #7]
  4013aa:	2b63      	cmp	r3, #99	; 0x63
  4013ac:	d9cc      	bls.n	401348 <bsp_gpio_init+0xc>
  }
}
  4013ae:	bf00      	nop
  4013b0:	3708      	adds	r7, #8
  4013b2:	46bd      	mov	sp, r7
  4013b4:	bd80      	pop	{r7, pc}
  4013b6:	bf00      	nop
  4013b8:	00403120 	.word	0x00403120
  4013bc:	00401325 	.word	0x00401325
  4013c0:	00401231 	.word	0x00401231
  4013c4:	004012b9 	.word	0x004012b9
  4013c8:	00401115 	.word	0x00401115

004013cc <bsp_lcd_init>:
/* Private function prototypes ---------------------------------------- */
void m_bsp_lcd_set_position(uint8_t row, uint8_t col);

/* Function definitions ----------------------------------------------- */
void bsp_lcd_init(void)
{
  4013cc:	b580      	push	{r7, lr}
  4013ce:	af00      	add	r7, sp, #0
  m_ssd1311.device_address = SSD1311_I2C_ADDRESS;
  4013d0:	4b06      	ldr	r3, [pc, #24]	; (4013ec <bsp_lcd_init+0x20>)
  4013d2:	223c      	movs	r2, #60	; 0x3c
  4013d4:	701a      	strb	r2, [r3, #0]
  m_ssd1311.i2c_write      = bsp_i2c_write;
  4013d6:	4b05      	ldr	r3, [pc, #20]	; (4013ec <bsp_lcd_init+0x20>)
  4013d8:	4a05      	ldr	r2, [pc, #20]	; (4013f0 <bsp_lcd_init+0x24>)
  4013da:	605a      	str	r2, [r3, #4]
  m_ssd1311.delay          = bsp_delay;
  4013dc:	4b03      	ldr	r3, [pc, #12]	; (4013ec <bsp_lcd_init+0x20>)
  4013de:	4a05      	ldr	r2, [pc, #20]	; (4013f4 <bsp_lcd_init+0x28>)
  4013e0:	609a      	str	r2, [r3, #8]
  
  ssd1311_init(&m_ssd1311);
  4013e2:	4802      	ldr	r0, [pc, #8]	; (4013ec <bsp_lcd_init+0x20>)
  4013e4:	4b04      	ldr	r3, [pc, #16]	; (4013f8 <bsp_lcd_init+0x2c>)
  4013e6:	4798      	blx	r3
}
  4013e8:	bf00      	nop
  4013ea:	bd80      	pop	{r7, pc}
  4013ec:	2000a7ac 	.word	0x2000a7ac
  4013f0:	00400dd5 	.word	0x00400dd5
  4013f4:	00400e49 	.word	0x00400e49
  4013f8:	00401431 	.word	0x00401431

004013fc <bsp_rtc_init>:
/* Private macros ----------------------------------------------------- */
/* Public variables --------------------------------------------------- */
/* Private variables -------------------------------------------------- */
/* Private function prototypes ---------------------------------------- */
void bsp_rtc_init(void)
{
  4013fc:	b580      	push	{r7, lr}
  4013fe:	af00      	add	r7, sp, #0
  pmc_switch_sclk_to_32kxtal(PMC_OSC_XTAL);
  401400:	2000      	movs	r0, #0
  401402:	4b07      	ldr	r3, [pc, #28]	; (401420 <bsp_rtc_init+0x24>)
  401404:	4798      	blx	r3

  while (!pmc_osc_is_ready_32kxtal());
  401406:	bf00      	nop
  401408:	4b06      	ldr	r3, [pc, #24]	; (401424 <bsp_rtc_init+0x28>)
  40140a:	4798      	blx	r3
  40140c:	4603      	mov	r3, r0
  40140e:	2b00      	cmp	r3, #0
  401410:	d0fa      	beq.n	401408 <bsp_rtc_init+0xc>

  rtc_set_hour_mode(RTC, 0);
  401412:	2100      	movs	r1, #0
  401414:	4804      	ldr	r0, [pc, #16]	; (401428 <bsp_rtc_init+0x2c>)
  401416:	4b05      	ldr	r3, [pc, #20]	; (40142c <bsp_rtc_init+0x30>)
  401418:	4798      	blx	r3
}
  40141a:	bf00      	nop
  40141c:	bd80      	pop	{r7, pc}
  40141e:	bf00      	nop
  401420:	0040279d 	.word	0x0040279d
  401424:	004027d5 	.word	0x004027d5
  401428:	400e1860 	.word	0x400e1860
  40142c:	00401a3d 	.word	0x00401a3d

00401430 <ssd1311_init>:
void cursPos(ssd1311_t *me, uint8_t col, uint8_t row);


/* Function definitions ----------------------------------------------- */
base_status_t ssd1311_init(ssd1311_t *me)
{
  401430:	b580      	push	{r7, lr}
  401432:	b082      	sub	sp, #8
  401434:	af00      	add	r7, sp, #0
  401436:	6078      	str	r0, [r7, #4]
  if ((me == NULL) || (me->i2c_write == NULL))
  401438:	687b      	ldr	r3, [r7, #4]
  40143a:	2b00      	cmp	r3, #0
  40143c:	d003      	beq.n	401446 <ssd1311_init+0x16>
  40143e:	687b      	ldr	r3, [r7, #4]
  401440:	685b      	ldr	r3, [r3, #4]
  401442:	2b00      	cmp	r3, #0
  401444:	d101      	bne.n	40144a <ssd1311_init+0x1a>
    return BS_ERROR_PARAMS;
  401446:	2301      	movs	r3, #1
  401448:	e003      	b.n	401452 <ssd1311_init+0x22>

  m_ssd1311_run_cfg_script(me);
  40144a:	6878      	ldr	r0, [r7, #4]
  40144c:	4b03      	ldr	r3, [pc, #12]	; (40145c <ssd1311_init+0x2c>)
  40144e:	4798      	blx	r3

  return BS_OK;
  401450:	2300      	movs	r3, #0
}
  401452:	4618      	mov	r0, r3
  401454:	3708      	adds	r7, #8
  401456:	46bd      	mov	sp, r7
  401458:	bd80      	pop	{r7, pc}
  40145a:	bf00      	nop
  40145c:	004014c1 	.word	0x004014c1

00401460 <ssd1311_write_cmd>:

base_status_t ssd1311_write_cmd(ssd1311_t *me, uint8_t cmd)
{
  401460:	b590      	push	{r4, r7, lr}
  401462:	b083      	sub	sp, #12
  401464:	af00      	add	r7, sp, #0
  401466:	6078      	str	r0, [r7, #4]
  401468:	460b      	mov	r3, r1
  40146a:	70fb      	strb	r3, [r7, #3]
  CHECK(BS_OK == me->i2c_write(me->device_address, SSD1311_CMD_MODE, &cmd, 1), BS_ERROR);
  40146c:	687b      	ldr	r3, [r7, #4]
  40146e:	685c      	ldr	r4, [r3, #4]
  401470:	687b      	ldr	r3, [r7, #4]
  401472:	7818      	ldrb	r0, [r3, #0]
  401474:	1cfa      	adds	r2, r7, #3
  401476:	2301      	movs	r3, #1
  401478:	2180      	movs	r1, #128	; 0x80
  40147a:	47a0      	blx	r4
  40147c:	4603      	mov	r3, r0
  40147e:	2b00      	cmp	r3, #0
  401480:	d001      	beq.n	401486 <ssd1311_write_cmd+0x26>
  401482:	2302      	movs	r3, #2
  401484:	e000      	b.n	401488 <ssd1311_write_cmd+0x28>

  return BS_OK;
  401486:	2300      	movs	r3, #0
}
  401488:	4618      	mov	r0, r3
  40148a:	370c      	adds	r7, #12
  40148c:	46bd      	mov	sp, r7
  40148e:	bd90      	pop	{r4, r7, pc}

00401490 <ssd1311_write_data_byte>:

  return BS_OK;
}

base_status_t ssd1311_write_data_byte(ssd1311_t *me, uint8_t data)
{
  401490:	b590      	push	{r4, r7, lr}
  401492:	b083      	sub	sp, #12
  401494:	af00      	add	r7, sp, #0
  401496:	6078      	str	r0, [r7, #4]
  401498:	460b      	mov	r3, r1
  40149a:	70fb      	strb	r3, [r7, #3]
  CHECK(BS_OK == me->i2c_write(me->device_address, SSD1311_DATA_MODE, &data, 1), BS_ERROR);
  40149c:	687b      	ldr	r3, [r7, #4]
  40149e:	685c      	ldr	r4, [r3, #4]
  4014a0:	687b      	ldr	r3, [r7, #4]
  4014a2:	7818      	ldrb	r0, [r3, #0]
  4014a4:	1cfa      	adds	r2, r7, #3
  4014a6:	2301      	movs	r3, #1
  4014a8:	2140      	movs	r1, #64	; 0x40
  4014aa:	47a0      	blx	r4
  4014ac:	4603      	mov	r3, r0
  4014ae:	2b00      	cmp	r3, #0
  4014b0:	d001      	beq.n	4014b6 <ssd1311_write_data_byte+0x26>
  4014b2:	2302      	movs	r3, #2
  4014b4:	e000      	b.n	4014b8 <ssd1311_write_data_byte+0x28>

  return BS_OK;
  4014b6:	2300      	movs	r3, #0
}
  4014b8:	4618      	mov	r0, r3
  4014ba:	370c      	adds	r7, #12
  4014bc:	46bd      	mov	sp, r7
  4014be:	bd90      	pop	{r4, r7, pc}

004014c0 <m_ssd1311_run_cfg_script>:
 * @return
 * - BS_OK
 * - BS_ERROR
 */
static base_status_t m_ssd1311_run_cfg_script(ssd1311_t *me)
{
  4014c0:	b580      	push	{r7, lr}
  4014c2:	b084      	sub	sp, #16
  4014c4:	af00      	add	r7, sp, #0
  4014c6:	6078      	str	r0, [r7, #4]
  int i          = 0;
  4014c8:	2300      	movs	r3, #0
  4014ca:	60fb      	str	r3, [r7, #12]
  int end_script = 0;
  4014cc:	2300      	movs	r3, #0
  4014ce:	60bb      	str	r3, [r7, #8]

  do
  {
    switch (SSD1311_CFG_SCRIPT[i].cmd)
  4014d0:	4a20      	ldr	r2, [pc, #128]	; (401554 <m_ssd1311_run_cfg_script+0x94>)
  4014d2:	68fb      	ldr	r3, [r7, #12]
  4014d4:	f812 3013 	ldrb.w	r3, [r2, r3, lsl #1]
  4014d8:	2b04      	cmp	r3, #4
  4014da:	d82e      	bhi.n	40153a <m_ssd1311_run_cfg_script+0x7a>
  4014dc:	a201      	add	r2, pc, #4	; (adr r2, 4014e4 <m_ssd1311_run_cfg_script+0x24>)
  4014de:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4014e2:	bf00      	nop
  4014e4:	0040153b 	.word	0x0040153b
  4014e8:	00401535 	.word	0x00401535
  4014ec:	004014f9 	.word	0x004014f9
  4014f0:	0040150d 	.word	0x0040150d
  4014f4:	00401521 	.word	0x00401521
    {
    case SSD1311_START:
      break;
    case SSD1311_CMD:
      ssd1311_write_cmd(me, SSD1311_CFG_SCRIPT[i].data & 0xFF);
  4014f8:	4a16      	ldr	r2, [pc, #88]	; (401554 <m_ssd1311_run_cfg_script+0x94>)
  4014fa:	68fb      	ldr	r3, [r7, #12]
  4014fc:	005b      	lsls	r3, r3, #1
  4014fe:	4413      	add	r3, r2
  401500:	785b      	ldrb	r3, [r3, #1]
  401502:	4619      	mov	r1, r3
  401504:	6878      	ldr	r0, [r7, #4]
  401506:	4b14      	ldr	r3, [pc, #80]	; (401558 <m_ssd1311_run_cfg_script+0x98>)
  401508:	4798      	blx	r3
      break;
  40150a:	e017      	b.n	40153c <m_ssd1311_run_cfg_script+0x7c>
    case SSD1311_DATA:
      ssd1311_write_data_byte(me, SSD1311_CFG_SCRIPT[i].data & 0xFF);
  40150c:	4a11      	ldr	r2, [pc, #68]	; (401554 <m_ssd1311_run_cfg_script+0x94>)
  40150e:	68fb      	ldr	r3, [r7, #12]
  401510:	005b      	lsls	r3, r3, #1
  401512:	4413      	add	r3, r2
  401514:	785b      	ldrb	r3, [r3, #1]
  401516:	4619      	mov	r1, r3
  401518:	6878      	ldr	r0, [r7, #4]
  40151a:	4b10      	ldr	r3, [pc, #64]	; (40155c <m_ssd1311_run_cfg_script+0x9c>)
  40151c:	4798      	blx	r3
      break;
  40151e:	e00d      	b.n	40153c <m_ssd1311_run_cfg_script+0x7c>
    case SSD1311_DELAY:
      me->delay(SSD1311_CFG_SCRIPT[i].data);
  401520:	687b      	ldr	r3, [r7, #4]
  401522:	689a      	ldr	r2, [r3, #8]
  401524:	490b      	ldr	r1, [pc, #44]	; (401554 <m_ssd1311_run_cfg_script+0x94>)
  401526:	68fb      	ldr	r3, [r7, #12]
  401528:	005b      	lsls	r3, r3, #1
  40152a:	440b      	add	r3, r1
  40152c:	785b      	ldrb	r3, [r3, #1]
  40152e:	4618      	mov	r0, r3
  401530:	4790      	blx	r2
      break;
  401532:	e003      	b.n	40153c <m_ssd1311_run_cfg_script+0x7c>
    case SSD1311_END:
      end_script = 1;
  401534:	2301      	movs	r3, #1
  401536:	60bb      	str	r3, [r7, #8]
      break;
  401538:	e000      	b.n	40153c <m_ssd1311_run_cfg_script+0x7c>
    default:
      break;
  40153a:	bf00      	nop
    }
    i++;
  40153c:	68fb      	ldr	r3, [r7, #12]
  40153e:	3301      	adds	r3, #1
  401540:	60fb      	str	r3, [r7, #12]
  }
  while (!end_script);
  401542:	68bb      	ldr	r3, [r7, #8]
  401544:	2b00      	cmp	r3, #0
  401546:	d0c3      	beq.n	4014d0 <m_ssd1311_run_cfg_script+0x10>

  return BS_OK;
  401548:	2300      	movs	r3, #0
}
  40154a:	4618      	mov	r0, r3
  40154c:	3710      	adds	r7, #16
  40154e:	46bd      	mov	sp, r7
  401550:	bd80      	pop	{r7, pc}
  401552:	bf00      	nop
  401554:	004038f0 	.word	0x004038f0
  401558:	00401461 	.word	0x00401461
  40155c:	00401491 	.word	0x00401491

00401560 <sys_init>:
static void m_lcd_write_sensor_event(date_time_t *dt, uint8_t sensor_name, sys_evt_src_t evt_src);
static void m_sdcard_write_sensor_event(date_time_t *dt, uint8_t sensor_name, sys_evt_src_t evt_src);

/* Function definitions ----------------------------------------------- */
void sys_init(void)
{
  401560:	b580      	push	{r7, lr}
  401562:	af00      	add	r7, sp, #0
  g_sensor_evt_queue = xQueueCreate(10, sizeof(uint8_t));
  401564:	2200      	movs	r2, #0
  401566:	2101      	movs	r1, #1
  401568:	200a      	movs	r0, #10
  40156a:	4b11      	ldr	r3, [pc, #68]	; (4015b0 <sys_init+0x50>)
  40156c:	4798      	blx	r3
  40156e:	4602      	mov	r2, r0
  401570:	4b10      	ldr	r3, [pc, #64]	; (4015b4 <sys_init+0x54>)
  401572:	601a      	str	r2, [r3, #0]

  sysclk_init();   // Initialize System Clock
  401574:	4b10      	ldr	r3, [pc, #64]	; (4015b8 <sys_init+0x58>)
  401576:	4798      	blx	r3
  board_init();    // Board init
  401578:	4b10      	ldr	r3, [pc, #64]	; (4015bc <sys_init+0x5c>)
  40157a:	4798      	blx	r3
  bsp_hw_init();   // Hardware init
  40157c:	4b10      	ldr	r3, [pc, #64]	; (4015c0 <sys_init+0x60>)
  40157e:	4798      	blx	r3
  bsp_can_init();  // Can bus init
  401580:	4b10      	ldr	r3, [pc, #64]	; (4015c4 <sys_init+0x64>)
  401582:	4798      	blx	r3
  bsp_lcd_init();  // LCD init
  401584:	4b10      	ldr	r3, [pc, #64]	; (4015c8 <sys_init+0x68>)
  401586:	4798      	blx	r3

  while (1)
  {
    bsp_delay(1000);
  401588:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  40158c:	4b0f      	ldr	r3, [pc, #60]	; (4015cc <sys_init+0x6c>)
  40158e:	4798      	blx	r3
    bsp_uart_write('+');
  401590:	202b      	movs	r0, #43	; 0x2b
  401592:	4b0f      	ldr	r3, [pc, #60]	; (4015d0 <sys_init+0x70>)
  401594:	4798      	blx	r3
    bsp_delay(1);
  401596:	2001      	movs	r0, #1
  401598:	4b0c      	ldr	r3, [pc, #48]	; (4015cc <sys_init+0x6c>)
  40159a:	4798      	blx	r3
    bsp_uart_write('+');
  40159c:	202b      	movs	r0, #43	; 0x2b
  40159e:	4b0c      	ldr	r3, [pc, #48]	; (4015d0 <sys_init+0x70>)
  4015a0:	4798      	blx	r3
    bsp_delay(1);
  4015a2:	2001      	movs	r0, #1
  4015a4:	4b09      	ldr	r3, [pc, #36]	; (4015cc <sys_init+0x6c>)
  4015a6:	4798      	blx	r3
    bsp_uart_write('+');
  4015a8:	202b      	movs	r0, #43	; 0x2b
  4015aa:	4b09      	ldr	r3, [pc, #36]	; (4015d0 <sys_init+0x70>)
  4015ac:	4798      	blx	r3
    bsp_delay(1000);
  4015ae:	e7eb      	b.n	401588 <sys_init+0x28>
  4015b0:	004007c1 	.word	0x004007c1
  4015b4:	2000a7a8 	.word	0x2000a7a8
  4015b8:	00402085 	.word	0x00402085
  4015bc:	00401949 	.word	0x00401949
  4015c0:	00400dad 	.word	0x00400dad
  4015c4:	004010a1 	.word	0x004010a1
  4015c8:	004013cd 	.word	0x004013cd
  4015cc:	00400e49 	.word	0x00400e49
  4015d0:	00400e1d 	.word	0x00400e1d

004015d4 <sysclk_enable_peripheral_clock>:
{
  4015d4:	b580      	push	{r7, lr}
  4015d6:	b082      	sub	sp, #8
  4015d8:	af00      	add	r7, sp, #0
  4015da:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  4015dc:	6878      	ldr	r0, [r7, #4]
  4015de:	4b03      	ldr	r3, [pc, #12]	; (4015ec <sysclk_enable_peripheral_clock+0x18>)
  4015e0:	4798      	blx	r3
}
  4015e2:	bf00      	nop
  4015e4:	3708      	adds	r7, #8
  4015e6:	46bd      	mov	sp, r7
  4015e8:	bd80      	pop	{r7, pc}
  4015ea:	bf00      	nop
  4015ec:	00402945 	.word	0x00402945

004015f0 <ioport_init>:
{
  4015f0:	b580      	push	{r7, lr}
  4015f2:	af00      	add	r7, sp, #0
	sysclk_enable_peripheral_clock(ID_PIOA);
  4015f4:	2009      	movs	r0, #9
  4015f6:	4b08      	ldr	r3, [pc, #32]	; (401618 <ioport_init+0x28>)
  4015f8:	4798      	blx	r3
	sysclk_enable_peripheral_clock(ID_PIOB);
  4015fa:	200a      	movs	r0, #10
  4015fc:	4b06      	ldr	r3, [pc, #24]	; (401618 <ioport_init+0x28>)
  4015fe:	4798      	blx	r3
	sysclk_enable_peripheral_clock(ID_PIOC);
  401600:	200b      	movs	r0, #11
  401602:	4b05      	ldr	r3, [pc, #20]	; (401618 <ioport_init+0x28>)
  401604:	4798      	blx	r3
	sysclk_enable_peripheral_clock(ID_PIOD);
  401606:	200c      	movs	r0, #12
  401608:	4b03      	ldr	r3, [pc, #12]	; (401618 <ioport_init+0x28>)
  40160a:	4798      	blx	r3
	sysclk_enable_peripheral_clock(ID_PIOE);
  40160c:	200d      	movs	r0, #13
  40160e:	4b02      	ldr	r3, [pc, #8]	; (401618 <ioport_init+0x28>)
  401610:	4798      	blx	r3
}
  401612:	bf00      	nop
  401614:	bd80      	pop	{r7, pc}
  401616:	bf00      	nop
  401618:	004015d5 	.word	0x004015d5

0040161c <ioport_disable_pin>:
{
  40161c:	b480      	push	{r7}
  40161e:	b089      	sub	sp, #36	; 0x24
  401620:	af00      	add	r7, sp, #0
  401622:	6078      	str	r0, [r7, #4]
  401624:	687b      	ldr	r3, [r7, #4]
  401626:	61fb      	str	r3, [r7, #28]
  401628:	69fb      	ldr	r3, [r7, #28]
  40162a:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  40162c:	69bb      	ldr	r3, [r7, #24]
  40162e:	095a      	lsrs	r2, r3, #5
  401630:	69fb      	ldr	r3, [r7, #28]
  401632:	617b      	str	r3, [r7, #20]
	return 1U << (pin & 0x1F);
  401634:	697b      	ldr	r3, [r7, #20]
  401636:	f003 031f 	and.w	r3, r3, #31
  40163a:	2101      	movs	r1, #1
  40163c:	fa01 f303 	lsl.w	r3, r1, r3
  401640:	613a      	str	r2, [r7, #16]
  401642:	60fb      	str	r3, [r7, #12]
  401644:	693b      	ldr	r3, [r7, #16]
  401646:	60bb      	str	r3, [r7, #8]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  401648:	68bb      	ldr	r3, [r7, #8]
  40164a:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  40164e:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401652:	025b      	lsls	r3, r3, #9
  401654:	461a      	mov	r2, r3
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  401656:	68fb      	ldr	r3, [r7, #12]
  401658:	6053      	str	r3, [r2, #4]
}
  40165a:	bf00      	nop
  40165c:	3724      	adds	r7, #36	; 0x24
  40165e:	46bd      	mov	sp, r7
  401660:	f85d 7b04 	ldr.w	r7, [sp], #4
  401664:	4770      	bx	lr

00401666 <ioport_set_pin_mode>:
{
  401666:	b480      	push	{r7}
  401668:	b08d      	sub	sp, #52	; 0x34
  40166a:	af00      	add	r7, sp, #0
  40166c:	6078      	str	r0, [r7, #4]
  40166e:	6039      	str	r1, [r7, #0]
  401670:	687b      	ldr	r3, [r7, #4]
  401672:	62fb      	str	r3, [r7, #44]	; 0x2c
  401674:	683b      	ldr	r3, [r7, #0]
  401676:	62bb      	str	r3, [r7, #40]	; 0x28
  401678:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40167a:	627b      	str	r3, [r7, #36]	; 0x24
	return pin >> 5;
  40167c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40167e:	095a      	lsrs	r2, r3, #5
  401680:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401682:	623b      	str	r3, [r7, #32]
	return 1U << (pin & 0x1F);
  401684:	6a3b      	ldr	r3, [r7, #32]
  401686:	f003 031f 	and.w	r3, r3, #31
  40168a:	2101      	movs	r1, #1
  40168c:	fa01 f303 	lsl.w	r3, r1, r3
  401690:	61fa      	str	r2, [r7, #28]
  401692:	61bb      	str	r3, [r7, #24]
  401694:	6abb      	ldr	r3, [r7, #40]	; 0x28
  401696:	617b      	str	r3, [r7, #20]
  401698:	69fb      	ldr	r3, [r7, #28]
  40169a:	613b      	str	r3, [r7, #16]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  40169c:	693b      	ldr	r3, [r7, #16]
  40169e:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4016a2:	f203 7307 	addw	r3, r3, #1799	; 0x707
  4016a6:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_port_to_base(port);
  4016a8:	60fb      	str	r3, [r7, #12]
	if (mode & IOPORT_MODE_PULLUP) {
  4016aa:	697b      	ldr	r3, [r7, #20]
  4016ac:	f003 0308 	and.w	r3, r3, #8
  4016b0:	2b00      	cmp	r3, #0
  4016b2:	d003      	beq.n	4016bc <ioport_set_pin_mode+0x56>
		base->PIO_PUER = mask;
  4016b4:	68fb      	ldr	r3, [r7, #12]
  4016b6:	69ba      	ldr	r2, [r7, #24]
  4016b8:	665a      	str	r2, [r3, #100]	; 0x64
  4016ba:	e002      	b.n	4016c2 <ioport_set_pin_mode+0x5c>
		base->PIO_PUDR = mask;
  4016bc:	68fb      	ldr	r3, [r7, #12]
  4016be:	69ba      	ldr	r2, [r7, #24]
  4016c0:	661a      	str	r2, [r3, #96]	; 0x60
	if (mode & IOPORT_MODE_PULLDOWN) {
  4016c2:	697b      	ldr	r3, [r7, #20]
  4016c4:	f003 0310 	and.w	r3, r3, #16
  4016c8:	2b00      	cmp	r3, #0
  4016ca:	d004      	beq.n	4016d6 <ioport_set_pin_mode+0x70>
		base->PIO_PPDER = mask;
  4016cc:	68fb      	ldr	r3, [r7, #12]
  4016ce:	69ba      	ldr	r2, [r7, #24]
  4016d0:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  4016d4:	e003      	b.n	4016de <ioport_set_pin_mode+0x78>
		base->PIO_PPDDR = mask;
  4016d6:	68fb      	ldr	r3, [r7, #12]
  4016d8:	69ba      	ldr	r2, [r7, #24]
  4016da:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	if (mode & IOPORT_MODE_OPEN_DRAIN) {
  4016de:	697b      	ldr	r3, [r7, #20]
  4016e0:	f003 0320 	and.w	r3, r3, #32
  4016e4:	2b00      	cmp	r3, #0
  4016e6:	d003      	beq.n	4016f0 <ioport_set_pin_mode+0x8a>
		base->PIO_MDER = mask;
  4016e8:	68fb      	ldr	r3, [r7, #12]
  4016ea:	69ba      	ldr	r2, [r7, #24]
  4016ec:	651a      	str	r2, [r3, #80]	; 0x50
  4016ee:	e002      	b.n	4016f6 <ioport_set_pin_mode+0x90>
		base->PIO_MDDR = mask;
  4016f0:	68fb      	ldr	r3, [r7, #12]
  4016f2:	69ba      	ldr	r2, [r7, #24]
  4016f4:	655a      	str	r2, [r3, #84]	; 0x54
	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
  4016f6:	697b      	ldr	r3, [r7, #20]
  4016f8:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
  4016fc:	2b00      	cmp	r3, #0
  4016fe:	d003      	beq.n	401708 <ioport_set_pin_mode+0xa2>
		base->PIO_IFER = mask;
  401700:	68fb      	ldr	r3, [r7, #12]
  401702:	69ba      	ldr	r2, [r7, #24]
  401704:	621a      	str	r2, [r3, #32]
  401706:	e002      	b.n	40170e <ioport_set_pin_mode+0xa8>
		base->PIO_IFDR = mask;
  401708:	68fb      	ldr	r3, [r7, #12]
  40170a:	69ba      	ldr	r2, [r7, #24]
  40170c:	625a      	str	r2, [r3, #36]	; 0x24
	if (mode & IOPORT_MODE_DEBOUNCE) {
  40170e:	697b      	ldr	r3, [r7, #20]
  401710:	f003 0380 	and.w	r3, r3, #128	; 0x80
  401714:	2b00      	cmp	r3, #0
  401716:	d004      	beq.n	401722 <ioport_set_pin_mode+0xbc>
		base->PIO_IFSCER = mask;
  401718:	68fb      	ldr	r3, [r7, #12]
  40171a:	69ba      	ldr	r2, [r7, #24]
  40171c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  401720:	e003      	b.n	40172a <ioport_set_pin_mode+0xc4>
		base->PIO_IFSCDR = mask;
  401722:	68fb      	ldr	r3, [r7, #12]
  401724:	69ba      	ldr	r2, [r7, #24]
  401726:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	if (mode & IOPORT_MODE_MUX_BIT0) {
  40172a:	697b      	ldr	r3, [r7, #20]
  40172c:	f003 0301 	and.w	r3, r3, #1
  401730:	2b00      	cmp	r3, #0
  401732:	d006      	beq.n	401742 <ioport_set_pin_mode+0xdc>
		base->PIO_ABCDSR[0] |= mask;
  401734:	68fb      	ldr	r3, [r7, #12]
  401736:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  401738:	69bb      	ldr	r3, [r7, #24]
  40173a:	431a      	orrs	r2, r3
  40173c:	68fb      	ldr	r3, [r7, #12]
  40173e:	671a      	str	r2, [r3, #112]	; 0x70
  401740:	e006      	b.n	401750 <ioport_set_pin_mode+0xea>
		base->PIO_ABCDSR[0] &= ~mask;
  401742:	68fb      	ldr	r3, [r7, #12]
  401744:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  401746:	69bb      	ldr	r3, [r7, #24]
  401748:	43db      	mvns	r3, r3
  40174a:	401a      	ands	r2, r3
  40174c:	68fb      	ldr	r3, [r7, #12]
  40174e:	671a      	str	r2, [r3, #112]	; 0x70
	if (mode & IOPORT_MODE_MUX_BIT1) {
  401750:	697b      	ldr	r3, [r7, #20]
  401752:	f003 0302 	and.w	r3, r3, #2
  401756:	2b00      	cmp	r3, #0
  401758:	d006      	beq.n	401768 <ioport_set_pin_mode+0x102>
		base->PIO_ABCDSR[1] |= mask;
  40175a:	68fb      	ldr	r3, [r7, #12]
  40175c:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  40175e:	69bb      	ldr	r3, [r7, #24]
  401760:	431a      	orrs	r2, r3
  401762:	68fb      	ldr	r3, [r7, #12]
  401764:	675a      	str	r2, [r3, #116]	; 0x74
}
  401766:	e006      	b.n	401776 <ioport_set_pin_mode+0x110>
		base->PIO_ABCDSR[1] &= ~mask;
  401768:	68fb      	ldr	r3, [r7, #12]
  40176a:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  40176c:	69bb      	ldr	r3, [r7, #24]
  40176e:	43db      	mvns	r3, r3
  401770:	401a      	ands	r2, r3
  401772:	68fb      	ldr	r3, [r7, #12]
  401774:	675a      	str	r2, [r3, #116]	; 0x74
  401776:	bf00      	nop
  401778:	3734      	adds	r7, #52	; 0x34
  40177a:	46bd      	mov	sp, r7
  40177c:	f85d 7b04 	ldr.w	r7, [sp], #4
  401780:	4770      	bx	lr

00401782 <ioport_set_pin_dir>:
{
  401782:	b480      	push	{r7}
  401784:	b08d      	sub	sp, #52	; 0x34
  401786:	af00      	add	r7, sp, #0
  401788:	6078      	str	r0, [r7, #4]
  40178a:	460b      	mov	r3, r1
  40178c:	70fb      	strb	r3, [r7, #3]
  40178e:	687b      	ldr	r3, [r7, #4]
  401790:	62fb      	str	r3, [r7, #44]	; 0x2c
  401792:	78fb      	ldrb	r3, [r7, #3]
  401794:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  401798:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40179a:	627b      	str	r3, [r7, #36]	; 0x24
  40179c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40179e:	623b      	str	r3, [r7, #32]
	return pin >> 5;
  4017a0:	6a3b      	ldr	r3, [r7, #32]
  4017a2:	095b      	lsrs	r3, r3, #5
  4017a4:	61fb      	str	r3, [r7, #28]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  4017a6:	69fb      	ldr	r3, [r7, #28]
  4017a8:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4017ac:	f203 7307 	addw	r3, r3, #1799	; 0x707
  4017b0:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_pin_to_base(pin);
  4017b2:	61bb      	str	r3, [r7, #24]
	if (dir == IOPORT_DIR_OUTPUT) {
  4017b4:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  4017b8:	2b01      	cmp	r3, #1
  4017ba:	d109      	bne.n	4017d0 <ioport_set_pin_dir+0x4e>
  4017bc:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4017be:	617b      	str	r3, [r7, #20]
	return 1U << (pin & 0x1F);
  4017c0:	697b      	ldr	r3, [r7, #20]
  4017c2:	f003 031f 	and.w	r3, r3, #31
  4017c6:	2201      	movs	r2, #1
  4017c8:	409a      	lsls	r2, r3
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  4017ca:	69bb      	ldr	r3, [r7, #24]
  4017cc:	611a      	str	r2, [r3, #16]
  4017ce:	e00c      	b.n	4017ea <ioport_set_pin_dir+0x68>
	} else if (dir == IOPORT_DIR_INPUT) {
  4017d0:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  4017d4:	2b00      	cmp	r3, #0
  4017d6:	d108      	bne.n	4017ea <ioport_set_pin_dir+0x68>
  4017d8:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4017da:	613b      	str	r3, [r7, #16]
	return 1U << (pin & 0x1F);
  4017dc:	693b      	ldr	r3, [r7, #16]
  4017de:	f003 031f 	and.w	r3, r3, #31
  4017e2:	2201      	movs	r2, #1
  4017e4:	409a      	lsls	r2, r3
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
  4017e6:	69bb      	ldr	r3, [r7, #24]
  4017e8:	615a      	str	r2, [r3, #20]
  4017ea:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4017ec:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  4017ee:	68fb      	ldr	r3, [r7, #12]
  4017f0:	f003 031f 	and.w	r3, r3, #31
  4017f4:	2201      	movs	r2, #1
  4017f6:	409a      	lsls	r2, r3
	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  4017f8:	69bb      	ldr	r3, [r7, #24]
  4017fa:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
}
  4017fe:	bf00      	nop
  401800:	3734      	adds	r7, #52	; 0x34
  401802:	46bd      	mov	sp, r7
  401804:	f85d 7b04 	ldr.w	r7, [sp], #4
  401808:	4770      	bx	lr

0040180a <ioport_set_pin_level>:
{
  40180a:	b480      	push	{r7}
  40180c:	b08b      	sub	sp, #44	; 0x2c
  40180e:	af00      	add	r7, sp, #0
  401810:	6078      	str	r0, [r7, #4]
  401812:	460b      	mov	r3, r1
  401814:	70fb      	strb	r3, [r7, #3]
  401816:	687b      	ldr	r3, [r7, #4]
  401818:	627b      	str	r3, [r7, #36]	; 0x24
  40181a:	78fb      	ldrb	r3, [r7, #3]
  40181c:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  401820:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401822:	61fb      	str	r3, [r7, #28]
  401824:	69fb      	ldr	r3, [r7, #28]
  401826:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  401828:	69bb      	ldr	r3, [r7, #24]
  40182a:	095b      	lsrs	r3, r3, #5
  40182c:	617b      	str	r3, [r7, #20]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  40182e:	697b      	ldr	r3, [r7, #20]
  401830:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401834:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401838:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_pin_to_base(pin);
  40183a:	613b      	str	r3, [r7, #16]
	if (level) {
  40183c:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  401840:	2b00      	cmp	r3, #0
  401842:	d009      	beq.n	401858 <ioport_set_pin_level+0x4e>
  401844:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401846:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  401848:	68fb      	ldr	r3, [r7, #12]
  40184a:	f003 031f 	and.w	r3, r3, #31
  40184e:	2201      	movs	r2, #1
  401850:	409a      	lsls	r2, r3
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  401852:	693b      	ldr	r3, [r7, #16]
  401854:	631a      	str	r2, [r3, #48]	; 0x30
}
  401856:	e008      	b.n	40186a <ioport_set_pin_level+0x60>
  401858:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40185a:	60bb      	str	r3, [r7, #8]
	return 1U << (pin & 0x1F);
  40185c:	68bb      	ldr	r3, [r7, #8]
  40185e:	f003 031f 	and.w	r3, r3, #31
  401862:	2201      	movs	r2, #1
  401864:	409a      	lsls	r2, r3
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  401866:	693b      	ldr	r3, [r7, #16]
  401868:	635a      	str	r2, [r3, #52]	; 0x34
  40186a:	bf00      	nop
  40186c:	372c      	adds	r7, #44	; 0x2c
  40186e:	46bd      	mov	sp, r7
  401870:	f85d 7b04 	ldr.w	r7, [sp], #4
  401874:	4770      	bx	lr
	...

00401878 <ioport_set_pin_sense_mode>:
 * \param pin IOPORT pin to configure
 * \param pin_sense Edge to sense for the pin (\ref ioport_sense)
 */
static inline void ioport_set_pin_sense_mode(ioport_pin_t pin,
		enum ioport_sense pin_sense)
{
  401878:	b480      	push	{r7}
  40187a:	b08d      	sub	sp, #52	; 0x34
  40187c:	af00      	add	r7, sp, #0
  40187e:	6078      	str	r0, [r7, #4]
  401880:	460b      	mov	r3, r1
  401882:	70fb      	strb	r3, [r7, #3]
  401884:	687b      	ldr	r3, [r7, #4]
  401886:	62fb      	str	r3, [r7, #44]	; 0x2c
  401888:	78fb      	ldrb	r3, [r7, #3]
  40188a:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  40188e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401890:	627b      	str	r3, [r7, #36]	; 0x24
	return pin >> 5;
  401892:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401894:	095a      	lsrs	r2, r3, #5
  401896:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401898:	623b      	str	r3, [r7, #32]
	return 1U << (pin & 0x1F);
  40189a:	6a3b      	ldr	r3, [r7, #32]
  40189c:	f003 031f 	and.w	r3, r3, #31
  4018a0:	2101      	movs	r1, #1
  4018a2:	fa01 f303 	lsl.w	r3, r1, r3
  4018a6:	61fa      	str	r2, [r7, #28]
  4018a8:	61bb      	str	r3, [r7, #24]
  4018aa:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  4018ae:	75fb      	strb	r3, [r7, #23]
  4018b0:	69fb      	ldr	r3, [r7, #28]
  4018b2:	613b      	str	r3, [r7, #16]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  4018b4:	693b      	ldr	r3, [r7, #16]
  4018b6:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4018ba:	f203 7307 	addw	r3, r3, #1799	; 0x707
  4018be:	025b      	lsls	r3, r3, #9
}

__always_inline static void arch_ioport_set_port_sense_mode(ioport_port_t port,
		ioport_port_mask_t mask, enum ioport_sense pin_sense)
{
	Pio *base = arch_ioport_port_to_base(port);
  4018c0:	60fb      	str	r3, [r7, #12]
	 *       1       0         0    IOPORT_SENSE_FALLING
	 *       1       0         1    IOPORT_SENSE_RISING
	 *       1       1         0    IOPORT_SENSE_LEVEL_LOW
	 *       1       1         1    IOPORT_SENSE_LEVEL_HIGH
	 */
	switch(pin_sense) {
  4018c2:	7dfb      	ldrb	r3, [r7, #23]
  4018c4:	3b01      	subs	r3, #1
  4018c6:	2b03      	cmp	r3, #3
  4018c8:	d82e      	bhi.n	401928 <ioport_set_pin_sense_mode+0xb0>
  4018ca:	a201      	add	r2, pc, #4	; (adr r2, 4018d0 <ioport_set_pin_sense_mode+0x58>)
  4018cc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4018d0:	00401905 	.word	0x00401905
  4018d4:	00401917 	.word	0x00401917
  4018d8:	004018e1 	.word	0x004018e1
  4018dc:	004018f3 	.word	0x004018f3
	case IOPORT_SENSE_LEVEL_LOW:
		base->PIO_LSR = mask;
  4018e0:	68fb      	ldr	r3, [r7, #12]
  4018e2:	69ba      	ldr	r2, [r7, #24]
  4018e4:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
		base->PIO_FELLSR = mask;
  4018e8:	68fb      	ldr	r3, [r7, #12]
  4018ea:	69ba      	ldr	r2, [r7, #24]
  4018ec:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
  4018f0:	e01f      	b.n	401932 <ioport_set_pin_sense_mode+0xba>
		break;
	case IOPORT_SENSE_LEVEL_HIGH:
		base->PIO_LSR = mask;
  4018f2:	68fb      	ldr	r3, [r7, #12]
  4018f4:	69ba      	ldr	r2, [r7, #24]
  4018f6:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
		base->PIO_REHLSR = mask;
  4018fa:	68fb      	ldr	r3, [r7, #12]
  4018fc:	69ba      	ldr	r2, [r7, #24]
  4018fe:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
  401902:	e016      	b.n	401932 <ioport_set_pin_sense_mode+0xba>
		break;
	case IOPORT_SENSE_FALLING:
		base->PIO_ESR = mask;
  401904:	68fb      	ldr	r3, [r7, #12]
  401906:	69ba      	ldr	r2, [r7, #24]
  401908:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
		base->PIO_FELLSR = mask;
  40190c:	68fb      	ldr	r3, [r7, #12]
  40190e:	69ba      	ldr	r2, [r7, #24]
  401910:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
  401914:	e00d      	b.n	401932 <ioport_set_pin_sense_mode+0xba>
		break;
	case IOPORT_SENSE_RISING:
		base->PIO_ESR = mask;
  401916:	68fb      	ldr	r3, [r7, #12]
  401918:	69ba      	ldr	r2, [r7, #24]
  40191a:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
		base->PIO_REHLSR = mask;
  40191e:	68fb      	ldr	r3, [r7, #12]
  401920:	69ba      	ldr	r2, [r7, #24]
  401922:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
  401926:	e004      	b.n	401932 <ioport_set_pin_sense_mode+0xba>
		break;
	default:
		base->PIO_AIMDR = mask;
  401928:	68fb      	ldr	r3, [r7, #12]
  40192a:	69ba      	ldr	r2, [r7, #24]
  40192c:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
	arch_ioport_set_pin_sense_mode(pin, pin_sense);
}
  401930:	e003      	b.n	40193a <ioport_set_pin_sense_mode+0xc2>
		return;
	}
	base->PIO_AIMER = mask;
  401932:	68fb      	ldr	r3, [r7, #12]
  401934:	69ba      	ldr	r2, [r7, #24]
  401936:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
  40193a:	bf00      	nop
  40193c:	3734      	adds	r7, #52	; 0x34
  40193e:	46bd      	mov	sp, r7
  401940:	f85d 7b04 	ldr.w	r7, [sp], #4
  401944:	4770      	bx	lr
  401946:	bf00      	nop

00401948 <board_init>:
		ioport_set_pin_mode(pin, mode);\
		ioport_set_pin_sense_mode(pin, sense);\
	} while (0)

void board_init(void)
{
  401948:	b580      	push	{r7, lr}
  40194a:	af00      	add	r7, sp, #0
#ifndef CONF_BOARD_KEEP_WATCHDOG_AT_INIT
	/* Disable the watchdog */
	WDT->WDT_MR = WDT_MR_WDDIS;
  40194c:	4b34      	ldr	r3, [pc, #208]	; (401a20 <board_init+0xd8>)
  40194e:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  401952:	605a      	str	r2, [r3, #4]
#endif

	/* Initialize IOPORTs */
	ioport_init();
  401954:	4b33      	ldr	r3, [pc, #204]	; (401a24 <board_init+0xdc>)
  401956:	4798      	blx	r3

	/* Configure the pins connected to LED as output and set their
	 * default initial state to high (LED off).
	 */
	ioport_set_pin_dir(LED0_GPIO, IOPORT_DIR_OUTPUT);
  401958:	2101      	movs	r1, #1
  40195a:	2076      	movs	r0, #118	; 0x76
  40195c:	4b32      	ldr	r3, [pc, #200]	; (401a28 <board_init+0xe0>)
  40195e:	4798      	blx	r3
	ioport_set_pin_level(LED0_GPIO, LED0_INACTIVE_LEVEL);
  401960:	2101      	movs	r1, #1
  401962:	2076      	movs	r0, #118	; 0x76
  401964:	4b31      	ldr	r3, [pc, #196]	; (401a2c <board_init+0xe4>)
  401966:	4798      	blx	r3

	/* Configure Push Button pins */
	ioport_set_pin_input_mode(GPIO_PUSH_BUTTON_1, GPIO_PUSH_BUTTON_1_FLAGS,
  401968:	2100      	movs	r1, #0
  40196a:	2002      	movs	r0, #2
  40196c:	4b2e      	ldr	r3, [pc, #184]	; (401a28 <board_init+0xe0>)
  40196e:	4798      	blx	r3
  401970:	2188      	movs	r1, #136	; 0x88
  401972:	2002      	movs	r0, #2
  401974:	4b2e      	ldr	r3, [pc, #184]	; (401a30 <board_init+0xe8>)
  401976:	4798      	blx	r3
  401978:	2102      	movs	r1, #2
  40197a:	2002      	movs	r0, #2
  40197c:	4b2d      	ldr	r3, [pc, #180]	; (401a34 <board_init+0xec>)
  40197e:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_PWM_LED0_GPIO, PIN_PWM_LED0_FLAGS);
#endif

#ifdef CONF_BOARD_CAN
	/* Configure the CAN1 TX and RX pin. */
	ioport_set_pin_peripheral_mode(PIN_CAN1_RX_IDX, PIN_CAN1_RX_FLAGS);
  401980:	2102      	movs	r1, #2
  401982:	204c      	movs	r0, #76	; 0x4c
  401984:	4b2a      	ldr	r3, [pc, #168]	; (401a30 <board_init+0xe8>)
  401986:	4798      	blx	r3
  401988:	204c      	movs	r0, #76	; 0x4c
  40198a:	4b2b      	ldr	r3, [pc, #172]	; (401a38 <board_init+0xf0>)
  40198c:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_CAN1_TX_IDX, PIN_CAN1_TX_FLAGS);
  40198e:	2102      	movs	r1, #2
  401990:	204f      	movs	r0, #79	; 0x4f
  401992:	4b27      	ldr	r3, [pc, #156]	; (401a30 <board_init+0xe8>)
  401994:	4798      	blx	r3
  401996:	204f      	movs	r0, #79	; 0x4f
  401998:	4b27      	ldr	r3, [pc, #156]	; (401a38 <board_init+0xf0>)
  40199a:	4798      	blx	r3
	/* Configure the transiver1 RS & EN pins. */
	ioport_set_pin_dir(PIN_CAN1_TR_RS_IDX, IOPORT_DIR_OUTPUT);
  40199c:	2101      	movs	r1, #1
  40199e:	2082      	movs	r0, #130	; 0x82
  4019a0:	4b21      	ldr	r3, [pc, #132]	; (401a28 <board_init+0xe0>)
  4019a2:	4798      	blx	r3
	ioport_set_pin_dir(PIN_CAN1_TR_EN_IDX, IOPORT_DIR_OUTPUT);
  4019a4:	2101      	movs	r1, #1
  4019a6:	2083      	movs	r0, #131	; 0x83
  4019a8:	4b1f      	ldr	r3, [pc, #124]	; (401a28 <board_init+0xe0>)
  4019aa:	4798      	blx	r3
#  endif
#endif

#if defined (CONF_BOARD_SD_MMC_HSMCI)
	/* Configure HSMCI pins */
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCCDA_GPIO, PIN_HSMCI_MCCDA_FLAGS);
  4019ac:	2102      	movs	r1, #2
  4019ae:	201c      	movs	r0, #28
  4019b0:	4b1f      	ldr	r3, [pc, #124]	; (401a30 <board_init+0xe8>)
  4019b2:	4798      	blx	r3
  4019b4:	201c      	movs	r0, #28
  4019b6:	4b20      	ldr	r3, [pc, #128]	; (401a38 <board_init+0xf0>)
  4019b8:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCCK_GPIO, PIN_HSMCI_MCCK_FLAGS);
  4019ba:	2102      	movs	r1, #2
  4019bc:	201d      	movs	r0, #29
  4019be:	4b1c      	ldr	r3, [pc, #112]	; (401a30 <board_init+0xe8>)
  4019c0:	4798      	blx	r3
  4019c2:	201d      	movs	r0, #29
  4019c4:	4b1c      	ldr	r3, [pc, #112]	; (401a38 <board_init+0xf0>)
  4019c6:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCDA0_GPIO, PIN_HSMCI_MCDA0_FLAGS);
  4019c8:	2102      	movs	r1, #2
  4019ca:	201e      	movs	r0, #30
  4019cc:	4b18      	ldr	r3, [pc, #96]	; (401a30 <board_init+0xe8>)
  4019ce:	4798      	blx	r3
  4019d0:	201e      	movs	r0, #30
  4019d2:	4b19      	ldr	r3, [pc, #100]	; (401a38 <board_init+0xf0>)
  4019d4:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCDA1_GPIO, PIN_HSMCI_MCDA1_FLAGS);
  4019d6:	2102      	movs	r1, #2
  4019d8:	201f      	movs	r0, #31
  4019da:	4b15      	ldr	r3, [pc, #84]	; (401a30 <board_init+0xe8>)
  4019dc:	4798      	blx	r3
  4019de:	201f      	movs	r0, #31
  4019e0:	4b15      	ldr	r3, [pc, #84]	; (401a38 <board_init+0xf0>)
  4019e2:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCDA2_GPIO, PIN_HSMCI_MCDA2_FLAGS);
  4019e4:	2102      	movs	r1, #2
  4019e6:	201a      	movs	r0, #26
  4019e8:	4b11      	ldr	r3, [pc, #68]	; (401a30 <board_init+0xe8>)
  4019ea:	4798      	blx	r3
  4019ec:	201a      	movs	r0, #26
  4019ee:	4b12      	ldr	r3, [pc, #72]	; (401a38 <board_init+0xf0>)
  4019f0:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCDA3_GPIO, PIN_HSMCI_MCDA3_FLAGS);
  4019f2:	2102      	movs	r1, #2
  4019f4:	201b      	movs	r0, #27
  4019f6:	4b0e      	ldr	r3, [pc, #56]	; (401a30 <board_init+0xe8>)
  4019f8:	4798      	blx	r3
  4019fa:	201b      	movs	r0, #27
  4019fc:	4b0e      	ldr	r3, [pc, #56]	; (401a38 <board_init+0xf0>)
  4019fe:	4798      	blx	r3
	ioport_set_pin_dir(AT86RFX_SLP_PIN, IOPORT_DIR_OUTPUT);
	ioport_set_pin_level(AT86RFX_SLP_PIN, IOPORT_PIN_LEVEL_HIGH);
#endif  

#if (defined(CONF_BOARD_TWI0) || defined(CONF_BOARD_EDBG_TWI))
	ioport_set_pin_peripheral_mode(TWI0_DATA_GPIO, TWI0_DATA_FLAGS);
  401a00:	2100      	movs	r1, #0
  401a02:	2003      	movs	r0, #3
  401a04:	4b0a      	ldr	r3, [pc, #40]	; (401a30 <board_init+0xe8>)
  401a06:	4798      	blx	r3
  401a08:	2003      	movs	r0, #3
  401a0a:	4b0b      	ldr	r3, [pc, #44]	; (401a38 <board_init+0xf0>)
  401a0c:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(TWI0_CLK_GPIO, TWI0_CLK_FLAGS);
  401a0e:	2100      	movs	r1, #0
  401a10:	2004      	movs	r0, #4
  401a12:	4b07      	ldr	r3, [pc, #28]	; (401a30 <board_init+0xe8>)
  401a14:	4798      	blx	r3
  401a16:	2004      	movs	r0, #4
  401a18:	4b07      	ldr	r3, [pc, #28]	; (401a38 <board_init+0xf0>)
  401a1a:	4798      	blx	r3
#endif

}
  401a1c:	bf00      	nop
  401a1e:	bd80      	pop	{r7, pc}
  401a20:	400e1850 	.word	0x400e1850
  401a24:	004015f1 	.word	0x004015f1
  401a28:	00401783 	.word	0x00401783
  401a2c:	0040180b 	.word	0x0040180b
  401a30:	00401667 	.word	0x00401667
  401a34:	00401879 	.word	0x00401879
  401a38:	0040161d 	.word	0x0040161d

00401a3c <rtc_set_hour_mode>:
 *
 * \param p_rtc Pointer to an RTC instance.
 * \param ul_mode 1 for 12-hour mode, 0 for 24-hour mode.
 */
void rtc_set_hour_mode(Rtc *p_rtc, uint32_t ul_mode)
{
  401a3c:	b480      	push	{r7}
  401a3e:	b083      	sub	sp, #12
  401a40:	af00      	add	r7, sp, #0
  401a42:	6078      	str	r0, [r7, #4]
  401a44:	6039      	str	r1, [r7, #0]
	if (ul_mode) {
  401a46:	683b      	ldr	r3, [r7, #0]
  401a48:	2b00      	cmp	r3, #0
  401a4a:	d006      	beq.n	401a5a <rtc_set_hour_mode+0x1e>
		p_rtc->RTC_MR |= RTC_MR_HRMOD;
  401a4c:	687b      	ldr	r3, [r7, #4]
  401a4e:	685b      	ldr	r3, [r3, #4]
  401a50:	f043 0201 	orr.w	r2, r3, #1
  401a54:	687b      	ldr	r3, [r7, #4]
  401a56:	605a      	str	r2, [r3, #4]
	} else {
		p_rtc->RTC_MR &= (~RTC_MR_HRMOD);
	}
}
  401a58:	e005      	b.n	401a66 <rtc_set_hour_mode+0x2a>
		p_rtc->RTC_MR &= (~RTC_MR_HRMOD);
  401a5a:	687b      	ldr	r3, [r7, #4]
  401a5c:	685b      	ldr	r3, [r3, #4]
  401a5e:	f023 0201 	bic.w	r2, r3, #1
  401a62:	687b      	ldr	r3, [r7, #4]
  401a64:	605a      	str	r2, [r3, #4]
}
  401a66:	bf00      	nop
  401a68:	370c      	adds	r7, #12
  401a6a:	46bd      	mov	sp, r7
  401a6c:	f85d 7b04 	ldr.w	r7, [sp], #4
  401a70:	4770      	bx	lr

00401a72 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  401a72:	b480      	push	{r7}
  401a74:	af00      	add	r7, sp, #0
	while (1) {
  401a76:	e7fe      	b.n	401a76 <Dummy_Handler+0x4>

00401a78 <cpu_irq_save>:

static volatile uint32_t cpu_irq_critical_section_counter;
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
  401a78:	b480      	push	{r7}
  401a7a:	b083      	sub	sp, #12
  401a7c:	af00      	add	r7, sp, #0
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
  401a7e:	f3ef 8310 	mrs	r3, PRIMASK
  401a82:	607b      	str	r3, [r7, #4]
  return(result);
  401a84:	687b      	ldr	r3, [r7, #4]
	volatile irqflags_t flags = cpu_irq_is_enabled();
  401a86:	2b00      	cmp	r3, #0
  401a88:	bf0c      	ite	eq
  401a8a:	2301      	moveq	r3, #1
  401a8c:	2300      	movne	r3, #0
  401a8e:	b2db      	uxtb	r3, r3
  401a90:	603b      	str	r3, [r7, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  401a92:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
  401a94:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
  401a98:	4b04      	ldr	r3, [pc, #16]	; (401aac <cpu_irq_save+0x34>)
  401a9a:	2200      	movs	r2, #0
  401a9c:	701a      	strb	r2, [r3, #0]
	return flags;
  401a9e:	683b      	ldr	r3, [r7, #0]
}
  401aa0:	4618      	mov	r0, r3
  401aa2:	370c      	adds	r7, #12
  401aa4:	46bd      	mov	sp, r7
  401aa6:	f85d 7b04 	ldr.w	r7, [sp], #4
  401aaa:	4770      	bx	lr
  401aac:	20000018 	.word	0x20000018

00401ab0 <cpu_irq_is_enabled_flags>:

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
  401ab0:	b480      	push	{r7}
  401ab2:	b083      	sub	sp, #12
  401ab4:	af00      	add	r7, sp, #0
  401ab6:	6078      	str	r0, [r7, #4]
	return (flags);
  401ab8:	687b      	ldr	r3, [r7, #4]
  401aba:	2b00      	cmp	r3, #0
  401abc:	bf14      	ite	ne
  401abe:	2301      	movne	r3, #1
  401ac0:	2300      	moveq	r3, #0
  401ac2:	b2db      	uxtb	r3, r3
}
  401ac4:	4618      	mov	r0, r3
  401ac6:	370c      	adds	r7, #12
  401ac8:	46bd      	mov	sp, r7
  401aca:	f85d 7b04 	ldr.w	r7, [sp], #4
  401ace:	4770      	bx	lr

00401ad0 <cpu_irq_restore>:

static inline void cpu_irq_restore(irqflags_t flags)
{
  401ad0:	b580      	push	{r7, lr}
  401ad2:	b082      	sub	sp, #8
  401ad4:	af00      	add	r7, sp, #0
  401ad6:	6078      	str	r0, [r7, #4]
	if (cpu_irq_is_enabled_flags(flags))
  401ad8:	6878      	ldr	r0, [r7, #4]
  401ada:	4b07      	ldr	r3, [pc, #28]	; (401af8 <cpu_irq_restore+0x28>)
  401adc:	4798      	blx	r3
  401ade:	4603      	mov	r3, r0
  401ae0:	2b00      	cmp	r3, #0
  401ae2:	d005      	beq.n	401af0 <cpu_irq_restore+0x20>
		cpu_irq_enable();
  401ae4:	4b05      	ldr	r3, [pc, #20]	; (401afc <cpu_irq_restore+0x2c>)
  401ae6:	2201      	movs	r2, #1
  401ae8:	701a      	strb	r2, [r3, #0]
  401aea:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  401aee:	b662      	cpsie	i
}
  401af0:	bf00      	nop
  401af2:	3708      	adds	r7, #8
  401af4:	46bd      	mov	sp, r7
  401af6:	bd80      	pop	{r7, pc}
  401af8:	00401ab1 	.word	0x00401ab1
  401afc:	20000018 	.word	0x20000018

00401b00 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  401b00:	b580      	push	{r7, lr}
  401b02:	b084      	sub	sp, #16
  401b04:	af00      	add	r7, sp, #0
	uint32_t *pSrc, *pDest;

	/* Initialize the relocate segment */
	pSrc = &_etext;
  401b06:	4b1e      	ldr	r3, [pc, #120]	; (401b80 <Reset_Handler+0x80>)
  401b08:	60fb      	str	r3, [r7, #12]
	pDest = &_srelocate;
  401b0a:	4b1e      	ldr	r3, [pc, #120]	; (401b84 <Reset_Handler+0x84>)
  401b0c:	60bb      	str	r3, [r7, #8]

	if (pSrc != pDest) {
  401b0e:	68fa      	ldr	r2, [r7, #12]
  401b10:	68bb      	ldr	r3, [r7, #8]
  401b12:	429a      	cmp	r2, r3
  401b14:	d00c      	beq.n	401b30 <Reset_Handler+0x30>
		for (; pDest < &_erelocate;) {
  401b16:	e007      	b.n	401b28 <Reset_Handler+0x28>
			*pDest++ = *pSrc++;
  401b18:	68bb      	ldr	r3, [r7, #8]
  401b1a:	1d1a      	adds	r2, r3, #4
  401b1c:	60ba      	str	r2, [r7, #8]
  401b1e:	68fa      	ldr	r2, [r7, #12]
  401b20:	1d11      	adds	r1, r2, #4
  401b22:	60f9      	str	r1, [r7, #12]
  401b24:	6812      	ldr	r2, [r2, #0]
  401b26:	601a      	str	r2, [r3, #0]
		for (; pDest < &_erelocate;) {
  401b28:	68bb      	ldr	r3, [r7, #8]
  401b2a:	4a17      	ldr	r2, [pc, #92]	; (401b88 <Reset_Handler+0x88>)
  401b2c:	4293      	cmp	r3, r2
  401b2e:	d3f3      	bcc.n	401b18 <Reset_Handler+0x18>
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  401b30:	4b16      	ldr	r3, [pc, #88]	; (401b8c <Reset_Handler+0x8c>)
  401b32:	60bb      	str	r3, [r7, #8]
  401b34:	e004      	b.n	401b40 <Reset_Handler+0x40>
		*pDest++ = 0;
  401b36:	68bb      	ldr	r3, [r7, #8]
  401b38:	1d1a      	adds	r2, r3, #4
  401b3a:	60ba      	str	r2, [r7, #8]
  401b3c:	2200      	movs	r2, #0
  401b3e:	601a      	str	r2, [r3, #0]
	for (pDest = &_szero; pDest < &_ezero;) {
  401b40:	68bb      	ldr	r3, [r7, #8]
  401b42:	4a13      	ldr	r2, [pc, #76]	; (401b90 <Reset_Handler+0x90>)
  401b44:	4293      	cmp	r3, r2
  401b46:	d3f6      	bcc.n	401b36 <Reset_Handler+0x36>
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) & _sfixed;
  401b48:	4b12      	ldr	r3, [pc, #72]	; (401b94 <Reset_Handler+0x94>)
  401b4a:	60fb      	str	r3, [r7, #12]
	SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  401b4c:	4a12      	ldr	r2, [pc, #72]	; (401b98 <Reset_Handler+0x98>)
  401b4e:	68fb      	ldr	r3, [r7, #12]
  401b50:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  401b54:	6093      	str	r3, [r2, #8]
 * \brief Enable FPU
 */
__always_inline static void fpu_enable(void)
{
	irqflags_t flags;
	flags = cpu_irq_save();
  401b56:	4b11      	ldr	r3, [pc, #68]	; (401b9c <Reset_Handler+0x9c>)
  401b58:	4798      	blx	r3
  401b5a:	6078      	str	r0, [r7, #4]
	REG_CPACR |=  (0xFu << 20);
  401b5c:	4a10      	ldr	r2, [pc, #64]	; (401ba0 <Reset_Handler+0xa0>)
  401b5e:	4b10      	ldr	r3, [pc, #64]	; (401ba0 <Reset_Handler+0xa0>)
  401b60:	681b      	ldr	r3, [r3, #0]
  401b62:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
  401b66:	6013      	str	r3, [r2, #0]
  __ASM volatile ("dsb 0xF":::"memory");
  401b68:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  401b6c:	f3bf 8f6f 	isb	sy
	__DSB();
	__ISB();
	cpu_irq_restore(flags);
  401b70:	6878      	ldr	r0, [r7, #4]
  401b72:	4b0c      	ldr	r3, [pc, #48]	; (401ba4 <Reset_Handler+0xa4>)
  401b74:	4798      	blx	r3
#if __FPU_USED
	fpu_enable();
#endif

	/* Initialize the C library */
	__libc_init_array();
  401b76:	4b0c      	ldr	r3, [pc, #48]	; (401ba8 <Reset_Handler+0xa8>)
  401b78:	4798      	blx	r3

	/* Branch to main function */
	main();
  401b7a:	4b0c      	ldr	r3, [pc, #48]	; (401bac <Reset_Handler+0xac>)
  401b7c:	4798      	blx	r3

	/* Infinite loop */
	while (1);
  401b7e:	e7fe      	b.n	401b7e <Reset_Handler+0x7e>
  401b80:	004039cc 	.word	0x004039cc
  401b84:	20000000 	.word	0x20000000
  401b88:	2000044c 	.word	0x2000044c
  401b8c:	20000450 	.word	0x20000450
  401b90:	2000a7e0 	.word	0x2000a7e0
  401b94:	00400000 	.word	0x00400000
  401b98:	e000ed00 	.word	0xe000ed00
  401b9c:	00401a79 	.word	0x00401a79
  401ba0:	e000ed88 	.word	0xe000ed88
  401ba4:	00401ad1 	.word	0x00401ad1
  401ba8:	00402fb1 	.word	0x00402fb1
  401bac:	00401db1 	.word	0x00401db1

00401bb0 <SystemCoreClockUpdate>:

	SystemCoreClock = CHIP_FREQ_CPU_MAX;
}

void SystemCoreClockUpdate( void )
{
  401bb0:	b480      	push	{r7}
  401bb2:	af00      	add	r7, sp, #0
	/* Determine clock frequency according to clock register values */
	switch (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) {
  401bb4:	4b52      	ldr	r3, [pc, #328]	; (401d00 <SystemCoreClockUpdate+0x150>)
  401bb6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  401bb8:	f003 0303 	and.w	r3, r3, #3
  401bbc:	2b01      	cmp	r3, #1
  401bbe:	d014      	beq.n	401bea <SystemCoreClockUpdate+0x3a>
  401bc0:	2b01      	cmp	r3, #1
  401bc2:	d302      	bcc.n	401bca <SystemCoreClockUpdate+0x1a>
  401bc4:	2b02      	cmp	r3, #2
  401bc6:	d038      	beq.n	401c3a <SystemCoreClockUpdate+0x8a>
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos));
		}
		break;

	default:
		break;
  401bc8:	e07a      	b.n	401cc0 <SystemCoreClockUpdate+0x110>
		if ( SUPC->SUPC_SR & SUPC_SR_OSCSEL ) {
  401bca:	4b4e      	ldr	r3, [pc, #312]	; (401d04 <SystemCoreClockUpdate+0x154>)
  401bcc:	695b      	ldr	r3, [r3, #20]
  401bce:	f003 0380 	and.w	r3, r3, #128	; 0x80
  401bd2:	2b00      	cmp	r3, #0
  401bd4:	d004      	beq.n	401be0 <SystemCoreClockUpdate+0x30>
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
  401bd6:	4b4c      	ldr	r3, [pc, #304]	; (401d08 <SystemCoreClockUpdate+0x158>)
  401bd8:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  401bdc:	601a      	str	r2, [r3, #0]
		break;
  401bde:	e06f      	b.n	401cc0 <SystemCoreClockUpdate+0x110>
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
  401be0:	4b49      	ldr	r3, [pc, #292]	; (401d08 <SystemCoreClockUpdate+0x158>)
  401be2:	f44f 42fa 	mov.w	r2, #32000	; 0x7d00
  401be6:	601a      	str	r2, [r3, #0]
		break;
  401be8:	e06a      	b.n	401cc0 <SystemCoreClockUpdate+0x110>
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  401bea:	4b45      	ldr	r3, [pc, #276]	; (401d00 <SystemCoreClockUpdate+0x150>)
  401bec:	6a1b      	ldr	r3, [r3, #32]
  401bee:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  401bf2:	2b00      	cmp	r3, #0
  401bf4:	d003      	beq.n	401bfe <SystemCoreClockUpdate+0x4e>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
  401bf6:	4b44      	ldr	r3, [pc, #272]	; (401d08 <SystemCoreClockUpdate+0x158>)
  401bf8:	4a44      	ldr	r2, [pc, #272]	; (401d0c <SystemCoreClockUpdate+0x15c>)
  401bfa:	601a      	str	r2, [r3, #0]
		break;
  401bfc:	e060      	b.n	401cc0 <SystemCoreClockUpdate+0x110>
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  401bfe:	4b42      	ldr	r3, [pc, #264]	; (401d08 <SystemCoreClockUpdate+0x158>)
  401c00:	4a43      	ldr	r2, [pc, #268]	; (401d10 <SystemCoreClockUpdate+0x160>)
  401c02:	601a      	str	r2, [r3, #0]
			switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  401c04:	4b3e      	ldr	r3, [pc, #248]	; (401d00 <SystemCoreClockUpdate+0x150>)
  401c06:	6a1b      	ldr	r3, [r3, #32]
  401c08:	f003 0370 	and.w	r3, r3, #112	; 0x70
  401c0c:	2b10      	cmp	r3, #16
  401c0e:	d004      	beq.n	401c1a <SystemCoreClockUpdate+0x6a>
  401c10:	2b20      	cmp	r3, #32
  401c12:	d008      	beq.n	401c26 <SystemCoreClockUpdate+0x76>
  401c14:	2b00      	cmp	r3, #0
  401c16:	d00e      	beq.n	401c36 <SystemCoreClockUpdate+0x86>
				break;
  401c18:	e00e      	b.n	401c38 <SystemCoreClockUpdate+0x88>
				SystemCoreClock *= 2U;
  401c1a:	4b3b      	ldr	r3, [pc, #236]	; (401d08 <SystemCoreClockUpdate+0x158>)
  401c1c:	681b      	ldr	r3, [r3, #0]
  401c1e:	005b      	lsls	r3, r3, #1
  401c20:	4a39      	ldr	r2, [pc, #228]	; (401d08 <SystemCoreClockUpdate+0x158>)
  401c22:	6013      	str	r3, [r2, #0]
				break;
  401c24:	e008      	b.n	401c38 <SystemCoreClockUpdate+0x88>
				SystemCoreClock *= 3U;
  401c26:	4b38      	ldr	r3, [pc, #224]	; (401d08 <SystemCoreClockUpdate+0x158>)
  401c28:	681a      	ldr	r2, [r3, #0]
  401c2a:	4613      	mov	r3, r2
  401c2c:	005b      	lsls	r3, r3, #1
  401c2e:	4413      	add	r3, r2
  401c30:	4a35      	ldr	r2, [pc, #212]	; (401d08 <SystemCoreClockUpdate+0x158>)
  401c32:	6013      	str	r3, [r2, #0]
				break;
  401c34:	e000      	b.n	401c38 <SystemCoreClockUpdate+0x88>
				break;
  401c36:	bf00      	nop
		break;
  401c38:	e042      	b.n	401cc0 <SystemCoreClockUpdate+0x110>
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  401c3a:	4b31      	ldr	r3, [pc, #196]	; (401d00 <SystemCoreClockUpdate+0x150>)
  401c3c:	6a1b      	ldr	r3, [r3, #32]
  401c3e:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  401c42:	2b00      	cmp	r3, #0
  401c44:	d003      	beq.n	401c4e <SystemCoreClockUpdate+0x9e>
			SystemCoreClock = CHIP_FREQ_XTAL_12M ;
  401c46:	4b30      	ldr	r3, [pc, #192]	; (401d08 <SystemCoreClockUpdate+0x158>)
  401c48:	4a30      	ldr	r2, [pc, #192]	; (401d0c <SystemCoreClockUpdate+0x15c>)
  401c4a:	601a      	str	r2, [r3, #0]
  401c4c:	e01c      	b.n	401c88 <SystemCoreClockUpdate+0xd8>
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  401c4e:	4b2e      	ldr	r3, [pc, #184]	; (401d08 <SystemCoreClockUpdate+0x158>)
  401c50:	4a2f      	ldr	r2, [pc, #188]	; (401d10 <SystemCoreClockUpdate+0x160>)
  401c52:	601a      	str	r2, [r3, #0]
			switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  401c54:	4b2a      	ldr	r3, [pc, #168]	; (401d00 <SystemCoreClockUpdate+0x150>)
  401c56:	6a1b      	ldr	r3, [r3, #32]
  401c58:	f003 0370 	and.w	r3, r3, #112	; 0x70
  401c5c:	2b10      	cmp	r3, #16
  401c5e:	d004      	beq.n	401c6a <SystemCoreClockUpdate+0xba>
  401c60:	2b20      	cmp	r3, #32
  401c62:	d008      	beq.n	401c76 <SystemCoreClockUpdate+0xc6>
  401c64:	2b00      	cmp	r3, #0
  401c66:	d00e      	beq.n	401c86 <SystemCoreClockUpdate+0xd6>
				break;
  401c68:	e00e      	b.n	401c88 <SystemCoreClockUpdate+0xd8>
				SystemCoreClock *= 2U;
  401c6a:	4b27      	ldr	r3, [pc, #156]	; (401d08 <SystemCoreClockUpdate+0x158>)
  401c6c:	681b      	ldr	r3, [r3, #0]
  401c6e:	005b      	lsls	r3, r3, #1
  401c70:	4a25      	ldr	r2, [pc, #148]	; (401d08 <SystemCoreClockUpdate+0x158>)
  401c72:	6013      	str	r3, [r2, #0]
				break;
  401c74:	e008      	b.n	401c88 <SystemCoreClockUpdate+0xd8>
				SystemCoreClock *= 3U;
  401c76:	4b24      	ldr	r3, [pc, #144]	; (401d08 <SystemCoreClockUpdate+0x158>)
  401c78:	681a      	ldr	r2, [r3, #0]
  401c7a:	4613      	mov	r3, r2
  401c7c:	005b      	lsls	r3, r3, #1
  401c7e:	4413      	add	r3, r2
  401c80:	4a21      	ldr	r2, [pc, #132]	; (401d08 <SystemCoreClockUpdate+0x158>)
  401c82:	6013      	str	r3, [r2, #0]
				break;
  401c84:	e000      	b.n	401c88 <SystemCoreClockUpdate+0xd8>
				break;
  401c86:	bf00      	nop
		if ((uint32_t) (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK)
  401c88:	4b1d      	ldr	r3, [pc, #116]	; (401d00 <SystemCoreClockUpdate+0x150>)
  401c8a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  401c8c:	f003 0303 	and.w	r3, r3, #3
  401c90:	2b02      	cmp	r3, #2
  401c92:	d114      	bne.n	401cbe <SystemCoreClockUpdate+0x10e>
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> CKGR_PLLAR_MULA_Pos) + 1U);
  401c94:	4b1a      	ldr	r3, [pc, #104]	; (401d00 <SystemCoreClockUpdate+0x150>)
  401c96:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  401c98:	0c1b      	lsrs	r3, r3, #16
  401c9a:	f3c3 030a 	ubfx	r3, r3, #0, #11
  401c9e:	3301      	adds	r3, #1
  401ca0:	4a19      	ldr	r2, [pc, #100]	; (401d08 <SystemCoreClockUpdate+0x158>)
  401ca2:	6812      	ldr	r2, [r2, #0]
  401ca4:	fb02 f303 	mul.w	r3, r2, r3
  401ca8:	4a17      	ldr	r2, [pc, #92]	; (401d08 <SystemCoreClockUpdate+0x158>)
  401caa:	6013      	str	r3, [r2, #0]
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos));
  401cac:	4b14      	ldr	r3, [pc, #80]	; (401d00 <SystemCoreClockUpdate+0x150>)
  401cae:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  401cb0:	b2db      	uxtb	r3, r3
  401cb2:	4a15      	ldr	r2, [pc, #84]	; (401d08 <SystemCoreClockUpdate+0x158>)
  401cb4:	6812      	ldr	r2, [r2, #0]
  401cb6:	fbb2 f3f3 	udiv	r3, r2, r3
  401cba:	4a13      	ldr	r2, [pc, #76]	; (401d08 <SystemCoreClockUpdate+0x158>)
  401cbc:	6013      	str	r3, [r2, #0]
		break;
  401cbe:	bf00      	nop
	}

	if ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3) {
  401cc0:	4b0f      	ldr	r3, [pc, #60]	; (401d00 <SystemCoreClockUpdate+0x150>)
  401cc2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  401cc4:	f003 0370 	and.w	r3, r3, #112	; 0x70
  401cc8:	2b70      	cmp	r3, #112	; 0x70
  401cca:	d108      	bne.n	401cde <SystemCoreClockUpdate+0x12e>
		SystemCoreClock /= 3U;
  401ccc:	4b0e      	ldr	r3, [pc, #56]	; (401d08 <SystemCoreClockUpdate+0x158>)
  401cce:	681b      	ldr	r3, [r3, #0]
  401cd0:	4a10      	ldr	r2, [pc, #64]	; (401d14 <SystemCoreClockUpdate+0x164>)
  401cd2:	fba2 2303 	umull	r2, r3, r2, r3
  401cd6:	085b      	lsrs	r3, r3, #1
  401cd8:	4a0b      	ldr	r2, [pc, #44]	; (401d08 <SystemCoreClockUpdate+0x158>)
  401cda:	6013      	str	r3, [r2, #0]
	} else {
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >>
				PMC_MCKR_PRES_Pos);
	}
}
  401cdc:	e00a      	b.n	401cf4 <SystemCoreClockUpdate+0x144>
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >>
  401cde:	4b08      	ldr	r3, [pc, #32]	; (401d00 <SystemCoreClockUpdate+0x150>)
  401ce0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  401ce2:	091b      	lsrs	r3, r3, #4
  401ce4:	f003 0307 	and.w	r3, r3, #7
  401ce8:	4a07      	ldr	r2, [pc, #28]	; (401d08 <SystemCoreClockUpdate+0x158>)
  401cea:	6812      	ldr	r2, [r2, #0]
  401cec:	fa22 f303 	lsr.w	r3, r2, r3
  401cf0:	4a05      	ldr	r2, [pc, #20]	; (401d08 <SystemCoreClockUpdate+0x158>)
  401cf2:	6013      	str	r3, [r2, #0]
}
  401cf4:	bf00      	nop
  401cf6:	46bd      	mov	sp, r7
  401cf8:	f85d 7b04 	ldr.w	r7, [sp], #4
  401cfc:	4770      	bx	lr
  401cfe:	bf00      	nop
  401d00:	400e0400 	.word	0x400e0400
  401d04:	400e1810 	.word	0x400e1810
  401d08:	2000001c 	.word	0x2000001c
  401d0c:	00b71b00 	.word	0x00b71b00
  401d10:	003d0900 	.word	0x003d0900
  401d14:	aaaaaaab 	.word	0xaaaaaaab

00401d18 <system_init_flash>:

/**
 * Initialize flash.
 */
void system_init_flash( uint32_t ul_clk )
{
  401d18:	b480      	push	{r7}
  401d1a:	b083      	sub	sp, #12
  401d1c:	af00      	add	r7, sp, #0
  401d1e:	6078      	str	r0, [r7, #4]
	/* Set FWS for embedded Flash access according to operating frequency */
	if ( ul_clk < CHIP_FREQ_FWS_0 ) {
  401d20:	687b      	ldr	r3, [r7, #4]
  401d22:	4a19      	ldr	r2, [pc, #100]	; (401d88 <system_init_flash+0x70>)
  401d24:	4293      	cmp	r3, r2
  401d26:	d804      	bhi.n	401d32 <system_init_flash+0x1a>
		EFC->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  401d28:	4b18      	ldr	r3, [pc, #96]	; (401d8c <system_init_flash+0x74>)
  401d2a:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
  401d2e:	601a      	str	r2, [r3, #0]
					}
				}
			}
		}
	}
}
  401d30:	e023      	b.n	401d7a <system_init_flash+0x62>
		if (ul_clk < CHIP_FREQ_FWS_1) {
  401d32:	687b      	ldr	r3, [r7, #4]
  401d34:	4a16      	ldr	r2, [pc, #88]	; (401d90 <system_init_flash+0x78>)
  401d36:	4293      	cmp	r3, r2
  401d38:	d803      	bhi.n	401d42 <system_init_flash+0x2a>
			EFC->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
  401d3a:	4b14      	ldr	r3, [pc, #80]	; (401d8c <system_init_flash+0x74>)
  401d3c:	4a15      	ldr	r2, [pc, #84]	; (401d94 <system_init_flash+0x7c>)
  401d3e:	601a      	str	r2, [r3, #0]
}
  401d40:	e01b      	b.n	401d7a <system_init_flash+0x62>
			if (ul_clk < CHIP_FREQ_FWS_2) {
  401d42:	687b      	ldr	r3, [r7, #4]
  401d44:	4a14      	ldr	r2, [pc, #80]	; (401d98 <system_init_flash+0x80>)
  401d46:	4293      	cmp	r3, r2
  401d48:	d803      	bhi.n	401d52 <system_init_flash+0x3a>
				EFC->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
  401d4a:	4b10      	ldr	r3, [pc, #64]	; (401d8c <system_init_flash+0x74>)
  401d4c:	4a13      	ldr	r2, [pc, #76]	; (401d9c <system_init_flash+0x84>)
  401d4e:	601a      	str	r2, [r3, #0]
}
  401d50:	e013      	b.n	401d7a <system_init_flash+0x62>
				if ( ul_clk < CHIP_FREQ_FWS_3 ) {
  401d52:	687b      	ldr	r3, [r7, #4]
  401d54:	4a12      	ldr	r2, [pc, #72]	; (401da0 <system_init_flash+0x88>)
  401d56:	4293      	cmp	r3, r2
  401d58:	d803      	bhi.n	401d62 <system_init_flash+0x4a>
					EFC->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
  401d5a:	4b0c      	ldr	r3, [pc, #48]	; (401d8c <system_init_flash+0x74>)
  401d5c:	4a11      	ldr	r2, [pc, #68]	; (401da4 <system_init_flash+0x8c>)
  401d5e:	601a      	str	r2, [r3, #0]
}
  401d60:	e00b      	b.n	401d7a <system_init_flash+0x62>
					if ( ul_clk < CHIP_FREQ_FWS_4 ) {
  401d62:	687b      	ldr	r3, [r7, #4]
  401d64:	4a10      	ldr	r2, [pc, #64]	; (401da8 <system_init_flash+0x90>)
  401d66:	4293      	cmp	r3, r2
  401d68:	d804      	bhi.n	401d74 <system_init_flash+0x5c>
						EFC->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  401d6a:	4b08      	ldr	r3, [pc, #32]	; (401d8c <system_init_flash+0x74>)
  401d6c:	f04f 2204 	mov.w	r2, #67109888	; 0x4000400
  401d70:	601a      	str	r2, [r3, #0]
}
  401d72:	e002      	b.n	401d7a <system_init_flash+0x62>
						EFC->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  401d74:	4b05      	ldr	r3, [pc, #20]	; (401d8c <system_init_flash+0x74>)
  401d76:	4a0d      	ldr	r2, [pc, #52]	; (401dac <system_init_flash+0x94>)
  401d78:	601a      	str	r2, [r3, #0]
}
  401d7a:	bf00      	nop
  401d7c:	370c      	adds	r7, #12
  401d7e:	46bd      	mov	sp, r7
  401d80:	f85d 7b04 	ldr.w	r7, [sp], #4
  401d84:	4770      	bx	lr
  401d86:	bf00      	nop
  401d88:	01312cff 	.word	0x01312cff
  401d8c:	400e0a00 	.word	0x400e0a00
  401d90:	026259ff 	.word	0x026259ff
  401d94:	04000100 	.word	0x04000100
  401d98:	039386ff 	.word	0x039386ff
  401d9c:	04000200 	.word	0x04000200
  401da0:	04c4b3ff 	.word	0x04c4b3ff
  401da4:	04000300 	.word	0x04000300
  401da8:	05f5e0ff 	.word	0x05f5e0ff
  401dac:	04000500 	.word	0x04000500

00401db0 <main>:
/* Function definitions ----------------------------------------------- */
/**
 * @brief Entry
 */
int main(void)
{
  401db0:	b580      	push	{r7, lr}
  401db2:	af00      	add	r7, sp, #0
  sys_init();
  401db4:	4b02      	ldr	r3, [pc, #8]	; (401dc0 <main+0x10>)
  401db6:	4798      	blx	r3
  401db8:	2300      	movs	r3, #0
}
  401dba:	4618      	mov	r0, r3
  401dbc:	bd80      	pop	{r7, pc}
  401dbe:	bf00      	nop
  401dc0:	00401561 	.word	0x00401561

00401dc4 <osc_enable>:
{
  401dc4:	b580      	push	{r7, lr}
  401dc6:	b082      	sub	sp, #8
  401dc8:	af00      	add	r7, sp, #0
  401dca:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  401dcc:	687b      	ldr	r3, [r7, #4]
  401dce:	2b07      	cmp	r3, #7
  401dd0:	d831      	bhi.n	401e36 <osc_enable+0x72>
  401dd2:	a201      	add	r2, pc, #4	; (adr r2, 401dd8 <osc_enable+0x14>)
  401dd4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  401dd8:	00401e35 	.word	0x00401e35
  401ddc:	00401df9 	.word	0x00401df9
  401de0:	00401e01 	.word	0x00401e01
  401de4:	00401e09 	.word	0x00401e09
  401de8:	00401e11 	.word	0x00401e11
  401dec:	00401e19 	.word	0x00401e19
  401df0:	00401e21 	.word	0x00401e21
  401df4:	00401e2b 	.word	0x00401e2b
		pmc_switch_sclk_to_32kxtal(PMC_OSC_XTAL);
  401df8:	2000      	movs	r0, #0
  401dfa:	4b11      	ldr	r3, [pc, #68]	; (401e40 <osc_enable+0x7c>)
  401dfc:	4798      	blx	r3
		break;
  401dfe:	e01a      	b.n	401e36 <osc_enable+0x72>
		pmc_switch_sclk_to_32kxtal(PMC_OSC_BYPASS);
  401e00:	2001      	movs	r0, #1
  401e02:	4b0f      	ldr	r3, [pc, #60]	; (401e40 <osc_enable+0x7c>)
  401e04:	4798      	blx	r3
		break;
  401e06:	e016      	b.n	401e36 <osc_enable+0x72>
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_4_MHz);
  401e08:	2000      	movs	r0, #0
  401e0a:	4b0e      	ldr	r3, [pc, #56]	; (401e44 <osc_enable+0x80>)
  401e0c:	4798      	blx	r3
		break;
  401e0e:	e012      	b.n	401e36 <osc_enable+0x72>
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_8_MHz);
  401e10:	2010      	movs	r0, #16
  401e12:	4b0c      	ldr	r3, [pc, #48]	; (401e44 <osc_enable+0x80>)
  401e14:	4798      	blx	r3
		break;
  401e16:	e00e      	b.n	401e36 <osc_enable+0x72>
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_12_MHz);
  401e18:	2020      	movs	r0, #32
  401e1a:	4b0a      	ldr	r3, [pc, #40]	; (401e44 <osc_enable+0x80>)
  401e1c:	4798      	blx	r3
		break;
  401e1e:	e00a      	b.n	401e36 <osc_enable+0x72>
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL,
  401e20:	213e      	movs	r1, #62	; 0x3e
  401e22:	2000      	movs	r0, #0
  401e24:	4b08      	ldr	r3, [pc, #32]	; (401e48 <osc_enable+0x84>)
  401e26:	4798      	blx	r3
		break;
  401e28:	e005      	b.n	401e36 <osc_enable+0x72>
		pmc_switch_mainck_to_xtal(PMC_OSC_BYPASS,
  401e2a:	213e      	movs	r1, #62	; 0x3e
  401e2c:	2001      	movs	r0, #1
  401e2e:	4b06      	ldr	r3, [pc, #24]	; (401e48 <osc_enable+0x84>)
  401e30:	4798      	blx	r3
		break;
  401e32:	e000      	b.n	401e36 <osc_enable+0x72>
		break;
  401e34:	bf00      	nop
}
  401e36:	bf00      	nop
  401e38:	3708      	adds	r7, #8
  401e3a:	46bd      	mov	sp, r7
  401e3c:	bd80      	pop	{r7, pc}
  401e3e:	bf00      	nop
  401e40:	0040279d 	.word	0x0040279d
  401e44:	00402809 	.word	0x00402809
  401e48:	00402879 	.word	0x00402879

00401e4c <osc_is_ready>:
{
  401e4c:	b580      	push	{r7, lr}
  401e4e:	b082      	sub	sp, #8
  401e50:	af00      	add	r7, sp, #0
  401e52:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  401e54:	687b      	ldr	r3, [r7, #4]
  401e56:	2b07      	cmp	r3, #7
  401e58:	d826      	bhi.n	401ea8 <osc_is_ready+0x5c>
  401e5a:	a201      	add	r2, pc, #4	; (adr r2, 401e60 <osc_is_ready+0x14>)
  401e5c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  401e60:	00401e81 	.word	0x00401e81
  401e64:	00401e85 	.word	0x00401e85
  401e68:	00401e85 	.word	0x00401e85
  401e6c:	00401e97 	.word	0x00401e97
  401e70:	00401e97 	.word	0x00401e97
  401e74:	00401e97 	.word	0x00401e97
  401e78:	00401e97 	.word	0x00401e97
  401e7c:	00401e97 	.word	0x00401e97
		return 1;
  401e80:	2301      	movs	r3, #1
  401e82:	e012      	b.n	401eaa <osc_is_ready+0x5e>
		return pmc_osc_is_ready_32kxtal();
  401e84:	4b0b      	ldr	r3, [pc, #44]	; (401eb4 <osc_is_ready+0x68>)
  401e86:	4798      	blx	r3
  401e88:	4603      	mov	r3, r0
  401e8a:	2b00      	cmp	r3, #0
  401e8c:	bf14      	ite	ne
  401e8e:	2301      	movne	r3, #1
  401e90:	2300      	moveq	r3, #0
  401e92:	b2db      	uxtb	r3, r3
  401e94:	e009      	b.n	401eaa <osc_is_ready+0x5e>
		return pmc_osc_is_ready_mainck();
  401e96:	4b08      	ldr	r3, [pc, #32]	; (401eb8 <osc_is_ready+0x6c>)
  401e98:	4798      	blx	r3
  401e9a:	4603      	mov	r3, r0
  401e9c:	2b00      	cmp	r3, #0
  401e9e:	bf14      	ite	ne
  401ea0:	2301      	movne	r3, #1
  401ea2:	2300      	moveq	r3, #0
  401ea4:	b2db      	uxtb	r3, r3
  401ea6:	e000      	b.n	401eaa <osc_is_ready+0x5e>
	return 0;
  401ea8:	2300      	movs	r3, #0
}
  401eaa:	4618      	mov	r0, r3
  401eac:	3708      	adds	r7, #8
  401eae:	46bd      	mov	sp, r7
  401eb0:	bd80      	pop	{r7, pc}
  401eb2:	bf00      	nop
  401eb4:	004027d5 	.word	0x004027d5
  401eb8:	004028f1 	.word	0x004028f1

00401ebc <osc_get_rate>:
{
  401ebc:	b480      	push	{r7}
  401ebe:	b083      	sub	sp, #12
  401ec0:	af00      	add	r7, sp, #0
  401ec2:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  401ec4:	687b      	ldr	r3, [r7, #4]
  401ec6:	2b07      	cmp	r3, #7
  401ec8:	d825      	bhi.n	401f16 <osc_get_rate+0x5a>
  401eca:	a201      	add	r2, pc, #4	; (adr r2, 401ed0 <osc_get_rate+0x14>)
  401ecc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  401ed0:	00401ef1 	.word	0x00401ef1
  401ed4:	00401ef7 	.word	0x00401ef7
  401ed8:	00401efd 	.word	0x00401efd
  401edc:	00401f03 	.word	0x00401f03
  401ee0:	00401f07 	.word	0x00401f07
  401ee4:	00401f0b 	.word	0x00401f0b
  401ee8:	00401f0f 	.word	0x00401f0f
  401eec:	00401f13 	.word	0x00401f13
		return OSC_SLCK_32K_RC_HZ;
  401ef0:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  401ef4:	e010      	b.n	401f18 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_XTAL;
  401ef6:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  401efa:	e00d      	b.n	401f18 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_BYPASS;
  401efc:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  401f00:	e00a      	b.n	401f18 <osc_get_rate+0x5c>
		return OSC_MAINCK_4M_RC_HZ;
  401f02:	4b08      	ldr	r3, [pc, #32]	; (401f24 <osc_get_rate+0x68>)
  401f04:	e008      	b.n	401f18 <osc_get_rate+0x5c>
		return OSC_MAINCK_8M_RC_HZ;
  401f06:	4b08      	ldr	r3, [pc, #32]	; (401f28 <osc_get_rate+0x6c>)
  401f08:	e006      	b.n	401f18 <osc_get_rate+0x5c>
		return OSC_MAINCK_12M_RC_HZ;
  401f0a:	4b08      	ldr	r3, [pc, #32]	; (401f2c <osc_get_rate+0x70>)
  401f0c:	e004      	b.n	401f18 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_XTAL;
  401f0e:	4b07      	ldr	r3, [pc, #28]	; (401f2c <osc_get_rate+0x70>)
  401f10:	e002      	b.n	401f18 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_BYPASS;
  401f12:	4b06      	ldr	r3, [pc, #24]	; (401f2c <osc_get_rate+0x70>)
  401f14:	e000      	b.n	401f18 <osc_get_rate+0x5c>
	return 0;
  401f16:	2300      	movs	r3, #0
}
  401f18:	4618      	mov	r0, r3
  401f1a:	370c      	adds	r7, #12
  401f1c:	46bd      	mov	sp, r7
  401f1e:	f85d 7b04 	ldr.w	r7, [sp], #4
  401f22:	4770      	bx	lr
  401f24:	003d0900 	.word	0x003d0900
  401f28:	007a1200 	.word	0x007a1200
  401f2c:	00b71b00 	.word	0x00b71b00

00401f30 <osc_wait_ready>:
 * to become stable and ready to use as a clock source.
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
  401f30:	b580      	push	{r7, lr}
  401f32:	b082      	sub	sp, #8
  401f34:	af00      	add	r7, sp, #0
  401f36:	4603      	mov	r3, r0
  401f38:	71fb      	strb	r3, [r7, #7]
	while (!osc_is_ready(id)) {
  401f3a:	bf00      	nop
  401f3c:	79fb      	ldrb	r3, [r7, #7]
  401f3e:	4618      	mov	r0, r3
  401f40:	4b05      	ldr	r3, [pc, #20]	; (401f58 <osc_wait_ready+0x28>)
  401f42:	4798      	blx	r3
  401f44:	4603      	mov	r3, r0
  401f46:	f083 0301 	eor.w	r3, r3, #1
  401f4a:	b2db      	uxtb	r3, r3
  401f4c:	2b00      	cmp	r3, #0
  401f4e:	d1f5      	bne.n	401f3c <osc_wait_ready+0xc>
		/* Do nothing */
	}
}
  401f50:	bf00      	nop
  401f52:	3708      	adds	r7, #8
  401f54:	46bd      	mov	sp, r7
  401f56:	bd80      	pop	{r7, pc}
  401f58:	00401e4d 	.word	0x00401e4d

00401f5c <pll_config_init>:
 * hardware mul+1 is hidden in this implementation. Use mul as mul effective
 * value.
 */
static inline void pll_config_init(struct pll_config *p_cfg,
		enum pll_source e_src, uint32_t ul_div, uint32_t ul_mul)
{
  401f5c:	b580      	push	{r7, lr}
  401f5e:	b086      	sub	sp, #24
  401f60:	af00      	add	r7, sp, #0
  401f62:	60f8      	str	r0, [r7, #12]
  401f64:	607a      	str	r2, [r7, #4]
  401f66:	603b      	str	r3, [r7, #0]
  401f68:	460b      	mov	r3, r1
  401f6a:	72fb      	strb	r3, [r7, #11]
	uint32_t vco_hz;

	Assert(e_src < PLL_NR_SOURCES);

	/* Calculate internal VCO frequency */
	vco_hz = osc_get_rate(e_src) / ul_div;
  401f6c:	7afb      	ldrb	r3, [r7, #11]
  401f6e:	4618      	mov	r0, r3
  401f70:	4b0d      	ldr	r3, [pc, #52]	; (401fa8 <pll_config_init+0x4c>)
  401f72:	4798      	blx	r3
  401f74:	4602      	mov	r2, r0
  401f76:	687b      	ldr	r3, [r7, #4]
  401f78:	fbb2 f3f3 	udiv	r3, r2, r3
  401f7c:	617b      	str	r3, [r7, #20]
	Assert(vco_hz >= PLL_INPUT_MIN_HZ);
	Assert(vco_hz <= PLL_INPUT_MAX_HZ);

	vco_hz *= ul_mul;
  401f7e:	697b      	ldr	r3, [r7, #20]
  401f80:	683a      	ldr	r2, [r7, #0]
  401f82:	fb02 f303 	mul.w	r3, r2, r3
  401f86:	617b      	str	r3, [r7, #20]
	Assert(vco_hz >= PLL_OUTPUT_MIN_HZ);
	Assert(vco_hz <= PLL_OUTPUT_MAX_HZ);

	/* PMC hardware will automatically make it mul+1 */
	p_cfg->ctrl = CKGR_PLLAR_MULA(ul_mul - 1) | CKGR_PLLAR_DIVA(ul_div) | \
  401f88:	683b      	ldr	r3, [r7, #0]
  401f8a:	3b01      	subs	r3, #1
  401f8c:	041a      	lsls	r2, r3, #16
  401f8e:	4b07      	ldr	r3, [pc, #28]	; (401fac <pll_config_init+0x50>)
  401f90:	4013      	ands	r3, r2
  401f92:	687a      	ldr	r2, [r7, #4]
  401f94:	b2d2      	uxtb	r2, r2
  401f96:	4313      	orrs	r3, r2
  401f98:	f443 527c 	orr.w	r2, r3, #16128	; 0x3f00
  401f9c:	68fb      	ldr	r3, [r7, #12]
  401f9e:	601a      	str	r2, [r3, #0]
			CKGR_PLLAR_PLLACOUNT(PLL_COUNT);
}
  401fa0:	bf00      	nop
  401fa2:	3718      	adds	r7, #24
  401fa4:	46bd      	mov	sp, r7
  401fa6:	bd80      	pop	{r7, pc}
  401fa8:	00401ebd 	.word	0x00401ebd
  401fac:	07ff0000 	.word	0x07ff0000

00401fb0 <pll_enable>:
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
	}
}

static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
  401fb0:	b580      	push	{r7, lr}
  401fb2:	b082      	sub	sp, #8
  401fb4:	af00      	add	r7, sp, #0
  401fb6:	6078      	str	r0, [r7, #4]
  401fb8:	6039      	str	r1, [r7, #0]
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
  401fba:	683b      	ldr	r3, [r7, #0]
  401fbc:	2b00      	cmp	r3, #0
  401fbe:	d107      	bne.n	401fd0 <pll_enable+0x20>
		pmc_disable_pllack(); // Always stop PLL first!
  401fc0:	4b05      	ldr	r3, [pc, #20]	; (401fd8 <pll_enable+0x28>)
  401fc2:	4798      	blx	r3
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
  401fc4:	4a05      	ldr	r2, [pc, #20]	; (401fdc <pll_enable+0x2c>)
  401fc6:	687b      	ldr	r3, [r7, #4]
  401fc8:	681b      	ldr	r3, [r3, #0]
  401fca:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
  401fce:	6293      	str	r3, [r2, #40]	; 0x28
	}
}
  401fd0:	bf00      	nop
  401fd2:	3708      	adds	r7, #8
  401fd4:	46bd      	mov	sp, r7
  401fd6:	bd80      	pop	{r7, pc}
  401fd8:	0040290d 	.word	0x0040290d
  401fdc:	400e0400 	.word	0x400e0400

00401fe0 <pll_is_locked>:
		pmc_disable_pllack();
	}
}

static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
  401fe0:	b580      	push	{r7, lr}
  401fe2:	b082      	sub	sp, #8
  401fe4:	af00      	add	r7, sp, #0
  401fe6:	6078      	str	r0, [r7, #4]
	Assert(ul_pll_id < NR_PLLS);

	UNUSED(ul_pll_id);
	return pmc_is_locked_pllack();
  401fe8:	4b03      	ldr	r3, [pc, #12]	; (401ff8 <pll_is_locked+0x18>)
  401fea:	4798      	blx	r3
  401fec:	4603      	mov	r3, r0
}
  401fee:	4618      	mov	r0, r3
  401ff0:	3708      	adds	r7, #8
  401ff2:	46bd      	mov	sp, r7
  401ff4:	bd80      	pop	{r7, pc}
  401ff6:	bf00      	nop
  401ff8:	00402929 	.word	0x00402929

00401ffc <pll_enable_source>:

static inline void pll_enable_source(enum pll_source e_src)
{
  401ffc:	b580      	push	{r7, lr}
  401ffe:	b082      	sub	sp, #8
  402000:	af00      	add	r7, sp, #0
  402002:	4603      	mov	r3, r0
  402004:	71fb      	strb	r3, [r7, #7]
	switch (e_src) {
  402006:	79fb      	ldrb	r3, [r7, #7]
  402008:	3b03      	subs	r3, #3
  40200a:	2b04      	cmp	r3, #4
  40200c:	d808      	bhi.n	402020 <pll_enable_source+0x24>
	case PLL_SRC_MAINCK_4M_RC:
	case PLL_SRC_MAINCK_8M_RC:
	case PLL_SRC_MAINCK_12M_RC:
	case PLL_SRC_MAINCK_XTAL:
	case PLL_SRC_MAINCK_BYPASS:
		osc_enable(e_src);
  40200e:	79fb      	ldrb	r3, [r7, #7]
  402010:	4618      	mov	r0, r3
  402012:	4b06      	ldr	r3, [pc, #24]	; (40202c <pll_enable_source+0x30>)
  402014:	4798      	blx	r3
		osc_wait_ready(e_src);
  402016:	79fb      	ldrb	r3, [r7, #7]
  402018:	4618      	mov	r0, r3
  40201a:	4b05      	ldr	r3, [pc, #20]	; (402030 <pll_enable_source+0x34>)
  40201c:	4798      	blx	r3
		break;
  40201e:	e000      	b.n	402022 <pll_enable_source+0x26>

	default:
		Assert(false);
		break;
  402020:	bf00      	nop
	}
}
  402022:	bf00      	nop
  402024:	3708      	adds	r7, #8
  402026:	46bd      	mov	sp, r7
  402028:	bd80      	pop	{r7, pc}
  40202a:	bf00      	nop
  40202c:	00401dc5 	.word	0x00401dc5
  402030:	00401f31 	.word	0x00401f31

00402034 <pll_wait_for_lock>:
 *
 * \retval STATUS_OK The PLL is now locked.
 * \retval ERR_TIMEOUT Timed out waiting for PLL to become locked.
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
  402034:	b580      	push	{r7, lr}
  402036:	b082      	sub	sp, #8
  402038:	af00      	add	r7, sp, #0
  40203a:	6078      	str	r0, [r7, #4]
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  40203c:	bf00      	nop
  40203e:	6878      	ldr	r0, [r7, #4]
  402040:	4b04      	ldr	r3, [pc, #16]	; (402054 <pll_wait_for_lock+0x20>)
  402042:	4798      	blx	r3
  402044:	4603      	mov	r3, r0
  402046:	2b00      	cmp	r3, #0
  402048:	d0f9      	beq.n	40203e <pll_wait_for_lock+0xa>
		/* Do nothing */
	}

	return 0;
  40204a:	2300      	movs	r3, #0
}
  40204c:	4618      	mov	r0, r3
  40204e:	3708      	adds	r7, #8
  402050:	46bd      	mov	sp, r7
  402052:	bd80      	pop	{r7, pc}
  402054:	00401fe1 	.word	0x00401fe1

00402058 <sysclk_get_main_hz>:
{
  402058:	b580      	push	{r7, lr}
  40205a:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  40205c:	2006      	movs	r0, #6
  40205e:	4b03      	ldr	r3, [pc, #12]	; (40206c <sysclk_get_main_hz+0x14>)
  402060:	4798      	blx	r3
  402062:	4603      	mov	r3, r0
  402064:	011b      	lsls	r3, r3, #4
}
  402066:	4618      	mov	r0, r3
  402068:	bd80      	pop	{r7, pc}
  40206a:	bf00      	nop
  40206c:	00401ebd 	.word	0x00401ebd

00402070 <sysclk_get_cpu_hz>:
{
  402070:	b580      	push	{r7, lr}
  402072:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  402074:	4b02      	ldr	r3, [pc, #8]	; (402080 <sysclk_get_cpu_hz+0x10>)
  402076:	4798      	blx	r3
  402078:	4603      	mov	r3, r0
  40207a:	085b      	lsrs	r3, r3, #1
}
  40207c:	4618      	mov	r0, r3
  40207e:	bd80      	pop	{r7, pc}
  402080:	00402059 	.word	0x00402059

00402084 <sysclk_init>:
	pmc_disable_udpck();
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
  402084:	b590      	push	{r4, r7, lr}
  402086:	b083      	sub	sp, #12
  402088:	af00      	add	r7, sp, #0
	/* Set flash wait state to max in case the below clock switching. */
	system_init_flash(CHIP_FREQ_CPU_MAX);
  40208a:	4811      	ldr	r0, [pc, #68]	; (4020d0 <sysclk_init+0x4c>)
  40208c:	4b11      	ldr	r3, [pc, #68]	; (4020d4 <sysclk_init+0x50>)
  40208e:	4798      	blx	r3

#ifdef CONFIG_PLL0_SOURCE
	else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_PLLACK) {
		struct pll_config pllcfg;

		pll_enable_source(CONFIG_PLL0_SOURCE);
  402090:	2006      	movs	r0, #6
  402092:	4b11      	ldr	r3, [pc, #68]	; (4020d8 <sysclk_init+0x54>)
  402094:	4798      	blx	r3
		pll_config_defaults(&pllcfg, 0);
  402096:	1d38      	adds	r0, r7, #4
  402098:	2310      	movs	r3, #16
  40209a:	2201      	movs	r2, #1
  40209c:	2106      	movs	r1, #6
  40209e:	4c0f      	ldr	r4, [pc, #60]	; (4020dc <sysclk_init+0x58>)
  4020a0:	47a0      	blx	r4
		pll_enable(&pllcfg, 0);
  4020a2:	1d3b      	adds	r3, r7, #4
  4020a4:	2100      	movs	r1, #0
  4020a6:	4618      	mov	r0, r3
  4020a8:	4b0d      	ldr	r3, [pc, #52]	; (4020e0 <sysclk_init+0x5c>)
  4020aa:	4798      	blx	r3
		pll_wait_for_lock(0);
  4020ac:	2000      	movs	r0, #0
  4020ae:	4b0d      	ldr	r3, [pc, #52]	; (4020e4 <sysclk_init+0x60>)
  4020b0:	4798      	blx	r3
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  4020b2:	2010      	movs	r0, #16
  4020b4:	4b0c      	ldr	r3, [pc, #48]	; (4020e8 <sysclk_init+0x64>)
  4020b6:	4798      	blx	r3
	}
#endif

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  4020b8:	4b0c      	ldr	r3, [pc, #48]	; (4020ec <sysclk_init+0x68>)
  4020ba:	4798      	blx	r3

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  4020bc:	4b0c      	ldr	r3, [pc, #48]	; (4020f0 <sysclk_init+0x6c>)
  4020be:	4798      	blx	r3
  4020c0:	4603      	mov	r3, r0
  4020c2:	4618      	mov	r0, r3
  4020c4:	4b03      	ldr	r3, [pc, #12]	; (4020d4 <sysclk_init+0x50>)
  4020c6:	4798      	blx	r3

#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
	/* Signal that the internal frequencies are setup */
	sysclk_initialized = 1;
#endif
}
  4020c8:	bf00      	nop
  4020ca:	370c      	adds	r7, #12
  4020cc:	46bd      	mov	sp, r7
  4020ce:	bd90      	pop	{r4, r7, pc}
  4020d0:	07270e00 	.word	0x07270e00
  4020d4:	00401d19 	.word	0x00401d19
  4020d8:	00401ffd 	.word	0x00401ffd
  4020dc:	00401f5d 	.word	0x00401f5d
  4020e0:	00401fb1 	.word	0x00401fb1
  4020e4:	00402035 	.word	0x00402035
  4020e8:	00402719 	.word	0x00402719
  4020ec:	00401bb1 	.word	0x00401bb1
  4020f0:	00402071 	.word	0x00402071

004020f4 <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  4020f4:	b580      	push	{r7, lr}
  4020f6:	b084      	sub	sp, #16
  4020f8:	af00      	add	r7, sp, #0
  4020fa:	6078      	str	r0, [r7, #4]
  4020fc:	6039      	str	r1, [r7, #0]
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  4020fe:	6878      	ldr	r0, [r7, #4]
  402100:	4b2c      	ldr	r3, [pc, #176]	; (4021b4 <pio_handler_process+0xc0>)
  402102:	4798      	blx	r3
  402104:	60f8      	str	r0, [r7, #12]
	status &= pio_get_interrupt_mask(p_pio);
  402106:	6878      	ldr	r0, [r7, #4]
  402108:	4b2b      	ldr	r3, [pc, #172]	; (4021b8 <pio_handler_process+0xc4>)
  40210a:	4798      	blx	r3
  40210c:	4602      	mov	r2, r0
  40210e:	68fb      	ldr	r3, [r7, #12]
  402110:	4013      	ands	r3, r2
  402112:	60fb      	str	r3, [r7, #12]

	/* Check pending events */
	if (status != 0) {
  402114:	68fb      	ldr	r3, [r7, #12]
  402116:	2b00      	cmp	r3, #0
  402118:	d03c      	beq.n	402194 <pio_handler_process+0xa0>
		/* Find triggering source */
		i = 0;
  40211a:	2300      	movs	r3, #0
  40211c:	60bb      	str	r3, [r7, #8]
		while (status != 0) {
  40211e:	e034      	b.n	40218a <pio_handler_process+0x96>
			/* Source is configured on the same controller */
			if (gs_interrupt_sources[i].id == ul_id) {
  402120:	4a26      	ldr	r2, [pc, #152]	; (4021bc <pio_handler_process+0xc8>)
  402122:	68bb      	ldr	r3, [r7, #8]
  402124:	011b      	lsls	r3, r3, #4
  402126:	4413      	add	r3, r2
  402128:	681a      	ldr	r2, [r3, #0]
  40212a:	683b      	ldr	r3, [r7, #0]
  40212c:	429a      	cmp	r2, r3
  40212e:	d126      	bne.n	40217e <pio_handler_process+0x8a>
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
  402130:	4a22      	ldr	r2, [pc, #136]	; (4021bc <pio_handler_process+0xc8>)
  402132:	68bb      	ldr	r3, [r7, #8]
  402134:	011b      	lsls	r3, r3, #4
  402136:	4413      	add	r3, r2
  402138:	3304      	adds	r3, #4
  40213a:	681a      	ldr	r2, [r3, #0]
  40213c:	68fb      	ldr	r3, [r7, #12]
  40213e:	4013      	ands	r3, r2
  402140:	2b00      	cmp	r3, #0
  402142:	d01c      	beq.n	40217e <pio_handler_process+0x8a>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
  402144:	4a1d      	ldr	r2, [pc, #116]	; (4021bc <pio_handler_process+0xc8>)
  402146:	68bb      	ldr	r3, [r7, #8]
  402148:	011b      	lsls	r3, r3, #4
  40214a:	4413      	add	r3, r2
  40214c:	330c      	adds	r3, #12
  40214e:	681b      	ldr	r3, [r3, #0]
  402150:	491a      	ldr	r1, [pc, #104]	; (4021bc <pio_handler_process+0xc8>)
  402152:	68ba      	ldr	r2, [r7, #8]
  402154:	0112      	lsls	r2, r2, #4
  402156:	440a      	add	r2, r1
  402158:	6810      	ldr	r0, [r2, #0]
  40215a:	4918      	ldr	r1, [pc, #96]	; (4021bc <pio_handler_process+0xc8>)
  40215c:	68ba      	ldr	r2, [r7, #8]
  40215e:	0112      	lsls	r2, r2, #4
  402160:	440a      	add	r2, r1
  402162:	3204      	adds	r2, #4
  402164:	6812      	ldr	r2, [r2, #0]
  402166:	4611      	mov	r1, r2
  402168:	4798      	blx	r3
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
  40216a:	4a14      	ldr	r2, [pc, #80]	; (4021bc <pio_handler_process+0xc8>)
  40216c:	68bb      	ldr	r3, [r7, #8]
  40216e:	011b      	lsls	r3, r3, #4
  402170:	4413      	add	r3, r2
  402172:	3304      	adds	r3, #4
  402174:	681b      	ldr	r3, [r3, #0]
  402176:	43db      	mvns	r3, r3
  402178:	68fa      	ldr	r2, [r7, #12]
  40217a:	4013      	ands	r3, r2
  40217c:	60fb      	str	r3, [r7, #12]
				}
			}
			i++;
  40217e:	68bb      	ldr	r3, [r7, #8]
  402180:	3301      	adds	r3, #1
  402182:	60bb      	str	r3, [r7, #8]
			if (i >= MAX_INTERRUPT_SOURCES) {
  402184:	68bb      	ldr	r3, [r7, #8]
  402186:	2b06      	cmp	r3, #6
  402188:	d803      	bhi.n	402192 <pio_handler_process+0x9e>
		while (status != 0) {
  40218a:	68fb      	ldr	r3, [r7, #12]
  40218c:	2b00      	cmp	r3, #0
  40218e:	d1c7      	bne.n	402120 <pio_handler_process+0x2c>
  402190:	e000      	b.n	402194 <pio_handler_process+0xa0>
				break;
  402192:	bf00      	nop
		}
	}

	/* Check capture events */
#if (SAM3S || SAM4S || SAM4E)
	if (pio_capture_enable_flag) {
  402194:	4b0a      	ldr	r3, [pc, #40]	; (4021c0 <pio_handler_process+0xcc>)
  402196:	681b      	ldr	r3, [r3, #0]
  402198:	2b00      	cmp	r3, #0
  40219a:	d007      	beq.n	4021ac <pio_handler_process+0xb8>
		if (pio_capture_handler) {
  40219c:	4b09      	ldr	r3, [pc, #36]	; (4021c4 <pio_handler_process+0xd0>)
  40219e:	681b      	ldr	r3, [r3, #0]
  4021a0:	2b00      	cmp	r3, #0
  4021a2:	d003      	beq.n	4021ac <pio_handler_process+0xb8>
			pio_capture_handler(p_pio);
  4021a4:	4b07      	ldr	r3, [pc, #28]	; (4021c4 <pio_handler_process+0xd0>)
  4021a6:	681b      	ldr	r3, [r3, #0]
  4021a8:	6878      	ldr	r0, [r7, #4]
  4021aa:	4798      	blx	r3
		}
	}
#endif
}
  4021ac:	bf00      	nop
  4021ae:	3710      	adds	r7, #16
  4021b0:	46bd      	mov	sp, r7
  4021b2:	bd80      	pop	{r7, pc}
  4021b4:	004026e9 	.word	0x004026e9
  4021b8:	00402701 	.word	0x00402701
  4021bc:	2000a734 	.word	0x2000a734
  4021c0:	2000a7b8 	.word	0x2000a7b8
  4021c4:	2000a7a4 	.word	0x2000a7a4

004021c8 <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
  4021c8:	b580      	push	{r7, lr}
  4021ca:	af00      	add	r7, sp, #0
	pio_handler_process(PIOA, ID_PIOA);
  4021cc:	2109      	movs	r1, #9
  4021ce:	4802      	ldr	r0, [pc, #8]	; (4021d8 <PIOA_Handler+0x10>)
  4021d0:	4b02      	ldr	r3, [pc, #8]	; (4021dc <PIOA_Handler+0x14>)
  4021d2:	4798      	blx	r3
}
  4021d4:	bf00      	nop
  4021d6:	bd80      	pop	{r7, pc}
  4021d8:	400e0e00 	.word	0x400e0e00
  4021dc:	004020f5 	.word	0x004020f5

004021e0 <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
  4021e0:	b580      	push	{r7, lr}
  4021e2:	af00      	add	r7, sp, #0
    pio_handler_process(PIOB, ID_PIOB);
  4021e4:	210a      	movs	r1, #10
  4021e6:	4802      	ldr	r0, [pc, #8]	; (4021f0 <PIOB_Handler+0x10>)
  4021e8:	4b02      	ldr	r3, [pc, #8]	; (4021f4 <PIOB_Handler+0x14>)
  4021ea:	4798      	blx	r3
}
  4021ec:	bf00      	nop
  4021ee:	bd80      	pop	{r7, pc}
  4021f0:	400e1000 	.word	0x400e1000
  4021f4:	004020f5 	.word	0x004020f5

004021f8 <PIOC_Handler>:
/**
 * \brief Parallel IO Controller C interrupt handler.
 * Redefined PIOC interrupt handler for NVIC interrupt table.
 */
void PIOC_Handler(void)
{
  4021f8:	b580      	push	{r7, lr}
  4021fa:	af00      	add	r7, sp, #0
	pio_handler_process(PIOC, ID_PIOC);
  4021fc:	210b      	movs	r1, #11
  4021fe:	4802      	ldr	r0, [pc, #8]	; (402208 <PIOC_Handler+0x10>)
  402200:	4b02      	ldr	r3, [pc, #8]	; (40220c <PIOC_Handler+0x14>)
  402202:	4798      	blx	r3
}
  402204:	bf00      	nop
  402206:	bd80      	pop	{r7, pc}
  402208:	400e1200 	.word	0x400e1200
  40220c:	004020f5 	.word	0x004020f5

00402210 <PIOD_Handler>:
/**
 * \brief Parallel IO Controller D interrupt handler.
 * Redefined PIOD interrupt handler for NVIC interrupt table.
 */
void PIOD_Handler(void)
{
  402210:	b580      	push	{r7, lr}
  402212:	af00      	add	r7, sp, #0
	pio_handler_process(PIOD, ID_PIOD);
  402214:	210c      	movs	r1, #12
  402216:	4802      	ldr	r0, [pc, #8]	; (402220 <PIOD_Handler+0x10>)
  402218:	4b02      	ldr	r3, [pc, #8]	; (402224 <PIOD_Handler+0x14>)
  40221a:	4798      	blx	r3
}
  40221c:	bf00      	nop
  40221e:	bd80      	pop	{r7, pc}
  402220:	400e1400 	.word	0x400e1400
  402224:	004020f5 	.word	0x004020f5

00402228 <PIOE_Handler>:
/**
 * \brief Parallel IO Controller E interrupt handler.
 * Redefined PIOE interrupt handler for NVIC interrupt table.
 */
void PIOE_Handler(void)
{
  402228:	b580      	push	{r7, lr}
  40222a:	af00      	add	r7, sp, #0
	pio_handler_process(PIOE, ID_PIOE);
  40222c:	210d      	movs	r1, #13
  40222e:	4802      	ldr	r0, [pc, #8]	; (402238 <PIOE_Handler+0x10>)
  402230:	4b02      	ldr	r3, [pc, #8]	; (40223c <PIOE_Handler+0x14>)
  402232:	4798      	blx	r3
}
  402234:	bf00      	nop
  402236:	bd80      	pop	{r7, pc}
  402238:	400e1600 	.word	0x400e1600
  40223c:	004020f5 	.word	0x004020f5

00402240 <can_set_baudrate>:
 *
 * \retval Set the baudrate successfully or not.
 */
static uint32_t can_set_baudrate(Can *p_can, uint32_t ul_mck,
		uint32_t ul_baudrate)
{
  402240:	b580      	push	{r7, lr}
  402242:	b08a      	sub	sp, #40	; 0x28
  402244:	af00      	add	r7, sp, #0
  402246:	60f8      	str	r0, [r7, #12]
  402248:	60b9      	str	r1, [r7, #8]
  40224a:	607a      	str	r2, [r7, #4]
	uint32_t ul_cur_mod;
	can_bit_timing_t *p_bit_time;

	/* Check whether the baudrate prescale will be greater than the max
	 * divide value. */
	if (((ul_mck + (ul_baudrate * CAN_MAX_TQ_NUM * 1000 - 1)) /
  40224c:	687b      	ldr	r3, [r7, #4]
  40224e:	f246 12a8 	movw	r2, #25000	; 0x61a8
  402252:	fb02 f203 	mul.w	r2, r2, r3
  402256:	68bb      	ldr	r3, [r7, #8]
  402258:	4413      	add	r3, r2
  40225a:	1e5a      	subs	r2, r3, #1
			(ul_baudrate * CAN_MAX_TQ_NUM * 1000)) >
  40225c:	687b      	ldr	r3, [r7, #4]
  40225e:	f246 11a8 	movw	r1, #25000	; 0x61a8
  402262:	fb01 f303 	mul.w	r3, r1, r3
	if (((ul_mck + (ul_baudrate * CAN_MAX_TQ_NUM * 1000 - 1)) /
  402266:	fbb2 f3f3 	udiv	r3, r2, r3
  40226a:	2b80      	cmp	r3, #128	; 0x80
  40226c:	d901      	bls.n	402272 <can_set_baudrate+0x32>
			CAN_BAUDRATE_MAX_DIV) {
		return 0;
  40226e:	2300      	movs	r3, #0
  402270:	e086      	b.n	402380 <can_set_baudrate+0x140>
	}

	/* Check whether the input MCK is too small. */
	if ((ul_mck / 2)  < ul_baudrate * CAN_MIN_TQ_NUM * 1000) {
  402272:	68bb      	ldr	r3, [r7, #8]
  402274:	085a      	lsrs	r2, r3, #1
  402276:	687b      	ldr	r3, [r7, #4]
  402278:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
  40227c:	fb01 f303 	mul.w	r3, r1, r3
  402280:	429a      	cmp	r2, r3
  402282:	d201      	bcs.n	402288 <can_set_baudrate+0x48>
		return 0;
  402284:	2300      	movs	r3, #0
  402286:	e07b      	b.n	402380 <can_set_baudrate+0x140>
	}

	/* Initialize it as the minimum Time Quantum. */
	uc_tq = CAN_MIN_TQ_NUM;
  402288:	2308      	movs	r3, #8
  40228a:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

	/* Initialize the remainder as the max value. When the remainder is 0,
	 *get the right TQ number. */
	ul_mod = 0xffffffff;
  40228e:	f04f 33ff 	mov.w	r3, #4294967295
  402292:	623b      	str	r3, [r7, #32]
	/* Find out the approximate Time Quantum according to the baudrate. */
	for (uint8_t i = CAN_MIN_TQ_NUM; i <= CAN_MAX_TQ_NUM; i++) {
  402294:	2308      	movs	r3, #8
  402296:	77fb      	strb	r3, [r7, #31]
  402298:	e02a      	b.n	4022f0 <can_set_baudrate+0xb0>
		if ((ul_mck / (ul_baudrate * i * 1000)) <=
  40229a:	7ffb      	ldrb	r3, [r7, #31]
  40229c:	687a      	ldr	r2, [r7, #4]
  40229e:	fb02 f303 	mul.w	r3, r2, r3
  4022a2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  4022a6:	fb02 f303 	mul.w	r3, r2, r3
  4022aa:	68ba      	ldr	r2, [r7, #8]
  4022ac:	fbb2 f3f3 	udiv	r3, r2, r3
  4022b0:	2b80      	cmp	r3, #128	; 0x80
  4022b2:	d81a      	bhi.n	4022ea <can_set_baudrate+0xaa>
				CAN_BAUDRATE_MAX_DIV) {
			ul_cur_mod = ul_mck % (ul_baudrate * i * 1000);
  4022b4:	7ffb      	ldrb	r3, [r7, #31]
  4022b6:	687a      	ldr	r2, [r7, #4]
  4022b8:	fb02 f303 	mul.w	r3, r2, r3
  4022bc:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  4022c0:	fb02 f203 	mul.w	r2, r2, r3
  4022c4:	68bb      	ldr	r3, [r7, #8]
  4022c6:	fbb3 f1f2 	udiv	r1, r3, r2
  4022ca:	fb02 f201 	mul.w	r2, r2, r1
  4022ce:	1a9b      	subs	r3, r3, r2
  4022d0:	61bb      	str	r3, [r7, #24]
			if (ul_cur_mod < ul_mod) {
  4022d2:	69ba      	ldr	r2, [r7, #24]
  4022d4:	6a3b      	ldr	r3, [r7, #32]
  4022d6:	429a      	cmp	r2, r3
  4022d8:	d207      	bcs.n	4022ea <can_set_baudrate+0xaa>
				ul_mod = ul_cur_mod;
  4022da:	69bb      	ldr	r3, [r7, #24]
  4022dc:	623b      	str	r3, [r7, #32]
				uc_tq = i;
  4022de:	7ffb      	ldrb	r3, [r7, #31]
  4022e0:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
				if (!ul_mod) {
  4022e4:	6a3b      	ldr	r3, [r7, #32]
  4022e6:	2b00      	cmp	r3, #0
  4022e8:	d006      	beq.n	4022f8 <can_set_baudrate+0xb8>
	for (uint8_t i = CAN_MIN_TQ_NUM; i <= CAN_MAX_TQ_NUM; i++) {
  4022ea:	7ffb      	ldrb	r3, [r7, #31]
  4022ec:	3301      	adds	r3, #1
  4022ee:	77fb      	strb	r3, [r7, #31]
  4022f0:	7ffb      	ldrb	r3, [r7, #31]
  4022f2:	2b19      	cmp	r3, #25
  4022f4:	d9d1      	bls.n	40229a <can_set_baudrate+0x5a>
  4022f6:	e000      	b.n	4022fa <can_set_baudrate+0xba>
					break;
  4022f8:	bf00      	nop
			}
		}
	}

	/* Calculate the baudrate prescale value. */
	uc_prescale = ul_mck / (ul_baudrate * uc_tq * 1000);
  4022fa:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  4022fe:	687a      	ldr	r2, [r7, #4]
  402300:	fb02 f303 	mul.w	r3, r2, r3
  402304:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  402308:	fb02 f303 	mul.w	r3, r2, r3
  40230c:	68ba      	ldr	r2, [r7, #8]
  40230e:	fbb2 f3f3 	udiv	r3, r2, r3
  402312:	75fb      	strb	r3, [r7, #23]
	if (uc_prescale < 2) {
  402314:	7dfb      	ldrb	r3, [r7, #23]
  402316:	2b01      	cmp	r3, #1
  402318:	d801      	bhi.n	40231e <can_set_baudrate+0xde>
		return 0;
  40231a:	2300      	movs	r3, #0
  40231c:	e030      	b.n	402380 <can_set_baudrate+0x140>
	}

	/* Get the right CAN BIT Timing group. */
	p_bit_time = (can_bit_timing_t *)&can_bit_time[uc_tq - CAN_MIN_TQ_NUM];
  40231e:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  402322:	f1a3 0208 	sub.w	r2, r3, #8
  402326:	4613      	mov	r3, r2
  402328:	005b      	lsls	r3, r3, #1
  40232a:	4413      	add	r3, r2
  40232c:	005b      	lsls	r3, r3, #1
  40232e:	4a16      	ldr	r2, [pc, #88]	; (402388 <can_set_baudrate+0x148>)
  402330:	4413      	add	r3, r2
  402332:	613b      	str	r3, [r7, #16]

	/* Before modifying the CANBR register, disable the CAN controller. */
	can_disable(p_can);
  402334:	68f8      	ldr	r0, [r7, #12]
  402336:	4b15      	ldr	r3, [pc, #84]	; (40238c <can_set_baudrate+0x14c>)
  402338:	4798      	blx	r3

	/* Write into the CAN baudrate register. */
	p_can->CAN_BR = CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
  40233a:	693b      	ldr	r3, [r7, #16]
  40233c:	78db      	ldrb	r3, [r3, #3]
  40233e:	3b01      	subs	r3, #1
  402340:	f003 0207 	and.w	r2, r3, #7
			CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
  402344:	693b      	ldr	r3, [r7, #16]
  402346:	789b      	ldrb	r3, [r3, #2]
  402348:	3b01      	subs	r3, #1
  40234a:	011b      	lsls	r3, r3, #4
  40234c:	f003 0370 	and.w	r3, r3, #112	; 0x70
	p_can->CAN_BR = CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
  402350:	431a      	orrs	r2, r3
			CAN_BR_PROPAG(p_bit_time->uc_prog - 1) |
  402352:	693b      	ldr	r3, [r7, #16]
  402354:	785b      	ldrb	r3, [r3, #1]
  402356:	3b01      	subs	r3, #1
  402358:	021b      	lsls	r3, r3, #8
  40235a:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
			CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
  40235e:	431a      	orrs	r2, r3
			CAN_BR_SJW(p_bit_time->uc_sjw - 1) |
  402360:	693b      	ldr	r3, [r7, #16]
  402362:	791b      	ldrb	r3, [r3, #4]
  402364:	3b01      	subs	r3, #1
  402366:	031b      	lsls	r3, r3, #12
  402368:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
			CAN_BR_PROPAG(p_bit_time->uc_prog - 1) |
  40236c:	431a      	orrs	r2, r3
			CAN_BR_BRP(uc_prescale - 1);
  40236e:	7dfb      	ldrb	r3, [r7, #23]
  402370:	3b01      	subs	r3, #1
  402372:	041b      	lsls	r3, r3, #16
  402374:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
			CAN_BR_SJW(p_bit_time->uc_sjw - 1) |
  402378:	431a      	orrs	r2, r3
	p_can->CAN_BR = CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
  40237a:	68fb      	ldr	r3, [r7, #12]
  40237c:	615a      	str	r2, [r3, #20]
	return 1;
  40237e:	2301      	movs	r3, #1
}
  402380:	4618      	mov	r0, r3
  402382:	3728      	adds	r7, #40	; 0x28
  402384:	46bd      	mov	sp, r7
  402386:	bd80      	pop	{r7, pc}
  402388:	00403930 	.word	0x00403930
  40238c:	00402439 	.word	0x00402439

00402390 <can_init>:
 *
 * \note PMC clock for CAN peripheral should be enabled before calling this
 *function.
 */
uint32_t can_init(Can *p_can, uint32_t ul_mck, uint32_t ul_baudrate)
{
  402390:	b580      	push	{r7, lr}
  402392:	b086      	sub	sp, #24
  402394:	af00      	add	r7, sp, #0
  402396:	60f8      	str	r0, [r7, #12]
  402398:	60b9      	str	r1, [r7, #8]
  40239a:	607a      	str	r2, [r7, #4]
	uint32_t ul_flag;
	uint32_t ul_tick;

	/* Initialize the baudrate for CAN module. */
	ul_flag = can_set_baudrate(p_can, ul_mck, ul_baudrate);
  40239c:	687a      	ldr	r2, [r7, #4]
  40239e:	68b9      	ldr	r1, [r7, #8]
  4023a0:	68f8      	ldr	r0, [r7, #12]
  4023a2:	4b17      	ldr	r3, [pc, #92]	; (402400 <can_init+0x70>)
  4023a4:	4798      	blx	r3
  4023a6:	6178      	str	r0, [r7, #20]
	if (ul_flag == 0) {
  4023a8:	697b      	ldr	r3, [r7, #20]
  4023aa:	2b00      	cmp	r3, #0
  4023ac:	d101      	bne.n	4023b2 <can_init+0x22>
		return 0;
  4023ae:	2300      	movs	r3, #0
  4023b0:	e021      	b.n	4023f6 <can_init+0x66>
	}

	/* Reset the CAN eight message mailbox. */
	can_reset_all_mailbox(p_can);
  4023b2:	68f8      	ldr	r0, [r7, #12]
  4023b4:	4b13      	ldr	r3, [pc, #76]	; (402404 <can_init+0x74>)
  4023b6:	4798      	blx	r3

	/* Enable the CAN controller. */
	can_enable(p_can);
  4023b8:	68f8      	ldr	r0, [r7, #12]
  4023ba:	4b13      	ldr	r3, [pc, #76]	; (402408 <can_init+0x78>)
  4023bc:	4798      	blx	r3

	/* Wait until the CAN is synchronized with the bus activity. */
	ul_flag = 0;
  4023be:	2300      	movs	r3, #0
  4023c0:	617b      	str	r3, [r7, #20]
	ul_tick = 0;
  4023c2:	2300      	movs	r3, #0
  4023c4:	613b      	str	r3, [r7, #16]
	while (!(ul_flag & CAN_SR_WAKEUP) && (ul_tick < CAN_TIMEOUT)) {
  4023c6:	e006      	b.n	4023d6 <can_init+0x46>
		ul_flag = can_get_status(p_can);
  4023c8:	68f8      	ldr	r0, [r7, #12]
  4023ca:	4b10      	ldr	r3, [pc, #64]	; (40240c <can_init+0x7c>)
  4023cc:	4798      	blx	r3
  4023ce:	6178      	str	r0, [r7, #20]
		ul_tick++;
  4023d0:	693b      	ldr	r3, [r7, #16]
  4023d2:	3301      	adds	r3, #1
  4023d4:	613b      	str	r3, [r7, #16]
	while (!(ul_flag & CAN_SR_WAKEUP) && (ul_tick < CAN_TIMEOUT)) {
  4023d6:	697b      	ldr	r3, [r7, #20]
  4023d8:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
  4023dc:	2b00      	cmp	r3, #0
  4023de:	d103      	bne.n	4023e8 <can_init+0x58>
  4023e0:	693b      	ldr	r3, [r7, #16]
  4023e2:	4a0b      	ldr	r2, [pc, #44]	; (402410 <can_init+0x80>)
  4023e4:	4293      	cmp	r3, r2
  4023e6:	d9ef      	bls.n	4023c8 <can_init+0x38>
	}

	/* Timeout or the CAN module has been synchronized with the bus. */
	if (CAN_TIMEOUT == ul_tick) {
  4023e8:	693b      	ldr	r3, [r7, #16]
  4023ea:	4a0a      	ldr	r2, [pc, #40]	; (402414 <can_init+0x84>)
  4023ec:	4293      	cmp	r3, r2
  4023ee:	d101      	bne.n	4023f4 <can_init+0x64>
		return 0;
  4023f0:	2300      	movs	r3, #0
  4023f2:	e000      	b.n	4023f6 <can_init+0x66>
	} else {
		return 1;
  4023f4:	2301      	movs	r3, #1
	}
}
  4023f6:	4618      	mov	r0, r3
  4023f8:	3718      	adds	r7, #24
  4023fa:	46bd      	mov	sp, r7
  4023fc:	bd80      	pop	{r7, pc}
  4023fe:	bf00      	nop
  402400:	00402241 	.word	0x00402241
  402404:	00402595 	.word	0x00402595
  402408:	00402419 	.word	0x00402419
  40240c:	00402459 	.word	0x00402459
  402410:	0001869f 	.word	0x0001869f
  402414:	000186a0 	.word	0x000186a0

00402418 <can_enable>:
 * \brief Enable CAN Controller.
 *
 * \param p_can  Pointer to a CAN peripheral instance.
 */
void can_enable(Can *p_can)
{
  402418:	b480      	push	{r7}
  40241a:	b083      	sub	sp, #12
  40241c:	af00      	add	r7, sp, #0
  40241e:	6078      	str	r0, [r7, #4]
	p_can->CAN_MR |= CAN_MR_CANEN;
  402420:	687b      	ldr	r3, [r7, #4]
  402422:	681b      	ldr	r3, [r3, #0]
  402424:	f043 0201 	orr.w	r2, r3, #1
  402428:	687b      	ldr	r3, [r7, #4]
  40242a:	601a      	str	r2, [r3, #0]
}
  40242c:	bf00      	nop
  40242e:	370c      	adds	r7, #12
  402430:	46bd      	mov	sp, r7
  402432:	f85d 7b04 	ldr.w	r7, [sp], #4
  402436:	4770      	bx	lr

00402438 <can_disable>:
 * \brief Disable CAN Controller.
 *
 * \param p_can  Pointer to a CAN peripheral instance.
 */
void can_disable(Can *p_can)
{
  402438:	b480      	push	{r7}
  40243a:	b083      	sub	sp, #12
  40243c:	af00      	add	r7, sp, #0
  40243e:	6078      	str	r0, [r7, #4]
	p_can->CAN_MR &= ~CAN_MR_CANEN;
  402440:	687b      	ldr	r3, [r7, #4]
  402442:	681b      	ldr	r3, [r3, #0]
  402444:	f023 0201 	bic.w	r2, r3, #1
  402448:	687b      	ldr	r3, [r7, #4]
  40244a:	601a      	str	r2, [r3, #0]
}
  40244c:	bf00      	nop
  40244e:	370c      	adds	r7, #12
  402450:	46bd      	mov	sp, r7
  402452:	f85d 7b04 	ldr.w	r7, [sp], #4
  402456:	4770      	bx	lr

00402458 <can_get_status>:
 * \param p_can Pointer to a CAN peripheral instance.
 *
 * \retval CAN status.
 */
uint32_t can_get_status(Can *p_can)
{
  402458:	b480      	push	{r7}
  40245a:	b083      	sub	sp, #12
  40245c:	af00      	add	r7, sp, #0
  40245e:	6078      	str	r0, [r7, #4]
	return (p_can->CAN_SR);
  402460:	687b      	ldr	r3, [r7, #4]
  402462:	691b      	ldr	r3, [r3, #16]
}
  402464:	4618      	mov	r0, r3
  402466:	370c      	adds	r7, #12
  402468:	46bd      	mov	sp, r7
  40246a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40246e:	4770      	bx	lr

00402470 <can_mailbox_init>:
 *
 * \param p_can    Pointer to a CAN peripheral instance.
 * \param p_mailbox Pointer to a CAN mailbox instance.
 */
void can_mailbox_init(Can *p_can, can_mb_conf_t *p_mailbox)
{
  402470:	b480      	push	{r7}
  402472:	b085      	sub	sp, #20
  402474:	af00      	add	r7, sp, #0
  402476:	6078      	str	r0, [r7, #4]
  402478:	6039      	str	r1, [r7, #0]
	uint8_t uc_index;

	uc_index = (uint8_t)p_mailbox->ul_mb_idx;
  40247a:	683b      	ldr	r3, [r7, #0]
  40247c:	681b      	ldr	r3, [r3, #0]
  40247e:	73fb      	strb	r3, [r7, #15]
	/* Check the object type of the mailbox. If it's used to disable the
	 * mailbox, reset the whole mailbox. */
	if (!p_mailbox->uc_obj_type) {
  402480:	683b      	ldr	r3, [r7, #0]
  402482:	791b      	ldrb	r3, [r3, #4]
  402484:	2b00      	cmp	r3, #0
  402486:	d12f      	bne.n	4024e8 <can_mailbox_init+0x78>
		p_can->CAN_MB[uc_index].CAN_MMR = 0;
  402488:	7bfb      	ldrb	r3, [r7, #15]
  40248a:	687a      	ldr	r2, [r7, #4]
  40248c:	3310      	adds	r3, #16
  40248e:	015b      	lsls	r3, r3, #5
  402490:	4413      	add	r3, r2
  402492:	2200      	movs	r2, #0
  402494:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MAM = 0;
  402496:	7bfb      	ldrb	r3, [r7, #15]
  402498:	687a      	ldr	r2, [r7, #4]
  40249a:	3310      	adds	r3, #16
  40249c:	015b      	lsls	r3, r3, #5
  40249e:	4413      	add	r3, r2
  4024a0:	3304      	adds	r3, #4
  4024a2:	2200      	movs	r2, #0
  4024a4:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MID = 0;
  4024a6:	7bfb      	ldrb	r3, [r7, #15]
  4024a8:	687a      	ldr	r2, [r7, #4]
  4024aa:	015b      	lsls	r3, r3, #5
  4024ac:	4413      	add	r3, r2
  4024ae:	f503 7302 	add.w	r3, r3, #520	; 0x208
  4024b2:	2200      	movs	r2, #0
  4024b4:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MDL = 0;
  4024b6:	7bfb      	ldrb	r3, [r7, #15]
  4024b8:	687a      	ldr	r2, [r7, #4]
  4024ba:	015b      	lsls	r3, r3, #5
  4024bc:	4413      	add	r3, r2
  4024be:	f503 7305 	add.w	r3, r3, #532	; 0x214
  4024c2:	2200      	movs	r2, #0
  4024c4:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MDH = 0;
  4024c6:	7bfb      	ldrb	r3, [r7, #15]
  4024c8:	687a      	ldr	r2, [r7, #4]
  4024ca:	015b      	lsls	r3, r3, #5
  4024cc:	4413      	add	r3, r2
  4024ce:	f503 7306 	add.w	r3, r3, #536	; 0x218
  4024d2:	2200      	movs	r2, #0
  4024d4:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MCR = 0;
  4024d6:	7bfb      	ldrb	r3, [r7, #15]
  4024d8:	687a      	ldr	r2, [r7, #4]
  4024da:	015b      	lsls	r3, r3, #5
  4024dc:	4413      	add	r3, r2
  4024de:	f503 7307 	add.w	r3, r3, #540	; 0x21c
  4024e2:	2200      	movs	r2, #0
  4024e4:	601a      	str	r2, [r3, #0]
		return;
  4024e6:	e050      	b.n	40258a <can_mailbox_init+0x11a>
	}

	/* Set the priority in Transmit mode. */
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  4024e8:	7bfb      	ldrb	r3, [r7, #15]
  4024ea:	7bfa      	ldrb	r2, [r7, #15]
  4024ec:	6879      	ldr	r1, [r7, #4]
  4024ee:	3210      	adds	r2, #16
  4024f0:	0152      	lsls	r2, r2, #5
  4024f2:	440a      	add	r2, r1
  4024f4:	6812      	ldr	r2, [r2, #0]
  4024f6:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
			~CAN_MMR_PRIOR_Msk) |
			(p_mailbox->uc_tx_prio << CAN_MMR_PRIOR_Pos);
  4024fa:	6839      	ldr	r1, [r7, #0]
  4024fc:	79c9      	ldrb	r1, [r1, #7]
  4024fe:	0409      	lsls	r1, r1, #16
			~CAN_MMR_PRIOR_Msk) |
  402500:	430a      	orrs	r2, r1
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  402502:	6879      	ldr	r1, [r7, #4]
  402504:	3310      	adds	r3, #16
  402506:	015b      	lsls	r3, r3, #5
  402508:	440b      	add	r3, r1
  40250a:	601a      	str	r2, [r3, #0]

	/* Set the message ID and message acceptance mask for the mailbox in
	 * other modes. */
	if (p_mailbox->uc_id_ver) {
  40250c:	683b      	ldr	r3, [r7, #0]
  40250e:	795b      	ldrb	r3, [r3, #5]
  402510:	2b00      	cmp	r3, #0
  402512:	d016      	beq.n	402542 <can_mailbox_init+0xd2>
		p_can->CAN_MB[uc_index].CAN_MAM = p_mailbox->ul_id_msk |
  402514:	7bfb      	ldrb	r3, [r7, #15]
  402516:	683a      	ldr	r2, [r7, #0]
  402518:	68d2      	ldr	r2, [r2, #12]
  40251a:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
  40251e:	6879      	ldr	r1, [r7, #4]
  402520:	3310      	adds	r3, #16
  402522:	015b      	lsls	r3, r3, #5
  402524:	440b      	add	r3, r1
  402526:	3304      	adds	r3, #4
  402528:	601a      	str	r2, [r3, #0]
				CAN_MAM_MIDE;
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id |
  40252a:	7bfb      	ldrb	r3, [r7, #15]
  40252c:	683a      	ldr	r2, [r7, #0]
  40252e:	6912      	ldr	r2, [r2, #16]
  402530:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
  402534:	6879      	ldr	r1, [r7, #4]
  402536:	015b      	lsls	r3, r3, #5
  402538:	440b      	add	r3, r1
  40253a:	f503 7302 	add.w	r3, r3, #520	; 0x208
  40253e:	601a      	str	r2, [r3, #0]
  402540:	e011      	b.n	402566 <can_mailbox_init+0xf6>
				CAN_MAM_MIDE;
	} else {
		p_can->CAN_MB[uc_index].CAN_MAM = p_mailbox->ul_id_msk;
  402542:	7bfb      	ldrb	r3, [r7, #15]
  402544:	683a      	ldr	r2, [r7, #0]
  402546:	68d2      	ldr	r2, [r2, #12]
  402548:	6879      	ldr	r1, [r7, #4]
  40254a:	3310      	adds	r3, #16
  40254c:	015b      	lsls	r3, r3, #5
  40254e:	440b      	add	r3, r1
  402550:	3304      	adds	r3, #4
  402552:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id;
  402554:	7bfb      	ldrb	r3, [r7, #15]
  402556:	683a      	ldr	r2, [r7, #0]
  402558:	6912      	ldr	r2, [r2, #16]
  40255a:	6879      	ldr	r1, [r7, #4]
  40255c:	015b      	lsls	r3, r3, #5
  40255e:	440b      	add	r3, r1
  402560:	f503 7302 	add.w	r3, r3, #520	; 0x208
  402564:	601a      	str	r2, [r3, #0]
	}

	/* Set up mailbox in one of the five different modes. */
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  402566:	7bfb      	ldrb	r3, [r7, #15]
  402568:	7bfa      	ldrb	r2, [r7, #15]
  40256a:	6879      	ldr	r1, [r7, #4]
  40256c:	3210      	adds	r2, #16
  40256e:	0152      	lsls	r2, r2, #5
  402570:	440a      	add	r2, r1
  402572:	6812      	ldr	r2, [r2, #0]
  402574:	f022 62e0 	bic.w	r2, r2, #117440512	; 0x7000000
			~CAN_MMR_MOT_Msk) |
			(p_mailbox->uc_obj_type << CAN_MMR_MOT_Pos);
  402578:	6839      	ldr	r1, [r7, #0]
  40257a:	7909      	ldrb	r1, [r1, #4]
  40257c:	0609      	lsls	r1, r1, #24
			~CAN_MMR_MOT_Msk) |
  40257e:	430a      	orrs	r2, r1
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  402580:	6879      	ldr	r1, [r7, #4]
  402582:	3310      	adds	r3, #16
  402584:	015b      	lsls	r3, r3, #5
  402586:	440b      	add	r3, r1
  402588:	601a      	str	r2, [r3, #0]
}
  40258a:	3714      	adds	r7, #20
  40258c:	46bd      	mov	sp, r7
  40258e:	f85d 7b04 	ldr.w	r7, [sp], #4
  402592:	4770      	bx	lr

00402594 <can_reset_all_mailbox>:
 * \brief Reset the eight mailboxes.
 *
 * \param p_can Pointer to a CAN peripheral instance.
 */
void can_reset_all_mailbox(Can *p_can)
{
  402594:	b580      	push	{r7, lr}
  402596:	b08c      	sub	sp, #48	; 0x30
  402598:	af00      	add	r7, sp, #0
  40259a:	6078      	str	r0, [r7, #4]
	can_mb_conf_t mb_config_t;

	/* Set the mailbox object type parameter to disable the mailbox. */
	mb_config_t.uc_obj_type = CAN_MB_DISABLE_MODE;
  40259c:	2300      	movs	r3, #0
  40259e:	743b      	strb	r3, [r7, #16]

	for (uint8_t i = 0; i < CANMB_NUMBER; i++) {
  4025a0:	2300      	movs	r3, #0
  4025a2:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  4025a6:	e00d      	b.n	4025c4 <can_reset_all_mailbox+0x30>
		mb_config_t.ul_mb_idx = i;
  4025a8:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  4025ac:	60fb      	str	r3, [r7, #12]
		can_mailbox_init(p_can, &mb_config_t);
  4025ae:	f107 030c 	add.w	r3, r7, #12
  4025b2:	4619      	mov	r1, r3
  4025b4:	6878      	ldr	r0, [r7, #4]
  4025b6:	4b07      	ldr	r3, [pc, #28]	; (4025d4 <can_reset_all_mailbox+0x40>)
  4025b8:	4798      	blx	r3
	for (uint8_t i = 0; i < CANMB_NUMBER; i++) {
  4025ba:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  4025be:	3301      	adds	r3, #1
  4025c0:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  4025c4:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  4025c8:	2b07      	cmp	r3, #7
  4025ca:	d9ed      	bls.n	4025a8 <can_reset_all_mailbox+0x14>
	}
}
  4025cc:	bf00      	nop
  4025ce:	3730      	adds	r7, #48	; 0x30
  4025d0:	46bd      	mov	sp, r7
  4025d2:	bd80      	pop	{r7, pc}
  4025d4:	00402471 	.word	0x00402471

004025d8 <pio_set_peripheral>:
 * \param ul_type PIO type.
 * \param ul_mask Bitmask of one or more pin(s) to configure.
 */
void pio_set_peripheral(Pio *p_pio, const pio_type_t ul_type,
		const uint32_t ul_mask)
{
  4025d8:	b480      	push	{r7}
  4025da:	b087      	sub	sp, #28
  4025dc:	af00      	add	r7, sp, #0
  4025de:	60f8      	str	r0, [r7, #12]
  4025e0:	60b9      	str	r1, [r7, #8]
  4025e2:	607a      	str	r2, [r7, #4]
	uint32_t ul_sr;

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;
  4025e4:	68fb      	ldr	r3, [r7, #12]
  4025e6:	687a      	ldr	r2, [r7, #4]
  4025e8:	645a      	str	r2, [r3, #68]	; 0x44

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  4025ea:	68bb      	ldr	r3, [r7, #8]
  4025ec:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
  4025f0:	d04a      	beq.n	402688 <pio_set_peripheral+0xb0>
  4025f2:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
  4025f6:	d808      	bhi.n	40260a <pio_set_peripheral+0x32>
  4025f8:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
  4025fc:	d016      	beq.n	40262c <pio_set_peripheral+0x54>
  4025fe:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  402602:	d02c      	beq.n	40265e <pio_set_peripheral+0x86>
  402604:	2b00      	cmp	r3, #0
  402606:	d069      	beq.n	4026dc <pio_set_peripheral+0x104>
  402608:	e064      	b.n	4026d4 <pio_set_peripheral+0xfc>
  40260a:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  40260e:	d065      	beq.n	4026dc <pio_set_peripheral+0x104>
  402610:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  402614:	d803      	bhi.n	40261e <pio_set_peripheral+0x46>
  402616:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
  40261a:	d04a      	beq.n	4026b2 <pio_set_peripheral+0xda>
  40261c:	e05a      	b.n	4026d4 <pio_set_peripheral+0xfc>
  40261e:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
  402622:	d05b      	beq.n	4026dc <pio_set_peripheral+0x104>
  402624:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  402628:	d058      	beq.n	4026dc <pio_set_peripheral+0x104>
  40262a:	e053      	b.n	4026d4 <pio_set_peripheral+0xfc>
	case PIO_PERIPH_A:
		ul_sr = p_pio->PIO_ABCDSR[0];
  40262c:	68fb      	ldr	r3, [r7, #12]
  40262e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  402630:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  402632:	68fb      	ldr	r3, [r7, #12]
  402634:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  402636:	687b      	ldr	r3, [r7, #4]
  402638:	43d9      	mvns	r1, r3
  40263a:	697b      	ldr	r3, [r7, #20]
  40263c:	400b      	ands	r3, r1
  40263e:	401a      	ands	r2, r3
  402640:	68fb      	ldr	r3, [r7, #12]
  402642:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  402644:	68fb      	ldr	r3, [r7, #12]
  402646:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  402648:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  40264a:	68fb      	ldr	r3, [r7, #12]
  40264c:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  40264e:	687b      	ldr	r3, [r7, #4]
  402650:	43d9      	mvns	r1, r3
  402652:	697b      	ldr	r3, [r7, #20]
  402654:	400b      	ands	r3, r1
  402656:	401a      	ands	r2, r3
  402658:	68fb      	ldr	r3, [r7, #12]
  40265a:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  40265c:	e03a      	b.n	4026d4 <pio_set_peripheral+0xfc>
	case PIO_PERIPH_B:
		ul_sr = p_pio->PIO_ABCDSR[0];
  40265e:	68fb      	ldr	r3, [r7, #12]
  402660:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  402662:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  402664:	687a      	ldr	r2, [r7, #4]
  402666:	697b      	ldr	r3, [r7, #20]
  402668:	431a      	orrs	r2, r3
  40266a:	68fb      	ldr	r3, [r7, #12]
  40266c:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  40266e:	68fb      	ldr	r3, [r7, #12]
  402670:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  402672:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  402674:	68fb      	ldr	r3, [r7, #12]
  402676:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  402678:	687b      	ldr	r3, [r7, #4]
  40267a:	43d9      	mvns	r1, r3
  40267c:	697b      	ldr	r3, [r7, #20]
  40267e:	400b      	ands	r3, r1
  402680:	401a      	ands	r2, r3
  402682:	68fb      	ldr	r3, [r7, #12]
  402684:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  402686:	e025      	b.n	4026d4 <pio_set_peripheral+0xfc>
#if (!SAMG)
	case PIO_PERIPH_C:
		ul_sr = p_pio->PIO_ABCDSR[0];
  402688:	68fb      	ldr	r3, [r7, #12]
  40268a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  40268c:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  40268e:	68fb      	ldr	r3, [r7, #12]
  402690:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  402692:	687b      	ldr	r3, [r7, #4]
  402694:	43d9      	mvns	r1, r3
  402696:	697b      	ldr	r3, [r7, #20]
  402698:	400b      	ands	r3, r1
  40269a:	401a      	ands	r2, r3
  40269c:	68fb      	ldr	r3, [r7, #12]
  40269e:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  4026a0:	68fb      	ldr	r3, [r7, #12]
  4026a2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  4026a4:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  4026a6:	687a      	ldr	r2, [r7, #4]
  4026a8:	697b      	ldr	r3, [r7, #20]
  4026aa:	431a      	orrs	r2, r3
  4026ac:	68fb      	ldr	r3, [r7, #12]
  4026ae:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  4026b0:	e010      	b.n	4026d4 <pio_set_peripheral+0xfc>
	case PIO_PERIPH_D:
		ul_sr = p_pio->PIO_ABCDSR[0];
  4026b2:	68fb      	ldr	r3, [r7, #12]
  4026b4:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  4026b6:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  4026b8:	687a      	ldr	r2, [r7, #4]
  4026ba:	697b      	ldr	r3, [r7, #20]
  4026bc:	431a      	orrs	r2, r3
  4026be:	68fb      	ldr	r3, [r7, #12]
  4026c0:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  4026c2:	68fb      	ldr	r3, [r7, #12]
  4026c4:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  4026c6:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  4026c8:	687a      	ldr	r2, [r7, #4]
  4026ca:	697b      	ldr	r3, [r7, #20]
  4026cc:	431a      	orrs	r2, r3
  4026ce:	68fb      	ldr	r3, [r7, #12]
  4026d0:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  4026d2:	bf00      	nop
#else
#error "Unsupported device"
#endif

	/* Remove the pins from under the control of PIO */
	p_pio->PIO_PDR = ul_mask;
  4026d4:	68fb      	ldr	r3, [r7, #12]
  4026d6:	687a      	ldr	r2, [r7, #4]
  4026d8:	605a      	str	r2, [r3, #4]
  4026da:	e000      	b.n	4026de <pio_set_peripheral+0x106>
		return;
  4026dc:	bf00      	nop
}
  4026de:	371c      	adds	r7, #28
  4026e0:	46bd      	mov	sp, r7
  4026e2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4026e6:	4770      	bx	lr

004026e8 <pio_get_interrupt_status>:
 * \param p_pio Pointer to a PIO instance.
 *
 * \return The interrupt status value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
  4026e8:	b480      	push	{r7}
  4026ea:	b083      	sub	sp, #12
  4026ec:	af00      	add	r7, sp, #0
  4026ee:	6078      	str	r0, [r7, #4]
	return p_pio->PIO_ISR;
  4026f0:	687b      	ldr	r3, [r7, #4]
  4026f2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
}
  4026f4:	4618      	mov	r0, r3
  4026f6:	370c      	adds	r7, #12
  4026f8:	46bd      	mov	sp, r7
  4026fa:	f85d 7b04 	ldr.w	r7, [sp], #4
  4026fe:	4770      	bx	lr

00402700 <pio_get_interrupt_mask>:
 * \param p_pio Pointer to a PIO instance.
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
  402700:	b480      	push	{r7}
  402702:	b083      	sub	sp, #12
  402704:	af00      	add	r7, sp, #0
  402706:	6078      	str	r0, [r7, #4]
	return p_pio->PIO_IMR;
  402708:	687b      	ldr	r3, [r7, #4]
  40270a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
}
  40270c:	4618      	mov	r0, r3
  40270e:	370c      	adds	r7, #12
  402710:	46bd      	mov	sp, r7
  402712:	f85d 7b04 	ldr.w	r7, [sp], #4
  402716:	4770      	bx	lr

00402718 <pmc_switch_mck_to_pllack>:
 *
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
  402718:	b480      	push	{r7}
  40271a:	b085      	sub	sp, #20
  40271c:	af00      	add	r7, sp, #0
  40271e:	6078      	str	r0, [r7, #4]
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  402720:	491d      	ldr	r1, [pc, #116]	; (402798 <pmc_switch_mck_to_pllack+0x80>)
  402722:	4b1d      	ldr	r3, [pc, #116]	; (402798 <pmc_switch_mck_to_pllack+0x80>)
  402724:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  402726:	f023 0270 	bic.w	r2, r3, #112	; 0x70
  40272a:	687b      	ldr	r3, [r7, #4]
  40272c:	4313      	orrs	r3, r2
  40272e:	630b      	str	r3, [r1, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  402730:	f44f 6300 	mov.w	r3, #2048	; 0x800
  402734:	60fb      	str	r3, [r7, #12]
  402736:	e007      	b.n	402748 <pmc_switch_mck_to_pllack+0x30>
			--ul_timeout) {
		if (ul_timeout == 0) {
  402738:	68fb      	ldr	r3, [r7, #12]
  40273a:	2b00      	cmp	r3, #0
  40273c:	d101      	bne.n	402742 <pmc_switch_mck_to_pllack+0x2a>
			return 1;
  40273e:	2301      	movs	r3, #1
  402740:	e023      	b.n	40278a <pmc_switch_mck_to_pllack+0x72>
			--ul_timeout) {
  402742:	68fb      	ldr	r3, [r7, #12]
  402744:	3b01      	subs	r3, #1
  402746:	60fb      	str	r3, [r7, #12]
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  402748:	4b13      	ldr	r3, [pc, #76]	; (402798 <pmc_switch_mck_to_pllack+0x80>)
  40274a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  40274c:	f003 0308 	and.w	r3, r3, #8
  402750:	2b00      	cmp	r3, #0
  402752:	d0f1      	beq.n	402738 <pmc_switch_mck_to_pllack+0x20>
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  402754:	4a10      	ldr	r2, [pc, #64]	; (402798 <pmc_switch_mck_to_pllack+0x80>)
  402756:	4b10      	ldr	r3, [pc, #64]	; (402798 <pmc_switch_mck_to_pllack+0x80>)
  402758:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  40275a:	f023 0303 	bic.w	r3, r3, #3
  40275e:	f043 0302 	orr.w	r3, r3, #2
  402762:	6313      	str	r3, [r2, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  402764:	f44f 6300 	mov.w	r3, #2048	; 0x800
  402768:	60fb      	str	r3, [r7, #12]
  40276a:	e007      	b.n	40277c <pmc_switch_mck_to_pllack+0x64>
			--ul_timeout) {
		if (ul_timeout == 0) {
  40276c:	68fb      	ldr	r3, [r7, #12]
  40276e:	2b00      	cmp	r3, #0
  402770:	d101      	bne.n	402776 <pmc_switch_mck_to_pllack+0x5e>
			return 1;
  402772:	2301      	movs	r3, #1
  402774:	e009      	b.n	40278a <pmc_switch_mck_to_pllack+0x72>
			--ul_timeout) {
  402776:	68fb      	ldr	r3, [r7, #12]
  402778:	3b01      	subs	r3, #1
  40277a:	60fb      	str	r3, [r7, #12]
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40277c:	4b06      	ldr	r3, [pc, #24]	; (402798 <pmc_switch_mck_to_pllack+0x80>)
  40277e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  402780:	f003 0308 	and.w	r3, r3, #8
  402784:	2b00      	cmp	r3, #0
  402786:	d0f1      	beq.n	40276c <pmc_switch_mck_to_pllack+0x54>
		}
	}

	return 0;
  402788:	2300      	movs	r3, #0
}
  40278a:	4618      	mov	r0, r3
  40278c:	3714      	adds	r7, #20
  40278e:	46bd      	mov	sp, r7
  402790:	f85d 7b04 	ldr.w	r7, [sp], #4
  402794:	4770      	bx	lr
  402796:	bf00      	nop
  402798:	400e0400 	.word	0x400e0400

0040279c <pmc_switch_sclk_to_32kxtal>:
 *       VDDIO power supply.
 *
 * \param ul_bypass 0 for Xtal, 1 for bypass.
 */
void pmc_switch_sclk_to_32kxtal(uint32_t ul_bypass)
{
  40279c:	b480      	push	{r7}
  40279e:	b083      	sub	sp, #12
  4027a0:	af00      	add	r7, sp, #0
  4027a2:	6078      	str	r0, [r7, #4]
	/* Set Bypass mode if required */
	if (ul_bypass == 1) {
  4027a4:	687b      	ldr	r3, [r7, #4]
  4027a6:	2b01      	cmp	r3, #1
  4027a8:	d107      	bne.n	4027ba <pmc_switch_sclk_to_32kxtal+0x1e>
		SUPC->SUPC_MR |= SUPC_MR_KEY_PASSWD |
  4027aa:	4a08      	ldr	r2, [pc, #32]	; (4027cc <pmc_switch_sclk_to_32kxtal+0x30>)
  4027ac:	4b07      	ldr	r3, [pc, #28]	; (4027cc <pmc_switch_sclk_to_32kxtal+0x30>)
  4027ae:	689b      	ldr	r3, [r3, #8]
  4027b0:	f043 4325 	orr.w	r3, r3, #2768240640	; 0xa5000000
  4027b4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  4027b8:	6093      	str	r3, [r2, #8]
			SUPC_MR_OSCBYPASS;
	}

	SUPC->SUPC_CR = SUPC_CR_KEY_PASSWD | SUPC_CR_XTALSEL;
  4027ba:	4b04      	ldr	r3, [pc, #16]	; (4027cc <pmc_switch_sclk_to_32kxtal+0x30>)
  4027bc:	4a04      	ldr	r2, [pc, #16]	; (4027d0 <pmc_switch_sclk_to_32kxtal+0x34>)
  4027be:	601a      	str	r2, [r3, #0]
}
  4027c0:	bf00      	nop
  4027c2:	370c      	adds	r7, #12
  4027c4:	46bd      	mov	sp, r7
  4027c6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4027ca:	4770      	bx	lr
  4027cc:	400e1810 	.word	0x400e1810
  4027d0:	a5000008 	.word	0xa5000008

004027d4 <pmc_osc_is_ready_32kxtal>:
 *
 * \retval 1 External 32k Xtal is ready.
 * \retval 0 External 32k Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_32kxtal(void)
{
  4027d4:	b480      	push	{r7}
  4027d6:	af00      	add	r7, sp, #0
	return ((SUPC->SUPC_SR & SUPC_SR_OSCSEL)
  4027d8:	4b09      	ldr	r3, [pc, #36]	; (402800 <pmc_osc_is_ready_32kxtal+0x2c>)
  4027da:	695b      	ldr	r3, [r3, #20]
  4027dc:	f003 0380 	and.w	r3, r3, #128	; 0x80
			&& (PMC->PMC_SR & PMC_SR_OSCSELS));
  4027e0:	2b00      	cmp	r3, #0
  4027e2:	d007      	beq.n	4027f4 <pmc_osc_is_ready_32kxtal+0x20>
  4027e4:	4b07      	ldr	r3, [pc, #28]	; (402804 <pmc_osc_is_ready_32kxtal+0x30>)
  4027e6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4027e8:	f003 0380 	and.w	r3, r3, #128	; 0x80
  4027ec:	2b00      	cmp	r3, #0
  4027ee:	d001      	beq.n	4027f4 <pmc_osc_is_ready_32kxtal+0x20>
  4027f0:	2301      	movs	r3, #1
  4027f2:	e000      	b.n	4027f6 <pmc_osc_is_ready_32kxtal+0x22>
  4027f4:	2300      	movs	r3, #0
}
  4027f6:	4618      	mov	r0, r3
  4027f8:	46bd      	mov	sp, r7
  4027fa:	f85d 7b04 	ldr.w	r7, [sp], #4
  4027fe:	4770      	bx	lr
  402800:	400e1810 	.word	0x400e1810
  402804:	400e0400 	.word	0x400e0400

00402808 <pmc_switch_mainck_to_fastrc>:
 * \retval 0 Success.
 * \retval 1 Timeout error.
 * \retval 2 Invalid frequency.
 */
void pmc_switch_mainck_to_fastrc(uint32_t ul_moscrcf)
{
  402808:	b480      	push	{r7}
  40280a:	b083      	sub	sp, #12
  40280c:	af00      	add	r7, sp, #0
  40280e:	6078      	str	r0, [r7, #4]
	/* Enable Fast RC oscillator but DO NOT switch to RC now */
	PMC->CKGR_MOR |= (CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCRCEN);
  402810:	4a18      	ldr	r2, [pc, #96]	; (402874 <pmc_switch_mainck_to_fastrc+0x6c>)
  402812:	4b18      	ldr	r3, [pc, #96]	; (402874 <pmc_switch_mainck_to_fastrc+0x6c>)
  402814:	6a1b      	ldr	r3, [r3, #32]
  402816:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  40281a:	f043 0308 	orr.w	r3, r3, #8
  40281e:	6213      	str	r3, [r2, #32]

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  402820:	bf00      	nop
  402822:	4b14      	ldr	r3, [pc, #80]	; (402874 <pmc_switch_mainck_to_fastrc+0x6c>)
  402824:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  402826:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  40282a:	2b00      	cmp	r3, #0
  40282c:	d0f9      	beq.n	402822 <pmc_switch_mainck_to_fastrc+0x1a>

	/* Change Fast RC oscillator frequency */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  40282e:	4911      	ldr	r1, [pc, #68]	; (402874 <pmc_switch_mainck_to_fastrc+0x6c>)
  402830:	4b10      	ldr	r3, [pc, #64]	; (402874 <pmc_switch_mainck_to_fastrc+0x6c>)
  402832:	6a1b      	ldr	r3, [r3, #32]
  402834:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  402838:	f023 0370 	bic.w	r3, r3, #112	; 0x70
			CKGR_MOR_KEY_PASSWD | ul_moscrcf;
  40283c:	687a      	ldr	r2, [r7, #4]
  40283e:	4313      	orrs	r3, r2
  402840:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  402844:	620b      	str	r3, [r1, #32]

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  402846:	bf00      	nop
  402848:	4b0a      	ldr	r3, [pc, #40]	; (402874 <pmc_switch_mainck_to_fastrc+0x6c>)
  40284a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  40284c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  402850:	2b00      	cmp	r3, #0
  402852:	d0f9      	beq.n	402848 <pmc_switch_mainck_to_fastrc+0x40>

	/* Switch to Fast RC */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCSEL) |
  402854:	4a07      	ldr	r2, [pc, #28]	; (402874 <pmc_switch_mainck_to_fastrc+0x6c>)
  402856:	4b07      	ldr	r3, [pc, #28]	; (402874 <pmc_switch_mainck_to_fastrc+0x6c>)
  402858:	6a1b      	ldr	r3, [r3, #32]
  40285a:	f023 739b 	bic.w	r3, r3, #20316160	; 0x1360000
  40285e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  402862:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  402866:	6213      	str	r3, [r2, #32]
			CKGR_MOR_KEY_PASSWD;
}
  402868:	bf00      	nop
  40286a:	370c      	adds	r7, #12
  40286c:	46bd      	mov	sp, r7
  40286e:	f85d 7b04 	ldr.w	r7, [sp], #4
  402872:	4770      	bx	lr
  402874:	400e0400 	.word	0x400e0400

00402878 <pmc_switch_mainck_to_xtal>:
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
  402878:	b480      	push	{r7}
  40287a:	b083      	sub	sp, #12
  40287c:	af00      	add	r7, sp, #0
  40287e:	6078      	str	r0, [r7, #4]
  402880:	6039      	str	r1, [r7, #0]
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
  402882:	687b      	ldr	r3, [r7, #4]
  402884:	2b00      	cmp	r3, #0
  402886:	d008      	beq.n	40289a <pmc_switch_mainck_to_xtal+0x22>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  402888:	4916      	ldr	r1, [pc, #88]	; (4028e4 <pmc_switch_mainck_to_xtal+0x6c>)
  40288a:	4b16      	ldr	r3, [pc, #88]	; (4028e4 <pmc_switch_mainck_to_xtal+0x6c>)
  40288c:	6a1b      	ldr	r3, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
  40288e:	4a16      	ldr	r2, [pc, #88]	; (4028e8 <pmc_switch_mainck_to_xtal+0x70>)
  402890:	401a      	ands	r2, r3
  402892:	4b16      	ldr	r3, [pc, #88]	; (4028ec <pmc_switch_mainck_to_xtal+0x74>)
  402894:	4313      	orrs	r3, r2
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  402896:	620b      	str	r3, [r1, #32]
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));

		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
	}
}
  402898:	e01e      	b.n	4028d8 <pmc_switch_mainck_to_xtal+0x60>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  40289a:	4912      	ldr	r1, [pc, #72]	; (4028e4 <pmc_switch_mainck_to_xtal+0x6c>)
  40289c:	4b11      	ldr	r3, [pc, #68]	; (4028e4 <pmc_switch_mainck_to_xtal+0x6c>)
  40289e:	6a1b      	ldr	r3, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  4028a0:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  4028a4:	f023 0303 	bic.w	r3, r3, #3
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
  4028a8:	683a      	ldr	r2, [r7, #0]
  4028aa:	0212      	lsls	r2, r2, #8
  4028ac:	b292      	uxth	r2, r2
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  4028ae:	4313      	orrs	r3, r2
  4028b0:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  4028b4:	f043 0301 	orr.w	r3, r3, #1
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  4028b8:	620b      	str	r3, [r1, #32]
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
  4028ba:	bf00      	nop
  4028bc:	4b09      	ldr	r3, [pc, #36]	; (4028e4 <pmc_switch_mainck_to_xtal+0x6c>)
  4028be:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4028c0:	f003 0301 	and.w	r3, r3, #1
  4028c4:	2b00      	cmp	r3, #0
  4028c6:	d0f9      	beq.n	4028bc <pmc_switch_mainck_to_xtal+0x44>
		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
  4028c8:	4a06      	ldr	r2, [pc, #24]	; (4028e4 <pmc_switch_mainck_to_xtal+0x6c>)
  4028ca:	4b06      	ldr	r3, [pc, #24]	; (4028e4 <pmc_switch_mainck_to_xtal+0x6c>)
  4028cc:	6a1b      	ldr	r3, [r3, #32]
  4028ce:	f043 739b 	orr.w	r3, r3, #20316160	; 0x1360000
  4028d2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  4028d6:	6213      	str	r3, [r2, #32]
}
  4028d8:	bf00      	nop
  4028da:	370c      	adds	r7, #12
  4028dc:	46bd      	mov	sp, r7
  4028de:	f85d 7b04 	ldr.w	r7, [sp], #4
  4028e2:	4770      	bx	lr
  4028e4:	400e0400 	.word	0x400e0400
  4028e8:	fec8fffc 	.word	0xfec8fffc
  4028ec:	01370002 	.word	0x01370002

004028f0 <pmc_osc_is_ready_mainck>:
 *
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
  4028f0:	b480      	push	{r7}
  4028f2:	af00      	add	r7, sp, #0
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
  4028f4:	4b04      	ldr	r3, [pc, #16]	; (402908 <pmc_osc_is_ready_mainck+0x18>)
  4028f6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4028f8:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
}
  4028fc:	4618      	mov	r0, r3
  4028fe:	46bd      	mov	sp, r7
  402900:	f85d 7b04 	ldr.w	r7, [sp], #4
  402904:	4770      	bx	lr
  402906:	bf00      	nop
  402908:	400e0400 	.word	0x400e0400

0040290c <pmc_disable_pllack>:

/**
 * \brief Disable PLLA clock.
 */
void pmc_disable_pllack(void)
{
  40290c:	b480      	push	{r7}
  40290e:	af00      	add	r7, sp, #0
#if (SAM4C || SAM4CM || SAM4CP || SAMG)
	PMC->CKGR_PLLAR = CKGR_PLLAR_MULA(0);
#else
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
  402910:	4b04      	ldr	r3, [pc, #16]	; (402924 <pmc_disable_pllack+0x18>)
  402912:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  402916:	629a      	str	r2, [r3, #40]	; 0x28
#endif
}
  402918:	bf00      	nop
  40291a:	46bd      	mov	sp, r7
  40291c:	f85d 7b04 	ldr.w	r7, [sp], #4
  402920:	4770      	bx	lr
  402922:	bf00      	nop
  402924:	400e0400 	.word	0x400e0400

00402928 <pmc_is_locked_pllack>:
 *
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
  402928:	b480      	push	{r7}
  40292a:	af00      	add	r7, sp, #0
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  40292c:	4b04      	ldr	r3, [pc, #16]	; (402940 <pmc_is_locked_pllack+0x18>)
  40292e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  402930:	f003 0302 	and.w	r3, r3, #2
}
  402934:	4618      	mov	r0, r3
  402936:	46bd      	mov	sp, r7
  402938:	f85d 7b04 	ldr.w	r7, [sp], #4
  40293c:	4770      	bx	lr
  40293e:	bf00      	nop
  402940:	400e0400 	.word	0x400e0400

00402944 <pmc_enable_periph_clk>:
 *
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
  402944:	b480      	push	{r7}
  402946:	b083      	sub	sp, #12
  402948:	af00      	add	r7, sp, #0
  40294a:	6078      	str	r0, [r7, #4]
	PMC->PMC_PCR = ul_id & 0x7F;
	pcr = PMC->PMC_PCR | PMC_PCR_EN | PMC_PCR_CMD;
	PMC->PMC_PCR = pcr;
	return 0;
#else
	if (ul_id > MAX_PERIPH_ID) {
  40294c:	687b      	ldr	r3, [r7, #4]
  40294e:	2b2f      	cmp	r3, #47	; 0x2f
  402950:	d901      	bls.n	402956 <pmc_enable_periph_clk+0x12>
		return 1;
  402952:	2301      	movs	r3, #1
  402954:	e02f      	b.n	4029b6 <pmc_enable_periph_clk+0x72>
	}

	if (ul_id < 32) {
  402956:	687b      	ldr	r3, [r7, #4]
  402958:	2b1f      	cmp	r3, #31
  40295a:	d813      	bhi.n	402984 <pmc_enable_periph_clk+0x40>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  40295c:	4b19      	ldr	r3, [pc, #100]	; (4029c4 <pmc_enable_periph_clk+0x80>)
  40295e:	699a      	ldr	r2, [r3, #24]
  402960:	2101      	movs	r1, #1
  402962:	687b      	ldr	r3, [r7, #4]
  402964:	fa01 f303 	lsl.w	r3, r1, r3
  402968:	401a      	ands	r2, r3
  40296a:	2101      	movs	r1, #1
  40296c:	687b      	ldr	r3, [r7, #4]
  40296e:	fa01 f303 	lsl.w	r3, r1, r3
  402972:	429a      	cmp	r2, r3
  402974:	d01e      	beq.n	4029b4 <pmc_enable_periph_clk+0x70>
			PMC->PMC_PCER0 = 1 << ul_id;
  402976:	4a13      	ldr	r2, [pc, #76]	; (4029c4 <pmc_enable_periph_clk+0x80>)
  402978:	2101      	movs	r1, #1
  40297a:	687b      	ldr	r3, [r7, #4]
  40297c:	fa01 f303 	lsl.w	r3, r1, r3
  402980:	6113      	str	r3, [r2, #16]
  402982:	e017      	b.n	4029b4 <pmc_enable_periph_clk+0x70>
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CM || SAM4CP || SAMG55 || SAMV71 || SAMV70 || SAME70 || SAMS70)
	} else {
		ul_id -= 32;
  402984:	687b      	ldr	r3, [r7, #4]
  402986:	3b20      	subs	r3, #32
  402988:	607b      	str	r3, [r7, #4]
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  40298a:	4b0e      	ldr	r3, [pc, #56]	; (4029c4 <pmc_enable_periph_clk+0x80>)
  40298c:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
  402990:	2101      	movs	r1, #1
  402992:	687b      	ldr	r3, [r7, #4]
  402994:	fa01 f303 	lsl.w	r3, r1, r3
  402998:	401a      	ands	r2, r3
  40299a:	2101      	movs	r1, #1
  40299c:	687b      	ldr	r3, [r7, #4]
  40299e:	fa01 f303 	lsl.w	r3, r1, r3
  4029a2:	429a      	cmp	r2, r3
  4029a4:	d006      	beq.n	4029b4 <pmc_enable_periph_clk+0x70>
			PMC->PMC_PCER1 = 1 << ul_id;
  4029a6:	4a07      	ldr	r2, [pc, #28]	; (4029c4 <pmc_enable_periph_clk+0x80>)
  4029a8:	2101      	movs	r1, #1
  4029aa:	687b      	ldr	r3, [r7, #4]
  4029ac:	fa01 f303 	lsl.w	r3, r1, r3
  4029b0:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
		}
#endif
	}

	return 0;
  4029b4:	2300      	movs	r3, #0
#endif /* defined(REG_PMC_PCR) && !SAMG55 */
}
  4029b6:	4618      	mov	r0, r3
  4029b8:	370c      	adds	r7, #12
  4029ba:	46bd      	mov	sp, r7
  4029bc:	f85d 7b04 	ldr.w	r7, [sp], #4
  4029c0:	4770      	bx	lr
  4029c2:	bf00      	nop
  4029c4:	400e0400 	.word	0x400e0400

004029c8 <twi_enable_master_mode>:
 * \brief Enable TWI master mode.
 *
 * \param p_twi Pointer to a TWI instance.
 */
void twi_enable_master_mode(Twi *p_twi)
{
  4029c8:	b480      	push	{r7}
  4029ca:	b083      	sub	sp, #12
  4029cc:	af00      	add	r7, sp, #0
  4029ce:	6078      	str	r0, [r7, #4]
	/* Set Master Disable bit and Slave Disable bit */
	p_twi->TWI_CR = TWI_CR_MSDIS;
  4029d0:	687b      	ldr	r3, [r7, #4]
  4029d2:	2208      	movs	r2, #8
  4029d4:	601a      	str	r2, [r3, #0]
	p_twi->TWI_CR = TWI_CR_SVDIS;
  4029d6:	687b      	ldr	r3, [r7, #4]
  4029d8:	2220      	movs	r2, #32
  4029da:	601a      	str	r2, [r3, #0]

	/* Set Master Enable bit */
	p_twi->TWI_CR = TWI_CR_MSEN;
  4029dc:	687b      	ldr	r3, [r7, #4]
  4029de:	2204      	movs	r2, #4
  4029e0:	601a      	str	r2, [r3, #0]
}
  4029e2:	bf00      	nop
  4029e4:	370c      	adds	r7, #12
  4029e6:	46bd      	mov	sp, r7
  4029e8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4029ec:	4770      	bx	lr
	...

004029f0 <twi_master_init>:
 * \param p_opt Options for initializing the TWI module (see \ref twi_options_t).
 *
 * \return TWI_SUCCESS if initialization is complete, error code otherwise.
 */
uint32_t twi_master_init(Twi *p_twi, const twi_options_t *p_opt)
{
  4029f0:	b580      	push	{r7, lr}
  4029f2:	b084      	sub	sp, #16
  4029f4:	af00      	add	r7, sp, #0
  4029f6:	6078      	str	r0, [r7, #4]
  4029f8:	6039      	str	r1, [r7, #0]
	uint32_t status = TWI_SUCCESS;
  4029fa:	2300      	movs	r3, #0
  4029fc:	60fb      	str	r3, [r7, #12]

	/* Disable TWI interrupts */
	p_twi->TWI_IDR = ~0UL;
  4029fe:	687b      	ldr	r3, [r7, #4]
  402a00:	f04f 32ff 	mov.w	r2, #4294967295
  402a04:	629a      	str	r2, [r3, #40]	; 0x28

	/* Dummy read in status register */
	p_twi->TWI_SR;
  402a06:	687b      	ldr	r3, [r7, #4]
  402a08:	6a1b      	ldr	r3, [r3, #32]

	/* Reset TWI peripheral */
	twi_reset(p_twi);
  402a0a:	6878      	ldr	r0, [r7, #4]
  402a0c:	4b0e      	ldr	r3, [pc, #56]	; (402a48 <twi_master_init+0x58>)
  402a0e:	4798      	blx	r3

	twi_enable_master_mode(p_twi);
  402a10:	6878      	ldr	r0, [r7, #4]
  402a12:	4b0e      	ldr	r3, [pc, #56]	; (402a4c <twi_master_init+0x5c>)
  402a14:	4798      	blx	r3

	/* Select the speed */
	if (twi_set_speed(p_twi, p_opt->speed, p_opt->master_clk) == FAIL) {
  402a16:	683b      	ldr	r3, [r7, #0]
  402a18:	6859      	ldr	r1, [r3, #4]
  402a1a:	683b      	ldr	r3, [r7, #0]
  402a1c:	681b      	ldr	r3, [r3, #0]
  402a1e:	461a      	mov	r2, r3
  402a20:	6878      	ldr	r0, [r7, #4]
  402a22:	4b0b      	ldr	r3, [pc, #44]	; (402a50 <twi_master_init+0x60>)
  402a24:	4798      	blx	r3
  402a26:	4603      	mov	r3, r0
  402a28:	2b01      	cmp	r3, #1
  402a2a:	d101      	bne.n	402a30 <twi_master_init+0x40>
		/* The desired speed setting is rejected */
		status = TWI_INVALID_ARGUMENT;
  402a2c:	2301      	movs	r3, #1
  402a2e:	60fb      	str	r3, [r7, #12]
	}

	if (p_opt->smbus == 1) {
  402a30:	683b      	ldr	r3, [r7, #0]
  402a32:	7a5b      	ldrb	r3, [r3, #9]
  402a34:	2b01      	cmp	r3, #1
  402a36:	d102      	bne.n	402a3e <twi_master_init+0x4e>
		p_twi->TWI_CR = TWI_CR_QUICK;
  402a38:	687b      	ldr	r3, [r7, #4]
  402a3a:	2240      	movs	r2, #64	; 0x40
  402a3c:	601a      	str	r2, [r3, #0]
	}

	return status;
  402a3e:	68fb      	ldr	r3, [r7, #12]
}
  402a40:	4618      	mov	r0, r3
  402a42:	3710      	adds	r7, #16
  402a44:	46bd      	mov	sp, r7
  402a46:	bd80      	pop	{r7, pc}
  402a48:	00402c81 	.word	0x00402c81
  402a4c:	004029c9 	.word	0x004029c9
  402a50:	00402a55 	.word	0x00402a55

00402a54 <twi_set_speed>:
 *
 * \retval PASS New speed setting is accepted.
 * \retval FAIL New speed setting is rejected.
 */
uint32_t twi_set_speed(Twi *p_twi, uint32_t ul_speed, uint32_t ul_mck)
{
  402a54:	b480      	push	{r7}
  402a56:	b089      	sub	sp, #36	; 0x24
  402a58:	af00      	add	r7, sp, #0
  402a5a:	60f8      	str	r0, [r7, #12]
  402a5c:	60b9      	str	r1, [r7, #8]
  402a5e:	607a      	str	r2, [r7, #4]
	uint32_t ckdiv = 0;
  402a60:	2300      	movs	r3, #0
  402a62:	61fb      	str	r3, [r7, #28]
	uint32_t c_lh_div;
	uint32_t cldiv, chdiv;

	if (ul_speed > I2C_FAST_MODE_SPEED) {
  402a64:	68bb      	ldr	r3, [r7, #8]
  402a66:	4a34      	ldr	r2, [pc, #208]	; (402b38 <twi_set_speed+0xe4>)
  402a68:	4293      	cmp	r3, r2
  402a6a:	d901      	bls.n	402a70 <twi_set_speed+0x1c>
		return FAIL;
  402a6c:	2301      	movs	r3, #1
  402a6e:	e05d      	b.n	402b2c <twi_set_speed+0xd8>
	}

	/* Low level time not less than 1.3us of I2C Fast Mode. */
	if (ul_speed > LOW_LEVEL_TIME_LIMIT) {
  402a70:	68bb      	ldr	r3, [r7, #8]
  402a72:	4a32      	ldr	r2, [pc, #200]	; (402b3c <twi_set_speed+0xe8>)
  402a74:	4293      	cmp	r3, r2
  402a76:	d937      	bls.n	402ae8 <twi_set_speed+0x94>
		/* Low level of time fixed for 1.3us. */
		cldiv = ul_mck / (LOW_LEVEL_TIME_LIMIT * TWI_CLK_DIVIDER) - TWI_CLK_CALC_ARGU;
  402a78:	687b      	ldr	r3, [r7, #4]
  402a7a:	4a31      	ldr	r2, [pc, #196]	; (402b40 <twi_set_speed+0xec>)
  402a7c:	fba2 2303 	umull	r2, r3, r2, r3
  402a80:	0b9b      	lsrs	r3, r3, #14
  402a82:	3b04      	subs	r3, #4
  402a84:	617b      	str	r3, [r7, #20]
		chdiv = ul_mck / ((ul_speed + (ul_speed - LOW_LEVEL_TIME_LIMIT)) * TWI_CLK_DIVIDER) - TWI_CLK_CALC_ARGU;
  402a86:	68ba      	ldr	r2, [r7, #8]
  402a88:	4b2e      	ldr	r3, [pc, #184]	; (402b44 <twi_set_speed+0xf0>)
  402a8a:	4413      	add	r3, r2
  402a8c:	009b      	lsls	r3, r3, #2
  402a8e:	687a      	ldr	r2, [r7, #4]
  402a90:	fbb2 f3f3 	udiv	r3, r2, r3
  402a94:	3b04      	subs	r3, #4
  402a96:	613b      	str	r3, [r7, #16]
		
		/* cldiv must fit in 8 bits, ckdiv must fit in 3 bits */
		while ((cldiv > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  402a98:	e005      	b.n	402aa6 <twi_set_speed+0x52>
			/* Increase clock divider */
			ckdiv++;
  402a9a:	69fb      	ldr	r3, [r7, #28]
  402a9c:	3301      	adds	r3, #1
  402a9e:	61fb      	str	r3, [r7, #28]
			/* Divide cldiv value */
			cldiv /= TWI_CLK_DIVIDER;
  402aa0:	697b      	ldr	r3, [r7, #20]
  402aa2:	085b      	lsrs	r3, r3, #1
  402aa4:	617b      	str	r3, [r7, #20]
		while ((cldiv > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  402aa6:	697b      	ldr	r3, [r7, #20]
  402aa8:	2bff      	cmp	r3, #255	; 0xff
  402aaa:	d909      	bls.n	402ac0 <twi_set_speed+0x6c>
  402aac:	69fb      	ldr	r3, [r7, #28]
  402aae:	2b06      	cmp	r3, #6
  402ab0:	d9f3      	bls.n	402a9a <twi_set_speed+0x46>
		}
		/* chdiv must fit in 8 bits, ckdiv must fit in 3 bits */
		while ((chdiv > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  402ab2:	e005      	b.n	402ac0 <twi_set_speed+0x6c>
			/* Increase clock divider */
			ckdiv++;
  402ab4:	69fb      	ldr	r3, [r7, #28]
  402ab6:	3301      	adds	r3, #1
  402ab8:	61fb      	str	r3, [r7, #28]
			/* Divide cldiv value */
			chdiv /= TWI_CLK_DIVIDER;
  402aba:	693b      	ldr	r3, [r7, #16]
  402abc:	085b      	lsrs	r3, r3, #1
  402abe:	613b      	str	r3, [r7, #16]
		while ((chdiv > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  402ac0:	693b      	ldr	r3, [r7, #16]
  402ac2:	2bff      	cmp	r3, #255	; 0xff
  402ac4:	d902      	bls.n	402acc <twi_set_speed+0x78>
  402ac6:	69fb      	ldr	r3, [r7, #28]
  402ac8:	2b06      	cmp	r3, #6
  402aca:	d9f3      	bls.n	402ab4 <twi_set_speed+0x60>
		}

		/* set clock waveform generator register */
		p_twi->TWI_CWGR =
				TWI_CWGR_CLDIV(cldiv) | TWI_CWGR_CHDIV(chdiv) |
  402acc:	697b      	ldr	r3, [r7, #20]
  402ace:	b2da      	uxtb	r2, r3
  402ad0:	693b      	ldr	r3, [r7, #16]
  402ad2:	021b      	lsls	r3, r3, #8
  402ad4:	b29b      	uxth	r3, r3
  402ad6:	431a      	orrs	r2, r3
				TWI_CWGR_CKDIV(ckdiv);		
  402ad8:	69fb      	ldr	r3, [r7, #28]
  402ada:	041b      	lsls	r3, r3, #16
  402adc:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
				TWI_CWGR_CLDIV(cldiv) | TWI_CWGR_CHDIV(chdiv) |
  402ae0:	431a      	orrs	r2, r3
		p_twi->TWI_CWGR =
  402ae2:	68fb      	ldr	r3, [r7, #12]
  402ae4:	611a      	str	r2, [r3, #16]
  402ae6:	e020      	b.n	402b2a <twi_set_speed+0xd6>
	} else {
		c_lh_div = ul_mck / (ul_speed * TWI_CLK_DIVIDER) - TWI_CLK_CALC_ARGU;
  402ae8:	68bb      	ldr	r3, [r7, #8]
  402aea:	005b      	lsls	r3, r3, #1
  402aec:	687a      	ldr	r2, [r7, #4]
  402aee:	fbb2 f3f3 	udiv	r3, r2, r3
  402af2:	3b04      	subs	r3, #4
  402af4:	61bb      	str	r3, [r7, #24]

		/* cldiv must fit in 8 bits, ckdiv must fit in 3 bits */
		while ((c_lh_div > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  402af6:	e005      	b.n	402b04 <twi_set_speed+0xb0>
			/* Increase clock divider */
			ckdiv++;
  402af8:	69fb      	ldr	r3, [r7, #28]
  402afa:	3301      	adds	r3, #1
  402afc:	61fb      	str	r3, [r7, #28]
			/* Divide cldiv value */
			c_lh_div /= TWI_CLK_DIVIDER;
  402afe:	69bb      	ldr	r3, [r7, #24]
  402b00:	085b      	lsrs	r3, r3, #1
  402b02:	61bb      	str	r3, [r7, #24]
		while ((c_lh_div > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  402b04:	69bb      	ldr	r3, [r7, #24]
  402b06:	2bff      	cmp	r3, #255	; 0xff
  402b08:	d902      	bls.n	402b10 <twi_set_speed+0xbc>
  402b0a:	69fb      	ldr	r3, [r7, #28]
  402b0c:	2b06      	cmp	r3, #6
  402b0e:	d9f3      	bls.n	402af8 <twi_set_speed+0xa4>
		}

		/* set clock waveform generator register */
		p_twi->TWI_CWGR =
				TWI_CWGR_CLDIV(c_lh_div) | TWI_CWGR_CHDIV(c_lh_div) |
  402b10:	69bb      	ldr	r3, [r7, #24]
  402b12:	b2da      	uxtb	r2, r3
  402b14:	69bb      	ldr	r3, [r7, #24]
  402b16:	021b      	lsls	r3, r3, #8
  402b18:	b29b      	uxth	r3, r3
  402b1a:	431a      	orrs	r2, r3
				TWI_CWGR_CKDIV(ckdiv);
  402b1c:	69fb      	ldr	r3, [r7, #28]
  402b1e:	041b      	lsls	r3, r3, #16
  402b20:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
				TWI_CWGR_CLDIV(c_lh_div) | TWI_CWGR_CHDIV(c_lh_div) |
  402b24:	431a      	orrs	r2, r3
		p_twi->TWI_CWGR =
  402b26:	68fb      	ldr	r3, [r7, #12]
  402b28:	611a      	str	r2, [r3, #16]
	}

	return PASS;
  402b2a:	2300      	movs	r3, #0
}
  402b2c:	4618      	mov	r0, r3
  402b2e:	3724      	adds	r7, #36	; 0x24
  402b30:	46bd      	mov	sp, r7
  402b32:	f85d 7b04 	ldr.w	r7, [sp], #4
  402b36:	4770      	bx	lr
  402b38:	00061a80 	.word	0x00061a80
  402b3c:	0005dc00 	.word	0x0005dc00
  402b40:	057619f1 	.word	0x057619f1
  402b44:	3ffd1200 	.word	0x3ffd1200

00402b48 <twi_mk_addr>:
 * which byte is the MSB to start with.
 *
 * Please see the device datasheet for details on this.
 */
uint32_t twi_mk_addr(const uint8_t *addr, int len)
{
  402b48:	b480      	push	{r7}
  402b4a:	b085      	sub	sp, #20
  402b4c:	af00      	add	r7, sp, #0
  402b4e:	6078      	str	r0, [r7, #4]
  402b50:	6039      	str	r1, [r7, #0]
	uint32_t val;

	if (len == 0)
  402b52:	683b      	ldr	r3, [r7, #0]
  402b54:	2b00      	cmp	r3, #0
  402b56:	d101      	bne.n	402b5c <twi_mk_addr+0x14>
		return 0;
  402b58:	2300      	movs	r3, #0
  402b5a:	e01d      	b.n	402b98 <twi_mk_addr+0x50>

	val = addr[0];
  402b5c:	687b      	ldr	r3, [r7, #4]
  402b5e:	781b      	ldrb	r3, [r3, #0]
  402b60:	60fb      	str	r3, [r7, #12]
	if (len > 1) {
  402b62:	683b      	ldr	r3, [r7, #0]
  402b64:	2b01      	cmp	r3, #1
  402b66:	dd09      	ble.n	402b7c <twi_mk_addr+0x34>
		val <<= 8;
  402b68:	68fb      	ldr	r3, [r7, #12]
  402b6a:	021b      	lsls	r3, r3, #8
  402b6c:	60fb      	str	r3, [r7, #12]
		val |= addr[1];
  402b6e:	687b      	ldr	r3, [r7, #4]
  402b70:	3301      	adds	r3, #1
  402b72:	781b      	ldrb	r3, [r3, #0]
  402b74:	461a      	mov	r2, r3
  402b76:	68fb      	ldr	r3, [r7, #12]
  402b78:	4313      	orrs	r3, r2
  402b7a:	60fb      	str	r3, [r7, #12]
	}
	if (len > 2) {
  402b7c:	683b      	ldr	r3, [r7, #0]
  402b7e:	2b02      	cmp	r3, #2
  402b80:	dd09      	ble.n	402b96 <twi_mk_addr+0x4e>
		val <<= 8;
  402b82:	68fb      	ldr	r3, [r7, #12]
  402b84:	021b      	lsls	r3, r3, #8
  402b86:	60fb      	str	r3, [r7, #12]
		val |= addr[2];
  402b88:	687b      	ldr	r3, [r7, #4]
  402b8a:	3302      	adds	r3, #2
  402b8c:	781b      	ldrb	r3, [r3, #0]
  402b8e:	461a      	mov	r2, r3
  402b90:	68fb      	ldr	r3, [r7, #12]
  402b92:	4313      	orrs	r3, r2
  402b94:	60fb      	str	r3, [r7, #12]
	}
	return val;
  402b96:	68fb      	ldr	r3, [r7, #12]
}
  402b98:	4618      	mov	r0, r3
  402b9a:	3714      	adds	r7, #20
  402b9c:	46bd      	mov	sp, r7
  402b9e:	f85d 7b04 	ldr.w	r7, [sp], #4
  402ba2:	4770      	bx	lr

00402ba4 <twi_master_write>:
 * \param p_packet Packet information and data (see \ref twi_packet_t).
 *
 * \return TWI_SUCCESS if all bytes were written, error code otherwise.
 */
uint32_t twi_master_write(Twi *p_twi, twi_packet_t *p_packet)
{
  402ba4:	b580      	push	{r7, lr}
  402ba6:	b086      	sub	sp, #24
  402ba8:	af00      	add	r7, sp, #0
  402baa:	6078      	str	r0, [r7, #4]
  402bac:	6039      	str	r1, [r7, #0]
	uint32_t status;
	uint32_t cnt = p_packet->length;
  402bae:	683b      	ldr	r3, [r7, #0]
  402bb0:	68db      	ldr	r3, [r3, #12]
  402bb2:	617b      	str	r3, [r7, #20]
	uint8_t *buffer = p_packet->buffer;
  402bb4:	683b      	ldr	r3, [r7, #0]
  402bb6:	689b      	ldr	r3, [r3, #8]
  402bb8:	613b      	str	r3, [r7, #16]

	/* Check argument */
	if (cnt == 0) {
  402bba:	697b      	ldr	r3, [r7, #20]
  402bbc:	2b00      	cmp	r3, #0
  402bbe:	d101      	bne.n	402bc4 <twi_master_write+0x20>
		return TWI_INVALID_ARGUMENT;
  402bc0:	2301      	movs	r3, #1
  402bc2:	e056      	b.n	402c72 <twi_master_write+0xce>
	}

	/* Set write mode, slave address and 3 internal address byte lengths */
	p_twi->TWI_MMR = 0;
  402bc4:	687b      	ldr	r3, [r7, #4]
  402bc6:	2200      	movs	r2, #0
  402bc8:	605a      	str	r2, [r3, #4]
	p_twi->TWI_MMR = TWI_MMR_DADR(p_packet->chip) |
  402bca:	683b      	ldr	r3, [r7, #0]
  402bcc:	7c1b      	ldrb	r3, [r3, #16]
  402bce:	041b      	lsls	r3, r3, #16
  402bd0:	f403 02fe 	and.w	r2, r3, #8323072	; 0x7f0000
			((p_packet->addr_length << TWI_MMR_IADRSZ_Pos) &
  402bd4:	683b      	ldr	r3, [r7, #0]
  402bd6:	685b      	ldr	r3, [r3, #4]
  402bd8:	021b      	lsls	r3, r3, #8
  402bda:	f403 7340 	and.w	r3, r3, #768	; 0x300
	p_twi->TWI_MMR = TWI_MMR_DADR(p_packet->chip) |
  402bde:	431a      	orrs	r2, r3
  402be0:	687b      	ldr	r3, [r7, #4]
  402be2:	605a      	str	r2, [r3, #4]
			TWI_MMR_IADRSZ_Msk);

	/* Set internal address for remote chip */
	p_twi->TWI_IADR = 0;
  402be4:	687b      	ldr	r3, [r7, #4]
  402be6:	2200      	movs	r2, #0
  402be8:	60da      	str	r2, [r3, #12]
	p_twi->TWI_IADR = twi_mk_addr(p_packet->addr, p_packet->addr_length);
  402bea:	683a      	ldr	r2, [r7, #0]
  402bec:	683b      	ldr	r3, [r7, #0]
  402bee:	685b      	ldr	r3, [r3, #4]
  402bf0:	4619      	mov	r1, r3
  402bf2:	4610      	mov	r0, r2
  402bf4:	4b21      	ldr	r3, [pc, #132]	; (402c7c <twi_master_write+0xd8>)
  402bf6:	4798      	blx	r3
  402bf8:	4602      	mov	r2, r0
  402bfa:	687b      	ldr	r3, [r7, #4]
  402bfc:	60da      	str	r2, [r3, #12]

	/* Send all bytes */
	while (cnt > 0) {
  402bfe:	e019      	b.n	402c34 <twi_master_write+0x90>
		status = p_twi->TWI_SR;
  402c00:	687b      	ldr	r3, [r7, #4]
  402c02:	6a1b      	ldr	r3, [r3, #32]
  402c04:	60fb      	str	r3, [r7, #12]
		if (status & TWI_SR_NACK) {
  402c06:	68fb      	ldr	r3, [r7, #12]
  402c08:	f403 7380 	and.w	r3, r3, #256	; 0x100
  402c0c:	2b00      	cmp	r3, #0
  402c0e:	d001      	beq.n	402c14 <twi_master_write+0x70>
			return TWI_RECEIVE_NACK;
  402c10:	2305      	movs	r3, #5
  402c12:	e02e      	b.n	402c72 <twi_master_write+0xce>
		}

		if (!(status & TWI_SR_TXRDY)) {
  402c14:	68fb      	ldr	r3, [r7, #12]
  402c16:	f003 0304 	and.w	r3, r3, #4
  402c1a:	2b00      	cmp	r3, #0
  402c1c:	d100      	bne.n	402c20 <twi_master_write+0x7c>
			continue;
  402c1e:	e009      	b.n	402c34 <twi_master_write+0x90>
		}
		p_twi->TWI_THR = *buffer++;
  402c20:	693b      	ldr	r3, [r7, #16]
  402c22:	1c5a      	adds	r2, r3, #1
  402c24:	613a      	str	r2, [r7, #16]
  402c26:	781b      	ldrb	r3, [r3, #0]
  402c28:	461a      	mov	r2, r3
  402c2a:	687b      	ldr	r3, [r7, #4]
  402c2c:	635a      	str	r2, [r3, #52]	; 0x34

		cnt--;
  402c2e:	697b      	ldr	r3, [r7, #20]
  402c30:	3b01      	subs	r3, #1
  402c32:	617b      	str	r3, [r7, #20]
	while (cnt > 0) {
  402c34:	697b      	ldr	r3, [r7, #20]
  402c36:	2b00      	cmp	r3, #0
  402c38:	d1e2      	bne.n	402c00 <twi_master_write+0x5c>
	}

	while (1) {
		status = p_twi->TWI_SR;
  402c3a:	687b      	ldr	r3, [r7, #4]
  402c3c:	6a1b      	ldr	r3, [r3, #32]
  402c3e:	60fb      	str	r3, [r7, #12]
		if (status & TWI_SR_NACK) {
  402c40:	68fb      	ldr	r3, [r7, #12]
  402c42:	f403 7380 	and.w	r3, r3, #256	; 0x100
  402c46:	2b00      	cmp	r3, #0
  402c48:	d001      	beq.n	402c4e <twi_master_write+0xaa>
			return TWI_RECEIVE_NACK;
  402c4a:	2305      	movs	r3, #5
  402c4c:	e011      	b.n	402c72 <twi_master_write+0xce>
		}

		if (status & TWI_SR_TXRDY) {
  402c4e:	68fb      	ldr	r3, [r7, #12]
  402c50:	f003 0304 	and.w	r3, r3, #4
  402c54:	2b00      	cmp	r3, #0
  402c56:	d100      	bne.n	402c5a <twi_master_write+0xb6>
		status = p_twi->TWI_SR;
  402c58:	e7ef      	b.n	402c3a <twi_master_write+0x96>
			break;
  402c5a:	bf00      	nop
		}
	}

	p_twi->TWI_CR = TWI_CR_STOP;
  402c5c:	687b      	ldr	r3, [r7, #4]
  402c5e:	2202      	movs	r2, #2
  402c60:	601a      	str	r2, [r3, #0]

	while (!(p_twi->TWI_SR & TWI_SR_TXCOMP)) {
  402c62:	bf00      	nop
  402c64:	687b      	ldr	r3, [r7, #4]
  402c66:	6a1b      	ldr	r3, [r3, #32]
  402c68:	f003 0301 	and.w	r3, r3, #1
  402c6c:	2b00      	cmp	r3, #0
  402c6e:	d0f9      	beq.n	402c64 <twi_master_write+0xc0>
	}

	return TWI_SUCCESS;
  402c70:	2300      	movs	r3, #0
}
  402c72:	4618      	mov	r0, r3
  402c74:	3718      	adds	r7, #24
  402c76:	46bd      	mov	sp, r7
  402c78:	bd80      	pop	{r7, pc}
  402c7a:	bf00      	nop
  402c7c:	00402b49 	.word	0x00402b49

00402c80 <twi_reset>:
 * \brief Reset TWI.
 *
 * \param p_twi Pointer to a TWI instance.
 */
void twi_reset(Twi *p_twi)
{
  402c80:	b480      	push	{r7}
  402c82:	b083      	sub	sp, #12
  402c84:	af00      	add	r7, sp, #0
  402c86:	6078      	str	r0, [r7, #4]
	/* Set SWRST bit to reset TWI peripheral */
	p_twi->TWI_CR = TWI_CR_SWRST;
  402c88:	687b      	ldr	r3, [r7, #4]
  402c8a:	2280      	movs	r2, #128	; 0x80
  402c8c:	601a      	str	r2, [r3, #0]
	p_twi->TWI_RHR;
  402c8e:	687b      	ldr	r3, [r7, #4]
  402c90:	6b1b      	ldr	r3, [r3, #48]	; 0x30
}
  402c92:	bf00      	nop
  402c94:	370c      	adds	r7, #12
  402c96:	46bd      	mov	sp, r7
  402c98:	f85d 7b04 	ldr.w	r7, [sp], #4
  402c9c:	4770      	bx	lr
	...

00402ca0 <__aeabi_uldivmod>:
  402ca0:	b953      	cbnz	r3, 402cb8 <__aeabi_uldivmod+0x18>
  402ca2:	b94a      	cbnz	r2, 402cb8 <__aeabi_uldivmod+0x18>
  402ca4:	2900      	cmp	r1, #0
  402ca6:	bf08      	it	eq
  402ca8:	2800      	cmpeq	r0, #0
  402caa:	bf1c      	itt	ne
  402cac:	f04f 31ff 	movne.w	r1, #4294967295
  402cb0:	f04f 30ff 	movne.w	r0, #4294967295
  402cb4:	f000 b97a 	b.w	402fac <__aeabi_idiv0>
  402cb8:	f1ad 0c08 	sub.w	ip, sp, #8
  402cbc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
  402cc0:	f000 f806 	bl	402cd0 <__udivmoddi4>
  402cc4:	f8dd e004 	ldr.w	lr, [sp, #4]
  402cc8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  402ccc:	b004      	add	sp, #16
  402cce:	4770      	bx	lr

00402cd0 <__udivmoddi4>:
  402cd0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  402cd4:	468c      	mov	ip, r1
  402cd6:	460d      	mov	r5, r1
  402cd8:	4604      	mov	r4, r0
  402cda:	9e08      	ldr	r6, [sp, #32]
  402cdc:	2b00      	cmp	r3, #0
  402cde:	d151      	bne.n	402d84 <__udivmoddi4+0xb4>
  402ce0:	428a      	cmp	r2, r1
  402ce2:	4617      	mov	r7, r2
  402ce4:	d96d      	bls.n	402dc2 <__udivmoddi4+0xf2>
  402ce6:	fab2 fe82 	clz	lr, r2
  402cea:	f1be 0f00 	cmp.w	lr, #0
  402cee:	d00b      	beq.n	402d08 <__udivmoddi4+0x38>
  402cf0:	f1ce 0c20 	rsb	ip, lr, #32
  402cf4:	fa01 f50e 	lsl.w	r5, r1, lr
  402cf8:	fa20 fc0c 	lsr.w	ip, r0, ip
  402cfc:	fa02 f70e 	lsl.w	r7, r2, lr
  402d00:	ea4c 0c05 	orr.w	ip, ip, r5
  402d04:	fa00 f40e 	lsl.w	r4, r0, lr
  402d08:	ea4f 4a17 	mov.w	sl, r7, lsr #16
  402d0c:	0c25      	lsrs	r5, r4, #16
  402d0e:	fbbc f8fa 	udiv	r8, ip, sl
  402d12:	fa1f f987 	uxth.w	r9, r7
  402d16:	fb0a cc18 	mls	ip, sl, r8, ip
  402d1a:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
  402d1e:	fb08 f309 	mul.w	r3, r8, r9
  402d22:	42ab      	cmp	r3, r5
  402d24:	d90a      	bls.n	402d3c <__udivmoddi4+0x6c>
  402d26:	19ed      	adds	r5, r5, r7
  402d28:	f108 32ff 	add.w	r2, r8, #4294967295
  402d2c:	f080 8123 	bcs.w	402f76 <__udivmoddi4+0x2a6>
  402d30:	42ab      	cmp	r3, r5
  402d32:	f240 8120 	bls.w	402f76 <__udivmoddi4+0x2a6>
  402d36:	f1a8 0802 	sub.w	r8, r8, #2
  402d3a:	443d      	add	r5, r7
  402d3c:	1aed      	subs	r5, r5, r3
  402d3e:	b2a4      	uxth	r4, r4
  402d40:	fbb5 f0fa 	udiv	r0, r5, sl
  402d44:	fb0a 5510 	mls	r5, sl, r0, r5
  402d48:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
  402d4c:	fb00 f909 	mul.w	r9, r0, r9
  402d50:	45a1      	cmp	r9, r4
  402d52:	d909      	bls.n	402d68 <__udivmoddi4+0x98>
  402d54:	19e4      	adds	r4, r4, r7
  402d56:	f100 33ff 	add.w	r3, r0, #4294967295
  402d5a:	f080 810a 	bcs.w	402f72 <__udivmoddi4+0x2a2>
  402d5e:	45a1      	cmp	r9, r4
  402d60:	f240 8107 	bls.w	402f72 <__udivmoddi4+0x2a2>
  402d64:	3802      	subs	r0, #2
  402d66:	443c      	add	r4, r7
  402d68:	eba4 0409 	sub.w	r4, r4, r9
  402d6c:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
  402d70:	2100      	movs	r1, #0
  402d72:	2e00      	cmp	r6, #0
  402d74:	d061      	beq.n	402e3a <__udivmoddi4+0x16a>
  402d76:	fa24 f40e 	lsr.w	r4, r4, lr
  402d7a:	2300      	movs	r3, #0
  402d7c:	6034      	str	r4, [r6, #0]
  402d7e:	6073      	str	r3, [r6, #4]
  402d80:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  402d84:	428b      	cmp	r3, r1
  402d86:	d907      	bls.n	402d98 <__udivmoddi4+0xc8>
  402d88:	2e00      	cmp	r6, #0
  402d8a:	d054      	beq.n	402e36 <__udivmoddi4+0x166>
  402d8c:	2100      	movs	r1, #0
  402d8e:	e886 0021 	stmia.w	r6, {r0, r5}
  402d92:	4608      	mov	r0, r1
  402d94:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  402d98:	fab3 f183 	clz	r1, r3
  402d9c:	2900      	cmp	r1, #0
  402d9e:	f040 808e 	bne.w	402ebe <__udivmoddi4+0x1ee>
  402da2:	42ab      	cmp	r3, r5
  402da4:	d302      	bcc.n	402dac <__udivmoddi4+0xdc>
  402da6:	4282      	cmp	r2, r0
  402da8:	f200 80fa 	bhi.w	402fa0 <__udivmoddi4+0x2d0>
  402dac:	1a84      	subs	r4, r0, r2
  402dae:	eb65 0503 	sbc.w	r5, r5, r3
  402db2:	2001      	movs	r0, #1
  402db4:	46ac      	mov	ip, r5
  402db6:	2e00      	cmp	r6, #0
  402db8:	d03f      	beq.n	402e3a <__udivmoddi4+0x16a>
  402dba:	e886 1010 	stmia.w	r6, {r4, ip}
  402dbe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  402dc2:	b912      	cbnz	r2, 402dca <__udivmoddi4+0xfa>
  402dc4:	2701      	movs	r7, #1
  402dc6:	fbb7 f7f2 	udiv	r7, r7, r2
  402dca:	fab7 fe87 	clz	lr, r7
  402dce:	f1be 0f00 	cmp.w	lr, #0
  402dd2:	d134      	bne.n	402e3e <__udivmoddi4+0x16e>
  402dd4:	1beb      	subs	r3, r5, r7
  402dd6:	0c3a      	lsrs	r2, r7, #16
  402dd8:	fa1f fc87 	uxth.w	ip, r7
  402ddc:	2101      	movs	r1, #1
  402dde:	fbb3 f8f2 	udiv	r8, r3, r2
  402de2:	0c25      	lsrs	r5, r4, #16
  402de4:	fb02 3318 	mls	r3, r2, r8, r3
  402de8:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
  402dec:	fb0c f308 	mul.w	r3, ip, r8
  402df0:	42ab      	cmp	r3, r5
  402df2:	d907      	bls.n	402e04 <__udivmoddi4+0x134>
  402df4:	19ed      	adds	r5, r5, r7
  402df6:	f108 30ff 	add.w	r0, r8, #4294967295
  402dfa:	d202      	bcs.n	402e02 <__udivmoddi4+0x132>
  402dfc:	42ab      	cmp	r3, r5
  402dfe:	f200 80d1 	bhi.w	402fa4 <__udivmoddi4+0x2d4>
  402e02:	4680      	mov	r8, r0
  402e04:	1aed      	subs	r5, r5, r3
  402e06:	b2a3      	uxth	r3, r4
  402e08:	fbb5 f0f2 	udiv	r0, r5, r2
  402e0c:	fb02 5510 	mls	r5, r2, r0, r5
  402e10:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
  402e14:	fb0c fc00 	mul.w	ip, ip, r0
  402e18:	45a4      	cmp	ip, r4
  402e1a:	d907      	bls.n	402e2c <__udivmoddi4+0x15c>
  402e1c:	19e4      	adds	r4, r4, r7
  402e1e:	f100 33ff 	add.w	r3, r0, #4294967295
  402e22:	d202      	bcs.n	402e2a <__udivmoddi4+0x15a>
  402e24:	45a4      	cmp	ip, r4
  402e26:	f200 80b8 	bhi.w	402f9a <__udivmoddi4+0x2ca>
  402e2a:	4618      	mov	r0, r3
  402e2c:	eba4 040c 	sub.w	r4, r4, ip
  402e30:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
  402e34:	e79d      	b.n	402d72 <__udivmoddi4+0xa2>
  402e36:	4631      	mov	r1, r6
  402e38:	4630      	mov	r0, r6
  402e3a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  402e3e:	f1ce 0420 	rsb	r4, lr, #32
  402e42:	fa05 f30e 	lsl.w	r3, r5, lr
  402e46:	fa07 f70e 	lsl.w	r7, r7, lr
  402e4a:	fa20 f804 	lsr.w	r8, r0, r4
  402e4e:	0c3a      	lsrs	r2, r7, #16
  402e50:	fa25 f404 	lsr.w	r4, r5, r4
  402e54:	ea48 0803 	orr.w	r8, r8, r3
  402e58:	fbb4 f1f2 	udiv	r1, r4, r2
  402e5c:	ea4f 4518 	mov.w	r5, r8, lsr #16
  402e60:	fb02 4411 	mls	r4, r2, r1, r4
  402e64:	fa1f fc87 	uxth.w	ip, r7
  402e68:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
  402e6c:	fb01 f30c 	mul.w	r3, r1, ip
  402e70:	42ab      	cmp	r3, r5
  402e72:	fa00 f40e 	lsl.w	r4, r0, lr
  402e76:	d909      	bls.n	402e8c <__udivmoddi4+0x1bc>
  402e78:	19ed      	adds	r5, r5, r7
  402e7a:	f101 30ff 	add.w	r0, r1, #4294967295
  402e7e:	f080 808a 	bcs.w	402f96 <__udivmoddi4+0x2c6>
  402e82:	42ab      	cmp	r3, r5
  402e84:	f240 8087 	bls.w	402f96 <__udivmoddi4+0x2c6>
  402e88:	3902      	subs	r1, #2
  402e8a:	443d      	add	r5, r7
  402e8c:	1aeb      	subs	r3, r5, r3
  402e8e:	fa1f f588 	uxth.w	r5, r8
  402e92:	fbb3 f0f2 	udiv	r0, r3, r2
  402e96:	fb02 3310 	mls	r3, r2, r0, r3
  402e9a:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
  402e9e:	fb00 f30c 	mul.w	r3, r0, ip
  402ea2:	42ab      	cmp	r3, r5
  402ea4:	d907      	bls.n	402eb6 <__udivmoddi4+0x1e6>
  402ea6:	19ed      	adds	r5, r5, r7
  402ea8:	f100 38ff 	add.w	r8, r0, #4294967295
  402eac:	d26f      	bcs.n	402f8e <__udivmoddi4+0x2be>
  402eae:	42ab      	cmp	r3, r5
  402eb0:	d96d      	bls.n	402f8e <__udivmoddi4+0x2be>
  402eb2:	3802      	subs	r0, #2
  402eb4:	443d      	add	r5, r7
  402eb6:	1aeb      	subs	r3, r5, r3
  402eb8:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
  402ebc:	e78f      	b.n	402dde <__udivmoddi4+0x10e>
  402ebe:	f1c1 0720 	rsb	r7, r1, #32
  402ec2:	fa22 f807 	lsr.w	r8, r2, r7
  402ec6:	408b      	lsls	r3, r1
  402ec8:	fa05 f401 	lsl.w	r4, r5, r1
  402ecc:	ea48 0303 	orr.w	r3, r8, r3
  402ed0:	fa20 fe07 	lsr.w	lr, r0, r7
  402ed4:	ea4f 4c13 	mov.w	ip, r3, lsr #16
  402ed8:	40fd      	lsrs	r5, r7
  402eda:	ea4e 0e04 	orr.w	lr, lr, r4
  402ede:	fbb5 f9fc 	udiv	r9, r5, ip
  402ee2:	ea4f 441e 	mov.w	r4, lr, lsr #16
  402ee6:	fb0c 5519 	mls	r5, ip, r9, r5
  402eea:	fa1f f883 	uxth.w	r8, r3
  402eee:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
  402ef2:	fb09 f408 	mul.w	r4, r9, r8
  402ef6:	42ac      	cmp	r4, r5
  402ef8:	fa02 f201 	lsl.w	r2, r2, r1
  402efc:	fa00 fa01 	lsl.w	sl, r0, r1
  402f00:	d908      	bls.n	402f14 <__udivmoddi4+0x244>
  402f02:	18ed      	adds	r5, r5, r3
  402f04:	f109 30ff 	add.w	r0, r9, #4294967295
  402f08:	d243      	bcs.n	402f92 <__udivmoddi4+0x2c2>
  402f0a:	42ac      	cmp	r4, r5
  402f0c:	d941      	bls.n	402f92 <__udivmoddi4+0x2c2>
  402f0e:	f1a9 0902 	sub.w	r9, r9, #2
  402f12:	441d      	add	r5, r3
  402f14:	1b2d      	subs	r5, r5, r4
  402f16:	fa1f fe8e 	uxth.w	lr, lr
  402f1a:	fbb5 f0fc 	udiv	r0, r5, ip
  402f1e:	fb0c 5510 	mls	r5, ip, r0, r5
  402f22:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
  402f26:	fb00 f808 	mul.w	r8, r0, r8
  402f2a:	45a0      	cmp	r8, r4
  402f2c:	d907      	bls.n	402f3e <__udivmoddi4+0x26e>
  402f2e:	18e4      	adds	r4, r4, r3
  402f30:	f100 35ff 	add.w	r5, r0, #4294967295
  402f34:	d229      	bcs.n	402f8a <__udivmoddi4+0x2ba>
  402f36:	45a0      	cmp	r8, r4
  402f38:	d927      	bls.n	402f8a <__udivmoddi4+0x2ba>
  402f3a:	3802      	subs	r0, #2
  402f3c:	441c      	add	r4, r3
  402f3e:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
  402f42:	eba4 0408 	sub.w	r4, r4, r8
  402f46:	fba0 8902 	umull	r8, r9, r0, r2
  402f4a:	454c      	cmp	r4, r9
  402f4c:	46c6      	mov	lr, r8
  402f4e:	464d      	mov	r5, r9
  402f50:	d315      	bcc.n	402f7e <__udivmoddi4+0x2ae>
  402f52:	d012      	beq.n	402f7a <__udivmoddi4+0x2aa>
  402f54:	b156      	cbz	r6, 402f6c <__udivmoddi4+0x29c>
  402f56:	ebba 030e 	subs.w	r3, sl, lr
  402f5a:	eb64 0405 	sbc.w	r4, r4, r5
  402f5e:	fa04 f707 	lsl.w	r7, r4, r7
  402f62:	40cb      	lsrs	r3, r1
  402f64:	431f      	orrs	r7, r3
  402f66:	40cc      	lsrs	r4, r1
  402f68:	6037      	str	r7, [r6, #0]
  402f6a:	6074      	str	r4, [r6, #4]
  402f6c:	2100      	movs	r1, #0
  402f6e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  402f72:	4618      	mov	r0, r3
  402f74:	e6f8      	b.n	402d68 <__udivmoddi4+0x98>
  402f76:	4690      	mov	r8, r2
  402f78:	e6e0      	b.n	402d3c <__udivmoddi4+0x6c>
  402f7a:	45c2      	cmp	sl, r8
  402f7c:	d2ea      	bcs.n	402f54 <__udivmoddi4+0x284>
  402f7e:	ebb8 0e02 	subs.w	lr, r8, r2
  402f82:	eb69 0503 	sbc.w	r5, r9, r3
  402f86:	3801      	subs	r0, #1
  402f88:	e7e4      	b.n	402f54 <__udivmoddi4+0x284>
  402f8a:	4628      	mov	r0, r5
  402f8c:	e7d7      	b.n	402f3e <__udivmoddi4+0x26e>
  402f8e:	4640      	mov	r0, r8
  402f90:	e791      	b.n	402eb6 <__udivmoddi4+0x1e6>
  402f92:	4681      	mov	r9, r0
  402f94:	e7be      	b.n	402f14 <__udivmoddi4+0x244>
  402f96:	4601      	mov	r1, r0
  402f98:	e778      	b.n	402e8c <__udivmoddi4+0x1bc>
  402f9a:	3802      	subs	r0, #2
  402f9c:	443c      	add	r4, r7
  402f9e:	e745      	b.n	402e2c <__udivmoddi4+0x15c>
  402fa0:	4608      	mov	r0, r1
  402fa2:	e708      	b.n	402db6 <__udivmoddi4+0xe6>
  402fa4:	f1a8 0802 	sub.w	r8, r8, #2
  402fa8:	443d      	add	r5, r7
  402faa:	e72b      	b.n	402e04 <__udivmoddi4+0x134>

00402fac <__aeabi_idiv0>:
  402fac:	4770      	bx	lr
  402fae:	bf00      	nop

00402fb0 <__libc_init_array>:
  402fb0:	b570      	push	{r4, r5, r6, lr}
  402fb2:	4e0f      	ldr	r6, [pc, #60]	; (402ff0 <__libc_init_array+0x40>)
  402fb4:	4d0f      	ldr	r5, [pc, #60]	; (402ff4 <__libc_init_array+0x44>)
  402fb6:	1b76      	subs	r6, r6, r5
  402fb8:	10b6      	asrs	r6, r6, #2
  402fba:	bf18      	it	ne
  402fbc:	2400      	movne	r4, #0
  402fbe:	d005      	beq.n	402fcc <__libc_init_array+0x1c>
  402fc0:	3401      	adds	r4, #1
  402fc2:	f855 3b04 	ldr.w	r3, [r5], #4
  402fc6:	4798      	blx	r3
  402fc8:	42a6      	cmp	r6, r4
  402fca:	d1f9      	bne.n	402fc0 <__libc_init_array+0x10>
  402fcc:	4e0a      	ldr	r6, [pc, #40]	; (402ff8 <__libc_init_array+0x48>)
  402fce:	4d0b      	ldr	r5, [pc, #44]	; (402ffc <__libc_init_array+0x4c>)
  402fd0:	1b76      	subs	r6, r6, r5
  402fd2:	f000 fce5 	bl	4039a0 <_init>
  402fd6:	10b6      	asrs	r6, r6, #2
  402fd8:	bf18      	it	ne
  402fda:	2400      	movne	r4, #0
  402fdc:	d006      	beq.n	402fec <__libc_init_array+0x3c>
  402fde:	3401      	adds	r4, #1
  402fe0:	f855 3b04 	ldr.w	r3, [r5], #4
  402fe4:	4798      	blx	r3
  402fe6:	42a6      	cmp	r6, r4
  402fe8:	d1f9      	bne.n	402fde <__libc_init_array+0x2e>
  402fea:	bd70      	pop	{r4, r5, r6, pc}
  402fec:	bd70      	pop	{r4, r5, r6, pc}
  402fee:	bf00      	nop
  402ff0:	004039ac 	.word	0x004039ac
  402ff4:	004039ac 	.word	0x004039ac
  402ff8:	004039b4 	.word	0x004039b4
  402ffc:	004039ac 	.word	0x004039ac

00403000 <register_fini>:
  403000:	4b02      	ldr	r3, [pc, #8]	; (40300c <register_fini+0xc>)
  403002:	b113      	cbz	r3, 40300a <register_fini+0xa>
  403004:	4802      	ldr	r0, [pc, #8]	; (403010 <register_fini+0x10>)
  403006:	f000 b805 	b.w	403014 <atexit>
  40300a:	4770      	bx	lr
  40300c:	00000000 	.word	0x00000000
  403010:	00403021 	.word	0x00403021

00403014 <atexit>:
  403014:	2300      	movs	r3, #0
  403016:	4601      	mov	r1, r0
  403018:	461a      	mov	r2, r3
  40301a:	4618      	mov	r0, r3
  40301c:	f000 b81e 	b.w	40305c <__register_exitproc>

00403020 <__libc_fini_array>:
  403020:	b538      	push	{r3, r4, r5, lr}
  403022:	4c0a      	ldr	r4, [pc, #40]	; (40304c <__libc_fini_array+0x2c>)
  403024:	4d0a      	ldr	r5, [pc, #40]	; (403050 <__libc_fini_array+0x30>)
  403026:	1b64      	subs	r4, r4, r5
  403028:	10a4      	asrs	r4, r4, #2
  40302a:	d00a      	beq.n	403042 <__libc_fini_array+0x22>
  40302c:	f104 4380 	add.w	r3, r4, #1073741824	; 0x40000000
  403030:	3b01      	subs	r3, #1
  403032:	eb05 0583 	add.w	r5, r5, r3, lsl #2
  403036:	3c01      	subs	r4, #1
  403038:	f855 3904 	ldr.w	r3, [r5], #-4
  40303c:	4798      	blx	r3
  40303e:	2c00      	cmp	r4, #0
  403040:	d1f9      	bne.n	403036 <__libc_fini_array+0x16>
  403042:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  403046:	f000 bcb5 	b.w	4039b4 <_fini>
  40304a:	bf00      	nop
  40304c:	004039c4 	.word	0x004039c4
  403050:	004039c0 	.word	0x004039c0

00403054 <__retarget_lock_acquire_recursive>:
  403054:	4770      	bx	lr
  403056:	bf00      	nop

00403058 <__retarget_lock_release_recursive>:
  403058:	4770      	bx	lr
  40305a:	bf00      	nop

0040305c <__register_exitproc>:
  40305c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  403060:	4d2c      	ldr	r5, [pc, #176]	; (403114 <__register_exitproc+0xb8>)
  403062:	4606      	mov	r6, r0
  403064:	6828      	ldr	r0, [r5, #0]
  403066:	4698      	mov	r8, r3
  403068:	460f      	mov	r7, r1
  40306a:	4691      	mov	r9, r2
  40306c:	f7ff fff2 	bl	403054 <__retarget_lock_acquire_recursive>
  403070:	4b29      	ldr	r3, [pc, #164]	; (403118 <__register_exitproc+0xbc>)
  403072:	681c      	ldr	r4, [r3, #0]
  403074:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
  403078:	2b00      	cmp	r3, #0
  40307a:	d03e      	beq.n	4030fa <__register_exitproc+0x9e>
  40307c:	685a      	ldr	r2, [r3, #4]
  40307e:	2a1f      	cmp	r2, #31
  403080:	dc1c      	bgt.n	4030bc <__register_exitproc+0x60>
  403082:	f102 0e01 	add.w	lr, r2, #1
  403086:	b176      	cbz	r6, 4030a6 <__register_exitproc+0x4a>
  403088:	eb03 0182 	add.w	r1, r3, r2, lsl #2
  40308c:	2401      	movs	r4, #1
  40308e:	f8c1 9088 	str.w	r9, [r1, #136]	; 0x88
  403092:	f8d3 0188 	ldr.w	r0, [r3, #392]	; 0x188
  403096:	4094      	lsls	r4, r2
  403098:	4320      	orrs	r0, r4
  40309a:	2e02      	cmp	r6, #2
  40309c:	f8c3 0188 	str.w	r0, [r3, #392]	; 0x188
  4030a0:	f8c1 8108 	str.w	r8, [r1, #264]	; 0x108
  4030a4:	d023      	beq.n	4030ee <__register_exitproc+0x92>
  4030a6:	3202      	adds	r2, #2
  4030a8:	f8c3 e004 	str.w	lr, [r3, #4]
  4030ac:	6828      	ldr	r0, [r5, #0]
  4030ae:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
  4030b2:	f7ff ffd1 	bl	403058 <__retarget_lock_release_recursive>
  4030b6:	2000      	movs	r0, #0
  4030b8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  4030bc:	4b17      	ldr	r3, [pc, #92]	; (40311c <__register_exitproc+0xc0>)
  4030be:	b30b      	cbz	r3, 403104 <__register_exitproc+0xa8>
  4030c0:	f44f 70c8 	mov.w	r0, #400	; 0x190
  4030c4:	f3af 8000 	nop.w
  4030c8:	4603      	mov	r3, r0
  4030ca:	b1d8      	cbz	r0, 403104 <__register_exitproc+0xa8>
  4030cc:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
  4030d0:	6002      	str	r2, [r0, #0]
  4030d2:	2100      	movs	r1, #0
  4030d4:	6041      	str	r1, [r0, #4]
  4030d6:	460a      	mov	r2, r1
  4030d8:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
  4030dc:	f04f 0e01 	mov.w	lr, #1
  4030e0:	f8c0 1188 	str.w	r1, [r0, #392]	; 0x188
  4030e4:	f8c0 118c 	str.w	r1, [r0, #396]	; 0x18c
  4030e8:	2e00      	cmp	r6, #0
  4030ea:	d0dc      	beq.n	4030a6 <__register_exitproc+0x4a>
  4030ec:	e7cc      	b.n	403088 <__register_exitproc+0x2c>
  4030ee:	f8d3 118c 	ldr.w	r1, [r3, #396]	; 0x18c
  4030f2:	430c      	orrs	r4, r1
  4030f4:	f8c3 418c 	str.w	r4, [r3, #396]	; 0x18c
  4030f8:	e7d5      	b.n	4030a6 <__register_exitproc+0x4a>
  4030fa:	f504 73a6 	add.w	r3, r4, #332	; 0x14c
  4030fe:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
  403102:	e7bb      	b.n	40307c <__register_exitproc+0x20>
  403104:	6828      	ldr	r0, [r5, #0]
  403106:	f7ff ffa7 	bl	403058 <__retarget_lock_release_recursive>
  40310a:	f04f 30ff 	mov.w	r0, #4294967295
  40310e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  403112:	bf00      	nop
  403114:	20000448 	.word	0x20000448
  403118:	0040399c 	.word	0x0040399c
  40311c:	00000000 	.word	0x00000000

00403120 <IO_SENSOR>:
	...
  403130:	00000001 400e1000 0000000a 00004000     .......@.....@..
  403140:	0000002e 00000001 400e1000 0000000a     ...........@....
  403150:	00002000 0000002d 00000001 400e1400     . ..-..........@
  403160:	0000000c 00000001 00000060 00000001     ........`.......
  403170:	400e1400 0000000c 80000000 0000007f     ...@............
  403180:	00000001 400e1600 0000000d 00000008     .......@........
  403190:	00000083 00000001 400e1600 0000000d     ...........@....
  4031a0:	00000001 00000080 00000001 400e1600     ...............@
  4031b0:	0000000d 00000002 00000081 00000001     ................
  4031c0:	400e1600 0000000d 00000004 00000082     ...@............
  4031d0:	00000001 400e1200 0000000b 08000000     .......@........
  4031e0:	0000005b 00000001 400e1200 0000000b     [..........@....
  4031f0:	00000001 00000040 00000001 400e1200     ....@..........@
  403200:	0000000b 04000000 0000005a 00000001     ........Z.......
  403210:	400e1200 0000000b 80000000 0000005f     ...@........_...
  403220:	00000001 400e1200 0000000b 40000000     .......@.......@
  403230:	0000005e 00000001 400e1200 0000000b     ^..........@....
  403240:	20000000 0000005d 00000001 400e1200     ... ]..........@
  403250:	0000000b 00002000 0000004d 00000001     ..... ..M.......
  403260:	400e1000 0000000a 00000001 00000020     ...@........ ...
  403270:	00000001 400e1000 0000000a 00000002     .......@........
  403280:	00000021 00000001 400e0e00 00000009     !..........@....
  403290:	00100000 00000014 00000001 400e0e00     ...............@
  4032a0:	00000009 00020000 00000011 00000001     ................
  4032b0:	400e1600 0000000d 00000010 00000084     ...@............
  4032c0:	00000001 400e0e00 00000009 00080000     .......@........
  4032d0:	00000013 00000001 400e1600 0000000d     ...........@....
  4032e0:	00000020 00000085 00000001 400e1000      ..............@
  4032f0:	0000000a 00000004 00000022 00000001     ........".......
  403300:	400e0e00 00000009 00040000 00000012     ...@............
  403310:	00000001 400e0e00 00000009 00200000     .......@...... .
  403320:	00000015 00000001 400e1000 0000000a     ...........@....
  403330:	00000008 00000023 00000001 400e1400     ....#..........@
  403340:	0000000c 04000000 0000007a 00000001     ........z.......
  403350:	400e1400 0000000c 40000000 0000007e     ...@.......@~...
  403360:	00000001 400e0e00 00000009 00800000     .......@........
  403370:	00000017 00000001 400e0e00 00000009     ...........@....
  403380:	00004000 0000000e 00000001 400e1400     .@.............@
  403390:	0000000c 00200000 00000075 00000001     ...... .u.......
  4033a0:	400e1400 0000000c 02000000 00000079     ...@........y...
  4033b0:	00000001 400e0e00 00000009 00010000     .......@........
  4033c0:	00000010 00000001 400e1400 0000000c     ...........@....
  4033d0:	00100000 00000074 00000001 400e0e00     ....t..........@
  4033e0:	00000009 00008000 0000000f 00000001     ................
  4033f0:	400e1200 0000000b 00000080 00000047     ...@........G...
  403400:	00000001 400e1400 0000000c 08000000     .......@........
  403410:	0000007b 00000001 400e0e00 00000009     {..........@....
  403420:	00400000 00000016 00000001 400e1200     ..@............@
  403430:	0000000b 00000002 00000041 00000001     ........A.......
  403440:	400e1200 0000000b 00000004 00000042     ...@........B...
  403450:	00000001 400e1200 0000000b 00000008     .......@........
  403460:	00000043 00000001 400e1200 0000000b     C..........@....
  403470:	00000010 00000044 00000001 400e0e00     ....D..........@
  403480:	00000009 00002000 0000000d 00000001     ..... ..........
  403490:	400e1200 0000000b 00000020 00000045     ...@.... ...E...
  4034a0:	00000001 400e1200 0000000b 00000040     .......@....@...
  4034b0:	00000046 00000001 400e1400 0000000c     F..........@....
  4034c0:	01000000 00000078 00000001 400e0e00     ....x..........@
  4034d0:	00000009 01000000 00000018 00000001     ................
  4034e0:	400e1400 0000000c 00800000 00000077     ...@........w...
  4034f0:	00000001 400e0e00 00000009 02000000     .......@........
  403500:	00000019 00000001 400e1400 0000000c     ...........@....
  403510:	00400000 00000076 00000001 400e1400     ..@.v..........@
  403520:	0000000c 00080000 00000073 00000001     ........s.......
  403530:	400e0e00 00000009 00001000 0000000c     ...@............
  403540:	00000001 400e1400 0000000c 00040000     .......@........
  403550:	00000072 00000001 400e0e00 00000009     r..........@....
  403560:	00000800 0000000b 00000001 400e1400     ...............@
  403570:	0000000c 00002000 0000006d 00000001     ..... ..m.......
  403580:	400e1200 0000000b 00000200 00000049     ...@........I...
  403590:	00000001 400e1400 0000000c 00004000     .......@.....@..
  4035a0:	0000006e 00000001 400e1400 0000000c     n..........@....
  4035b0:	10000000 0000007c 00000001 400e1200     ....|..........@
  4035c0:	0000000b 10000000 0000005c 00000001     ........\.......
  4035d0:	400e1000 0000000a 00000040 00000026     ...@....@...&...
  4035e0:	00000001 400e0e00 00000009 00000020     .......@.... ...
  4035f0:	00000005 00000001 400e1400 0000000c     ...........@....
  403600:	00020000 00000071 00000001 400e1400     ....q..........@
  403610:	0000000c 00010000 00000070 00000001     ........p.......
  403620:	400e1200 0000000b 00000100 00000048     ...@........H...
  403630:	00000001 400e1400 0000000c 00001000     .......@........
  403640:	0000006c 00000001 400e1200 0000000b     l..........@....
  403650:	00000800 0000004b 00000001 400e0e00     ....K..........@
  403660:	00000009 00000004 00000002 00000001     ................
  403670:	400e1000 0000000a 00001000 0000002c     ...@........,...
  403680:	00000001 400e1200 0000000b 00004000     .......@.....@..
  403690:	0000004e 00000001 400e1400 0000000c     N..........@....
  4036a0:	00000080 00000067 00000001 400e1000     ....g..........@
  4036b0:	0000000a 00000080 00000027 00000001     ........'.......
  4036c0:	400e1200 0000000b 00000400 0000004a     ...@........J...
  4036d0:	00000001 400e1400 0000000c 00000800     .......@........
  4036e0:	0000006b 00000001 400e0e00 00000009     k..........@....
  4036f0:	00000002 00000001 00000001 400e1200     ...............@
  403700:	0000000b 00010000 00000050 00000001     ........P.......
  403710:	400e1400 0000000c 00000400 0000006a     ...@........j...
  403720:	00000001 400e0e00 00000009 00000001     .......@........
  403730:	00000000 00000001 400e1200 0000000b     ...........@....
  403740:	00020000 00000051 00000001 400e1200     ....Q..........@
  403750:	0000000b 00080000 00000053 00000001     ........S.......
  403760:	400e1000 0000000a 00000010 00000024     ...@........$...
  403770:	00000001 400e1400 0000000c 00008000     .......@........
  403780:	0000006f 00000001 400e1400 0000000c     o..........@....
  403790:	20000000 0000007d 00000001 400e1000     ... }..........@
  4037a0:	0000000a 00000020 00000025 00000001     .... ...%.......
  4037b0:	400e1400 0000000c 00000200 00000069     ...@........i...
  4037c0:	00000001 400e1200 0000000b 00040000     .......@........
  4037d0:	00000052 00000001 400e1400 0000000c     R..........@....
  4037e0:	00000100 00000068 00000001 400e0e00     ....h..........@
  4037f0:	00000009 00000040 00000006 00000001     ....@...........
  403800:	400e1200 0000000b 00100000 00000054     ...@........T...
  403810:	00000001 400e1200 0000000b 00400000     .......@......@.
  403820:	00000056 00000001 400e1400 0000000c     V..........@....
  403830:	00000040 00000066 00000001 400e1200     @...f..........@
  403840:	0000000b 00200000 00000055 00000001     ...... .U.......
  403850:	400e1200 0000000b 01000000 00000058     ...@........X...
  403860:	00000001 400e1400 0000000c 00000020     .......@.... ...
  403870:	00000065 00000001 400e1400 0000000c     e..........@....
  403880:	00000010 00000064 00000001 400e1200     ....d..........@
  403890:	0000000b 00800000 00000057 00000001     ........W.......
  4038a0:	400e1400 0000000c 00000004 00000062     ...@........b...
  4038b0:	00000001 400e1400 0000000c 00000008     .......@........
  4038c0:	00000063 00000001 400e1400 0000000c     c..........@....
  4038d0:	00000002 00000061 00000001 400e1200     ....a..........@
  4038e0:	0000000b 02000000 00000059 00000000     ........Y.......

004038f0 <SSD1311_CFG_SCRIPT>:
  4038f0:	08020000 71022a02 72020003 79020003     .....*.q...r...y
  403900:	7f028102 6002d502 7802d902 1002da02     .......`...x....
  403910:	4002db02 0302dc02 78027804 06020902     ...@.....x.x....
  403920:	01022802 06020202 05040c02 00000101     .(..............

00403930 <can_bit_time>:
  403930:	02020308 02094b03 43020303 0303030a     .....K.....C....
  403940:	040b4603 48040303 0404030c 040d4304     .F.....H.....C..
  403950:	4d040404 0504040e 040f4004 43040505     ...M.....@.....C
  403960:	05050510 06114504 47040505 06060512     .....E.....G....
  403970:	06134304 44040606 06060714 08154604     .C.....D.....F..
  403980:	47040606 07070716 08174404 46040708     ...G.....D.....F
  403990:	08080718 08194304 44040808              .....C.....D

0040399c <_global_impure_ptr>:
  40399c:	20000020                                 .. 

004039a0 <_init>:
  4039a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4039a2:	bf00      	nop
  4039a4:	bcf8      	pop	{r3, r4, r5, r6, r7}
  4039a6:	bc08      	pop	{r3}
  4039a8:	469e      	mov	lr, r3
  4039aa:	4770      	bx	lr

004039ac <__init_array_start>:
  4039ac:	00403001 	.word	0x00403001

004039b0 <__frame_dummy_init_array_entry>:
  4039b0:	0040011d                                ..@.

004039b4 <_fini>:
  4039b4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  4039b6:	bf00      	nop
  4039b8:	bcf8      	pop	{r3, r4, r5, r6, r7}
  4039ba:	bc08      	pop	{r3}
  4039bc:	469e      	mov	lr, r3
  4039be:	4770      	bx	lr

004039c0 <__fini_array_start>:
  4039c0:	004000f9 	.word	0x004000f9

Disassembly of section .relocate:

20000000 <portable_delay_cycles>:
RAMFUNC
void portable_delay_cycles(unsigned long n)
{
	UNUSED(n);

	__asm (
20000000:	f3bf 8f5f 	dmb	sy
20000004:	3801      	subs	r0, #1
20000006:	d1fb      	bne.n	20000000 <portable_delay_cycles>
20000008:	4770      	bx	lr
	...

2000000c <uxCriticalNesting>:
2000000c:	aaaa aaaa                                   ....

20000010 <xFreeBytesRemaining>:
20000010:	a000 0000                                   ....

20000014 <xNextTaskUnblockTime>:
20000014:	ffff ffff                                   ....

20000018 <g_interrupt_enabled>:
20000018:	0001 0000                                   ....

2000001c <SystemCoreClock>:
2000001c:	0900 003d                                   ..=.

20000020 <impure_data>:
20000020:	0000 0000 030c 2000 0374 2000 03dc 2000     ....... t.. ... 
	...
200000c8:	0001 0000 0000 0000 330e abcd 1234 e66d     .........3..4.m.
200000d8:	deec 0005 000b 0000 0000 0000 0000 0000     ................
	...

20000448 <__atexit_recursive_mutex>:
20000448:	a7bc 2000                                   ... 
