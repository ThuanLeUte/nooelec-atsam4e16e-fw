
arm.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000039a0  00400000  00400000  00010000  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  004039a0  004039a0  000139a0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     0000044c  20000000  004039a8  00020000  2**3
                  CONTENTS, ALLOC, LOAD, CODE
  3 .bss          0000a390  20000450  00403df8  0002044c  2**3
                  ALLOC
  4 .stack        00003000  2000a7e0  0040e188  0002044c  2**0
                  ALLOC
  5 .ARM.attributes 0000002e  00000000  00000000  0002044c  2**0
                  CONTENTS, READONLY
  6 .comment      00000059  00000000  00000000  0002047a  2**0
                  CONTENTS, READONLY
  7 .debug_info   00021216  00000000  00000000  000204d3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000459c  00000000  00000000  000416e9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    000081a5  00000000  00000000  00045c85  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00000f78  00000000  00000000  0004de2a  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000e58  00000000  00000000  0004eda2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  0001d305  00000000  00000000  0004fbfa  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00016654  00000000  00000000  0006ceff  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    00071faa  00000000  00000000  00083553  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00003f00  00000000  00000000  000f5500  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <exception_table>:
  400000:	e0 d7 00 20 dd 1a 40 00 4f 1a 40 00 4f 1a 40 00     ... ..@.O.@.O.@.
  400010:	4f 1a 40 00 4f 1a 40 00 4f 1a 40 00 00 00 00 00     O.@.O.@.O.@.....
	...
  40002c:	41 03 40 00 4f 1a 40 00 00 00 00 00 e1 03 40 00     A.@.O.@.......@.
  40003c:	35 04 40 00 4f 1a 40 00 4f 1a 40 00 4f 1a 40 00     5.@.O.@.O.@.O.@.
  40004c:	4f 1a 40 00 4f 1a 40 00 4f 1a 40 00 4f 1a 40 00     O.@.O.@.O.@.O.@.
  40005c:	f9 0e 40 00 4f 1a 40 00 a5 21 40 00 bd 21 40 00     ..@.O.@..!@..!@.
  40006c:	d5 21 40 00 ed 21 40 00 05 22 40 00 4f 1a 40 00     .!@..!@.."@.O.@.
  40007c:	4f 1a 40 00 4f 1a 40 00 4f 1a 40 00 4f 1a 40 00     O.@.O.@.O.@.O.@.
  40008c:	4f 1a 40 00 4f 1a 40 00 4f 1a 40 00 4f 1a 40 00     O.@.O.@.O.@.O.@.
  40009c:	4f 1a 40 00 4f 1a 40 00 4f 1a 40 00 4f 1a 40 00     O.@.O.@.O.@.O.@.
  4000ac:	4f 1a 40 00 4f 1a 40 00 4f 1a 40 00 4f 1a 40 00     O.@.O.@.O.@.O.@.
  4000bc:	4f 1a 40 00 4f 1a 40 00 4f 1a 40 00 4f 1a 40 00     O.@.O.@.O.@.O.@.
  4000cc:	4f 1a 40 00 4f 1a 40 00 4f 1a 40 00 4f 1a 40 00     O.@.O.@.O.@.O.@.
  4000dc:	4f 1a 40 00 4f 1a 40 00 4f 1a 40 00 4f 1a 40 00     O.@.O.@.O.@.O.@.
  4000ec:	4f 1a 40 00 4f 1a 40 00 4f 1a 40 00                 O.@.O.@.O.@.

004000f8 <__do_global_dtors_aux>:
  4000f8:	b510      	push	{r4, lr}
  4000fa:	4c05      	ldr	r4, [pc, #20]	; (400110 <__do_global_dtors_aux+0x18>)
  4000fc:	7823      	ldrb	r3, [r4, #0]
  4000fe:	b933      	cbnz	r3, 40010e <__do_global_dtors_aux+0x16>
  400100:	4b04      	ldr	r3, [pc, #16]	; (400114 <__do_global_dtors_aux+0x1c>)
  400102:	b113      	cbz	r3, 40010a <__do_global_dtors_aux+0x12>
  400104:	4804      	ldr	r0, [pc, #16]	; (400118 <__do_global_dtors_aux+0x20>)
  400106:	f3af 8000 	nop.w
  40010a:	2301      	movs	r3, #1
  40010c:	7023      	strb	r3, [r4, #0]
  40010e:	bd10      	pop	{r4, pc}
  400110:	20000450 	.word	0x20000450
  400114:	00000000 	.word	0x00000000
  400118:	004039a8 	.word	0x004039a8

0040011c <frame_dummy>:
  40011c:	4b0c      	ldr	r3, [pc, #48]	; (400150 <frame_dummy+0x34>)
  40011e:	b143      	cbz	r3, 400132 <frame_dummy+0x16>
  400120:	480c      	ldr	r0, [pc, #48]	; (400154 <frame_dummy+0x38>)
  400122:	490d      	ldr	r1, [pc, #52]	; (400158 <frame_dummy+0x3c>)
  400124:	b510      	push	{r4, lr}
  400126:	f3af 8000 	nop.w
  40012a:	480c      	ldr	r0, [pc, #48]	; (40015c <frame_dummy+0x40>)
  40012c:	6803      	ldr	r3, [r0, #0]
  40012e:	b923      	cbnz	r3, 40013a <frame_dummy+0x1e>
  400130:	bd10      	pop	{r4, pc}
  400132:	480a      	ldr	r0, [pc, #40]	; (40015c <frame_dummy+0x40>)
  400134:	6803      	ldr	r3, [r0, #0]
  400136:	b933      	cbnz	r3, 400146 <frame_dummy+0x2a>
  400138:	4770      	bx	lr
  40013a:	4b09      	ldr	r3, [pc, #36]	; (400160 <frame_dummy+0x44>)
  40013c:	2b00      	cmp	r3, #0
  40013e:	d0f7      	beq.n	400130 <frame_dummy+0x14>
  400140:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  400144:	4718      	bx	r3
  400146:	4b06      	ldr	r3, [pc, #24]	; (400160 <frame_dummy+0x44>)
  400148:	2b00      	cmp	r3, #0
  40014a:	d0f5      	beq.n	400138 <frame_dummy+0x1c>
  40014c:	4718      	bx	r3
  40014e:	bf00      	nop
  400150:	00000000 	.word	0x00000000
  400154:	004039a8 	.word	0x004039a8
  400158:	20000454 	.word	0x20000454
  40015c:	004039a8 	.word	0x004039a8
  400160:	00000000 	.word	0x00000000

00400164 <uart_init>:
 *
 * \retval 0 Success.
 * \retval 1 Bad baud rate generator value.
 */
uint32_t uart_init(Uart *p_uart, const sam_uart_opt_t *p_uart_opt)
{
  400164:	b480      	push	{r7}
  400166:	b085      	sub	sp, #20
  400168:	af00      	add	r7, sp, #0
  40016a:	6078      	str	r0, [r7, #4]
  40016c:	6039      	str	r1, [r7, #0]
	uint32_t cd = 0;
  40016e:	2300      	movs	r3, #0
  400170:	60fb      	str	r3, [r7, #12]

	/* Reset and disable receiver & transmitter */
	p_uart->UART_CR = UART_CR_RSTRX | UART_CR_RSTTX
  400172:	687b      	ldr	r3, [r7, #4]
  400174:	22ac      	movs	r2, #172	; 0xac
  400176:	601a      	str	r2, [r3, #0]
			| UART_CR_RXDIS | UART_CR_TXDIS;

	/* Check and configure baudrate */
	/* Asynchronous, no oversampling */
	cd = (p_uart_opt->ul_mck / p_uart_opt->ul_baudrate) / UART_MCK_DIV;
  400178:	683b      	ldr	r3, [r7, #0]
  40017a:	681a      	ldr	r2, [r3, #0]
  40017c:	683b      	ldr	r3, [r7, #0]
  40017e:	685b      	ldr	r3, [r3, #4]
  400180:	fbb2 f3f3 	udiv	r3, r2, r3
  400184:	091b      	lsrs	r3, r3, #4
  400186:	60fb      	str	r3, [r7, #12]
	if (cd < UART_MCK_DIV_MIN_FACTOR || cd > UART_MCK_DIV_MAX_FACTOR)
  400188:	68fb      	ldr	r3, [r7, #12]
  40018a:	2b00      	cmp	r3, #0
  40018c:	d003      	beq.n	400196 <uart_init+0x32>
  40018e:	68fb      	ldr	r3, [r7, #12]
  400190:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
  400194:	d301      	bcc.n	40019a <uart_init+0x36>
		return 1;
  400196:	2301      	movs	r3, #1
  400198:	e00f      	b.n	4001ba <uart_init+0x56>

	p_uart->UART_BRGR = cd;
  40019a:	687b      	ldr	r3, [r7, #4]
  40019c:	68fa      	ldr	r2, [r7, #12]
  40019e:	621a      	str	r2, [r3, #32]
	/* Configure mode */
	p_uart->UART_MR = p_uart_opt->ul_mode;
  4001a0:	683b      	ldr	r3, [r7, #0]
  4001a2:	689a      	ldr	r2, [r3, #8]
  4001a4:	687b      	ldr	r3, [r7, #4]
  4001a6:	605a      	str	r2, [r3, #4]

#if (!SAMV71 && !SAMV70 && !SAME70 && !SAMS70)
	/* Disable PDC channel */
	p_uart->UART_PTCR = UART_PTCR_RXTDIS | UART_PTCR_TXTDIS;
  4001a8:	687b      	ldr	r3, [r7, #4]
  4001aa:	f240 2202 	movw	r2, #514	; 0x202
  4001ae:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
#endif

	/* Enable receiver and transmitter */
	p_uart->UART_CR = UART_CR_RXEN | UART_CR_TXEN;
  4001b2:	687b      	ldr	r3, [r7, #4]
  4001b4:	2250      	movs	r2, #80	; 0x50
  4001b6:	601a      	str	r2, [r3, #0]

	return 0;
  4001b8:	2300      	movs	r3, #0
}
  4001ba:	4618      	mov	r0, r3
  4001bc:	3714      	adds	r7, #20
  4001be:	46bd      	mov	sp, r7
  4001c0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4001c4:	4770      	bx	lr

004001c6 <uart_enable_interrupt>:
 *
 * \param p_uart Pointer to a UART instance.
 *  \param ul_sources Interrupts to be enabled.
 */
void uart_enable_interrupt(Uart *p_uart, uint32_t ul_sources)
{
  4001c6:	b480      	push	{r7}
  4001c8:	b083      	sub	sp, #12
  4001ca:	af00      	add	r7, sp, #0
  4001cc:	6078      	str	r0, [r7, #4]
  4001ce:	6039      	str	r1, [r7, #0]
	p_uart->UART_IER = ul_sources;
  4001d0:	687b      	ldr	r3, [r7, #4]
  4001d2:	683a      	ldr	r2, [r7, #0]
  4001d4:	609a      	str	r2, [r3, #8]
}
  4001d6:	bf00      	nop
  4001d8:	370c      	adds	r7, #12
  4001da:	46bd      	mov	sp, r7
  4001dc:	f85d 7b04 	ldr.w	r7, [sp], #4
  4001e0:	4770      	bx	lr

004001e2 <uart_get_status>:
 * \param p_uart Pointer to a UART instance.
 *
 * \return The current UART status.
 */
uint32_t uart_get_status(Uart *p_uart)
{
  4001e2:	b480      	push	{r7}
  4001e4:	b083      	sub	sp, #12
  4001e6:	af00      	add	r7, sp, #0
  4001e8:	6078      	str	r0, [r7, #4]
	return p_uart->UART_SR;
  4001ea:	687b      	ldr	r3, [r7, #4]
  4001ec:	695b      	ldr	r3, [r3, #20]
}
  4001ee:	4618      	mov	r0, r3
  4001f0:	370c      	adds	r7, #12
  4001f2:	46bd      	mov	sp, r7
  4001f4:	f85d 7b04 	ldr.w	r7, [sp], #4
  4001f8:	4770      	bx	lr

004001fa <uart_write>:
 *
 * \retval 0 Success.
 * \retval 1 I/O Failure, UART is not ready.
 */
uint32_t uart_write(Uart *p_uart, const uint8_t uc_data)
{
  4001fa:	b480      	push	{r7}
  4001fc:	b083      	sub	sp, #12
  4001fe:	af00      	add	r7, sp, #0
  400200:	6078      	str	r0, [r7, #4]
  400202:	460b      	mov	r3, r1
  400204:	70fb      	strb	r3, [r7, #3]
	/* Check if the transmitter is ready */
	if (!(p_uart->UART_SR & UART_SR_TXRDY))
  400206:	687b      	ldr	r3, [r7, #4]
  400208:	695b      	ldr	r3, [r3, #20]
  40020a:	f003 0302 	and.w	r3, r3, #2
  40020e:	2b00      	cmp	r3, #0
  400210:	d101      	bne.n	400216 <uart_write+0x1c>
		return 1;
  400212:	2301      	movs	r3, #1
  400214:	e003      	b.n	40021e <uart_write+0x24>

	/* Send character */
	p_uart->UART_THR = uc_data;
  400216:	78fa      	ldrb	r2, [r7, #3]
  400218:	687b      	ldr	r3, [r7, #4]
  40021a:	61da      	str	r2, [r3, #28]
	return 0;
  40021c:	2300      	movs	r3, #0
}
  40021e:	4618      	mov	r0, r3
  400220:	370c      	adds	r7, #12
  400222:	46bd      	mov	sp, r7
  400224:	f85d 7b04 	ldr.w	r7, [sp], #4
  400228:	4770      	bx	lr

0040022a <uart_read>:
 *
 * \retval 0 Success.
 * \retval 1 I/O Failure, UART is not ready.
 */
uint32_t uart_read(Uart *p_uart, uint8_t *puc_data)
{
  40022a:	b480      	push	{r7}
  40022c:	b083      	sub	sp, #12
  40022e:	af00      	add	r7, sp, #0
  400230:	6078      	str	r0, [r7, #4]
  400232:	6039      	str	r1, [r7, #0]
	/* Check if the receiver is ready */
	if ((p_uart->UART_SR & UART_SR_RXRDY) == 0)
  400234:	687b      	ldr	r3, [r7, #4]
  400236:	695b      	ldr	r3, [r3, #20]
  400238:	f003 0301 	and.w	r3, r3, #1
  40023c:	2b00      	cmp	r3, #0
  40023e:	d101      	bne.n	400244 <uart_read+0x1a>
		return 1;
  400240:	2301      	movs	r3, #1
  400242:	e005      	b.n	400250 <uart_read+0x26>

	/* Read character */
	*puc_data = (uint8_t) p_uart->UART_RHR;
  400244:	687b      	ldr	r3, [r7, #4]
  400246:	699b      	ldr	r3, [r3, #24]
  400248:	b2da      	uxtb	r2, r3
  40024a:	683b      	ldr	r3, [r7, #0]
  40024c:	701a      	strb	r2, [r3, #0]
	return 0;
  40024e:	2300      	movs	r3, #0
}
  400250:	4618      	mov	r0, r3
  400252:	370c      	adds	r7, #12
  400254:	46bd      	mov	sp, r7
  400256:	f85d 7b04 	ldr.w	r7, [sp], #4
  40025a:	4770      	bx	lr

0040025c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
  40025c:	b480      	push	{r7}
  40025e:	b083      	sub	sp, #12
  400260:	af00      	add	r7, sp, #0
  400262:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
  400264:	687b      	ldr	r3, [r7, #4]
  400266:	f103 0208 	add.w	r2, r3, #8
  40026a:	687b      	ldr	r3, [r7, #4]
  40026c:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
  40026e:	687b      	ldr	r3, [r7, #4]
  400270:	f04f 32ff 	mov.w	r2, #4294967295
  400274:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
  400276:	687b      	ldr	r3, [r7, #4]
  400278:	f103 0208 	add.w	r2, r3, #8
  40027c:	687b      	ldr	r3, [r7, #4]
  40027e:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
  400280:	687b      	ldr	r3, [r7, #4]
  400282:	f103 0208 	add.w	r2, r3, #8
  400286:	687b      	ldr	r3, [r7, #4]
  400288:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
  40028a:	687b      	ldr	r3, [r7, #4]
  40028c:	2200      	movs	r2, #0
  40028e:	601a      	str	r2, [r3, #0]
}
  400290:	bf00      	nop
  400292:	370c      	adds	r7, #12
  400294:	46bd      	mov	sp, r7
  400296:	f85d 7b04 	ldr.w	r7, [sp], #4
  40029a:	4770      	bx	lr

0040029c <vListInsertEnd>:
	pxItem->pvContainer = NULL;
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
  40029c:	b480      	push	{r7}
  40029e:	b085      	sub	sp, #20
  4002a0:	af00      	add	r7, sp, #0
  4002a2:	6078      	str	r0, [r7, #4]
  4002a4:	6039      	str	r1, [r7, #0]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
  4002a6:	687b      	ldr	r3, [r7, #4]
  4002a8:	685b      	ldr	r3, [r3, #4]
  4002aa:	60fb      	str	r3, [r7, #12]

	pxNewListItem->pxNext = pxIndex->pxNext;
  4002ac:	68fb      	ldr	r3, [r7, #12]
  4002ae:	685a      	ldr	r2, [r3, #4]
  4002b0:	683b      	ldr	r3, [r7, #0]
  4002b2:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
  4002b4:	687b      	ldr	r3, [r7, #4]
  4002b6:	685a      	ldr	r2, [r3, #4]
  4002b8:	683b      	ldr	r3, [r7, #0]
  4002ba:	609a      	str	r2, [r3, #8]
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
  4002bc:	68fb      	ldr	r3, [r7, #12]
  4002be:	685b      	ldr	r3, [r3, #4]
  4002c0:	683a      	ldr	r2, [r7, #0]
  4002c2:	609a      	str	r2, [r3, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
  4002c4:	68fb      	ldr	r3, [r7, #12]
  4002c6:	683a      	ldr	r2, [r7, #0]
  4002c8:	605a      	str	r2, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
  4002ca:	687b      	ldr	r3, [r7, #4]
  4002cc:	683a      	ldr	r2, [r7, #0]
  4002ce:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  4002d0:	683b      	ldr	r3, [r7, #0]
  4002d2:	687a      	ldr	r2, [r7, #4]
  4002d4:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
  4002d6:	687b      	ldr	r3, [r7, #4]
  4002d8:	681b      	ldr	r3, [r3, #0]
  4002da:	1c5a      	adds	r2, r3, #1
  4002dc:	687b      	ldr	r3, [r7, #4]
  4002de:	601a      	str	r2, [r3, #0]
}
  4002e0:	bf00      	nop
  4002e2:	3714      	adds	r7, #20
  4002e4:	46bd      	mov	sp, r7
  4002e6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4002ea:	4770      	bx	lr

004002ec <uxListRemove>:
	( pxList->uxNumberOfItems )++;
}
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
  4002ec:	b480      	push	{r7}
  4002ee:	b085      	sub	sp, #20
  4002f0:	af00      	add	r7, sp, #0
  4002f2:	6078      	str	r0, [r7, #4]
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  4002f4:	687b      	ldr	r3, [r7, #4]
  4002f6:	685b      	ldr	r3, [r3, #4]
  4002f8:	687a      	ldr	r2, [r7, #4]
  4002fa:	6892      	ldr	r2, [r2, #8]
  4002fc:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  4002fe:	687b      	ldr	r3, [r7, #4]
  400300:	689b      	ldr	r3, [r3, #8]
  400302:	687a      	ldr	r2, [r7, #4]
  400304:	6852      	ldr	r2, [r2, #4]
  400306:	605a      	str	r2, [r3, #4]

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
  400308:	687b      	ldr	r3, [r7, #4]
  40030a:	691b      	ldr	r3, [r3, #16]
  40030c:	60fb      	str	r3, [r7, #12]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
  40030e:	68fb      	ldr	r3, [r7, #12]
  400310:	685a      	ldr	r2, [r3, #4]
  400312:	687b      	ldr	r3, [r7, #4]
  400314:	429a      	cmp	r2, r3
  400316:	d103      	bne.n	400320 <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
  400318:	687b      	ldr	r3, [r7, #4]
  40031a:	689a      	ldr	r2, [r3, #8]
  40031c:	68fb      	ldr	r3, [r7, #12]
  40031e:	605a      	str	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
  400320:	687b      	ldr	r3, [r7, #4]
  400322:	2200      	movs	r2, #0
  400324:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
  400326:	68fb      	ldr	r3, [r7, #12]
  400328:	681b      	ldr	r3, [r3, #0]
  40032a:	1e5a      	subs	r2, r3, #1
  40032c:	68fb      	ldr	r3, [r7, #12]
  40032e:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
  400330:	68fb      	ldr	r3, [r7, #12]
  400332:	681b      	ldr	r3, [r3, #0]
}
  400334:	4618      	mov	r0, r3
  400336:	3714      	adds	r7, #20
  400338:	46bd      	mov	sp, r7
  40033a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40033e:	4770      	bx	lr

00400340 <SVC_Handler>:
/*-----------------------------------------------------------*/

/*void vPortSVCHandler( void )*/ /* ATMEL */
__attribute__ ((naked)) void SVC_Handler( void )
{
	__asm volatile (
  400340:	4b05      	ldr	r3, [pc, #20]	; (400358 <pxCurrentTCBConst2>)
  400342:	6819      	ldr	r1, [r3, #0]
  400344:	6808      	ldr	r0, [r1, #0]
  400346:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40034a:	f380 8809 	msr	PSP, r0
  40034e:	f04f 0000 	mov.w	r0, #0
  400352:	f380 8811 	msr	BASEPRI, r0
  400356:	4770      	bx	lr

00400358 <pxCurrentTCBConst2>:
  400358:	2000a47c 	.word	0x2000a47c
		" bx r14                          \n"
		"                                   \n"
		" .align 2                        \n"
		"pxCurrentTCBConst2: .word pxCurrentTCB \n"
		);
}
  40035c:	bf00      	nop
  40035e:	bf00      	nop

00400360 <vPortYieldFromISR>:
}

/*-----------------------------------------------------------*/

void vPortYieldFromISR( void )
{
  400360:	b480      	push	{r7}
  400362:	af00      	add	r7, sp, #0
	/* Set a PendSV to request a context switch. */
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
  400364:	4b04      	ldr	r3, [pc, #16]	; (400378 <vPortYieldFromISR+0x18>)
  400366:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  40036a:	601a      	str	r2, [r3, #0]
}
  40036c:	bf00      	nop
  40036e:	46bd      	mov	sp, r7
  400370:	f85d 7b04 	ldr.w	r7, [sp], #4
  400374:	4770      	bx	lr
  400376:	bf00      	nop
  400378:	e000ed04 	.word	0xe000ed04

0040037c <vPortEnterCritical>:

/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
  40037c:	b580      	push	{r7, lr}
  40037e:	af00      	add	r7, sp, #0
	portDISABLE_INTERRUPTS();
  400380:	4b04      	ldr	r3, [pc, #16]	; (400394 <vPortEnterCritical+0x18>)
  400382:	4798      	blx	r3
	uxCriticalNesting++;
  400384:	4b04      	ldr	r3, [pc, #16]	; (400398 <vPortEnterCritical+0x1c>)
  400386:	681b      	ldr	r3, [r3, #0]
  400388:	3301      	adds	r3, #1
  40038a:	4a03      	ldr	r2, [pc, #12]	; (400398 <vPortEnterCritical+0x1c>)
  40038c:	6013      	str	r3, [r2, #0]
}
  40038e:	bf00      	nop
  400390:	bd80      	pop	{r7, pc}
  400392:	bf00      	nop
  400394:	004003c5 	.word	0x004003c5
  400398:	2000000c 	.word	0x2000000c

0040039c <vPortExitCritical>:

/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
  40039c:	b580      	push	{r7, lr}
  40039e:	af00      	add	r7, sp, #0
	uxCriticalNesting--;
  4003a0:	4b06      	ldr	r3, [pc, #24]	; (4003bc <vPortExitCritical+0x20>)
  4003a2:	681b      	ldr	r3, [r3, #0]
  4003a4:	3b01      	subs	r3, #1
  4003a6:	4a05      	ldr	r2, [pc, #20]	; (4003bc <vPortExitCritical+0x20>)
  4003a8:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 0) {
  4003aa:	4b04      	ldr	r3, [pc, #16]	; (4003bc <vPortExitCritical+0x20>)
  4003ac:	681b      	ldr	r3, [r3, #0]
  4003ae:	2b00      	cmp	r3, #0
  4003b0:	d102      	bne.n	4003b8 <vPortExitCritical+0x1c>
		portENABLE_INTERRUPTS();
  4003b2:	2000      	movs	r0, #0
  4003b4:	4b02      	ldr	r3, [pc, #8]	; (4003c0 <vPortExitCritical+0x24>)
  4003b6:	4798      	blx	r3
	}
}
  4003b8:	bf00      	nop
  4003ba:	bd80      	pop	{r7, pc}
  4003bc:	2000000c 	.word	0x2000000c
  4003c0:	004003d7 	.word	0x004003d7

004003c4 <ulPortSetInterruptMask>:

/*-----------------------------------------------------------*/

__attribute__((naked)) unsigned long ulPortSetInterruptMask( void )
{
	__asm volatile \
  4003c4:	f3ef 8011 	mrs	r0, BASEPRI
  4003c8:	f04f 01a0 	mov.w	r1, #160	; 0xa0
  4003cc:	f381 8811 	msr	BASEPRI, r1
  4003d0:	4770      	bx	lr
		:: "i" (configMAX_SYSCALL_INTERRUPT_PRIORITY) : "r0", "r1" \
	);

	/* This return will not be reached but is necessary to prevent compiler
	 * warnings. */
	return 0;
  4003d2:	2300      	movs	r3, #0
}
  4003d4:	4618      	mov	r0, r3

004003d6 <vPortClearInterruptMask>:
/*-----------------------------------------------------------*/

__attribute__((naked)) void vPortClearInterruptMask(
		unsigned long ulNewMaskValue )
{
	__asm volatile \
  4003d6:	f380 8811 	msr	BASEPRI, r0
  4003da:	4770      	bx	lr
	( \
		" msr basepri, r0                            \n" \
		" bx lr                                      \n" \
		::: "r0" \
	);
}
  4003dc:	bf00      	nop
	...

004003e0 <PendSV_Handler>:
/*void xPortPendSVHandler( void )*/
__attribute__((naked)) void PendSV_Handler( void )   /* ATMEL */
{
	/* This is a naked function. */

	__asm volatile
  4003e0:	f3ef 8009 	mrs	r0, PSP
  4003e4:	4b11      	ldr	r3, [pc, #68]	; (40042c <pxCurrentTCBConst>)
  4003e6:	681a      	ldr	r2, [r3, #0]
  4003e8:	f01e 0f10 	tst.w	lr, #16
  4003ec:	bf08      	it	eq
  4003ee:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
  4003f2:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4003f6:	6010      	str	r0, [r2, #0]
  4003f8:	e92d 4008 	stmdb	sp!, {r3, lr}
  4003fc:	f04f 00a0 	mov.w	r0, #160	; 0xa0
  400400:	f380 8811 	msr	BASEPRI, r0
  400404:	f000 fb6c 	bl	400ae0 <vTaskSwitchContext>
  400408:	f04f 0000 	mov.w	r0, #0
  40040c:	f380 8811 	msr	BASEPRI, r0
  400410:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  400414:	6819      	ldr	r1, [r3, #0]
  400416:	6808      	ldr	r0, [r1, #0]
  400418:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40041c:	f01e 0f10 	tst.w	lr, #16
  400420:	bf08      	it	eq
  400422:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
  400426:	f380 8809 	msr	PSP, r0
  40042a:	4770      	bx	lr

0040042c <pxCurrentTCBConst>:
  40042c:	2000a47c 	.word	0x2000a47c
		"                                       \n"
		"   .align 2                            \n"
		"pxCurrentTCBConst: .word pxCurrentTCB    \n"
		::"i" (configMAX_SYSCALL_INTERRUPT_PRIORITY)
	);
}
  400430:	bf00      	nop
  400432:	bf00      	nop

00400434 <SysTick_Handler>:

/*-----------------------------------------------------------*/
void SysTick_Handler( void ) /* ATMEL */
{
  400434:	b580      	push	{r7, lr}
  400436:	af00      	add	r7, sp, #0
	/* If using preemption, also force a context switch. */
	#if configUSE_PREEMPTION == 1
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
  400438:	4b06      	ldr	r3, [pc, #24]	; (400454 <SysTick_Handler+0x20>)
  40043a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  40043e:	601a      	str	r2, [r3, #0]
	#endif

	(void)portSET_INTERRUPT_MASK_FROM_ISR();
  400440:	4b05      	ldr	r3, [pc, #20]	; (400458 <SysTick_Handler+0x24>)
  400442:	4798      	blx	r3
	{
		vTaskIncrementTick();
  400444:	4b05      	ldr	r3, [pc, #20]	; (40045c <SysTick_Handler+0x28>)
  400446:	4798      	blx	r3
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
  400448:	2000      	movs	r0, #0
  40044a:	4b05      	ldr	r3, [pc, #20]	; (400460 <SysTick_Handler+0x2c>)
  40044c:	4798      	blx	r3
}
  40044e:	bf00      	nop
  400450:	bd80      	pop	{r7, pc}
  400452:	bf00      	nop
  400454:	e000ed04 	.word	0xe000ed04
  400458:	004003c5 	.word	0x004003c5
  40045c:	00400995 	.word	0x00400995
  400460:	004003d7 	.word	0x004003d7

00400464 <pvPortMalloc>:
/* STATIC FUNCTIONS ARE DEFINED AS MACROS TO MINIMIZE THE FUNCTION CALL DEPTH. */

/*-----------------------------------------------------------*/
extern void vApplicationMallocFailedHook( void );
void *pvPortMalloc( size_t xWantedSize )
{
  400464:	b580      	push	{r7, lr}
  400466:	b086      	sub	sp, #24
  400468:	af00      	add	r7, sp, #0
  40046a:	6078      	str	r0, [r7, #4]
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
  40046c:	2300      	movs	r3, #0
  40046e:	60fb      	str	r3, [r7, #12]

	vTaskSuspendAll();
  400470:	4b34      	ldr	r3, [pc, #208]	; (400544 <pvPortMalloc+0xe0>)
  400472:	4798      	blx	r3
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
  400474:	4b34      	ldr	r3, [pc, #208]	; (400548 <pvPortMalloc+0xe4>)
  400476:	681b      	ldr	r3, [r3, #0]
  400478:	2b00      	cmp	r3, #0
  40047a:	d101      	bne.n	400480 <pvPortMalloc+0x1c>
		{
			prvHeapInit();
  40047c:	4b33      	ldr	r3, [pc, #204]	; (40054c <pvPortMalloc+0xe8>)
  40047e:	4798      	blx	r3
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
  400480:	687b      	ldr	r3, [r7, #4]
  400482:	2b00      	cmp	r3, #0
  400484:	d00e      	beq.n	4004a4 <pvPortMalloc+0x40>
		{
			xWantedSize += heapSTRUCT_SIZE;
  400486:	2310      	movs	r3, #16
  400488:	461a      	mov	r2, r3
  40048a:	687b      	ldr	r3, [r7, #4]
  40048c:	4413      	add	r3, r2
  40048e:	607b      	str	r3, [r7, #4]

			/* Ensure that blocks are always aligned to the required number of 
			bytes. */
			if( xWantedSize & portBYTE_ALIGNMENT_MASK )
  400490:	687b      	ldr	r3, [r7, #4]
  400492:	f003 0307 	and.w	r3, r3, #7
  400496:	2b00      	cmp	r3, #0
  400498:	d004      	beq.n	4004a4 <pvPortMalloc+0x40>
			{
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
  40049a:	687b      	ldr	r3, [r7, #4]
  40049c:	f023 0307 	bic.w	r3, r3, #7
  4004a0:	3308      	adds	r3, #8
  4004a2:	607b      	str	r3, [r7, #4]
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < xTotalHeapSize ) )
  4004a4:	687b      	ldr	r3, [r7, #4]
  4004a6:	2b00      	cmp	r3, #0
  4004a8:	d045      	beq.n	400536 <pvPortMalloc+0xd2>
  4004aa:	f44f 4220 	mov.w	r2, #40960	; 0xa000
  4004ae:	687b      	ldr	r3, [r7, #4]
  4004b0:	4293      	cmp	r3, r2
  4004b2:	d240      	bcs.n	400536 <pvPortMalloc+0xd2>
		{
			/* Traverse the list from the start	(lowest address) block until one
			of adequate size is found. */
			pxPreviousBlock = &xStart;
  4004b4:	4b26      	ldr	r3, [pc, #152]	; (400550 <pvPortMalloc+0xec>)
  4004b6:	613b      	str	r3, [r7, #16]
			pxBlock = xStart.pxNextFreeBlock;
  4004b8:	4b25      	ldr	r3, [pc, #148]	; (400550 <pvPortMalloc+0xec>)
  4004ba:	681b      	ldr	r3, [r3, #0]
  4004bc:	617b      	str	r3, [r7, #20]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  4004be:	e004      	b.n	4004ca <pvPortMalloc+0x66>
			{
				pxPreviousBlock = pxBlock;
  4004c0:	697b      	ldr	r3, [r7, #20]
  4004c2:	613b      	str	r3, [r7, #16]
				pxBlock = pxBlock->pxNextFreeBlock;
  4004c4:	697b      	ldr	r3, [r7, #20]
  4004c6:	681b      	ldr	r3, [r3, #0]
  4004c8:	617b      	str	r3, [r7, #20]
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
  4004ca:	697b      	ldr	r3, [r7, #20]
  4004cc:	685a      	ldr	r2, [r3, #4]
  4004ce:	687b      	ldr	r3, [r7, #4]
  4004d0:	429a      	cmp	r2, r3
  4004d2:	d203      	bcs.n	4004dc <pvPortMalloc+0x78>
  4004d4:	697b      	ldr	r3, [r7, #20]
  4004d6:	681b      	ldr	r3, [r3, #0]
  4004d8:	2b00      	cmp	r3, #0
  4004da:	d1f1      	bne.n	4004c0 <pvPortMalloc+0x5c>
			}

			/* If the end marker was reached then a block of adequate size was
			not found. */
			if( pxBlock != pxEnd )
  4004dc:	4b1a      	ldr	r3, [pc, #104]	; (400548 <pvPortMalloc+0xe4>)
  4004de:	681b      	ldr	r3, [r3, #0]
  4004e0:	697a      	ldr	r2, [r7, #20]
  4004e2:	429a      	cmp	r2, r3
  4004e4:	d027      	beq.n	400536 <pvPortMalloc+0xd2>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
  4004e6:	693b      	ldr	r3, [r7, #16]
  4004e8:	681b      	ldr	r3, [r3, #0]
  4004ea:	2210      	movs	r2, #16
  4004ec:	4413      	add	r3, r2
  4004ee:	60fb      	str	r3, [r7, #12]

				/* This block is being returned for use so must be taken out of
				the	list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
  4004f0:	697b      	ldr	r3, [r7, #20]
  4004f2:	681a      	ldr	r2, [r3, #0]
  4004f4:	693b      	ldr	r3, [r7, #16]
  4004f6:	601a      	str	r2, [r3, #0]

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
  4004f8:	697b      	ldr	r3, [r7, #20]
  4004fa:	685a      	ldr	r2, [r3, #4]
  4004fc:	687b      	ldr	r3, [r7, #4]
  4004fe:	1ad3      	subs	r3, r2, r3
  400500:	2210      	movs	r2, #16
  400502:	0052      	lsls	r2, r2, #1
  400504:	4293      	cmp	r3, r2
  400506:	d90f      	bls.n	400528 <pvPortMalloc+0xc4>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
  400508:	697a      	ldr	r2, [r7, #20]
  40050a:	687b      	ldr	r3, [r7, #4]
  40050c:	4413      	add	r3, r2
  40050e:	60bb      	str	r3, [r7, #8]

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
  400510:	697b      	ldr	r3, [r7, #20]
  400512:	685a      	ldr	r2, [r3, #4]
  400514:	687b      	ldr	r3, [r7, #4]
  400516:	1ad2      	subs	r2, r2, r3
  400518:	68bb      	ldr	r3, [r7, #8]
  40051a:	605a      	str	r2, [r3, #4]
					pxBlock->xBlockSize = xWantedSize;
  40051c:	697b      	ldr	r3, [r7, #20]
  40051e:	687a      	ldr	r2, [r7, #4]
  400520:	605a      	str	r2, [r3, #4]

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
  400522:	68b8      	ldr	r0, [r7, #8]
  400524:	4b0b      	ldr	r3, [pc, #44]	; (400554 <pvPortMalloc+0xf0>)
  400526:	4798      	blx	r3
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
  400528:	4b0b      	ldr	r3, [pc, #44]	; (400558 <pvPortMalloc+0xf4>)
  40052a:	681a      	ldr	r2, [r3, #0]
  40052c:	697b      	ldr	r3, [r7, #20]
  40052e:	685b      	ldr	r3, [r3, #4]
  400530:	1ad3      	subs	r3, r2, r3
  400532:	4a09      	ldr	r2, [pc, #36]	; (400558 <pvPortMalloc+0xf4>)
  400534:	6013      	str	r3, [r2, #0]
			}
		}
	}
	xTaskResumeAll();
  400536:	4b09      	ldr	r3, [pc, #36]	; (40055c <pvPortMalloc+0xf8>)
  400538:	4798      	blx	r3
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
  40053a:	68fb      	ldr	r3, [r7, #12]
}
  40053c:	4618      	mov	r0, r3
  40053e:	3718      	adds	r7, #24
  400540:	46bd      	mov	sp, r7
  400542:	bd80      	pop	{r7, pc}
  400544:	00400859 	.word	0x00400859
  400548:	2000a478 	.word	0x2000a478
  40054c:	004005b5 	.word	0x004005b5
  400550:	2000a470 	.word	0x2000a470
  400554:	00400645 	.word	0x00400645
  400558:	20000010 	.word	0x20000010
  40055c:	00400875 	.word	0x00400875

00400560 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
  400560:	b580      	push	{r7, lr}
  400562:	b084      	sub	sp, #16
  400564:	af00      	add	r7, sp, #0
  400566:	6078      	str	r0, [r7, #4]
unsigned char *puc = ( unsigned char * ) pv;
  400568:	687b      	ldr	r3, [r7, #4]
  40056a:	60fb      	str	r3, [r7, #12]
xBlockLink *pxLink;

	if( pv != NULL )
  40056c:	687b      	ldr	r3, [r7, #4]
  40056e:	2b00      	cmp	r3, #0
  400570:	d014      	beq.n	40059c <vPortFree+0x3c>
	{
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
  400572:	2310      	movs	r3, #16
  400574:	425b      	negs	r3, r3
  400576:	68fa      	ldr	r2, [r7, #12]
  400578:	4413      	add	r3, r2
  40057a:	60fb      	str	r3, [r7, #12]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
  40057c:	68fb      	ldr	r3, [r7, #12]
  40057e:	60bb      	str	r3, [r7, #8]

		vTaskSuspendAll();
  400580:	4b08      	ldr	r3, [pc, #32]	; (4005a4 <vPortFree+0x44>)
  400582:	4798      	blx	r3
		{
			/* Add this block to the list of free blocks. */
			xFreeBytesRemaining += pxLink->xBlockSize;
  400584:	68bb      	ldr	r3, [r7, #8]
  400586:	685a      	ldr	r2, [r3, #4]
  400588:	4b07      	ldr	r3, [pc, #28]	; (4005a8 <vPortFree+0x48>)
  40058a:	681b      	ldr	r3, [r3, #0]
  40058c:	4413      	add	r3, r2
  40058e:	4a06      	ldr	r2, [pc, #24]	; (4005a8 <vPortFree+0x48>)
  400590:	6013      	str	r3, [r2, #0]
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );			
  400592:	68b8      	ldr	r0, [r7, #8]
  400594:	4b05      	ldr	r3, [pc, #20]	; (4005ac <vPortFree+0x4c>)
  400596:	4798      	blx	r3
		}
		xTaskResumeAll();
  400598:	4b05      	ldr	r3, [pc, #20]	; (4005b0 <vPortFree+0x50>)
  40059a:	4798      	blx	r3
	}
}
  40059c:	bf00      	nop
  40059e:	3710      	adds	r7, #16
  4005a0:	46bd      	mov	sp, r7
  4005a2:	bd80      	pop	{r7, pc}
  4005a4:	00400859 	.word	0x00400859
  4005a8:	20000010 	.word	0x20000010
  4005ac:	00400645 	.word	0x00400645
  4005b0:	00400875 	.word	0x00400875

004005b4 <prvHeapInit>:
	/* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
  4005b4:	b580      	push	{r7, lr}
  4005b6:	b082      	sub	sp, #8
  4005b8:	af00      	add	r7, sp, #0
	/* Ensure the start of the heap is aligned. */
	configASSERT( ( ( ( unsigned long ) xHeap.ucHeap ) & ( ( unsigned long ) portBYTE_ALIGNMENT_MASK ) ) == 0UL );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) xHeap.ucHeap;
  4005ba:	4b1d      	ldr	r3, [pc, #116]	; (400630 <prvHeapInit+0x7c>)
  4005bc:	4a1d      	ldr	r2, [pc, #116]	; (400634 <prvHeapInit+0x80>)
  4005be:	601a      	str	r2, [r3, #0]
	xStart.xBlockSize = ( size_t ) 0;
  4005c0:	4b1b      	ldr	r3, [pc, #108]	; (400630 <prvHeapInit+0x7c>)
  4005c2:	2200      	movs	r2, #0
  4005c4:	605a      	str	r2, [r3, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	pucHeapEnd = xHeap.ucHeap + xTotalHeapSize;
  4005c6:	f44f 4220 	mov.w	r2, #40960	; 0xa000
  4005ca:	4b1a      	ldr	r3, [pc, #104]	; (400634 <prvHeapInit+0x80>)
  4005cc:	4413      	add	r3, r2
  4005ce:	607b      	str	r3, [r7, #4]
	pucHeapEnd -= heapSTRUCT_SIZE;
  4005d0:	2310      	movs	r3, #16
  4005d2:	425b      	negs	r3, r3
  4005d4:	687a      	ldr	r2, [r7, #4]
  4005d6:	4413      	add	r3, r2
  4005d8:	607b      	str	r3, [r7, #4]
	pxEnd = ( void * ) pucHeapEnd;
  4005da:	4a17      	ldr	r2, [pc, #92]	; (400638 <prvHeapInit+0x84>)
  4005dc:	687b      	ldr	r3, [r7, #4]
  4005de:	6013      	str	r3, [r2, #0]
	configASSERT( ( ( ( unsigned long ) pxEnd ) & ( ( unsigned long ) portBYTE_ALIGNMENT_MASK ) ) == 0UL );
  4005e0:	4b15      	ldr	r3, [pc, #84]	; (400638 <prvHeapInit+0x84>)
  4005e2:	681b      	ldr	r3, [r3, #0]
  4005e4:	f003 0307 	and.w	r3, r3, #7
  4005e8:	2b00      	cmp	r3, #0
  4005ea:	d003      	beq.n	4005f4 <prvHeapInit+0x40>
  4005ec:	4b13      	ldr	r3, [pc, #76]	; (40063c <prvHeapInit+0x88>)
  4005ee:	4798      	blx	r3
  4005f0:	bf00      	nop
  4005f2:	e7fd      	b.n	4005f0 <prvHeapInit+0x3c>
	pxEnd->xBlockSize = 0;
  4005f4:	4b10      	ldr	r3, [pc, #64]	; (400638 <prvHeapInit+0x84>)
  4005f6:	681b      	ldr	r3, [r3, #0]
  4005f8:	2200      	movs	r2, #0
  4005fa:	605a      	str	r2, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
  4005fc:	4b0e      	ldr	r3, [pc, #56]	; (400638 <prvHeapInit+0x84>)
  4005fe:	681b      	ldr	r3, [r3, #0]
  400600:	2200      	movs	r2, #0
  400602:	601a      	str	r2, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) xHeap.ucHeap;
  400604:	4b0b      	ldr	r3, [pc, #44]	; (400634 <prvHeapInit+0x80>)
  400606:	603b      	str	r3, [r7, #0]
	pxFirstFreeBlock->xBlockSize = xTotalHeapSize - heapSTRUCT_SIZE;
  400608:	f44f 4320 	mov.w	r3, #40960	; 0xa000
  40060c:	2210      	movs	r2, #16
  40060e:	1a9a      	subs	r2, r3, r2
  400610:	683b      	ldr	r3, [r7, #0]
  400612:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
  400614:	4b08      	ldr	r3, [pc, #32]	; (400638 <prvHeapInit+0x84>)
  400616:	681a      	ldr	r2, [r3, #0]
  400618:	683b      	ldr	r3, [r7, #0]
  40061a:	601a      	str	r2, [r3, #0]

	/* The heap now contains pxEnd. */
	xFreeBytesRemaining -= heapSTRUCT_SIZE;
  40061c:	4b08      	ldr	r3, [pc, #32]	; (400640 <prvHeapInit+0x8c>)
  40061e:	681b      	ldr	r3, [r3, #0]
  400620:	2210      	movs	r2, #16
  400622:	1a9b      	subs	r3, r3, r2
  400624:	4a06      	ldr	r2, [pc, #24]	; (400640 <prvHeapInit+0x8c>)
  400626:	6013      	str	r3, [r2, #0]
}
  400628:	bf00      	nop
  40062a:	3708      	adds	r7, #8
  40062c:	46bd      	mov	sp, r7
  40062e:	bd80      	pop	{r7, pc}
  400630:	2000a470 	.word	0x2000a470
  400634:	20000470 	.word	0x20000470
  400638:	2000a478 	.word	0x2000a478
  40063c:	004003c5 	.word	0x004003c5
  400640:	20000010 	.word	0x20000010

00400644 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( xBlockLink *pxBlockToInsert )
{
  400644:	b480      	push	{r7}
  400646:	b085      	sub	sp, #20
  400648:	af00      	add	r7, sp, #0
  40064a:	6078      	str	r0, [r7, #4]
xBlockLink *pxIterator;
unsigned char *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
  40064c:	4b28      	ldr	r3, [pc, #160]	; (4006f0 <prvInsertBlockIntoFreeList+0xac>)
  40064e:	60fb      	str	r3, [r7, #12]
  400650:	e002      	b.n	400658 <prvInsertBlockIntoFreeList+0x14>
  400652:	68fb      	ldr	r3, [r7, #12]
  400654:	681b      	ldr	r3, [r3, #0]
  400656:	60fb      	str	r3, [r7, #12]
  400658:	68fb      	ldr	r3, [r7, #12]
  40065a:	681a      	ldr	r2, [r3, #0]
  40065c:	687b      	ldr	r3, [r7, #4]
  40065e:	429a      	cmp	r2, r3
  400660:	d3f7      	bcc.n	400652 <prvInsertBlockIntoFreeList+0xe>
		/* Nothing to do here, just iterate to the right position. */
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */	
	puc = ( unsigned char * ) pxIterator;
  400662:	68fb      	ldr	r3, [r7, #12]
  400664:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxIterator->xBlockSize ) == ( unsigned char * ) pxBlockToInsert )
  400666:	68fb      	ldr	r3, [r7, #12]
  400668:	685b      	ldr	r3, [r3, #4]
  40066a:	68ba      	ldr	r2, [r7, #8]
  40066c:	441a      	add	r2, r3
  40066e:	687b      	ldr	r3, [r7, #4]
  400670:	429a      	cmp	r2, r3
  400672:	d108      	bne.n	400686 <prvInsertBlockIntoFreeList+0x42>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
  400674:	68fb      	ldr	r3, [r7, #12]
  400676:	685a      	ldr	r2, [r3, #4]
  400678:	687b      	ldr	r3, [r7, #4]
  40067a:	685b      	ldr	r3, [r3, #4]
  40067c:	441a      	add	r2, r3
  40067e:	68fb      	ldr	r3, [r7, #12]
  400680:	605a      	str	r2, [r3, #4]
		pxBlockToInsert = pxIterator;
  400682:	68fb      	ldr	r3, [r7, #12]
  400684:	607b      	str	r3, [r7, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( unsigned char * ) pxBlockToInsert;
  400686:	687b      	ldr	r3, [r7, #4]
  400688:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( unsigned char * ) pxIterator->pxNextFreeBlock )
  40068a:	687b      	ldr	r3, [r7, #4]
  40068c:	685b      	ldr	r3, [r3, #4]
  40068e:	68ba      	ldr	r2, [r7, #8]
  400690:	441a      	add	r2, r3
  400692:	68fb      	ldr	r3, [r7, #12]
  400694:	681b      	ldr	r3, [r3, #0]
  400696:	429a      	cmp	r2, r3
  400698:	d118      	bne.n	4006cc <prvInsertBlockIntoFreeList+0x88>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
  40069a:	68fb      	ldr	r3, [r7, #12]
  40069c:	681a      	ldr	r2, [r3, #0]
  40069e:	4b15      	ldr	r3, [pc, #84]	; (4006f4 <prvInsertBlockIntoFreeList+0xb0>)
  4006a0:	681b      	ldr	r3, [r3, #0]
  4006a2:	429a      	cmp	r2, r3
  4006a4:	d00d      	beq.n	4006c2 <prvInsertBlockIntoFreeList+0x7e>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
  4006a6:	687b      	ldr	r3, [r7, #4]
  4006a8:	685a      	ldr	r2, [r3, #4]
  4006aa:	68fb      	ldr	r3, [r7, #12]
  4006ac:	681b      	ldr	r3, [r3, #0]
  4006ae:	685b      	ldr	r3, [r3, #4]
  4006b0:	441a      	add	r2, r3
  4006b2:	687b      	ldr	r3, [r7, #4]
  4006b4:	605a      	str	r2, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
  4006b6:	68fb      	ldr	r3, [r7, #12]
  4006b8:	681b      	ldr	r3, [r3, #0]
  4006ba:	681a      	ldr	r2, [r3, #0]
  4006bc:	687b      	ldr	r3, [r7, #4]
  4006be:	601a      	str	r2, [r3, #0]
  4006c0:	e008      	b.n	4006d4 <prvInsertBlockIntoFreeList+0x90>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
  4006c2:	4b0c      	ldr	r3, [pc, #48]	; (4006f4 <prvInsertBlockIntoFreeList+0xb0>)
  4006c4:	681a      	ldr	r2, [r3, #0]
  4006c6:	687b      	ldr	r3, [r7, #4]
  4006c8:	601a      	str	r2, [r3, #0]
  4006ca:	e003      	b.n	4006d4 <prvInsertBlockIntoFreeList+0x90>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;		
  4006cc:	68fb      	ldr	r3, [r7, #12]
  4006ce:	681a      	ldr	r2, [r3, #0]
  4006d0:	687b      	ldr	r3, [r7, #4]
  4006d2:	601a      	str	r2, [r3, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
  4006d4:	68fa      	ldr	r2, [r7, #12]
  4006d6:	687b      	ldr	r3, [r7, #4]
  4006d8:	429a      	cmp	r2, r3
  4006da:	d002      	beq.n	4006e2 <prvInsertBlockIntoFreeList+0x9e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
  4006dc:	68fb      	ldr	r3, [r7, #12]
  4006de:	687a      	ldr	r2, [r7, #4]
  4006e0:	601a      	str	r2, [r3, #0]
	}
}
  4006e2:	bf00      	nop
  4006e4:	3714      	adds	r7, #20
  4006e6:	46bd      	mov	sp, r7
  4006e8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4006ec:	4770      	bx	lr
  4006ee:	bf00      	nop
  4006f0:	2000a470 	.word	0x2000a470
  4006f4:	2000a478 	.word	0x2000a478

004006f8 <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
  4006f8:	b580      	push	{r7, lr}
  4006fa:	b082      	sub	sp, #8
  4006fc:	af00      	add	r7, sp, #0
  4006fe:	6078      	str	r0, [r7, #4]
  400700:	6039      	str	r1, [r7, #0]
	configASSERT( pxQueue );
  400702:	687b      	ldr	r3, [r7, #4]
  400704:	2b00      	cmp	r3, #0
  400706:	d103      	bne.n	400710 <xQueueGenericReset+0x18>
  400708:	4b27      	ldr	r3, [pc, #156]	; (4007a8 <xQueueGenericReset+0xb0>)
  40070a:	4798      	blx	r3
  40070c:	bf00      	nop
  40070e:	e7fd      	b.n	40070c <xQueueGenericReset+0x14>

	taskENTER_CRITICAL();
  400710:	4b26      	ldr	r3, [pc, #152]	; (4007ac <xQueueGenericReset+0xb4>)
  400712:	4798      	blx	r3
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
  400714:	687b      	ldr	r3, [r7, #4]
  400716:	681a      	ldr	r2, [r3, #0]
  400718:	687b      	ldr	r3, [r7, #4]
  40071a:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  40071c:	6879      	ldr	r1, [r7, #4]
  40071e:	6c09      	ldr	r1, [r1, #64]	; 0x40
  400720:	fb01 f303 	mul.w	r3, r1, r3
  400724:	441a      	add	r2, r3
  400726:	687b      	ldr	r3, [r7, #4]
  400728:	605a      	str	r2, [r3, #4]
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
  40072a:	687b      	ldr	r3, [r7, #4]
  40072c:	2200      	movs	r2, #0
  40072e:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
  400730:	687b      	ldr	r3, [r7, #4]
  400732:	681a      	ldr	r2, [r3, #0]
  400734:	687b      	ldr	r3, [r7, #4]
  400736:	609a      	str	r2, [r3, #8]
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
  400738:	687b      	ldr	r3, [r7, #4]
  40073a:	681a      	ldr	r2, [r3, #0]
  40073c:	687b      	ldr	r3, [r7, #4]
  40073e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
  400740:	3b01      	subs	r3, #1
  400742:	6879      	ldr	r1, [r7, #4]
  400744:	6c09      	ldr	r1, [r1, #64]	; 0x40
  400746:	fb01 f303 	mul.w	r3, r1, r3
  40074a:	441a      	add	r2, r3
  40074c:	687b      	ldr	r3, [r7, #4]
  40074e:	60da      	str	r2, [r3, #12]
		pxQueue->xRxLock = queueUNLOCKED;
  400750:	687b      	ldr	r3, [r7, #4]
  400752:	f04f 32ff 	mov.w	r2, #4294967295
  400756:	645a      	str	r2, [r3, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
  400758:	687b      	ldr	r3, [r7, #4]
  40075a:	f04f 32ff 	mov.w	r2, #4294967295
  40075e:	649a      	str	r2, [r3, #72]	; 0x48

		if( xNewQueue == pdFALSE )
  400760:	683b      	ldr	r3, [r7, #0]
  400762:	2b00      	cmp	r3, #0
  400764:	d10e      	bne.n	400784 <xQueueGenericReset+0x8c>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  400766:	687b      	ldr	r3, [r7, #4]
  400768:	691b      	ldr	r3, [r3, #16]
  40076a:	2b00      	cmp	r3, #0
  40076c:	d014      	beq.n	400798 <xQueueGenericReset+0xa0>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
  40076e:	687b      	ldr	r3, [r7, #4]
  400770:	3310      	adds	r3, #16
  400772:	4618      	mov	r0, r3
  400774:	4b0e      	ldr	r3, [pc, #56]	; (4007b0 <xQueueGenericReset+0xb8>)
  400776:	4798      	blx	r3
  400778:	4603      	mov	r3, r0
  40077a:	2b01      	cmp	r3, #1
  40077c:	d10c      	bne.n	400798 <xQueueGenericReset+0xa0>
				{
					portYIELD_WITHIN_API();
  40077e:	4b0d      	ldr	r3, [pc, #52]	; (4007b4 <xQueueGenericReset+0xbc>)
  400780:	4798      	blx	r3
  400782:	e009      	b.n	400798 <xQueueGenericReset+0xa0>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
  400784:	687b      	ldr	r3, [r7, #4]
  400786:	3310      	adds	r3, #16
  400788:	4618      	mov	r0, r3
  40078a:	4b0b      	ldr	r3, [pc, #44]	; (4007b8 <xQueueGenericReset+0xc0>)
  40078c:	4798      	blx	r3
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
  40078e:	687b      	ldr	r3, [r7, #4]
  400790:	3324      	adds	r3, #36	; 0x24
  400792:	4618      	mov	r0, r3
  400794:	4b08      	ldr	r3, [pc, #32]	; (4007b8 <xQueueGenericReset+0xc0>)
  400796:	4798      	blx	r3
		}
	}
	taskEXIT_CRITICAL();
  400798:	4b08      	ldr	r3, [pc, #32]	; (4007bc <xQueueGenericReset+0xc4>)
  40079a:	4798      	blx	r3

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
  40079c:	2301      	movs	r3, #1
}
  40079e:	4618      	mov	r0, r3
  4007a0:	3708      	adds	r7, #8
  4007a2:	46bd      	mov	sp, r7
  4007a4:	bd80      	pop	{r7, pc}
  4007a6:	bf00      	nop
  4007a8:	004003c5 	.word	0x004003c5
  4007ac:	0040037d 	.word	0x0040037d
  4007b0:	00400b85 	.word	0x00400b85
  4007b4:	00400361 	.word	0x00400361
  4007b8:	0040025d 	.word	0x0040025d
  4007bc:	0040039d 	.word	0x0040039d

004007c0 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
  4007c0:	b580      	push	{r7, lr}
  4007c2:	b088      	sub	sp, #32
  4007c4:	af00      	add	r7, sp, #0
  4007c6:	60f8      	str	r0, [r7, #12]
  4007c8:	60b9      	str	r1, [r7, #8]
  4007ca:	4613      	mov	r3, r2
  4007cc:	71fb      	strb	r3, [r7, #7]
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
  4007ce:	2300      	movs	r3, #0
  4007d0:	61fb      	str	r3, [r7, #28]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
  4007d2:	68fb      	ldr	r3, [r7, #12]
  4007d4:	2b00      	cmp	r3, #0
  4007d6:	d02a      	beq.n	40082e <xQueueGenericCreate+0x6e>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
  4007d8:	2050      	movs	r0, #80	; 0x50
  4007da:	4b1b      	ldr	r3, [pc, #108]	; (400848 <xQueueGenericCreate+0x88>)
  4007dc:	4798      	blx	r3
  4007de:	61b8      	str	r0, [r7, #24]
		if( pxNewQueue != NULL )
  4007e0:	69bb      	ldr	r3, [r7, #24]
  4007e2:	2b00      	cmp	r3, #0
  4007e4:	d023      	beq.n	40082e <xQueueGenericCreate+0x6e>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
  4007e6:	68fb      	ldr	r3, [r7, #12]
  4007e8:	68ba      	ldr	r2, [r7, #8]
  4007ea:	fb02 f303 	mul.w	r3, r2, r3
  4007ee:	3301      	adds	r3, #1
  4007f0:	617b      	str	r3, [r7, #20]

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
  4007f2:	6978      	ldr	r0, [r7, #20]
  4007f4:	4b14      	ldr	r3, [pc, #80]	; (400848 <xQueueGenericCreate+0x88>)
  4007f6:	4798      	blx	r3
  4007f8:	4602      	mov	r2, r0
  4007fa:	69bb      	ldr	r3, [r7, #24]
  4007fc:	601a      	str	r2, [r3, #0]
			if( pxNewQueue->pcHead != NULL )
  4007fe:	69bb      	ldr	r3, [r7, #24]
  400800:	681b      	ldr	r3, [r3, #0]
  400802:	2b00      	cmp	r3, #0
  400804:	d010      	beq.n	400828 <xQueueGenericCreate+0x68>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
  400806:	69bb      	ldr	r3, [r7, #24]
  400808:	68fa      	ldr	r2, [r7, #12]
  40080a:	63da      	str	r2, [r3, #60]	; 0x3c
				pxNewQueue->uxItemSize = uxItemSize;
  40080c:	69bb      	ldr	r3, [r7, #24]
  40080e:	68ba      	ldr	r2, [r7, #8]
  400810:	641a      	str	r2, [r3, #64]	; 0x40
				xQueueGenericReset( pxNewQueue, pdTRUE );
  400812:	2101      	movs	r1, #1
  400814:	69b8      	ldr	r0, [r7, #24]
  400816:	4b0d      	ldr	r3, [pc, #52]	; (40084c <xQueueGenericCreate+0x8c>)
  400818:	4798      	blx	r3
				#if ( configUSE_TRACE_FACILITY == 1 )
				{
					pxNewQueue->ucQueueType = ucQueueType;
  40081a:	69bb      	ldr	r3, [r7, #24]
  40081c:	79fa      	ldrb	r2, [r7, #7]
  40081e:	f883 204d 	strb.w	r2, [r3, #77]	; 0x4d
				}
				#endif /* configUSE_TRACE_FACILITY */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
  400822:	69bb      	ldr	r3, [r7, #24]
  400824:	61fb      	str	r3, [r7, #28]
  400826:	e002      	b.n	40082e <xQueueGenericCreate+0x6e>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
  400828:	69b8      	ldr	r0, [r7, #24]
  40082a:	4b09      	ldr	r3, [pc, #36]	; (400850 <xQueueGenericCreate+0x90>)
  40082c:	4798      	blx	r3
			}
		}
	}

	configASSERT( xReturn );
  40082e:	69fb      	ldr	r3, [r7, #28]
  400830:	2b00      	cmp	r3, #0
  400832:	d103      	bne.n	40083c <xQueueGenericCreate+0x7c>
  400834:	4b07      	ldr	r3, [pc, #28]	; (400854 <xQueueGenericCreate+0x94>)
  400836:	4798      	blx	r3
  400838:	bf00      	nop
  40083a:	e7fd      	b.n	400838 <xQueueGenericCreate+0x78>

	return xReturn;
  40083c:	69fb      	ldr	r3, [r7, #28]
}
  40083e:	4618      	mov	r0, r3
  400840:	3720      	adds	r7, #32
  400842:	46bd      	mov	sp, r7
  400844:	bd80      	pop	{r7, pc}
  400846:	bf00      	nop
  400848:	00400465 	.word	0x00400465
  40084c:	004006f9 	.word	0x004006f9
  400850:	00400561 	.word	0x00400561
  400854:	004003c5 	.word	0x004003c5

00400858 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
  400858:	b480      	push	{r7}
  40085a:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
  40085c:	4b04      	ldr	r3, [pc, #16]	; (400870 <vTaskSuspendAll+0x18>)
  40085e:	681b      	ldr	r3, [r3, #0]
  400860:	3301      	adds	r3, #1
  400862:	4a03      	ldr	r2, [pc, #12]	; (400870 <vTaskSuspendAll+0x18>)
  400864:	6013      	str	r3, [r2, #0]
}
  400866:	bf00      	nop
  400868:	46bd      	mov	sp, r7
  40086a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40086e:	4770      	bx	lr
  400870:	2000a50c 	.word	0x2000a50c

00400874 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
  400874:	b590      	push	{r4, r7, lr}
  400876:	b083      	sub	sp, #12
  400878:	af00      	add	r7, sp, #0
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
  40087a:	2300      	movs	r3, #0
  40087c:	607b      	str	r3, [r7, #4]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
  40087e:	4b36      	ldr	r3, [pc, #216]	; (400958 <xTaskResumeAll+0xe4>)
  400880:	681b      	ldr	r3, [r3, #0]
  400882:	2b00      	cmp	r3, #0
  400884:	d103      	bne.n	40088e <xTaskResumeAll+0x1a>
  400886:	4b35      	ldr	r3, [pc, #212]	; (40095c <xTaskResumeAll+0xe8>)
  400888:	4798      	blx	r3
  40088a:	bf00      	nop
  40088c:	e7fd      	b.n	40088a <xTaskResumeAll+0x16>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
  40088e:	4b34      	ldr	r3, [pc, #208]	; (400960 <xTaskResumeAll+0xec>)
  400890:	4798      	blx	r3
	{
		--uxSchedulerSuspended;
  400892:	4b31      	ldr	r3, [pc, #196]	; (400958 <xTaskResumeAll+0xe4>)
  400894:	681b      	ldr	r3, [r3, #0]
  400896:	3b01      	subs	r3, #1
  400898:	4a2f      	ldr	r2, [pc, #188]	; (400958 <xTaskResumeAll+0xe4>)
  40089a:	6013      	str	r3, [r2, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  40089c:	4b2e      	ldr	r3, [pc, #184]	; (400958 <xTaskResumeAll+0xe4>)
  40089e:	681b      	ldr	r3, [r3, #0]
  4008a0:	2b00      	cmp	r3, #0
  4008a2:	d152      	bne.n	40094a <xTaskResumeAll+0xd6>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
  4008a4:	4b2f      	ldr	r3, [pc, #188]	; (400964 <xTaskResumeAll+0xf0>)
  4008a6:	681b      	ldr	r3, [r3, #0]
  4008a8:	2b00      	cmp	r3, #0
  4008aa:	d04e      	beq.n	40094a <xTaskResumeAll+0xd6>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
  4008ac:	2300      	movs	r3, #0
  4008ae:	603b      	str	r3, [r7, #0]

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
  4008b0:	e027      	b.n	400902 <xTaskResumeAll+0x8e>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
  4008b2:	4b2d      	ldr	r3, [pc, #180]	; (400968 <xTaskResumeAll+0xf4>)
  4008b4:	68db      	ldr	r3, [r3, #12]
  4008b6:	68dc      	ldr	r4, [r3, #12]
					uxListRemove( &( pxTCB->xEventListItem ) );
  4008b8:	f104 0318 	add.w	r3, r4, #24
  4008bc:	4618      	mov	r0, r3
  4008be:	4b2b      	ldr	r3, [pc, #172]	; (40096c <xTaskResumeAll+0xf8>)
  4008c0:	4798      	blx	r3
					uxListRemove( &( pxTCB->xGenericListItem ) );
  4008c2:	1d23      	adds	r3, r4, #4
  4008c4:	4618      	mov	r0, r3
  4008c6:	4b29      	ldr	r3, [pc, #164]	; (40096c <xTaskResumeAll+0xf8>)
  4008c8:	4798      	blx	r3
					prvAddTaskToReadyQueue( pxTCB );
  4008ca:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  4008cc:	4b28      	ldr	r3, [pc, #160]	; (400970 <xTaskResumeAll+0xfc>)
  4008ce:	681b      	ldr	r3, [r3, #0]
  4008d0:	429a      	cmp	r2, r3
  4008d2:	d902      	bls.n	4008da <xTaskResumeAll+0x66>
  4008d4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  4008d6:	4a26      	ldr	r2, [pc, #152]	; (400970 <xTaskResumeAll+0xfc>)
  4008d8:	6013      	str	r3, [r2, #0]
  4008da:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  4008dc:	4613      	mov	r3, r2
  4008de:	009b      	lsls	r3, r3, #2
  4008e0:	4413      	add	r3, r2
  4008e2:	009b      	lsls	r3, r3, #2
  4008e4:	4a23      	ldr	r2, [pc, #140]	; (400974 <xTaskResumeAll+0x100>)
  4008e6:	4413      	add	r3, r2
  4008e8:	1d22      	adds	r2, r4, #4
  4008ea:	4611      	mov	r1, r2
  4008ec:	4618      	mov	r0, r3
  4008ee:	4b22      	ldr	r3, [pc, #136]	; (400978 <xTaskResumeAll+0x104>)
  4008f0:	4798      	blx	r3

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  4008f2:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  4008f4:	4b21      	ldr	r3, [pc, #132]	; (40097c <xTaskResumeAll+0x108>)
  4008f6:	681b      	ldr	r3, [r3, #0]
  4008f8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4008fa:	429a      	cmp	r2, r3
  4008fc:	d301      	bcc.n	400902 <xTaskResumeAll+0x8e>
					{
						xYieldRequired = pdTRUE;
  4008fe:	2301      	movs	r3, #1
  400900:	603b      	str	r3, [r7, #0]
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
  400902:	4b19      	ldr	r3, [pc, #100]	; (400968 <xTaskResumeAll+0xf4>)
  400904:	681b      	ldr	r3, [r3, #0]
  400906:	2b00      	cmp	r3, #0
  400908:	d1d3      	bne.n	4008b2 <xTaskResumeAll+0x3e>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
  40090a:	4b1d      	ldr	r3, [pc, #116]	; (400980 <xTaskResumeAll+0x10c>)
  40090c:	681b      	ldr	r3, [r3, #0]
  40090e:	2b00      	cmp	r3, #0
  400910:	d00d      	beq.n	40092e <xTaskResumeAll+0xba>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
  400912:	e006      	b.n	400922 <xTaskResumeAll+0xae>
					{
						vTaskIncrementTick();
  400914:	4b1b      	ldr	r3, [pc, #108]	; (400984 <xTaskResumeAll+0x110>)
  400916:	4798      	blx	r3
						--uxMissedTicks;
  400918:	4b19      	ldr	r3, [pc, #100]	; (400980 <xTaskResumeAll+0x10c>)
  40091a:	681b      	ldr	r3, [r3, #0]
  40091c:	3b01      	subs	r3, #1
  40091e:	4a18      	ldr	r2, [pc, #96]	; (400980 <xTaskResumeAll+0x10c>)
  400920:	6013      	str	r3, [r2, #0]
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
  400922:	4b17      	ldr	r3, [pc, #92]	; (400980 <xTaskResumeAll+0x10c>)
  400924:	681b      	ldr	r3, [r3, #0]
  400926:	2b00      	cmp	r3, #0
  400928:	d1f4      	bne.n	400914 <xTaskResumeAll+0xa0>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
  40092a:	2301      	movs	r3, #1
  40092c:	603b      	str	r3, [r7, #0]
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
  40092e:	683b      	ldr	r3, [r7, #0]
  400930:	2b01      	cmp	r3, #1
  400932:	d003      	beq.n	40093c <xTaskResumeAll+0xc8>
  400934:	4b14      	ldr	r3, [pc, #80]	; (400988 <xTaskResumeAll+0x114>)
  400936:	681b      	ldr	r3, [r3, #0]
  400938:	2b01      	cmp	r3, #1
  40093a:	d106      	bne.n	40094a <xTaskResumeAll+0xd6>
				{
					xAlreadyYielded = pdTRUE;
  40093c:	2301      	movs	r3, #1
  40093e:	607b      	str	r3, [r7, #4]
					xMissedYield = pdFALSE;
  400940:	4b11      	ldr	r3, [pc, #68]	; (400988 <xTaskResumeAll+0x114>)
  400942:	2200      	movs	r2, #0
  400944:	601a      	str	r2, [r3, #0]
					portYIELD_WITHIN_API();
  400946:	4b11      	ldr	r3, [pc, #68]	; (40098c <xTaskResumeAll+0x118>)
  400948:	4798      	blx	r3
				}
			}
		}
	}
	taskEXIT_CRITICAL();
  40094a:	4b11      	ldr	r3, [pc, #68]	; (400990 <xTaskResumeAll+0x11c>)
  40094c:	4798      	blx	r3

	return xAlreadyYielded;
  40094e:	687b      	ldr	r3, [r7, #4]
}
  400950:	4618      	mov	r0, r3
  400952:	370c      	adds	r7, #12
  400954:	46bd      	mov	sp, r7
  400956:	bd90      	pop	{r4, r7, pc}
  400958:	2000a50c 	.word	0x2000a50c
  40095c:	004003c5 	.word	0x004003c5
  400960:	0040037d 	.word	0x0040037d
  400964:	2000a500 	.word	0x2000a500
  400968:	2000a4ec 	.word	0x2000a4ec
  40096c:	004002ed 	.word	0x004002ed
  400970:	2000a508 	.word	0x2000a508
  400974:	2000a480 	.word	0x2000a480
  400978:	0040029d 	.word	0x0040029d
  40097c:	2000a47c 	.word	0x2000a47c
  400980:	2000a510 	.word	0x2000a510
  400984:	00400995 	.word	0x00400995
  400988:	2000a514 	.word	0x2000a514
  40098c:	00400361 	.word	0x00400361
  400990:	0040039d 	.word	0x0040039d

00400994 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
  400994:	b580      	push	{r7, lr}
  400996:	b084      	sub	sp, #16
  400998:	af00      	add	r7, sp, #0

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  40099a:	4b45      	ldr	r3, [pc, #276]	; (400ab0 <vTaskIncrementTick+0x11c>)
  40099c:	681b      	ldr	r3, [r3, #0]
  40099e:	2b00      	cmp	r3, #0
  4009a0:	d17b      	bne.n	400a9a <vTaskIncrementTick+0x106>
	{
		++xTickCount;
  4009a2:	4b44      	ldr	r3, [pc, #272]	; (400ab4 <vTaskIncrementTick+0x120>)
  4009a4:	681b      	ldr	r3, [r3, #0]
  4009a6:	3301      	adds	r3, #1
  4009a8:	4a42      	ldr	r2, [pc, #264]	; (400ab4 <vTaskIncrementTick+0x120>)
  4009aa:	6013      	str	r3, [r2, #0]
		if( xTickCount == ( portTickType ) 0U )
  4009ac:	4b41      	ldr	r3, [pc, #260]	; (400ab4 <vTaskIncrementTick+0x120>)
  4009ae:	681b      	ldr	r3, [r3, #0]
  4009b0:	2b00      	cmp	r3, #0
  4009b2:	d12a      	bne.n	400a0a <vTaskIncrementTick+0x76>
			xList *pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
  4009b4:	4b40      	ldr	r3, [pc, #256]	; (400ab8 <vTaskIncrementTick+0x124>)
  4009b6:	681b      	ldr	r3, [r3, #0]
  4009b8:	681b      	ldr	r3, [r3, #0]
  4009ba:	2b00      	cmp	r3, #0
  4009bc:	d003      	beq.n	4009c6 <vTaskIncrementTick+0x32>
  4009be:	4b3f      	ldr	r3, [pc, #252]	; (400abc <vTaskIncrementTick+0x128>)
  4009c0:	4798      	blx	r3
  4009c2:	bf00      	nop
  4009c4:	e7fd      	b.n	4009c2 <vTaskIncrementTick+0x2e>

			pxTemp = pxDelayedTaskList;
  4009c6:	4b3c      	ldr	r3, [pc, #240]	; (400ab8 <vTaskIncrementTick+0x124>)
  4009c8:	681b      	ldr	r3, [r3, #0]
  4009ca:	60fb      	str	r3, [r7, #12]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
  4009cc:	4b3c      	ldr	r3, [pc, #240]	; (400ac0 <vTaskIncrementTick+0x12c>)
  4009ce:	681b      	ldr	r3, [r3, #0]
  4009d0:	4a39      	ldr	r2, [pc, #228]	; (400ab8 <vTaskIncrementTick+0x124>)
  4009d2:	6013      	str	r3, [r2, #0]
			pxOverflowDelayedTaskList = pxTemp;
  4009d4:	4a3a      	ldr	r2, [pc, #232]	; (400ac0 <vTaskIncrementTick+0x12c>)
  4009d6:	68fb      	ldr	r3, [r7, #12]
  4009d8:	6013      	str	r3, [r2, #0]
			xNumOfOverflows++;
  4009da:	4b3a      	ldr	r3, [pc, #232]	; (400ac4 <vTaskIncrementTick+0x130>)
  4009dc:	681b      	ldr	r3, [r3, #0]
  4009de:	3301      	adds	r3, #1
  4009e0:	4a38      	ldr	r2, [pc, #224]	; (400ac4 <vTaskIncrementTick+0x130>)
  4009e2:	6013      	str	r3, [r2, #0]

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  4009e4:	4b34      	ldr	r3, [pc, #208]	; (400ab8 <vTaskIncrementTick+0x124>)
  4009e6:	681b      	ldr	r3, [r3, #0]
  4009e8:	681b      	ldr	r3, [r3, #0]
  4009ea:	2b00      	cmp	r3, #0
  4009ec:	d104      	bne.n	4009f8 <vTaskIncrementTick+0x64>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
  4009ee:	4b36      	ldr	r3, [pc, #216]	; (400ac8 <vTaskIncrementTick+0x134>)
  4009f0:	f04f 32ff 	mov.w	r2, #4294967295
  4009f4:	601a      	str	r2, [r3, #0]
  4009f6:	e008      	b.n	400a0a <vTaskIncrementTick+0x76>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  4009f8:	4b2f      	ldr	r3, [pc, #188]	; (400ab8 <vTaskIncrementTick+0x124>)
  4009fa:	681b      	ldr	r3, [r3, #0]
  4009fc:	68db      	ldr	r3, [r3, #12]
  4009fe:	68db      	ldr	r3, [r3, #12]
  400a00:	60bb      	str	r3, [r7, #8]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
  400a02:	68bb      	ldr	r3, [r7, #8]
  400a04:	685b      	ldr	r3, [r3, #4]
  400a06:	4a30      	ldr	r2, [pc, #192]	; (400ac8 <vTaskIncrementTick+0x134>)
  400a08:	6013      	str	r3, [r2, #0]
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
  400a0a:	4b2a      	ldr	r3, [pc, #168]	; (400ab4 <vTaskIncrementTick+0x120>)
  400a0c:	681a      	ldr	r2, [r3, #0]
  400a0e:	4b2e      	ldr	r3, [pc, #184]	; (400ac8 <vTaskIncrementTick+0x134>)
  400a10:	681b      	ldr	r3, [r3, #0]
  400a12:	429a      	cmp	r2, r3
  400a14:	d347      	bcc.n	400aa6 <vTaskIncrementTick+0x112>
  400a16:	4b28      	ldr	r3, [pc, #160]	; (400ab8 <vTaskIncrementTick+0x124>)
  400a18:	681b      	ldr	r3, [r3, #0]
  400a1a:	681b      	ldr	r3, [r3, #0]
  400a1c:	2b00      	cmp	r3, #0
  400a1e:	d104      	bne.n	400a2a <vTaskIncrementTick+0x96>
  400a20:	4b29      	ldr	r3, [pc, #164]	; (400ac8 <vTaskIncrementTick+0x134>)
  400a22:	f04f 32ff 	mov.w	r2, #4294967295
  400a26:	601a      	str	r2, [r3, #0]
  400a28:	e03d      	b.n	400aa6 <vTaskIncrementTick+0x112>
  400a2a:	4b23      	ldr	r3, [pc, #140]	; (400ab8 <vTaskIncrementTick+0x124>)
  400a2c:	681b      	ldr	r3, [r3, #0]
  400a2e:	68db      	ldr	r3, [r3, #12]
  400a30:	68db      	ldr	r3, [r3, #12]
  400a32:	60bb      	str	r3, [r7, #8]
  400a34:	68bb      	ldr	r3, [r7, #8]
  400a36:	685b      	ldr	r3, [r3, #4]
  400a38:	607b      	str	r3, [r7, #4]
  400a3a:	4b1e      	ldr	r3, [pc, #120]	; (400ab4 <vTaskIncrementTick+0x120>)
  400a3c:	681a      	ldr	r2, [r3, #0]
  400a3e:	687b      	ldr	r3, [r7, #4]
  400a40:	429a      	cmp	r2, r3
  400a42:	d203      	bcs.n	400a4c <vTaskIncrementTick+0xb8>
  400a44:	4a20      	ldr	r2, [pc, #128]	; (400ac8 <vTaskIncrementTick+0x134>)
  400a46:	687b      	ldr	r3, [r7, #4]
  400a48:	6013      	str	r3, [r2, #0]
  400a4a:	e02c      	b.n	400aa6 <vTaskIncrementTick+0x112>
  400a4c:	68bb      	ldr	r3, [r7, #8]
  400a4e:	3304      	adds	r3, #4
  400a50:	4618      	mov	r0, r3
  400a52:	4b1e      	ldr	r3, [pc, #120]	; (400acc <vTaskIncrementTick+0x138>)
  400a54:	4798      	blx	r3
  400a56:	68bb      	ldr	r3, [r7, #8]
  400a58:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  400a5a:	2b00      	cmp	r3, #0
  400a5c:	d004      	beq.n	400a68 <vTaskIncrementTick+0xd4>
  400a5e:	68bb      	ldr	r3, [r7, #8]
  400a60:	3318      	adds	r3, #24
  400a62:	4618      	mov	r0, r3
  400a64:	4b19      	ldr	r3, [pc, #100]	; (400acc <vTaskIncrementTick+0x138>)
  400a66:	4798      	blx	r3
  400a68:	68bb      	ldr	r3, [r7, #8]
  400a6a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  400a6c:	4b18      	ldr	r3, [pc, #96]	; (400ad0 <vTaskIncrementTick+0x13c>)
  400a6e:	681b      	ldr	r3, [r3, #0]
  400a70:	429a      	cmp	r2, r3
  400a72:	d903      	bls.n	400a7c <vTaskIncrementTick+0xe8>
  400a74:	68bb      	ldr	r3, [r7, #8]
  400a76:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  400a78:	4a15      	ldr	r2, [pc, #84]	; (400ad0 <vTaskIncrementTick+0x13c>)
  400a7a:	6013      	str	r3, [r2, #0]
  400a7c:	68bb      	ldr	r3, [r7, #8]
  400a7e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  400a80:	4613      	mov	r3, r2
  400a82:	009b      	lsls	r3, r3, #2
  400a84:	4413      	add	r3, r2
  400a86:	009b      	lsls	r3, r3, #2
  400a88:	4a12      	ldr	r2, [pc, #72]	; (400ad4 <vTaskIncrementTick+0x140>)
  400a8a:	441a      	add	r2, r3
  400a8c:	68bb      	ldr	r3, [r7, #8]
  400a8e:	3304      	adds	r3, #4
  400a90:	4619      	mov	r1, r3
  400a92:	4610      	mov	r0, r2
  400a94:	4b10      	ldr	r3, [pc, #64]	; (400ad8 <vTaskIncrementTick+0x144>)
  400a96:	4798      	blx	r3
  400a98:	e7bd      	b.n	400a16 <vTaskIncrementTick+0x82>
	}
	else
	{
		++uxMissedTicks;
  400a9a:	4b10      	ldr	r3, [pc, #64]	; (400adc <vTaskIncrementTick+0x148>)
  400a9c:	681b      	ldr	r3, [r3, #0]
  400a9e:	3301      	adds	r3, #1
  400aa0:	4a0e      	ldr	r2, [pc, #56]	; (400adc <vTaskIncrementTick+0x148>)
  400aa2:	6013      	str	r3, [r2, #0]
		{
			vApplicationTickHook();
		}
	}
	#endif
}
  400aa4:	e7ff      	b.n	400aa6 <vTaskIncrementTick+0x112>
  400aa6:	bf00      	nop
  400aa8:	3710      	adds	r7, #16
  400aaa:	46bd      	mov	sp, r7
  400aac:	bd80      	pop	{r7, pc}
  400aae:	bf00      	nop
  400ab0:	2000a50c 	.word	0x2000a50c
  400ab4:	2000a504 	.word	0x2000a504
  400ab8:	2000a4e4 	.word	0x2000a4e4
  400abc:	004003c5 	.word	0x004003c5
  400ac0:	2000a4e8 	.word	0x2000a4e8
  400ac4:	2000a518 	.word	0x2000a518
  400ac8:	20000014 	.word	0x20000014
  400acc:	004002ed 	.word	0x004002ed
  400ad0:	2000a508 	.word	0x2000a508
  400ad4:	2000a480 	.word	0x2000a480
  400ad8:	0040029d 	.word	0x0040029d
  400adc:	2000a510 	.word	0x2000a510

00400ae0 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
  400ae0:	b580      	push	{r7, lr}
  400ae2:	b082      	sub	sp, #8
  400ae4:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
  400ae6:	4b21      	ldr	r3, [pc, #132]	; (400b6c <vTaskSwitchContext+0x8c>)
  400ae8:	681b      	ldr	r3, [r3, #0]
  400aea:	2b00      	cmp	r3, #0
  400aec:	d010      	beq.n	400b10 <vTaskSwitchContext+0x30>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
  400aee:	4b20      	ldr	r3, [pc, #128]	; (400b70 <vTaskSwitchContext+0x90>)
  400af0:	2201      	movs	r2, #1
  400af2:	601a      	str	r2, [r3, #0]

		taskSELECT_HIGHEST_PRIORITY_TASK();

		traceTASK_SWITCHED_IN();
	}
}
  400af4:	e035      	b.n	400b62 <vTaskSwitchContext+0x82>
		taskSELECT_HIGHEST_PRIORITY_TASK();
  400af6:	4b1f      	ldr	r3, [pc, #124]	; (400b74 <vTaskSwitchContext+0x94>)
  400af8:	681b      	ldr	r3, [r3, #0]
  400afa:	2b00      	cmp	r3, #0
  400afc:	d103      	bne.n	400b06 <vTaskSwitchContext+0x26>
  400afe:	4b1e      	ldr	r3, [pc, #120]	; (400b78 <vTaskSwitchContext+0x98>)
  400b00:	4798      	blx	r3
  400b02:	bf00      	nop
  400b04:	e7fd      	b.n	400b02 <vTaskSwitchContext+0x22>
  400b06:	4b1b      	ldr	r3, [pc, #108]	; (400b74 <vTaskSwitchContext+0x94>)
  400b08:	681b      	ldr	r3, [r3, #0]
  400b0a:	3b01      	subs	r3, #1
  400b0c:	4a19      	ldr	r2, [pc, #100]	; (400b74 <vTaskSwitchContext+0x94>)
  400b0e:	6013      	str	r3, [r2, #0]
  400b10:	4b18      	ldr	r3, [pc, #96]	; (400b74 <vTaskSwitchContext+0x94>)
  400b12:	681a      	ldr	r2, [r3, #0]
  400b14:	4919      	ldr	r1, [pc, #100]	; (400b7c <vTaskSwitchContext+0x9c>)
  400b16:	4613      	mov	r3, r2
  400b18:	009b      	lsls	r3, r3, #2
  400b1a:	4413      	add	r3, r2
  400b1c:	009b      	lsls	r3, r3, #2
  400b1e:	440b      	add	r3, r1
  400b20:	681b      	ldr	r3, [r3, #0]
  400b22:	2b00      	cmp	r3, #0
  400b24:	d0e7      	beq.n	400af6 <vTaskSwitchContext+0x16>
  400b26:	4b13      	ldr	r3, [pc, #76]	; (400b74 <vTaskSwitchContext+0x94>)
  400b28:	681a      	ldr	r2, [r3, #0]
  400b2a:	4613      	mov	r3, r2
  400b2c:	009b      	lsls	r3, r3, #2
  400b2e:	4413      	add	r3, r2
  400b30:	009b      	lsls	r3, r3, #2
  400b32:	4a12      	ldr	r2, [pc, #72]	; (400b7c <vTaskSwitchContext+0x9c>)
  400b34:	4413      	add	r3, r2
  400b36:	607b      	str	r3, [r7, #4]
  400b38:	687b      	ldr	r3, [r7, #4]
  400b3a:	685b      	ldr	r3, [r3, #4]
  400b3c:	685a      	ldr	r2, [r3, #4]
  400b3e:	687b      	ldr	r3, [r7, #4]
  400b40:	605a      	str	r2, [r3, #4]
  400b42:	687b      	ldr	r3, [r7, #4]
  400b44:	685a      	ldr	r2, [r3, #4]
  400b46:	687b      	ldr	r3, [r7, #4]
  400b48:	3308      	adds	r3, #8
  400b4a:	429a      	cmp	r2, r3
  400b4c:	d104      	bne.n	400b58 <vTaskSwitchContext+0x78>
  400b4e:	687b      	ldr	r3, [r7, #4]
  400b50:	685b      	ldr	r3, [r3, #4]
  400b52:	685a      	ldr	r2, [r3, #4]
  400b54:	687b      	ldr	r3, [r7, #4]
  400b56:	605a      	str	r2, [r3, #4]
  400b58:	687b      	ldr	r3, [r7, #4]
  400b5a:	685b      	ldr	r3, [r3, #4]
  400b5c:	68db      	ldr	r3, [r3, #12]
  400b5e:	4a08      	ldr	r2, [pc, #32]	; (400b80 <vTaskSwitchContext+0xa0>)
  400b60:	6013      	str	r3, [r2, #0]
}
  400b62:	bf00      	nop
  400b64:	3708      	adds	r7, #8
  400b66:	46bd      	mov	sp, r7
  400b68:	bd80      	pop	{r7, pc}
  400b6a:	bf00      	nop
  400b6c:	2000a50c 	.word	0x2000a50c
  400b70:	2000a514 	.word	0x2000a514
  400b74:	2000a508 	.word	0x2000a508
  400b78:	004003c5 	.word	0x004003c5
  400b7c:	2000a480 	.word	0x2000a480
  400b80:	2000a47c 	.word	0x2000a47c

00400b84 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
  400b84:	b580      	push	{r7, lr}
  400b86:	b084      	sub	sp, #16
  400b88:	af00      	add	r7, sp, #0
  400b8a:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
  400b8c:	687b      	ldr	r3, [r7, #4]
  400b8e:	68db      	ldr	r3, [r3, #12]
  400b90:	68db      	ldr	r3, [r3, #12]
  400b92:	60bb      	str	r3, [r7, #8]
	configASSERT( pxUnblockedTCB );
  400b94:	68bb      	ldr	r3, [r7, #8]
  400b96:	2b00      	cmp	r3, #0
  400b98:	d103      	bne.n	400ba2 <xTaskRemoveFromEventList+0x1e>
  400b9a:	4b21      	ldr	r3, [pc, #132]	; (400c20 <xTaskRemoveFromEventList+0x9c>)
  400b9c:	4798      	blx	r3
  400b9e:	bf00      	nop
  400ba0:	e7fd      	b.n	400b9e <xTaskRemoveFromEventList+0x1a>
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
  400ba2:	68bb      	ldr	r3, [r7, #8]
  400ba4:	3318      	adds	r3, #24
  400ba6:	4618      	mov	r0, r3
  400ba8:	4b1e      	ldr	r3, [pc, #120]	; (400c24 <xTaskRemoveFromEventList+0xa0>)
  400baa:	4798      	blx	r3

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  400bac:	4b1e      	ldr	r3, [pc, #120]	; (400c28 <xTaskRemoveFromEventList+0xa4>)
  400bae:	681b      	ldr	r3, [r3, #0]
  400bb0:	2b00      	cmp	r3, #0
  400bb2:	d11d      	bne.n	400bf0 <xTaskRemoveFromEventList+0x6c>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
  400bb4:	68bb      	ldr	r3, [r7, #8]
  400bb6:	3304      	adds	r3, #4
  400bb8:	4618      	mov	r0, r3
  400bba:	4b1a      	ldr	r3, [pc, #104]	; (400c24 <xTaskRemoveFromEventList+0xa0>)
  400bbc:	4798      	blx	r3
		prvAddTaskToReadyQueue( pxUnblockedTCB );
  400bbe:	68bb      	ldr	r3, [r7, #8]
  400bc0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  400bc2:	4b1a      	ldr	r3, [pc, #104]	; (400c2c <xTaskRemoveFromEventList+0xa8>)
  400bc4:	681b      	ldr	r3, [r3, #0]
  400bc6:	429a      	cmp	r2, r3
  400bc8:	d903      	bls.n	400bd2 <xTaskRemoveFromEventList+0x4e>
  400bca:	68bb      	ldr	r3, [r7, #8]
  400bcc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  400bce:	4a17      	ldr	r2, [pc, #92]	; (400c2c <xTaskRemoveFromEventList+0xa8>)
  400bd0:	6013      	str	r3, [r2, #0]
  400bd2:	68bb      	ldr	r3, [r7, #8]
  400bd4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  400bd6:	4613      	mov	r3, r2
  400bd8:	009b      	lsls	r3, r3, #2
  400bda:	4413      	add	r3, r2
  400bdc:	009b      	lsls	r3, r3, #2
  400bde:	4a14      	ldr	r2, [pc, #80]	; (400c30 <xTaskRemoveFromEventList+0xac>)
  400be0:	441a      	add	r2, r3
  400be2:	68bb      	ldr	r3, [r7, #8]
  400be4:	3304      	adds	r3, #4
  400be6:	4619      	mov	r1, r3
  400be8:	4610      	mov	r0, r2
  400bea:	4b12      	ldr	r3, [pc, #72]	; (400c34 <xTaskRemoveFromEventList+0xb0>)
  400bec:	4798      	blx	r3
  400bee:	e005      	b.n	400bfc <xTaskRemoveFromEventList+0x78>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
  400bf0:	68bb      	ldr	r3, [r7, #8]
  400bf2:	3318      	adds	r3, #24
  400bf4:	4619      	mov	r1, r3
  400bf6:	4810      	ldr	r0, [pc, #64]	; (400c38 <xTaskRemoveFromEventList+0xb4>)
  400bf8:	4b0e      	ldr	r3, [pc, #56]	; (400c34 <xTaskRemoveFromEventList+0xb0>)
  400bfa:	4798      	blx	r3
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
  400bfc:	68bb      	ldr	r3, [r7, #8]
  400bfe:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  400c00:	4b0e      	ldr	r3, [pc, #56]	; (400c3c <xTaskRemoveFromEventList+0xb8>)
  400c02:	681b      	ldr	r3, [r3, #0]
  400c04:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  400c06:	429a      	cmp	r2, r3
  400c08:	d302      	bcc.n	400c10 <xTaskRemoveFromEventList+0x8c>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
  400c0a:	2301      	movs	r3, #1
  400c0c:	60fb      	str	r3, [r7, #12]
  400c0e:	e001      	b.n	400c14 <xTaskRemoveFromEventList+0x90>
	}
	else
	{
		xReturn = pdFALSE;
  400c10:	2300      	movs	r3, #0
  400c12:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
  400c14:	68fb      	ldr	r3, [r7, #12]
}
  400c16:	4618      	mov	r0, r3
  400c18:	3710      	adds	r7, #16
  400c1a:	46bd      	mov	sp, r7
  400c1c:	bd80      	pop	{r7, pc}
  400c1e:	bf00      	nop
  400c20:	004003c5 	.word	0x004003c5
  400c24:	004002ed 	.word	0x004002ed
  400c28:	2000a50c 	.word	0x2000a50c
  400c2c:	2000a508 	.word	0x2000a508
  400c30:	2000a480 	.word	0x2000a480
  400c34:	0040029d 	.word	0x0040029d
  400c38:	2000a4ec 	.word	0x2000a4ec
  400c3c:	2000a47c 	.word	0x2000a47c

00400c40 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  400c40:	b480      	push	{r7}
  400c42:	b083      	sub	sp, #12
  400c44:	af00      	add	r7, sp, #0
  400c46:	4603      	mov	r3, r0
  400c48:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
  400c4a:	f997 3007 	ldrsb.w	r3, [r7, #7]
  400c4e:	2b00      	cmp	r3, #0
  400c50:	db0b      	blt.n	400c6a <__NVIC_EnableIRQ+0x2a>
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
  400c52:	4909      	ldr	r1, [pc, #36]	; (400c78 <__NVIC_EnableIRQ+0x38>)
  400c54:	f997 3007 	ldrsb.w	r3, [r7, #7]
  400c58:	095b      	lsrs	r3, r3, #5
  400c5a:	79fa      	ldrb	r2, [r7, #7]
  400c5c:	f002 021f 	and.w	r2, r2, #31
  400c60:	2001      	movs	r0, #1
  400c62:	fa00 f202 	lsl.w	r2, r0, r2
  400c66:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
  400c6a:	bf00      	nop
  400c6c:	370c      	adds	r7, #12
  400c6e:	46bd      	mov	sp, r7
  400c70:	f85d 7b04 	ldr.w	r7, [sp], #4
  400c74:	4770      	bx	lr
  400c76:	bf00      	nop
  400c78:	e000e100 	.word	0xe000e100

00400c7c <osc_get_rate>:

	return 0;
}

static inline uint32_t osc_get_rate(uint32_t ul_id)
{
  400c7c:	b480      	push	{r7}
  400c7e:	b083      	sub	sp, #12
  400c80:	af00      	add	r7, sp, #0
  400c82:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  400c84:	687b      	ldr	r3, [r7, #4]
  400c86:	2b07      	cmp	r3, #7
  400c88:	d825      	bhi.n	400cd6 <osc_get_rate+0x5a>
  400c8a:	a201      	add	r2, pc, #4	; (adr r2, 400c90 <osc_get_rate+0x14>)
  400c8c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  400c90:	00400cb1 	.word	0x00400cb1
  400c94:	00400cb7 	.word	0x00400cb7
  400c98:	00400cbd 	.word	0x00400cbd
  400c9c:	00400cc3 	.word	0x00400cc3
  400ca0:	00400cc7 	.word	0x00400cc7
  400ca4:	00400ccb 	.word	0x00400ccb
  400ca8:	00400ccf 	.word	0x00400ccf
  400cac:	00400cd3 	.word	0x00400cd3
	case OSC_SLCK_32K_RC:
		return OSC_SLCK_32K_RC_HZ;
  400cb0:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  400cb4:	e010      	b.n	400cd8 <osc_get_rate+0x5c>

	case OSC_SLCK_32K_XTAL:
		return BOARD_FREQ_SLCK_XTAL;
  400cb6:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  400cba:	e00d      	b.n	400cd8 <osc_get_rate+0x5c>

	case OSC_SLCK_32K_BYPASS:
		return BOARD_FREQ_SLCK_BYPASS;
  400cbc:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  400cc0:	e00a      	b.n	400cd8 <osc_get_rate+0x5c>

	case OSC_MAINCK_4M_RC:
		return OSC_MAINCK_4M_RC_HZ;
  400cc2:	4b08      	ldr	r3, [pc, #32]	; (400ce4 <osc_get_rate+0x68>)
  400cc4:	e008      	b.n	400cd8 <osc_get_rate+0x5c>

	case OSC_MAINCK_8M_RC:
		return OSC_MAINCK_8M_RC_HZ;
  400cc6:	4b08      	ldr	r3, [pc, #32]	; (400ce8 <osc_get_rate+0x6c>)
  400cc8:	e006      	b.n	400cd8 <osc_get_rate+0x5c>

	case OSC_MAINCK_12M_RC:
		return OSC_MAINCK_12M_RC_HZ;
  400cca:	4b08      	ldr	r3, [pc, #32]	; (400cec <osc_get_rate+0x70>)
  400ccc:	e004      	b.n	400cd8 <osc_get_rate+0x5c>

	case OSC_MAINCK_XTAL:
		return BOARD_FREQ_MAINCK_XTAL;
  400cce:	4b07      	ldr	r3, [pc, #28]	; (400cec <osc_get_rate+0x70>)
  400cd0:	e002      	b.n	400cd8 <osc_get_rate+0x5c>

	case OSC_MAINCK_BYPASS:
		return BOARD_FREQ_MAINCK_BYPASS;
  400cd2:	4b06      	ldr	r3, [pc, #24]	; (400cec <osc_get_rate+0x70>)
  400cd4:	e000      	b.n	400cd8 <osc_get_rate+0x5c>
	}

	return 0;
  400cd6:	2300      	movs	r3, #0
}
  400cd8:	4618      	mov	r0, r3
  400cda:	370c      	adds	r7, #12
  400cdc:	46bd      	mov	sp, r7
  400cde:	f85d 7b04 	ldr.w	r7, [sp], #4
  400ce2:	4770      	bx	lr
  400ce4:	003d0900 	.word	0x003d0900
  400ce8:	007a1200 	.word	0x007a1200
  400cec:	00b71b00 	.word	0x00b71b00

00400cf0 <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern uint32_t sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
  400cf0:	b580      	push	{r7, lr}
  400cf2:	af00      	add	r7, sp, #0
	} else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_MAINCK_BYPASS) {
		return OSC_MAINCK_BYPASS_HZ;
	}
#ifdef CONFIG_PLL0_SOURCE
	else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_PLLACK) {
		return pll_get_default_rate(0);
  400cf4:	2006      	movs	r0, #6
  400cf6:	4b03      	ldr	r3, [pc, #12]	; (400d04 <sysclk_get_main_hz+0x14>)
  400cf8:	4798      	blx	r3
  400cfa:	4603      	mov	r3, r0
  400cfc:	011b      	lsls	r3, r3, #4

	else {
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
  400cfe:	4618      	mov	r0, r3
  400d00:	bd80      	pop	{r7, pc}
  400d02:	bf00      	nop
  400d04:	00400c7d 	.word	0x00400c7d

00400d08 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
  400d08:	b580      	push	{r7, lr}
  400d0a:	af00      	add	r7, sp, #0
	/* CONFIG_SYSCLK_PRES is the register value for setting the expected */
	/* prescaler, not an immediate value. */
	return sysclk_get_main_hz() /
  400d0c:	4b02      	ldr	r3, [pc, #8]	; (400d18 <sysclk_get_cpu_hz+0x10>)
  400d0e:	4798      	blx	r3
  400d10:	4603      	mov	r3, r0
  400d12:	085b      	lsrs	r3, r3, #1
		((CONFIG_SYSCLK_PRES == SYSCLK_PRES_3) ? 3 :
			(1 << (CONFIG_SYSCLK_PRES >> PMC_MCKR_PRES_Pos)));
}
  400d14:	4618      	mov	r0, r3
  400d16:	bd80      	pop	{r7, pc}
  400d18:	00400cf1 	.word	0x00400cf1

00400d1c <sysclk_get_peripheral_hz>:
 * \brief Retrieves the current rate in Hz of the peripheral clocks.
 *
 * \return Frequency of the peripheral clocks, in Hz.
 */
static inline uint32_t sysclk_get_peripheral_hz(void)
{
  400d1c:	b580      	push	{r7, lr}
  400d1e:	af00      	add	r7, sp, #0
	/* CONFIG_SYSCLK_PRES is the register value for setting the expected */
	/* prescaler, not an immediate value. */
	return sysclk_get_main_hz() /
  400d20:	4b02      	ldr	r3, [pc, #8]	; (400d2c <sysclk_get_peripheral_hz+0x10>)
  400d22:	4798      	blx	r3
  400d24:	4603      	mov	r3, r0
  400d26:	085b      	lsrs	r3, r3, #1
		((CONFIG_SYSCLK_PRES == SYSCLK_PRES_3) ? 3 :
			(1 << (CONFIG_SYSCLK_PRES >> PMC_MCKR_PRES_Pos)));
}
  400d28:	4618      	mov	r0, r3
  400d2a:	bd80      	pop	{r7, pc}
  400d2c:	00400cf1 	.word	0x00400cf1

00400d30 <sysclk_enable_peripheral_clock>:
 * \brief Enable a peripheral's clock.
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
  400d30:	b580      	push	{r7, lr}
  400d32:	b082      	sub	sp, #8
  400d34:	af00      	add	r7, sp, #0
  400d36:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  400d38:	6878      	ldr	r0, [r7, #4]
  400d3a:	4b03      	ldr	r3, [pc, #12]	; (400d48 <sysclk_enable_peripheral_clock+0x18>)
  400d3c:	4798      	blx	r3
}
  400d3e:	bf00      	nop
  400d40:	3708      	adds	r7, #8
  400d42:	46bd      	mov	sp, r7
  400d44:	bd80      	pop	{r7, pc}
  400d46:	bf00      	nop
  400d48:	00402921 	.word	0x00402921

00400d4c <twi_master_setup>:
typedef twi_options_t twi_master_options_t;
typedef twi_packet_t twi_package_t;

static inline uint32_t twi_master_setup(twi_master_t p_twi,
		twi_master_options_t *p_opt)
{
  400d4c:	b580      	push	{r7, lr}
  400d4e:	b082      	sub	sp, #8
  400d50:	af00      	add	r7, sp, #0
  400d52:	6078      	str	r0, [r7, #4]
  400d54:	6039      	str	r1, [r7, #0]
	p_opt->master_clk = sysclk_get_peripheral_hz();
  400d56:	4b10      	ldr	r3, [pc, #64]	; (400d98 <twi_master_setup+0x4c>)
  400d58:	4798      	blx	r3
  400d5a:	4602      	mov	r2, r0
  400d5c:	683b      	ldr	r3, [r7, #0]
  400d5e:	601a      	str	r2, [r3, #0]
	p_opt->smbus      = 0;
  400d60:	683b      	ldr	r3, [r7, #0]
  400d62:	2200      	movs	r2, #0
  400d64:	725a      	strb	r2, [r3, #9]
	} else {
		// Do Nothing
	}
#else
#if (!(SAMG51 || SAMG53 || SAMG54))
	if (p_twi == TWI0) {
  400d66:	687b      	ldr	r3, [r7, #4]
  400d68:	4a0c      	ldr	r2, [pc, #48]	; (400d9c <twi_master_setup+0x50>)
  400d6a:	4293      	cmp	r3, r2
  400d6c:	d103      	bne.n	400d76 <twi_master_setup+0x2a>
		sysclk_enable_peripheral_clock(ID_TWI0);
  400d6e:	2011      	movs	r0, #17
  400d70:	4b0b      	ldr	r3, [pc, #44]	; (400da0 <twi_master_setup+0x54>)
  400d72:	4798      	blx	r3
  400d74:	e006      	b.n	400d84 <twi_master_setup+0x38>
	} else
#endif
	if (p_twi == TWI1) {
  400d76:	687b      	ldr	r3, [r7, #4]
  400d78:	4a0a      	ldr	r2, [pc, #40]	; (400da4 <twi_master_setup+0x58>)
  400d7a:	4293      	cmp	r3, r2
  400d7c:	d102      	bne.n	400d84 <twi_master_setup+0x38>
		sysclk_enable_peripheral_clock(ID_TWI1);
  400d7e:	2012      	movs	r0, #18
  400d80:	4b07      	ldr	r3, [pc, #28]	; (400da0 <twi_master_setup+0x54>)
  400d82:	4798      	blx	r3
	} else {
		// Do Nothing
	}
#endif

	return (twi_master_init(p_twi, p_opt));
  400d84:	6839      	ldr	r1, [r7, #0]
  400d86:	6878      	ldr	r0, [r7, #4]
  400d88:	4b07      	ldr	r3, [pc, #28]	; (400da8 <twi_master_setup+0x5c>)
  400d8a:	4798      	blx	r3
  400d8c:	4603      	mov	r3, r0
}
  400d8e:	4618      	mov	r0, r3
  400d90:	3708      	adds	r7, #8
  400d92:	46bd      	mov	sp, r7
  400d94:	bd80      	pop	{r7, pc}
  400d96:	bf00      	nop
  400d98:	00400d1d 	.word	0x00400d1d
  400d9c:	400a8000 	.word	0x400a8000
  400da0:	00400d31 	.word	0x00400d31
  400da4:	400ac000 	.word	0x400ac000
  400da8:	004029cd 	.word	0x004029cd

00400dac <bsp_hw_init>:
static void m_bsp_uart_init(void);
static void m_bsp_sdcard_init(void);

/* Function definitions ----------------------------------------------- */
void bsp_hw_init(void)
{
  400dac:	b580      	push	{r7, lr}
  400dae:	af00      	add	r7, sp, #0
  m_bsp_i2c_init();
  400db0:	4b04      	ldr	r3, [pc, #16]	; (400dc4 <bsp_hw_init+0x18>)
  400db2:	4798      	blx	r3
  m_bsp_uart_init();
  400db4:	4b04      	ldr	r3, [pc, #16]	; (400dc8 <bsp_hw_init+0x1c>)
  400db6:	4798      	blx	r3
  bsp_rtc_init();
  400db8:	4b04      	ldr	r3, [pc, #16]	; (400dcc <bsp_hw_init+0x20>)
  400dba:	4798      	blx	r3
#if (_CONFIG_ELEVATOR_BOARD) // {
#else // }{
  m_bsp_sdcard_init();
#endif // }

  bsp_gpio_init();
  400dbc:	4b04      	ldr	r3, [pc, #16]	; (400dd0 <bsp_hw_init+0x24>)
  400dbe:	4798      	blx	r3
}
  400dc0:	bf00      	nop
  400dc2:	bd80      	pop	{r7, pc}
  400dc4:	00400f51 	.word	0x00400f51
  400dc8:	00400f85 	.word	0x00400f85
  400dcc:	004013f1 	.word	0x004013f1
  400dd0:	00401331 	.word	0x00401331

00400dd4 <bsp_i2c_write>:

int bsp_i2c_write(uint8_t slave_addr, uint8_t reg_addr, uint8_t *p_data, uint32_t len)
{
  400dd4:	b580      	push	{r7, lr}
  400dd6:	b08a      	sub	sp, #40	; 0x28
  400dd8:	af00      	add	r7, sp, #0
  400dda:	60ba      	str	r2, [r7, #8]
  400ddc:	607b      	str	r3, [r7, #4]
  400dde:	4603      	mov	r3, r0
  400de0:	73fb      	strb	r3, [r7, #15]
  400de2:	460b      	mov	r3, r1
  400de4:	73bb      	strb	r3, [r7, #14]
  twi_package_t packet_write;

  packet_write.chip        = slave_addr;        // TWI slave bus address
  400de6:	7bfb      	ldrb	r3, [r7, #15]
  400de8:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
  packet_write.addr[0]     = reg_addr;          // TWI slave memory address data
  400dec:	7bbb      	ldrb	r3, [r7, #14]
  400dee:	753b      	strb	r3, [r7, #20]
  packet_write.addr_length = sizeof(reg_addr);  // TWI slave memory address data size
  400df0:	2301      	movs	r3, #1
  400df2:	61bb      	str	r3, [r7, #24]
  packet_write.buffer      = (void *)p_data;    // Transfer data source buffer
  400df4:	68bb      	ldr	r3, [r7, #8]
  400df6:	61fb      	str	r3, [r7, #28]
  packet_write.length      = len;               // Transfer data size (bytes)
  400df8:	687b      	ldr	r3, [r7, #4]
  400dfa:	623b      	str	r3, [r7, #32]

  return twi_master_write(TWI0, &packet_write);
  400dfc:	f107 0314 	add.w	r3, r7, #20
  400e00:	4619      	mov	r1, r3
  400e02:	4804      	ldr	r0, [pc, #16]	; (400e14 <bsp_i2c_write+0x40>)
  400e04:	4b04      	ldr	r3, [pc, #16]	; (400e18 <bsp_i2c_write+0x44>)
  400e06:	4798      	blx	r3
  400e08:	4603      	mov	r3, r0
}
  400e0a:	4618      	mov	r0, r3
  400e0c:	3728      	adds	r7, #40	; 0x28
  400e0e:	46bd      	mov	sp, r7
  400e10:	bd80      	pop	{r7, pc}
  400e12:	bf00      	nop
  400e14:	400a8000 	.word	0x400a8000
  400e18:	00402b81 	.word	0x00402b81

00400e1c <bsp_uart_write>:

uint32_t bsp_uart_write(uint8_t p_data)
{
  400e1c:	b580      	push	{r7, lr}
  400e1e:	b082      	sub	sp, #8
  400e20:	af00      	add	r7, sp, #0
  400e22:	4603      	mov	r3, r0
  400e24:	71fb      	strb	r3, [r7, #7]
  return uart_write(UART0, p_data);
  400e26:	79fb      	ldrb	r3, [r7, #7]
  400e28:	4619      	mov	r1, r3
  400e2a:	4804      	ldr	r0, [pc, #16]	; (400e3c <bsp_uart_write+0x20>)
  400e2c:	4b04      	ldr	r3, [pc, #16]	; (400e40 <bsp_uart_write+0x24>)
  400e2e:	4798      	blx	r3
  400e30:	4603      	mov	r3, r0
}
  400e32:	4618      	mov	r0, r3
  400e34:	3708      	adds	r7, #8
  400e36:	46bd      	mov	sp, r7
  400e38:	bd80      	pop	{r7, pc}
  400e3a:	bf00      	nop
  400e3c:	400e0600 	.word	0x400e0600
  400e40:	004001fb 	.word	0x004001fb
  400e44:	00000000 	.word	0x00000000

00400e48 <bsp_delay>:

void bsp_delay(uint32_t ms)
{
  400e48:	b5f0      	push	{r4, r5, r6, r7, lr}
  400e4a:	b083      	sub	sp, #12
  400e4c:	af00      	add	r7, sp, #0
  400e4e:	6078      	str	r0, [r7, #4]
  delay_ms(ms);
  400e50:	687b      	ldr	r3, [r7, #4]
  400e52:	2b00      	cmp	r3, #0
  400e54:	d026      	beq.n	400ea4 <bsp_delay+0x5c>
  400e56:	687b      	ldr	r3, [r7, #4]
  400e58:	461d      	mov	r5, r3
  400e5a:	f04f 0600 	mov.w	r6, #0
  400e5e:	4b22      	ldr	r3, [pc, #136]	; (400ee8 <bsp_delay+0xa0>)
  400e60:	4798      	blx	r3
  400e62:	4603      	mov	r3, r0
  400e64:	f04f 0400 	mov.w	r4, #0
  400e68:	fb03 f106 	mul.w	r1, r3, r6
  400e6c:	fb05 f204 	mul.w	r2, r5, r4
  400e70:	440a      	add	r2, r1
  400e72:	fba5 3403 	umull	r3, r4, r5, r3
  400e76:	4422      	add	r2, r4
  400e78:	4614      	mov	r4, r2
  400e7a:	f243 61af 	movw	r1, #13999	; 0x36af
  400e7e:	f04f 0200 	mov.w	r2, #0
  400e82:	185d      	adds	r5, r3, r1
  400e84:	eb44 0602 	adc.w	r6, r4, r2
  400e88:	4628      	mov	r0, r5
  400e8a:	4631      	mov	r1, r6
  400e8c:	4c17      	ldr	r4, [pc, #92]	; (400eec <bsp_delay+0xa4>)
  400e8e:	f243 62b0 	movw	r2, #14000	; 0x36b0
  400e92:	f04f 0300 	mov.w	r3, #0
  400e96:	47a0      	blx	r4
  400e98:	4603      	mov	r3, r0
  400e9a:	460c      	mov	r4, r1
  400e9c:	4618      	mov	r0, r3
  400e9e:	4b14      	ldr	r3, [pc, #80]	; (400ef0 <bsp_delay+0xa8>)
  400ea0:	4798      	blx	r3
}
  400ea2:	e016      	b.n	400ed2 <bsp_delay+0x8a>
  delay_ms(ms);
  400ea4:	4b10      	ldr	r3, [pc, #64]	; (400ee8 <bsp_delay+0xa0>)
  400ea6:	4798      	blx	r3
  400ea8:	4603      	mov	r3, r0
  400eaa:	f04f 0400 	mov.w	r4, #0
  400eae:	a20c      	add	r2, pc, #48	; (adr r2, 400ee0 <bsp_delay+0x98>)
  400eb0:	e9d2 1200 	ldrd	r1, r2, [r2]
  400eb4:	185d      	adds	r5, r3, r1
  400eb6:	eb44 0602 	adc.w	r6, r4, r2
  400eba:	4628      	mov	r0, r5
  400ebc:	4631      	mov	r1, r6
  400ebe:	4c0b      	ldr	r4, [pc, #44]	; (400eec <bsp_delay+0xa4>)
  400ec0:	4a0c      	ldr	r2, [pc, #48]	; (400ef4 <bsp_delay+0xac>)
  400ec2:	f04f 0300 	mov.w	r3, #0
  400ec6:	47a0      	blx	r4
  400ec8:	4603      	mov	r3, r0
  400eca:	460c      	mov	r4, r1
  400ecc:	4618      	mov	r0, r3
  400ece:	4b08      	ldr	r3, [pc, #32]	; (400ef0 <bsp_delay+0xa8>)
  400ed0:	4798      	blx	r3
}
  400ed2:	bf00      	nop
  400ed4:	370c      	adds	r7, #12
  400ed6:	46bd      	mov	sp, r7
  400ed8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  400eda:	bf00      	nop
  400edc:	f3af 8000 	nop.w
  400ee0:	00d59f7f 	.word	0x00d59f7f
  400ee4:	00000000 	.word	0x00000000
  400ee8:	00400d09 	.word	0x00400d09
  400eec:	00402c7d 	.word	0x00402c7d
  400ef0:	20000001 	.word	0x20000001
  400ef4:	00d59f80 	.word	0x00d59f80

00400ef8 <UART0_Handler>:

void UART0_Handler()
{
  400ef8:	b580      	push	{r7, lr}
  400efa:	b082      	sub	sp, #8
  400efc:	af00      	add	r7, sp, #0
  uint32_t dw_status = uart_get_status(UART0);
  400efe:	480f      	ldr	r0, [pc, #60]	; (400f3c <UART0_Handler+0x44>)
  400f00:	4b0f      	ldr	r3, [pc, #60]	; (400f40 <UART0_Handler+0x48>)
  400f02:	4798      	blx	r3
  400f04:	6078      	str	r0, [r7, #4]

  if (dw_status & UART_SR_RXRDY)
  400f06:	687b      	ldr	r3, [r7, #4]
  400f08:	f003 0301 	and.w	r3, r3, #1
  400f0c:	2b00      	cmp	r3, #0
  400f0e:	d010      	beq.n	400f32 <UART0_Handler+0x3a>
  {
    uint8_t received_byte;
    uart_read(UART0, &received_byte);
  400f10:	1cfb      	adds	r3, r7, #3
  400f12:	4619      	mov	r1, r3
  400f14:	4809      	ldr	r0, [pc, #36]	; (400f3c <UART0_Handler+0x44>)
  400f16:	4b0b      	ldr	r3, [pc, #44]	; (400f44 <UART0_Handler+0x4c>)
  400f18:	4798      	blx	r3
    m_read_buffer[m_read_buffer_index] = received_byte;
  400f1a:	4b0b      	ldr	r3, [pc, #44]	; (400f48 <UART0_Handler+0x50>)
  400f1c:	881b      	ldrh	r3, [r3, #0]
  400f1e:	461a      	mov	r2, r3
  400f20:	78f9      	ldrb	r1, [r7, #3]
  400f22:	4b0a      	ldr	r3, [pc, #40]	; (400f4c <UART0_Handler+0x54>)
  400f24:	5499      	strb	r1, [r3, r2]
    m_read_buffer_index++;
  400f26:	4b08      	ldr	r3, [pc, #32]	; (400f48 <UART0_Handler+0x50>)
  400f28:	881b      	ldrh	r3, [r3, #0]
  400f2a:	3301      	adds	r3, #1
  400f2c:	b29a      	uxth	r2, r3
  400f2e:	4b06      	ldr	r3, [pc, #24]	; (400f48 <UART0_Handler+0x50>)
  400f30:	801a      	strh	r2, [r3, #0]
  }
}
  400f32:	bf00      	nop
  400f34:	3708      	adds	r7, #8
  400f36:	46bd      	mov	sp, r7
  400f38:	bd80      	pop	{r7, pc}
  400f3a:	bf00      	nop
  400f3c:	400e0600 	.word	0x400e0600
  400f40:	004001e3 	.word	0x004001e3
  400f44:	0040022b 	.word	0x0040022b
  400f48:	2000a710 	.word	0x2000a710
  400f4c:	2000a51c 	.word	0x2000a51c

00400f50 <m_bsp_i2c_init>:
/* Private function definitions ---------------------------------------- */
/**
 * @brief I2C init
 */
static void m_bsp_i2c_init(void)
{
  400f50:	b580      	push	{r7, lr}
  400f52:	b084      	sub	sp, #16
  400f54:	af00      	add	r7, sp, #0
  twi_master_options_t opt = {
  400f56:	1d3b      	adds	r3, r7, #4
  400f58:	2200      	movs	r2, #0
  400f5a:	601a      	str	r2, [r3, #0]
  400f5c:	605a      	str	r2, [r3, #4]
  400f5e:	609a      	str	r2, [r3, #8]
  400f60:	4b05      	ldr	r3, [pc, #20]	; (400f78 <m_bsp_i2c_init+0x28>)
  400f62:	60bb      	str	r3, [r7, #8]
      .speed = 100000
  };

  twi_master_setup(TWI0, &opt);
  400f64:	1d3b      	adds	r3, r7, #4
  400f66:	4619      	mov	r1, r3
  400f68:	4804      	ldr	r0, [pc, #16]	; (400f7c <m_bsp_i2c_init+0x2c>)
  400f6a:	4b05      	ldr	r3, [pc, #20]	; (400f80 <m_bsp_i2c_init+0x30>)
  400f6c:	4798      	blx	r3
}
  400f6e:	bf00      	nop
  400f70:	3710      	adds	r7, #16
  400f72:	46bd      	mov	sp, r7
  400f74:	bd80      	pop	{r7, pc}
  400f76:	bf00      	nop
  400f78:	000186a0 	.word	0x000186a0
  400f7c:	400a8000 	.word	0x400a8000
  400f80:	00400d4d 	.word	0x00400d4d

00400f84 <m_bsp_uart_init>:

/**
 * @brief Uart init
 */
static void m_bsp_uart_init(void)
{
  400f84:	b580      	push	{r7, lr}
  400f86:	b084      	sub	sp, #16
  400f88:	af00      	add	r7, sp, #0
  const sam_uart_opt_t uart_settings = { sysclk_get_cpu_hz(), UART_SERIAL_BAUDRATE, UART_SERIAL_MODE };
  400f8a:	4b12      	ldr	r3, [pc, #72]	; (400fd4 <m_bsp_uart_init+0x50>)
  400f8c:	4798      	blx	r3
  400f8e:	4603      	mov	r3, r0
  400f90:	607b      	str	r3, [r7, #4]
  400f92:	f44f 5316 	mov.w	r3, #9600	; 0x2580
  400f96:	60bb      	str	r3, [r7, #8]
  400f98:	f44f 6300 	mov.w	r3, #2048	; 0x800
  400f9c:	60fb      	str	r3, [r7, #12]

  // Enable the uart peripheral clock
  sysclk_enable_peripheral_clock(ID_UART0);
  400f9e:	2007      	movs	r0, #7
  400fa0:	4b0d      	ldr	r3, [pc, #52]	; (400fd8 <m_bsp_uart_init+0x54>)
  400fa2:	4798      	blx	r3

  // Set the pins to use the uart peripheral
  pio_set_peripheral(PIOA, PIO_TYPE_PIO_PERIPH_A, PINS_UART0);
  400fa4:	f44f 62c0 	mov.w	r2, #1536	; 0x600
  400fa8:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  400fac:	480b      	ldr	r0, [pc, #44]	; (400fdc <m_bsp_uart_init+0x58>)
  400fae:	4b0c      	ldr	r3, [pc, #48]	; (400fe0 <m_bsp_uart_init+0x5c>)
  400fb0:	4798      	blx	r3

  // Init UART0 and enable Rx and Tx
  uart_init(UART0, &uart_settings);
  400fb2:	1d3b      	adds	r3, r7, #4
  400fb4:	4619      	mov	r1, r3
  400fb6:	480b      	ldr	r0, [pc, #44]	; (400fe4 <m_bsp_uart_init+0x60>)
  400fb8:	4b0b      	ldr	r3, [pc, #44]	; (400fe8 <m_bsp_uart_init+0x64>)
  400fba:	4798      	blx	r3

  // Interrupt reading ready
  uart_enable_interrupt(UART0, UART_IER_RXRDY);
  400fbc:	2101      	movs	r1, #1
  400fbe:	4809      	ldr	r0, [pc, #36]	; (400fe4 <m_bsp_uart_init+0x60>)
  400fc0:	4b0a      	ldr	r3, [pc, #40]	; (400fec <m_bsp_uart_init+0x68>)
  400fc2:	4798      	blx	r3
  NVIC_EnableIRQ(UART0_IRQn);
  400fc4:	2007      	movs	r0, #7
  400fc6:	4b0a      	ldr	r3, [pc, #40]	; (400ff0 <m_bsp_uart_init+0x6c>)
  400fc8:	4798      	blx	r3
}
  400fca:	bf00      	nop
  400fcc:	3710      	adds	r7, #16
  400fce:	46bd      	mov	sp, r7
  400fd0:	bd80      	pop	{r7, pc}
  400fd2:	bf00      	nop
  400fd4:	00400d09 	.word	0x00400d09
  400fd8:	00400d31 	.word	0x00400d31
  400fdc:	400e0e00 	.word	0x400e0e00
  400fe0:	004025b5 	.word	0x004025b5
  400fe4:	400e0600 	.word	0x400e0600
  400fe8:	00400165 	.word	0x00400165
  400fec:	004001c7 	.word	0x004001c7
  400ff0:	00400c41 	.word	0x00400c41

00400ff4 <osc_get_rate>:
{
  400ff4:	b480      	push	{r7}
  400ff6:	b083      	sub	sp, #12
  400ff8:	af00      	add	r7, sp, #0
  400ffa:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  400ffc:	687b      	ldr	r3, [r7, #4]
  400ffe:	2b07      	cmp	r3, #7
  401000:	d825      	bhi.n	40104e <osc_get_rate+0x5a>
  401002:	a201      	add	r2, pc, #4	; (adr r2, 401008 <osc_get_rate+0x14>)
  401004:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  401008:	00401029 	.word	0x00401029
  40100c:	0040102f 	.word	0x0040102f
  401010:	00401035 	.word	0x00401035
  401014:	0040103b 	.word	0x0040103b
  401018:	0040103f 	.word	0x0040103f
  40101c:	00401043 	.word	0x00401043
  401020:	00401047 	.word	0x00401047
  401024:	0040104b 	.word	0x0040104b
		return OSC_SLCK_32K_RC_HZ;
  401028:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  40102c:	e010      	b.n	401050 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_XTAL;
  40102e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  401032:	e00d      	b.n	401050 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_BYPASS;
  401034:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  401038:	e00a      	b.n	401050 <osc_get_rate+0x5c>
		return OSC_MAINCK_4M_RC_HZ;
  40103a:	4b08      	ldr	r3, [pc, #32]	; (40105c <osc_get_rate+0x68>)
  40103c:	e008      	b.n	401050 <osc_get_rate+0x5c>
		return OSC_MAINCK_8M_RC_HZ;
  40103e:	4b08      	ldr	r3, [pc, #32]	; (401060 <osc_get_rate+0x6c>)
  401040:	e006      	b.n	401050 <osc_get_rate+0x5c>
		return OSC_MAINCK_12M_RC_HZ;
  401042:	4b08      	ldr	r3, [pc, #32]	; (401064 <osc_get_rate+0x70>)
  401044:	e004      	b.n	401050 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_XTAL;
  401046:	4b07      	ldr	r3, [pc, #28]	; (401064 <osc_get_rate+0x70>)
  401048:	e002      	b.n	401050 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_BYPASS;
  40104a:	4b06      	ldr	r3, [pc, #24]	; (401064 <osc_get_rate+0x70>)
  40104c:	e000      	b.n	401050 <osc_get_rate+0x5c>
	return 0;
  40104e:	2300      	movs	r3, #0
}
  401050:	4618      	mov	r0, r3
  401052:	370c      	adds	r7, #12
  401054:	46bd      	mov	sp, r7
  401056:	f85d 7b04 	ldr.w	r7, [sp], #4
  40105a:	4770      	bx	lr
  40105c:	003d0900 	.word	0x003d0900
  401060:	007a1200 	.word	0x007a1200
  401064:	00b71b00 	.word	0x00b71b00

00401068 <sysclk_get_main_hz>:
{
  401068:	b580      	push	{r7, lr}
  40106a:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  40106c:	2006      	movs	r0, #6
  40106e:	4b03      	ldr	r3, [pc, #12]	; (40107c <sysclk_get_main_hz+0x14>)
  401070:	4798      	blx	r3
  401072:	4603      	mov	r3, r0
  401074:	011b      	lsls	r3, r3, #4
}
  401076:	4618      	mov	r0, r3
  401078:	bd80      	pop	{r7, pc}
  40107a:	bf00      	nop
  40107c:	00400ff5 	.word	0x00400ff5

00401080 <sysclk_get_cpu_hz>:
{
  401080:	b580      	push	{r7, lr}
  401082:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  401084:	4b02      	ldr	r3, [pc, #8]	; (401090 <sysclk_get_cpu_hz+0x10>)
  401086:	4798      	blx	r3
  401088:	4603      	mov	r3, r0
  40108a:	085b      	lsrs	r3, r3, #1
}
  40108c:	4618      	mov	r0, r3
  40108e:	bd80      	pop	{r7, pc}
  401090:	00401069 	.word	0x00401069

00401094 <bsp_can_init>:
static void m_bsp_can_pack_msg_sensor(uint8_t *can_data);
static void m_bsp_can_unpack_msg_sensor(uint8_t *can_data);

/* Function definitions ----------------------------------------------- */
void bsp_can_init(void)
{
  401094:	b580      	push	{r7, lr}
  401096:	b082      	sub	sp, #8
  401098:	af00      	add	r7, sp, #0
  uint32_t ul_sysclk = sysclk_get_cpu_hz();
  40109a:	4b14      	ldr	r3, [pc, #80]	; (4010ec <bsp_can_init+0x58>)
  40109c:	4798      	blx	r3
  40109e:	6078      	str	r0, [r7, #4]

  pmc_enable_periph_clk(ID_CAN1);
  4010a0:	2026      	movs	r0, #38	; 0x26
  4010a2:	4b13      	ldr	r3, [pc, #76]	; (4010f0 <bsp_can_init+0x5c>)
  4010a4:	4798      	blx	r3

  can_init(CAN1, ul_sysclk, CAN_BPS_250K);
  4010a6:	22fa      	movs	r2, #250	; 0xfa
  4010a8:	6879      	ldr	r1, [r7, #4]
  4010aa:	4812      	ldr	r0, [pc, #72]	; (4010f4 <bsp_can_init+0x60>)
  4010ac:	4b12      	ldr	r3, [pc, #72]	; (4010f8 <bsp_can_init+0x64>)
  4010ae:	4798      	blx	r3
  can_reset_all_mailbox(CAN1);
  4010b0:	4810      	ldr	r0, [pc, #64]	; (4010f4 <bsp_can_init+0x60>)
  4010b2:	4b12      	ldr	r3, [pc, #72]	; (4010fc <bsp_can_init+0x68>)
  4010b4:	4798      	blx	r3

  m_can1_mailbox.ul_mb_idx   = 0;
  4010b6:	4b12      	ldr	r3, [pc, #72]	; (401100 <bsp_can_init+0x6c>)
  4010b8:	2200      	movs	r2, #0
  4010ba:	601a      	str	r2, [r3, #0]
  m_can1_mailbox.uc_tx_prio  = 15;
  4010bc:	4b10      	ldr	r3, [pc, #64]	; (401100 <bsp_can_init+0x6c>)
  4010be:	220f      	movs	r2, #15
  4010c0:	71da      	strb	r2, [r3, #7]
  m_can1_mailbox.uc_id_ver   = 0;
  4010c2:	4b0f      	ldr	r3, [pc, #60]	; (401100 <bsp_can_init+0x6c>)
  4010c4:	2200      	movs	r2, #0
  4010c6:	715a      	strb	r2, [r3, #5]
  m_can1_mailbox.uc_length   = 8;
  4010c8:	4b0d      	ldr	r3, [pc, #52]	; (401100 <bsp_can_init+0x6c>)
  4010ca:	2208      	movs	r2, #8
  4010cc:	719a      	strb	r2, [r3, #6]

#if (_CONFIG_ELEVATOR_BOARD) // {
  m_can1_mailbox.uc_obj_type = CAN_MB_TX_MODE;
  4010ce:	4b0c      	ldr	r3, [pc, #48]	; (401100 <bsp_can_init+0x6c>)
  4010d0:	2203      	movs	r2, #3
  4010d2:	711a      	strb	r2, [r3, #4]
  m_can1_mailbox.ul_id_msk   = 0;
  4010d4:	4b0a      	ldr	r3, [pc, #40]	; (401100 <bsp_can_init+0x6c>)
  4010d6:	2200      	movs	r2, #0
  4010d8:	60da      	str	r2, [r3, #12]
  m_can1_mailbox.uc_obj_type = CAN_MB_RX_MODE;
  m_can1_mailbox.ul_id_msk   = CAN_MAM_MIDvA_Msk | CAN_MAM_MIDvB_Msk;
  m_can1_mailbox.ul_id       = CAN_MID_MIDvA(0x07);
#endif // }

  can_mailbox_init(CAN1, &m_can1_mailbox);
  4010da:	4909      	ldr	r1, [pc, #36]	; (401100 <bsp_can_init+0x6c>)
  4010dc:	4805      	ldr	r0, [pc, #20]	; (4010f4 <bsp_can_init+0x60>)
  4010de:	4b09      	ldr	r3, [pc, #36]	; (401104 <bsp_can_init+0x70>)
  4010e0:	4798      	blx	r3
}
  4010e2:	bf00      	nop
  4010e4:	3708      	adds	r7, #8
  4010e6:	46bd      	mov	sp, r7
  4010e8:	bd80      	pop	{r7, pc}
  4010ea:	bf00      	nop
  4010ec:	00401081 	.word	0x00401081
  4010f0:	00402921 	.word	0x00402921
  4010f4:	40014000 	.word	0x40014000
  4010f8:	0040236d 	.word	0x0040236d
  4010fc:	00402571 	.word	0x00402571
  401100:	2000a714 	.word	0x2000a714
  401104:	0040244d 	.word	0x0040244d

00401108 <ioport_set_pin_mode>:
 *
 * \param pin IOPORT pin to configure
 * \param mode Mode masks to configure for the specified pin (\ref ioport_modes)
 */
static inline void ioport_set_pin_mode(ioport_pin_t pin, ioport_mode_t mode)
{
  401108:	b480      	push	{r7}
  40110a:	b08d      	sub	sp, #52	; 0x34
  40110c:	af00      	add	r7, sp, #0
  40110e:	6078      	str	r0, [r7, #4]
  401110:	6039      	str	r1, [r7, #0]
  401112:	687b      	ldr	r3, [r7, #4]
  401114:	62fb      	str	r3, [r7, #44]	; 0x2c
  401116:	683b      	ldr	r3, [r7, #0]
  401118:	62bb      	str	r3, [r7, #40]	; 0x28
  40111a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40111c:	627b      	str	r3, [r7, #36]	; 0x24
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  40111e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401120:	095a      	lsrs	r2, r3, #5
  401122:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401124:	623b      	str	r3, [r7, #32]
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  401126:	6a3b      	ldr	r3, [r7, #32]
  401128:	f003 031f 	and.w	r3, r3, #31
  40112c:	2101      	movs	r1, #1
  40112e:	fa01 f303 	lsl.w	r3, r1, r3
  401132:	61fa      	str	r2, [r7, #28]
  401134:	61bb      	str	r3, [r7, #24]
  401136:	6abb      	ldr	r3, [r7, #40]	; 0x28
  401138:	617b      	str	r3, [r7, #20]
  40113a:	69fb      	ldr	r3, [r7, #28]
  40113c:	613b      	str	r3, [r7, #16]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  40113e:	693b      	ldr	r3, [r7, #16]
  401140:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401144:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401148:	025b      	lsls	r3, r3, #9
}

__always_inline static void arch_ioport_set_port_mode(ioport_port_t port,
		ioport_port_mask_t mask, ioport_mode_t mode)
{
	Pio *base = arch_ioport_port_to_base(port);
  40114a:	60fb      	str	r3, [r7, #12]

	if (mode & IOPORT_MODE_PULLUP) {
  40114c:	697b      	ldr	r3, [r7, #20]
  40114e:	f003 0308 	and.w	r3, r3, #8
  401152:	2b00      	cmp	r3, #0
  401154:	d003      	beq.n	40115e <ioport_set_pin_mode+0x56>
		base->PIO_PUER = mask;
  401156:	68fb      	ldr	r3, [r7, #12]
  401158:	69ba      	ldr	r2, [r7, #24]
  40115a:	665a      	str	r2, [r3, #100]	; 0x64
  40115c:	e002      	b.n	401164 <ioport_set_pin_mode+0x5c>
	} else {
		base->PIO_PUDR = mask;
  40115e:	68fb      	ldr	r3, [r7, #12]
  401160:	69ba      	ldr	r2, [r7, #24]
  401162:	661a      	str	r2, [r3, #96]	; 0x60
	}

#if defined(IOPORT_MODE_PULLDOWN)
	if (mode & IOPORT_MODE_PULLDOWN) {
  401164:	697b      	ldr	r3, [r7, #20]
  401166:	f003 0310 	and.w	r3, r3, #16
  40116a:	2b00      	cmp	r3, #0
  40116c:	d004      	beq.n	401178 <ioport_set_pin_mode+0x70>
		base->PIO_PPDER = mask;
  40116e:	68fb      	ldr	r3, [r7, #12]
  401170:	69ba      	ldr	r2, [r7, #24]
  401172:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  401176:	e003      	b.n	401180 <ioport_set_pin_mode+0x78>
	} else {
		base->PIO_PPDDR = mask;
  401178:	68fb      	ldr	r3, [r7, #12]
  40117a:	69ba      	ldr	r2, [r7, #24]
  40117c:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	}
#endif

	if (mode & IOPORT_MODE_OPEN_DRAIN) {
  401180:	697b      	ldr	r3, [r7, #20]
  401182:	f003 0320 	and.w	r3, r3, #32
  401186:	2b00      	cmp	r3, #0
  401188:	d003      	beq.n	401192 <ioport_set_pin_mode+0x8a>
		base->PIO_MDER = mask;
  40118a:	68fb      	ldr	r3, [r7, #12]
  40118c:	69ba      	ldr	r2, [r7, #24]
  40118e:	651a      	str	r2, [r3, #80]	; 0x50
  401190:	e002      	b.n	401198 <ioport_set_pin_mode+0x90>
	} else {
		base->PIO_MDDR = mask;
  401192:	68fb      	ldr	r3, [r7, #12]
  401194:	69ba      	ldr	r2, [r7, #24]
  401196:	655a      	str	r2, [r3, #84]	; 0x54
	}

	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
  401198:	697b      	ldr	r3, [r7, #20]
  40119a:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
  40119e:	2b00      	cmp	r3, #0
  4011a0:	d003      	beq.n	4011aa <ioport_set_pin_mode+0xa2>
		base->PIO_IFER = mask;
  4011a2:	68fb      	ldr	r3, [r7, #12]
  4011a4:	69ba      	ldr	r2, [r7, #24]
  4011a6:	621a      	str	r2, [r3, #32]
  4011a8:	e002      	b.n	4011b0 <ioport_set_pin_mode+0xa8>
	} else {
		base->PIO_IFDR = mask;
  4011aa:	68fb      	ldr	r3, [r7, #12]
  4011ac:	69ba      	ldr	r2, [r7, #24]
  4011ae:	625a      	str	r2, [r3, #36]	; 0x24
	}

	if (mode & IOPORT_MODE_DEBOUNCE) {
  4011b0:	697b      	ldr	r3, [r7, #20]
  4011b2:	f003 0380 	and.w	r3, r3, #128	; 0x80
  4011b6:	2b00      	cmp	r3, #0
  4011b8:	d004      	beq.n	4011c4 <ioport_set_pin_mode+0xbc>
#if SAM3U || SAM3XA
		base->PIO_DIFSR = mask;
#else
		base->PIO_IFSCER = mask;
  4011ba:	68fb      	ldr	r3, [r7, #12]
  4011bc:	69ba      	ldr	r2, [r7, #24]
  4011be:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  4011c2:	e003      	b.n	4011cc <ioport_set_pin_mode+0xc4>
#endif
	} else {
#if SAM3U || SAM3XA
		base->PIO_SCIFSR = mask;
#else
		base->PIO_IFSCDR = mask;
  4011c4:	68fb      	ldr	r3, [r7, #12]
  4011c6:	69ba      	ldr	r2, [r7, #24]
  4011c8:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
		base->PIO_ABSR |= mask;
	} else {
		base->PIO_ABSR &= ~mask;
	}
#else
	if (mode & IOPORT_MODE_MUX_BIT0) {
  4011cc:	697b      	ldr	r3, [r7, #20]
  4011ce:	f003 0301 	and.w	r3, r3, #1
  4011d2:	2b00      	cmp	r3, #0
  4011d4:	d006      	beq.n	4011e4 <ioport_set_pin_mode+0xdc>
		base->PIO_ABCDSR[0] |= mask;
  4011d6:	68fb      	ldr	r3, [r7, #12]
  4011d8:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  4011da:	69bb      	ldr	r3, [r7, #24]
  4011dc:	431a      	orrs	r2, r3
  4011de:	68fb      	ldr	r3, [r7, #12]
  4011e0:	671a      	str	r2, [r3, #112]	; 0x70
  4011e2:	e006      	b.n	4011f2 <ioport_set_pin_mode+0xea>
	} else {
		base->PIO_ABCDSR[0] &= ~mask;
  4011e4:	68fb      	ldr	r3, [r7, #12]
  4011e6:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  4011e8:	69bb      	ldr	r3, [r7, #24]
  4011ea:	43db      	mvns	r3, r3
  4011ec:	401a      	ands	r2, r3
  4011ee:	68fb      	ldr	r3, [r7, #12]
  4011f0:	671a      	str	r2, [r3, #112]	; 0x70
	}

	if (mode & IOPORT_MODE_MUX_BIT1) {
  4011f2:	697b      	ldr	r3, [r7, #20]
  4011f4:	f003 0302 	and.w	r3, r3, #2
  4011f8:	2b00      	cmp	r3, #0
  4011fa:	d006      	beq.n	40120a <ioport_set_pin_mode+0x102>
		base->PIO_ABCDSR[1] |= mask;
  4011fc:	68fb      	ldr	r3, [r7, #12]
  4011fe:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  401200:	69bb      	ldr	r3, [r7, #24]
  401202:	431a      	orrs	r2, r3
  401204:	68fb      	ldr	r3, [r7, #12]
  401206:	675a      	str	r2, [r3, #116]	; 0x74
	arch_ioport_set_pin_mode(pin, mode);
}
  401208:	e006      	b.n	401218 <ioport_set_pin_mode+0x110>
	} else {
		base->PIO_ABCDSR[1] &= ~mask;
  40120a:	68fb      	ldr	r3, [r7, #12]
  40120c:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  40120e:	69bb      	ldr	r3, [r7, #24]
  401210:	43db      	mvns	r3, r3
  401212:	401a      	ands	r2, r3
  401214:	68fb      	ldr	r3, [r7, #12]
  401216:	675a      	str	r2, [r3, #116]	; 0x74
  401218:	bf00      	nop
  40121a:	3734      	adds	r7, #52	; 0x34
  40121c:	46bd      	mov	sp, r7
  40121e:	f85d 7b04 	ldr.w	r7, [sp], #4
  401222:	4770      	bx	lr

00401224 <ioport_set_pin_dir>:
 * \param pin IOPORT pin to configure
 * \param dir Direction to set for the specified pin (\ref ioport_direction)
 */
static inline void ioport_set_pin_dir(ioport_pin_t pin,
		enum ioport_direction dir)
{
  401224:	b480      	push	{r7}
  401226:	b08d      	sub	sp, #52	; 0x34
  401228:	af00      	add	r7, sp, #0
  40122a:	6078      	str	r0, [r7, #4]
  40122c:	460b      	mov	r3, r1
  40122e:	70fb      	strb	r3, [r7, #3]
  401230:	687b      	ldr	r3, [r7, #4]
  401232:	62fb      	str	r3, [r7, #44]	; 0x2c
  401234:	78fb      	ldrb	r3, [r7, #3]
  401236:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  40123a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40123c:	627b      	str	r3, [r7, #36]	; 0x24
  40123e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401240:	623b      	str	r3, [r7, #32]
	return pin >> 5;
  401242:	6a3b      	ldr	r3, [r7, #32]
  401244:	095b      	lsrs	r3, r3, #5
  401246:	61fb      	str	r3, [r7, #28]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  401248:	69fb      	ldr	r3, [r7, #28]
  40124a:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  40124e:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401252:	025b      	lsls	r3, r3, #9
}

__always_inline static void arch_ioport_set_pin_dir(ioport_pin_t pin,
		enum ioport_direction dir)
{
	Pio *base = arch_ioport_pin_to_base(pin);
  401254:	61bb      	str	r3, [r7, #24]

	if (dir == IOPORT_DIR_OUTPUT) {
  401256:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  40125a:	2b01      	cmp	r3, #1
  40125c:	d109      	bne.n	401272 <ioport_set_pin_dir+0x4e>
  40125e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401260:	617b      	str	r3, [r7, #20]
	return 1U << (pin & 0x1F);
  401262:	697b      	ldr	r3, [r7, #20]
  401264:	f003 031f 	and.w	r3, r3, #31
  401268:	2201      	movs	r2, #1
  40126a:	409a      	lsls	r2, r3
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  40126c:	69bb      	ldr	r3, [r7, #24]
  40126e:	611a      	str	r2, [r3, #16]
  401270:	e00c      	b.n	40128c <ioport_set_pin_dir+0x68>
	} else if (dir == IOPORT_DIR_INPUT) {
  401272:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  401276:	2b00      	cmp	r3, #0
  401278:	d108      	bne.n	40128c <ioport_set_pin_dir+0x68>
  40127a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40127c:	613b      	str	r3, [r7, #16]
	return 1U << (pin & 0x1F);
  40127e:	693b      	ldr	r3, [r7, #16]
  401280:	f003 031f 	and.w	r3, r3, #31
  401284:	2201      	movs	r2, #1
  401286:	409a      	lsls	r2, r3
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
  401288:	69bb      	ldr	r3, [r7, #24]
  40128a:	615a      	str	r2, [r3, #20]
  40128c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40128e:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  401290:	68fb      	ldr	r3, [r7, #12]
  401292:	f003 031f 	and.w	r3, r3, #31
  401296:	2201      	movs	r2, #1
  401298:	409a      	lsls	r2, r3
	}

	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  40129a:	69bb      	ldr	r3, [r7, #24]
  40129c:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
	arch_ioport_set_pin_dir(pin, dir);
}
  4012a0:	bf00      	nop
  4012a2:	3734      	adds	r7, #52	; 0x34
  4012a4:	46bd      	mov	sp, r7
  4012a6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4012aa:	4770      	bx	lr

004012ac <ioport_set_pin_level>:
 *
 * \param pin IOPORT pin to configure
 * \param level Logical value of the pin
 */
static inline void ioport_set_pin_level(ioport_pin_t pin, bool level)
{
  4012ac:	b480      	push	{r7}
  4012ae:	b08b      	sub	sp, #44	; 0x2c
  4012b0:	af00      	add	r7, sp, #0
  4012b2:	6078      	str	r0, [r7, #4]
  4012b4:	460b      	mov	r3, r1
  4012b6:	70fb      	strb	r3, [r7, #3]
  4012b8:	687b      	ldr	r3, [r7, #4]
  4012ba:	627b      	str	r3, [r7, #36]	; 0x24
  4012bc:	78fb      	ldrb	r3, [r7, #3]
  4012be:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  4012c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4012c4:	61fb      	str	r3, [r7, #28]
  4012c6:	69fb      	ldr	r3, [r7, #28]
  4012c8:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  4012ca:	69bb      	ldr	r3, [r7, #24]
  4012cc:	095b      	lsrs	r3, r3, #5
  4012ce:	617b      	str	r3, [r7, #20]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  4012d0:	697b      	ldr	r3, [r7, #20]
  4012d2:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4012d6:	f203 7307 	addw	r3, r3, #1799	; 0x707
  4012da:	025b      	lsls	r3, r3, #9
}

__always_inline static void arch_ioport_set_pin_level(ioport_pin_t pin,
		bool level)
{
	Pio *base = arch_ioport_pin_to_base(pin);
  4012dc:	613b      	str	r3, [r7, #16]

	if (level) {
  4012de:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  4012e2:	2b00      	cmp	r3, #0
  4012e4:	d009      	beq.n	4012fa <ioport_set_pin_level+0x4e>
  4012e6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4012e8:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  4012ea:	68fb      	ldr	r3, [r7, #12]
  4012ec:	f003 031f 	and.w	r3, r3, #31
  4012f0:	2201      	movs	r2, #1
  4012f2:	409a      	lsls	r2, r3
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  4012f4:	693b      	ldr	r3, [r7, #16]
  4012f6:	631a      	str	r2, [r3, #48]	; 0x30
	arch_ioport_set_pin_level(pin, level);
}
  4012f8:	e008      	b.n	40130c <ioport_set_pin_level+0x60>
  4012fa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4012fc:	60bb      	str	r3, [r7, #8]
	return 1U << (pin & 0x1F);
  4012fe:	68bb      	ldr	r3, [r7, #8]
  401300:	f003 031f 	and.w	r3, r3, #31
  401304:	2201      	movs	r2, #1
  401306:	409a      	lsls	r2, r3
	} else {
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  401308:	693b      	ldr	r3, [r7, #16]
  40130a:	635a      	str	r2, [r3, #52]	; 0x34
  40130c:	bf00      	nop
  40130e:	372c      	adds	r7, #44	; 0x2c
  401310:	46bd      	mov	sp, r7
  401312:	f85d 7b04 	ldr.w	r7, [sp], #4
  401316:	4770      	bx	lr

00401318 <bsp_io_get_pin_index>:
{
  return io->pin;
}

static inline uint32_t bsp_io_get_pin_index(const bsp_io_10_t *io)
{
  401318:	b480      	push	{r7}
  40131a:	b083      	sub	sp, #12
  40131c:	af00      	add	r7, sp, #0
  40131e:	6078      	str	r0, [r7, #4]
  return io->pin_index;
  401320:	687b      	ldr	r3, [r7, #4]
  401322:	68db      	ldr	r3, [r3, #12]
}
  401324:	4618      	mov	r0, r3
  401326:	370c      	adds	r7, #12
  401328:	46bd      	mov	sp, r7
  40132a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40132e:	4770      	bx	lr

00401330 <bsp_gpio_init>:
/* Public variables --------------------------------------------------- */
/* Private variables -------------------------------------------------- */
/* Private function prototypes ---------------------------------------- */
/* Function definitions ----------------------------------------------- */
void bsp_gpio_init(void)
{
  401330:	b580      	push	{r7, lr}
  401332:	b082      	sub	sp, #8
  401334:	af00      	add	r7, sp, #0
  for (uint8_t i = 1; i <= SENSOR_COUNT_MAX; i++)
  401336:	2301      	movs	r3, #1
  401338:	71fb      	strb	r3, [r7, #7]
  40133a:	e02f      	b.n	40139c <bsp_gpio_init+0x6c>
  {
    ioport_set_pin_dir(PIN_INDEX(i), IOPORT_DIR_INPUT);
  40133c:	79fa      	ldrb	r2, [r7, #7]
  40133e:	4613      	mov	r3, r2
  401340:	009b      	lsls	r3, r3, #2
  401342:	4413      	add	r3, r2
  401344:	009b      	lsls	r3, r3, #2
  401346:	4a19      	ldr	r2, [pc, #100]	; (4013ac <bsp_gpio_init+0x7c>)
  401348:	4413      	add	r3, r2
  40134a:	4618      	mov	r0, r3
  40134c:	4b18      	ldr	r3, [pc, #96]	; (4013b0 <bsp_gpio_init+0x80>)
  40134e:	4798      	blx	r3
  401350:	4603      	mov	r3, r0
  401352:	2100      	movs	r1, #0
  401354:	4618      	mov	r0, r3
  401356:	4b17      	ldr	r3, [pc, #92]	; (4013b4 <bsp_gpio_init+0x84>)
  401358:	4798      	blx	r3
    ioport_set_pin_level(PIN_INDEX(i), IOPORT_PIN_LEVEL_LOW);
  40135a:	79fa      	ldrb	r2, [r7, #7]
  40135c:	4613      	mov	r3, r2
  40135e:	009b      	lsls	r3, r3, #2
  401360:	4413      	add	r3, r2
  401362:	009b      	lsls	r3, r3, #2
  401364:	4a11      	ldr	r2, [pc, #68]	; (4013ac <bsp_gpio_init+0x7c>)
  401366:	4413      	add	r3, r2
  401368:	4618      	mov	r0, r3
  40136a:	4b11      	ldr	r3, [pc, #68]	; (4013b0 <bsp_gpio_init+0x80>)
  40136c:	4798      	blx	r3
  40136e:	4603      	mov	r3, r0
  401370:	2100      	movs	r1, #0
  401372:	4618      	mov	r0, r3
  401374:	4b10      	ldr	r3, [pc, #64]	; (4013b8 <bsp_gpio_init+0x88>)
  401376:	4798      	blx	r3
    ioport_set_pin_mode(PIN_INDEX(i), IOPORT_MODE_PULLDOWN);
  401378:	79fa      	ldrb	r2, [r7, #7]
  40137a:	4613      	mov	r3, r2
  40137c:	009b      	lsls	r3, r3, #2
  40137e:	4413      	add	r3, r2
  401380:	009b      	lsls	r3, r3, #2
  401382:	4a0a      	ldr	r2, [pc, #40]	; (4013ac <bsp_gpio_init+0x7c>)
  401384:	4413      	add	r3, r2
  401386:	4618      	mov	r0, r3
  401388:	4b09      	ldr	r3, [pc, #36]	; (4013b0 <bsp_gpio_init+0x80>)
  40138a:	4798      	blx	r3
  40138c:	4603      	mov	r3, r0
  40138e:	2110      	movs	r1, #16
  401390:	4618      	mov	r0, r3
  401392:	4b0a      	ldr	r3, [pc, #40]	; (4013bc <bsp_gpio_init+0x8c>)
  401394:	4798      	blx	r3
  for (uint8_t i = 1; i <= SENSOR_COUNT_MAX; i++)
  401396:	79fb      	ldrb	r3, [r7, #7]
  401398:	3301      	adds	r3, #1
  40139a:	71fb      	strb	r3, [r7, #7]
  40139c:	79fb      	ldrb	r3, [r7, #7]
  40139e:	2b63      	cmp	r3, #99	; 0x63
  4013a0:	d9cc      	bls.n	40133c <bsp_gpio_init+0xc>
  }
}
  4013a2:	bf00      	nop
  4013a4:	3708      	adds	r7, #8
  4013a6:	46bd      	mov	sp, r7
  4013a8:	bd80      	pop	{r7, pc}
  4013aa:	bf00      	nop
  4013ac:	004030fc 	.word	0x004030fc
  4013b0:	00401319 	.word	0x00401319
  4013b4:	00401225 	.word	0x00401225
  4013b8:	004012ad 	.word	0x004012ad
  4013bc:	00401109 	.word	0x00401109

004013c0 <bsp_lcd_init>:
/* Private function prototypes ---------------------------------------- */
void m_bsp_lcd_set_position(uint8_t row, uint8_t col);

/* Function definitions ----------------------------------------------- */
void bsp_lcd_init(void)
{
  4013c0:	b580      	push	{r7, lr}
  4013c2:	af00      	add	r7, sp, #0
  m_ssd1311.device_address = SSD1311_I2C_ADDRESS;
  4013c4:	4b06      	ldr	r3, [pc, #24]	; (4013e0 <bsp_lcd_init+0x20>)
  4013c6:	223c      	movs	r2, #60	; 0x3c
  4013c8:	701a      	strb	r2, [r3, #0]
  m_ssd1311.i2c_write      = bsp_i2c_write;
  4013ca:	4b05      	ldr	r3, [pc, #20]	; (4013e0 <bsp_lcd_init+0x20>)
  4013cc:	4a05      	ldr	r2, [pc, #20]	; (4013e4 <bsp_lcd_init+0x24>)
  4013ce:	605a      	str	r2, [r3, #4]
  m_ssd1311.delay          = bsp_delay;
  4013d0:	4b03      	ldr	r3, [pc, #12]	; (4013e0 <bsp_lcd_init+0x20>)
  4013d2:	4a05      	ldr	r2, [pc, #20]	; (4013e8 <bsp_lcd_init+0x28>)
  4013d4:	609a      	str	r2, [r3, #8]
  
  ssd1311_init(&m_ssd1311);
  4013d6:	4802      	ldr	r0, [pc, #8]	; (4013e0 <bsp_lcd_init+0x20>)
  4013d8:	4b04      	ldr	r3, [pc, #16]	; (4013ec <bsp_lcd_init+0x2c>)
  4013da:	4798      	blx	r3
}
  4013dc:	bf00      	nop
  4013de:	bd80      	pop	{r7, pc}
  4013e0:	2000a7ac 	.word	0x2000a7ac
  4013e4:	00400dd5 	.word	0x00400dd5
  4013e8:	00400e49 	.word	0x00400e49
  4013ec:	00401425 	.word	0x00401425

004013f0 <bsp_rtc_init>:
/* Private macros ----------------------------------------------------- */
/* Public variables --------------------------------------------------- */
/* Private variables -------------------------------------------------- */
/* Private function prototypes ---------------------------------------- */
void bsp_rtc_init(void)
{
  4013f0:	b580      	push	{r7, lr}
  4013f2:	af00      	add	r7, sp, #0
  pmc_switch_sclk_to_32kxtal(PMC_OSC_XTAL);
  4013f4:	2000      	movs	r0, #0
  4013f6:	4b07      	ldr	r3, [pc, #28]	; (401414 <bsp_rtc_init+0x24>)
  4013f8:	4798      	blx	r3

  while (!pmc_osc_is_ready_32kxtal());
  4013fa:	bf00      	nop
  4013fc:	4b06      	ldr	r3, [pc, #24]	; (401418 <bsp_rtc_init+0x28>)
  4013fe:	4798      	blx	r3
  401400:	4603      	mov	r3, r0
  401402:	2b00      	cmp	r3, #0
  401404:	d0fa      	beq.n	4013fc <bsp_rtc_init+0xc>

  rtc_set_hour_mode(RTC, 0);
  401406:	2100      	movs	r1, #0
  401408:	4804      	ldr	r0, [pc, #16]	; (40141c <bsp_rtc_init+0x2c>)
  40140a:	4b05      	ldr	r3, [pc, #20]	; (401420 <bsp_rtc_init+0x30>)
  40140c:	4798      	blx	r3
}
  40140e:	bf00      	nop
  401410:	bd80      	pop	{r7, pc}
  401412:	bf00      	nop
  401414:	00402779 	.word	0x00402779
  401418:	004027b1 	.word	0x004027b1
  40141c:	400e1860 	.word	0x400e1860
  401420:	00401a19 	.word	0x00401a19

00401424 <ssd1311_init>:
void cursPos(ssd1311_t *me, uint8_t col, uint8_t row);


/* Function definitions ----------------------------------------------- */
base_status_t ssd1311_init(ssd1311_t *me)
{
  401424:	b580      	push	{r7, lr}
  401426:	b082      	sub	sp, #8
  401428:	af00      	add	r7, sp, #0
  40142a:	6078      	str	r0, [r7, #4]
  if ((me == NULL) || (me->i2c_write == NULL))
  40142c:	687b      	ldr	r3, [r7, #4]
  40142e:	2b00      	cmp	r3, #0
  401430:	d003      	beq.n	40143a <ssd1311_init+0x16>
  401432:	687b      	ldr	r3, [r7, #4]
  401434:	685b      	ldr	r3, [r3, #4]
  401436:	2b00      	cmp	r3, #0
  401438:	d101      	bne.n	40143e <ssd1311_init+0x1a>
    return BS_ERROR_PARAMS;
  40143a:	2301      	movs	r3, #1
  40143c:	e003      	b.n	401446 <ssd1311_init+0x22>

  m_ssd1311_run_cfg_script(me);
  40143e:	6878      	ldr	r0, [r7, #4]
  401440:	4b03      	ldr	r3, [pc, #12]	; (401450 <ssd1311_init+0x2c>)
  401442:	4798      	blx	r3

  return BS_OK;
  401444:	2300      	movs	r3, #0
}
  401446:	4618      	mov	r0, r3
  401448:	3708      	adds	r7, #8
  40144a:	46bd      	mov	sp, r7
  40144c:	bd80      	pop	{r7, pc}
  40144e:	bf00      	nop
  401450:	004014b5 	.word	0x004014b5

00401454 <ssd1311_write_cmd>:

base_status_t ssd1311_write_cmd(ssd1311_t *me, uint8_t cmd)
{
  401454:	b590      	push	{r4, r7, lr}
  401456:	b083      	sub	sp, #12
  401458:	af00      	add	r7, sp, #0
  40145a:	6078      	str	r0, [r7, #4]
  40145c:	460b      	mov	r3, r1
  40145e:	70fb      	strb	r3, [r7, #3]
  CHECK(BS_OK == me->i2c_write(me->device_address, SSD1311_CMD_MODE, &cmd, 1), BS_ERROR);
  401460:	687b      	ldr	r3, [r7, #4]
  401462:	685c      	ldr	r4, [r3, #4]
  401464:	687b      	ldr	r3, [r7, #4]
  401466:	7818      	ldrb	r0, [r3, #0]
  401468:	1cfa      	adds	r2, r7, #3
  40146a:	2301      	movs	r3, #1
  40146c:	2180      	movs	r1, #128	; 0x80
  40146e:	47a0      	blx	r4
  401470:	4603      	mov	r3, r0
  401472:	2b00      	cmp	r3, #0
  401474:	d001      	beq.n	40147a <ssd1311_write_cmd+0x26>
  401476:	2302      	movs	r3, #2
  401478:	e000      	b.n	40147c <ssd1311_write_cmd+0x28>

  return BS_OK;
  40147a:	2300      	movs	r3, #0
}
  40147c:	4618      	mov	r0, r3
  40147e:	370c      	adds	r7, #12
  401480:	46bd      	mov	sp, r7
  401482:	bd90      	pop	{r4, r7, pc}

00401484 <ssd1311_write_data_byte>:

  return BS_OK;
}

base_status_t ssd1311_write_data_byte(ssd1311_t *me, uint8_t data)
{
  401484:	b590      	push	{r4, r7, lr}
  401486:	b083      	sub	sp, #12
  401488:	af00      	add	r7, sp, #0
  40148a:	6078      	str	r0, [r7, #4]
  40148c:	460b      	mov	r3, r1
  40148e:	70fb      	strb	r3, [r7, #3]
  CHECK(BS_OK == me->i2c_write(me->device_address, SSD1311_DATA_MODE, &data, 1), BS_ERROR);
  401490:	687b      	ldr	r3, [r7, #4]
  401492:	685c      	ldr	r4, [r3, #4]
  401494:	687b      	ldr	r3, [r7, #4]
  401496:	7818      	ldrb	r0, [r3, #0]
  401498:	1cfa      	adds	r2, r7, #3
  40149a:	2301      	movs	r3, #1
  40149c:	2140      	movs	r1, #64	; 0x40
  40149e:	47a0      	blx	r4
  4014a0:	4603      	mov	r3, r0
  4014a2:	2b00      	cmp	r3, #0
  4014a4:	d001      	beq.n	4014aa <ssd1311_write_data_byte+0x26>
  4014a6:	2302      	movs	r3, #2
  4014a8:	e000      	b.n	4014ac <ssd1311_write_data_byte+0x28>

  return BS_OK;
  4014aa:	2300      	movs	r3, #0
}
  4014ac:	4618      	mov	r0, r3
  4014ae:	370c      	adds	r7, #12
  4014b0:	46bd      	mov	sp, r7
  4014b2:	bd90      	pop	{r4, r7, pc}

004014b4 <m_ssd1311_run_cfg_script>:
 * @return
 * - BS_OK
 * - BS_ERROR
 */
static base_status_t m_ssd1311_run_cfg_script(ssd1311_t *me)
{
  4014b4:	b580      	push	{r7, lr}
  4014b6:	b084      	sub	sp, #16
  4014b8:	af00      	add	r7, sp, #0
  4014ba:	6078      	str	r0, [r7, #4]
  int i          = 0;
  4014bc:	2300      	movs	r3, #0
  4014be:	60fb      	str	r3, [r7, #12]
  int end_script = 0;
  4014c0:	2300      	movs	r3, #0
  4014c2:	60bb      	str	r3, [r7, #8]

  do
  {
    switch (SSD1311_CFG_SCRIPT[i].cmd)
  4014c4:	4a20      	ldr	r2, [pc, #128]	; (401548 <m_ssd1311_run_cfg_script+0x94>)
  4014c6:	68fb      	ldr	r3, [r7, #12]
  4014c8:	f812 3013 	ldrb.w	r3, [r2, r3, lsl #1]
  4014cc:	2b04      	cmp	r3, #4
  4014ce:	d82e      	bhi.n	40152e <m_ssd1311_run_cfg_script+0x7a>
  4014d0:	a201      	add	r2, pc, #4	; (adr r2, 4014d8 <m_ssd1311_run_cfg_script+0x24>)
  4014d2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4014d6:	bf00      	nop
  4014d8:	0040152f 	.word	0x0040152f
  4014dc:	00401529 	.word	0x00401529
  4014e0:	004014ed 	.word	0x004014ed
  4014e4:	00401501 	.word	0x00401501
  4014e8:	00401515 	.word	0x00401515
    {
    case SSD1311_START:
      break;
    case SSD1311_CMD:
      ssd1311_write_cmd(me, SSD1311_CFG_SCRIPT[i].data & 0xFF);
  4014ec:	4a16      	ldr	r2, [pc, #88]	; (401548 <m_ssd1311_run_cfg_script+0x94>)
  4014ee:	68fb      	ldr	r3, [r7, #12]
  4014f0:	005b      	lsls	r3, r3, #1
  4014f2:	4413      	add	r3, r2
  4014f4:	785b      	ldrb	r3, [r3, #1]
  4014f6:	4619      	mov	r1, r3
  4014f8:	6878      	ldr	r0, [r7, #4]
  4014fa:	4b14      	ldr	r3, [pc, #80]	; (40154c <m_ssd1311_run_cfg_script+0x98>)
  4014fc:	4798      	blx	r3
      break;
  4014fe:	e017      	b.n	401530 <m_ssd1311_run_cfg_script+0x7c>
    case SSD1311_DATA:
      ssd1311_write_data_byte(me, SSD1311_CFG_SCRIPT[i].data & 0xFF);
  401500:	4a11      	ldr	r2, [pc, #68]	; (401548 <m_ssd1311_run_cfg_script+0x94>)
  401502:	68fb      	ldr	r3, [r7, #12]
  401504:	005b      	lsls	r3, r3, #1
  401506:	4413      	add	r3, r2
  401508:	785b      	ldrb	r3, [r3, #1]
  40150a:	4619      	mov	r1, r3
  40150c:	6878      	ldr	r0, [r7, #4]
  40150e:	4b10      	ldr	r3, [pc, #64]	; (401550 <m_ssd1311_run_cfg_script+0x9c>)
  401510:	4798      	blx	r3
      break;
  401512:	e00d      	b.n	401530 <m_ssd1311_run_cfg_script+0x7c>
    case SSD1311_DELAY:
      me->delay(SSD1311_CFG_SCRIPT[i].data);
  401514:	687b      	ldr	r3, [r7, #4]
  401516:	689a      	ldr	r2, [r3, #8]
  401518:	490b      	ldr	r1, [pc, #44]	; (401548 <m_ssd1311_run_cfg_script+0x94>)
  40151a:	68fb      	ldr	r3, [r7, #12]
  40151c:	005b      	lsls	r3, r3, #1
  40151e:	440b      	add	r3, r1
  401520:	785b      	ldrb	r3, [r3, #1]
  401522:	4618      	mov	r0, r3
  401524:	4790      	blx	r2
      break;
  401526:	e003      	b.n	401530 <m_ssd1311_run_cfg_script+0x7c>
    case SSD1311_END:
      end_script = 1;
  401528:	2301      	movs	r3, #1
  40152a:	60bb      	str	r3, [r7, #8]
      break;
  40152c:	e000      	b.n	401530 <m_ssd1311_run_cfg_script+0x7c>
    default:
      break;
  40152e:	bf00      	nop
    }
    i++;
  401530:	68fb      	ldr	r3, [r7, #12]
  401532:	3301      	adds	r3, #1
  401534:	60fb      	str	r3, [r7, #12]
  }
  while (!end_script);
  401536:	68bb      	ldr	r3, [r7, #8]
  401538:	2b00      	cmp	r3, #0
  40153a:	d0c3      	beq.n	4014c4 <m_ssd1311_run_cfg_script+0x10>

  return BS_OK;
  40153c:	2300      	movs	r3, #0
}
  40153e:	4618      	mov	r0, r3
  401540:	3710      	adds	r7, #16
  401542:	46bd      	mov	sp, r7
  401544:	bd80      	pop	{r7, pc}
  401546:	bf00      	nop
  401548:	004038cc 	.word	0x004038cc
  40154c:	00401455 	.word	0x00401455
  401550:	00401485 	.word	0x00401485

00401554 <sys_init>:
static void m_lcd_write_sensor_event(date_time_t *dt, uint8_t sensor_name, sys_evt_src_t evt_src);
static void m_sdcard_write_sensor_event(date_time_t *dt, uint8_t sensor_name, sys_evt_src_t evt_src);

/* Function definitions ----------------------------------------------- */
void sys_init(void)
{
  401554:	b580      	push	{r7, lr}
  401556:	af00      	add	r7, sp, #0
  g_sensor_evt_queue = xQueueCreate(10, sizeof(uint8_t));
  401558:	2200      	movs	r2, #0
  40155a:	2101      	movs	r1, #1
  40155c:	200a      	movs	r0, #10
  40155e:	4b0b      	ldr	r3, [pc, #44]	; (40158c <sys_init+0x38>)
  401560:	4798      	blx	r3
  401562:	4602      	mov	r2, r0
  401564:	4b0a      	ldr	r3, [pc, #40]	; (401590 <sys_init+0x3c>)
  401566:	601a      	str	r2, [r3, #0]

  sysclk_init();   // Initialize System Clock
  401568:	4b0a      	ldr	r3, [pc, #40]	; (401594 <sys_init+0x40>)
  40156a:	4798      	blx	r3
  board_init();    // Board init
  40156c:	4b0a      	ldr	r3, [pc, #40]	; (401598 <sys_init+0x44>)
  40156e:	4798      	blx	r3
  bsp_hw_init();   // Hardware init
  401570:	4b0a      	ldr	r3, [pc, #40]	; (40159c <sys_init+0x48>)
  401572:	4798      	blx	r3
  bsp_can_init();  // Can bus init
  401574:	4b0a      	ldr	r3, [pc, #40]	; (4015a0 <sys_init+0x4c>)
  401576:	4798      	blx	r3
  bsp_lcd_init();  // LCD init
  401578:	4b0a      	ldr	r3, [pc, #40]	; (4015a4 <sys_init+0x50>)
  40157a:	4798      	blx	r3

  while (1)
  {
    bsp_delay(1000);
  40157c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  401580:	4b09      	ldr	r3, [pc, #36]	; (4015a8 <sys_init+0x54>)
  401582:	4798      	blx	r3
    bsp_uart_write('1');
  401584:	2031      	movs	r0, #49	; 0x31
  401586:	4b09      	ldr	r3, [pc, #36]	; (4015ac <sys_init+0x58>)
  401588:	4798      	blx	r3
    bsp_delay(1000);
  40158a:	e7f7      	b.n	40157c <sys_init+0x28>
  40158c:	004007c1 	.word	0x004007c1
  401590:	2000a7a8 	.word	0x2000a7a8
  401594:	00402061 	.word	0x00402061
  401598:	00401925 	.word	0x00401925
  40159c:	00400dad 	.word	0x00400dad
  4015a0:	00401095 	.word	0x00401095
  4015a4:	004013c1 	.word	0x004013c1
  4015a8:	00400e49 	.word	0x00400e49
  4015ac:	00400e1d 	.word	0x00400e1d

004015b0 <sysclk_enable_peripheral_clock>:
{
  4015b0:	b580      	push	{r7, lr}
  4015b2:	b082      	sub	sp, #8
  4015b4:	af00      	add	r7, sp, #0
  4015b6:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
  4015b8:	6878      	ldr	r0, [r7, #4]
  4015ba:	4b03      	ldr	r3, [pc, #12]	; (4015c8 <sysclk_enable_peripheral_clock+0x18>)
  4015bc:	4798      	blx	r3
}
  4015be:	bf00      	nop
  4015c0:	3708      	adds	r7, #8
  4015c2:	46bd      	mov	sp, r7
  4015c4:	bd80      	pop	{r7, pc}
  4015c6:	bf00      	nop
  4015c8:	00402921 	.word	0x00402921

004015cc <ioport_init>:
{
  4015cc:	b580      	push	{r7, lr}
  4015ce:	af00      	add	r7, sp, #0
	sysclk_enable_peripheral_clock(ID_PIOA);
  4015d0:	2009      	movs	r0, #9
  4015d2:	4b08      	ldr	r3, [pc, #32]	; (4015f4 <ioport_init+0x28>)
  4015d4:	4798      	blx	r3
	sysclk_enable_peripheral_clock(ID_PIOB);
  4015d6:	200a      	movs	r0, #10
  4015d8:	4b06      	ldr	r3, [pc, #24]	; (4015f4 <ioport_init+0x28>)
  4015da:	4798      	blx	r3
	sysclk_enable_peripheral_clock(ID_PIOC);
  4015dc:	200b      	movs	r0, #11
  4015de:	4b05      	ldr	r3, [pc, #20]	; (4015f4 <ioport_init+0x28>)
  4015e0:	4798      	blx	r3
	sysclk_enable_peripheral_clock(ID_PIOD);
  4015e2:	200c      	movs	r0, #12
  4015e4:	4b03      	ldr	r3, [pc, #12]	; (4015f4 <ioport_init+0x28>)
  4015e6:	4798      	blx	r3
	sysclk_enable_peripheral_clock(ID_PIOE);
  4015e8:	200d      	movs	r0, #13
  4015ea:	4b02      	ldr	r3, [pc, #8]	; (4015f4 <ioport_init+0x28>)
  4015ec:	4798      	blx	r3
}
  4015ee:	bf00      	nop
  4015f0:	bd80      	pop	{r7, pc}
  4015f2:	bf00      	nop
  4015f4:	004015b1 	.word	0x004015b1

004015f8 <ioport_disable_pin>:
{
  4015f8:	b480      	push	{r7}
  4015fa:	b089      	sub	sp, #36	; 0x24
  4015fc:	af00      	add	r7, sp, #0
  4015fe:	6078      	str	r0, [r7, #4]
  401600:	687b      	ldr	r3, [r7, #4]
  401602:	61fb      	str	r3, [r7, #28]
  401604:	69fb      	ldr	r3, [r7, #28]
  401606:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  401608:	69bb      	ldr	r3, [r7, #24]
  40160a:	095a      	lsrs	r2, r3, #5
  40160c:	69fb      	ldr	r3, [r7, #28]
  40160e:	617b      	str	r3, [r7, #20]
	return 1U << (pin & 0x1F);
  401610:	697b      	ldr	r3, [r7, #20]
  401612:	f003 031f 	and.w	r3, r3, #31
  401616:	2101      	movs	r1, #1
  401618:	fa01 f303 	lsl.w	r3, r1, r3
  40161c:	613a      	str	r2, [r7, #16]
  40161e:	60fb      	str	r3, [r7, #12]
  401620:	693b      	ldr	r3, [r7, #16]
  401622:	60bb      	str	r3, [r7, #8]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  401624:	68bb      	ldr	r3, [r7, #8]
  401626:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  40162a:	f203 7307 	addw	r3, r3, #1799	; 0x707
  40162e:	025b      	lsls	r3, r3, #9
  401630:	461a      	mov	r2, r3
	arch_ioport_port_to_base(port)->PIO_PDR = mask;
  401632:	68fb      	ldr	r3, [r7, #12]
  401634:	6053      	str	r3, [r2, #4]
}
  401636:	bf00      	nop
  401638:	3724      	adds	r7, #36	; 0x24
  40163a:	46bd      	mov	sp, r7
  40163c:	f85d 7b04 	ldr.w	r7, [sp], #4
  401640:	4770      	bx	lr

00401642 <ioport_set_pin_mode>:
{
  401642:	b480      	push	{r7}
  401644:	b08d      	sub	sp, #52	; 0x34
  401646:	af00      	add	r7, sp, #0
  401648:	6078      	str	r0, [r7, #4]
  40164a:	6039      	str	r1, [r7, #0]
  40164c:	687b      	ldr	r3, [r7, #4]
  40164e:	62fb      	str	r3, [r7, #44]	; 0x2c
  401650:	683b      	ldr	r3, [r7, #0]
  401652:	62bb      	str	r3, [r7, #40]	; 0x28
  401654:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401656:	627b      	str	r3, [r7, #36]	; 0x24
	return pin >> 5;
  401658:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40165a:	095a      	lsrs	r2, r3, #5
  40165c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40165e:	623b      	str	r3, [r7, #32]
	return 1U << (pin & 0x1F);
  401660:	6a3b      	ldr	r3, [r7, #32]
  401662:	f003 031f 	and.w	r3, r3, #31
  401666:	2101      	movs	r1, #1
  401668:	fa01 f303 	lsl.w	r3, r1, r3
  40166c:	61fa      	str	r2, [r7, #28]
  40166e:	61bb      	str	r3, [r7, #24]
  401670:	6abb      	ldr	r3, [r7, #40]	; 0x28
  401672:	617b      	str	r3, [r7, #20]
  401674:	69fb      	ldr	r3, [r7, #28]
  401676:	613b      	str	r3, [r7, #16]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  401678:	693b      	ldr	r3, [r7, #16]
  40167a:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  40167e:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401682:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_port_to_base(port);
  401684:	60fb      	str	r3, [r7, #12]
	if (mode & IOPORT_MODE_PULLUP) {
  401686:	697b      	ldr	r3, [r7, #20]
  401688:	f003 0308 	and.w	r3, r3, #8
  40168c:	2b00      	cmp	r3, #0
  40168e:	d003      	beq.n	401698 <ioport_set_pin_mode+0x56>
		base->PIO_PUER = mask;
  401690:	68fb      	ldr	r3, [r7, #12]
  401692:	69ba      	ldr	r2, [r7, #24]
  401694:	665a      	str	r2, [r3, #100]	; 0x64
  401696:	e002      	b.n	40169e <ioport_set_pin_mode+0x5c>
		base->PIO_PUDR = mask;
  401698:	68fb      	ldr	r3, [r7, #12]
  40169a:	69ba      	ldr	r2, [r7, #24]
  40169c:	661a      	str	r2, [r3, #96]	; 0x60
	if (mode & IOPORT_MODE_PULLDOWN) {
  40169e:	697b      	ldr	r3, [r7, #20]
  4016a0:	f003 0310 	and.w	r3, r3, #16
  4016a4:	2b00      	cmp	r3, #0
  4016a6:	d004      	beq.n	4016b2 <ioport_set_pin_mode+0x70>
		base->PIO_PPDER = mask;
  4016a8:	68fb      	ldr	r3, [r7, #12]
  4016aa:	69ba      	ldr	r2, [r7, #24]
  4016ac:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  4016b0:	e003      	b.n	4016ba <ioport_set_pin_mode+0x78>
		base->PIO_PPDDR = mask;
  4016b2:	68fb      	ldr	r3, [r7, #12]
  4016b4:	69ba      	ldr	r2, [r7, #24]
  4016b6:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	if (mode & IOPORT_MODE_OPEN_DRAIN) {
  4016ba:	697b      	ldr	r3, [r7, #20]
  4016bc:	f003 0320 	and.w	r3, r3, #32
  4016c0:	2b00      	cmp	r3, #0
  4016c2:	d003      	beq.n	4016cc <ioport_set_pin_mode+0x8a>
		base->PIO_MDER = mask;
  4016c4:	68fb      	ldr	r3, [r7, #12]
  4016c6:	69ba      	ldr	r2, [r7, #24]
  4016c8:	651a      	str	r2, [r3, #80]	; 0x50
  4016ca:	e002      	b.n	4016d2 <ioport_set_pin_mode+0x90>
		base->PIO_MDDR = mask;
  4016cc:	68fb      	ldr	r3, [r7, #12]
  4016ce:	69ba      	ldr	r2, [r7, #24]
  4016d0:	655a      	str	r2, [r3, #84]	; 0x54
	if (mode & (IOPORT_MODE_GLITCH_FILTER | IOPORT_MODE_DEBOUNCE)) {
  4016d2:	697b      	ldr	r3, [r7, #20]
  4016d4:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
  4016d8:	2b00      	cmp	r3, #0
  4016da:	d003      	beq.n	4016e4 <ioport_set_pin_mode+0xa2>
		base->PIO_IFER = mask;
  4016dc:	68fb      	ldr	r3, [r7, #12]
  4016de:	69ba      	ldr	r2, [r7, #24]
  4016e0:	621a      	str	r2, [r3, #32]
  4016e2:	e002      	b.n	4016ea <ioport_set_pin_mode+0xa8>
		base->PIO_IFDR = mask;
  4016e4:	68fb      	ldr	r3, [r7, #12]
  4016e6:	69ba      	ldr	r2, [r7, #24]
  4016e8:	625a      	str	r2, [r3, #36]	; 0x24
	if (mode & IOPORT_MODE_DEBOUNCE) {
  4016ea:	697b      	ldr	r3, [r7, #20]
  4016ec:	f003 0380 	and.w	r3, r3, #128	; 0x80
  4016f0:	2b00      	cmp	r3, #0
  4016f2:	d004      	beq.n	4016fe <ioport_set_pin_mode+0xbc>
		base->PIO_IFSCER = mask;
  4016f4:	68fb      	ldr	r3, [r7, #12]
  4016f6:	69ba      	ldr	r2, [r7, #24]
  4016f8:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  4016fc:	e003      	b.n	401706 <ioport_set_pin_mode+0xc4>
		base->PIO_IFSCDR = mask;
  4016fe:	68fb      	ldr	r3, [r7, #12]
  401700:	69ba      	ldr	r2, [r7, #24]
  401702:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	if (mode & IOPORT_MODE_MUX_BIT0) {
  401706:	697b      	ldr	r3, [r7, #20]
  401708:	f003 0301 	and.w	r3, r3, #1
  40170c:	2b00      	cmp	r3, #0
  40170e:	d006      	beq.n	40171e <ioport_set_pin_mode+0xdc>
		base->PIO_ABCDSR[0] |= mask;
  401710:	68fb      	ldr	r3, [r7, #12]
  401712:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  401714:	69bb      	ldr	r3, [r7, #24]
  401716:	431a      	orrs	r2, r3
  401718:	68fb      	ldr	r3, [r7, #12]
  40171a:	671a      	str	r2, [r3, #112]	; 0x70
  40171c:	e006      	b.n	40172c <ioport_set_pin_mode+0xea>
		base->PIO_ABCDSR[0] &= ~mask;
  40171e:	68fb      	ldr	r3, [r7, #12]
  401720:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  401722:	69bb      	ldr	r3, [r7, #24]
  401724:	43db      	mvns	r3, r3
  401726:	401a      	ands	r2, r3
  401728:	68fb      	ldr	r3, [r7, #12]
  40172a:	671a      	str	r2, [r3, #112]	; 0x70
	if (mode & IOPORT_MODE_MUX_BIT1) {
  40172c:	697b      	ldr	r3, [r7, #20]
  40172e:	f003 0302 	and.w	r3, r3, #2
  401732:	2b00      	cmp	r3, #0
  401734:	d006      	beq.n	401744 <ioport_set_pin_mode+0x102>
		base->PIO_ABCDSR[1] |= mask;
  401736:	68fb      	ldr	r3, [r7, #12]
  401738:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  40173a:	69bb      	ldr	r3, [r7, #24]
  40173c:	431a      	orrs	r2, r3
  40173e:	68fb      	ldr	r3, [r7, #12]
  401740:	675a      	str	r2, [r3, #116]	; 0x74
}
  401742:	e006      	b.n	401752 <ioport_set_pin_mode+0x110>
		base->PIO_ABCDSR[1] &= ~mask;
  401744:	68fb      	ldr	r3, [r7, #12]
  401746:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  401748:	69bb      	ldr	r3, [r7, #24]
  40174a:	43db      	mvns	r3, r3
  40174c:	401a      	ands	r2, r3
  40174e:	68fb      	ldr	r3, [r7, #12]
  401750:	675a      	str	r2, [r3, #116]	; 0x74
  401752:	bf00      	nop
  401754:	3734      	adds	r7, #52	; 0x34
  401756:	46bd      	mov	sp, r7
  401758:	f85d 7b04 	ldr.w	r7, [sp], #4
  40175c:	4770      	bx	lr

0040175e <ioport_set_pin_dir>:
{
  40175e:	b480      	push	{r7}
  401760:	b08d      	sub	sp, #52	; 0x34
  401762:	af00      	add	r7, sp, #0
  401764:	6078      	str	r0, [r7, #4]
  401766:	460b      	mov	r3, r1
  401768:	70fb      	strb	r3, [r7, #3]
  40176a:	687b      	ldr	r3, [r7, #4]
  40176c:	62fb      	str	r3, [r7, #44]	; 0x2c
  40176e:	78fb      	ldrb	r3, [r7, #3]
  401770:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  401774:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401776:	627b      	str	r3, [r7, #36]	; 0x24
  401778:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  40177a:	623b      	str	r3, [r7, #32]
	return pin >> 5;
  40177c:	6a3b      	ldr	r3, [r7, #32]
  40177e:	095b      	lsrs	r3, r3, #5
  401780:	61fb      	str	r3, [r7, #28]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  401782:	69fb      	ldr	r3, [r7, #28]
  401784:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401788:	f203 7307 	addw	r3, r3, #1799	; 0x707
  40178c:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_pin_to_base(pin);
  40178e:	61bb      	str	r3, [r7, #24]
	if (dir == IOPORT_DIR_OUTPUT) {
  401790:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  401794:	2b01      	cmp	r3, #1
  401796:	d109      	bne.n	4017ac <ioport_set_pin_dir+0x4e>
  401798:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40179a:	617b      	str	r3, [r7, #20]
	return 1U << (pin & 0x1F);
  40179c:	697b      	ldr	r3, [r7, #20]
  40179e:	f003 031f 	and.w	r3, r3, #31
  4017a2:	2201      	movs	r2, #1
  4017a4:	409a      	lsls	r2, r3
		base->PIO_OER = arch_ioport_pin_to_mask(pin);
  4017a6:	69bb      	ldr	r3, [r7, #24]
  4017a8:	611a      	str	r2, [r3, #16]
  4017aa:	e00c      	b.n	4017c6 <ioport_set_pin_dir+0x68>
	} else if (dir == IOPORT_DIR_INPUT) {
  4017ac:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  4017b0:	2b00      	cmp	r3, #0
  4017b2:	d108      	bne.n	4017c6 <ioport_set_pin_dir+0x68>
  4017b4:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4017b6:	613b      	str	r3, [r7, #16]
	return 1U << (pin & 0x1F);
  4017b8:	693b      	ldr	r3, [r7, #16]
  4017ba:	f003 031f 	and.w	r3, r3, #31
  4017be:	2201      	movs	r2, #1
  4017c0:	409a      	lsls	r2, r3
		base->PIO_ODR = arch_ioport_pin_to_mask(pin);
  4017c2:	69bb      	ldr	r3, [r7, #24]
  4017c4:	615a      	str	r2, [r3, #20]
  4017c6:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  4017c8:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  4017ca:	68fb      	ldr	r3, [r7, #12]
  4017cc:	f003 031f 	and.w	r3, r3, #31
  4017d0:	2201      	movs	r2, #1
  4017d2:	409a      	lsls	r2, r3
	base->PIO_OWER = arch_ioport_pin_to_mask(pin);
  4017d4:	69bb      	ldr	r3, [r7, #24]
  4017d6:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
}
  4017da:	bf00      	nop
  4017dc:	3734      	adds	r7, #52	; 0x34
  4017de:	46bd      	mov	sp, r7
  4017e0:	f85d 7b04 	ldr.w	r7, [sp], #4
  4017e4:	4770      	bx	lr

004017e6 <ioport_set_pin_level>:
{
  4017e6:	b480      	push	{r7}
  4017e8:	b08b      	sub	sp, #44	; 0x2c
  4017ea:	af00      	add	r7, sp, #0
  4017ec:	6078      	str	r0, [r7, #4]
  4017ee:	460b      	mov	r3, r1
  4017f0:	70fb      	strb	r3, [r7, #3]
  4017f2:	687b      	ldr	r3, [r7, #4]
  4017f4:	627b      	str	r3, [r7, #36]	; 0x24
  4017f6:	78fb      	ldrb	r3, [r7, #3]
  4017f8:	f887 3023 	strb.w	r3, [r7, #35]	; 0x23
  4017fc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  4017fe:	61fb      	str	r3, [r7, #28]
  401800:	69fb      	ldr	r3, [r7, #28]
  401802:	61bb      	str	r3, [r7, #24]
	return pin >> 5;
  401804:	69bb      	ldr	r3, [r7, #24]
  401806:	095b      	lsrs	r3, r3, #5
  401808:	617b      	str	r3, [r7, #20]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  40180a:	697b      	ldr	r3, [r7, #20]
  40180c:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401810:	f203 7307 	addw	r3, r3, #1799	; 0x707
  401814:	025b      	lsls	r3, r3, #9
	Pio *base = arch_ioport_pin_to_base(pin);
  401816:	613b      	str	r3, [r7, #16]
	if (level) {
  401818:	f897 3023 	ldrb.w	r3, [r7, #35]	; 0x23
  40181c:	2b00      	cmp	r3, #0
  40181e:	d009      	beq.n	401834 <ioport_set_pin_level+0x4e>
  401820:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401822:	60fb      	str	r3, [r7, #12]
	return 1U << (pin & 0x1F);
  401824:	68fb      	ldr	r3, [r7, #12]
  401826:	f003 031f 	and.w	r3, r3, #31
  40182a:	2201      	movs	r2, #1
  40182c:	409a      	lsls	r2, r3
		base->PIO_SODR = arch_ioport_pin_to_mask(pin);
  40182e:	693b      	ldr	r3, [r7, #16]
  401830:	631a      	str	r2, [r3, #48]	; 0x30
}
  401832:	e008      	b.n	401846 <ioport_set_pin_level+0x60>
  401834:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401836:	60bb      	str	r3, [r7, #8]
	return 1U << (pin & 0x1F);
  401838:	68bb      	ldr	r3, [r7, #8]
  40183a:	f003 031f 	and.w	r3, r3, #31
  40183e:	2201      	movs	r2, #1
  401840:	409a      	lsls	r2, r3
		base->PIO_CODR = arch_ioport_pin_to_mask(pin);
  401842:	693b      	ldr	r3, [r7, #16]
  401844:	635a      	str	r2, [r3, #52]	; 0x34
  401846:	bf00      	nop
  401848:	372c      	adds	r7, #44	; 0x2c
  40184a:	46bd      	mov	sp, r7
  40184c:	f85d 7b04 	ldr.w	r7, [sp], #4
  401850:	4770      	bx	lr
	...

00401854 <ioport_set_pin_sense_mode>:
 * \param pin IOPORT pin to configure
 * \param pin_sense Edge to sense for the pin (\ref ioport_sense)
 */
static inline void ioport_set_pin_sense_mode(ioport_pin_t pin,
		enum ioport_sense pin_sense)
{
  401854:	b480      	push	{r7}
  401856:	b08d      	sub	sp, #52	; 0x34
  401858:	af00      	add	r7, sp, #0
  40185a:	6078      	str	r0, [r7, #4]
  40185c:	460b      	mov	r3, r1
  40185e:	70fb      	strb	r3, [r7, #3]
  401860:	687b      	ldr	r3, [r7, #4]
  401862:	62fb      	str	r3, [r7, #44]	; 0x2c
  401864:	78fb      	ldrb	r3, [r7, #3]
  401866:	f887 302b 	strb.w	r3, [r7, #43]	; 0x2b
  40186a:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40186c:	627b      	str	r3, [r7, #36]	; 0x24
	return pin >> 5;
  40186e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
  401870:	095a      	lsrs	r2, r3, #5
  401872:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  401874:	623b      	str	r3, [r7, #32]
	return 1U << (pin & 0x1F);
  401876:	6a3b      	ldr	r3, [r7, #32]
  401878:	f003 031f 	and.w	r3, r3, #31
  40187c:	2101      	movs	r1, #1
  40187e:	fa01 f303 	lsl.w	r3, r1, r3
  401882:	61fa      	str	r2, [r7, #28]
  401884:	61bb      	str	r3, [r7, #24]
  401886:	f897 302b 	ldrb.w	r3, [r7, #43]	; 0x2b
  40188a:	75fb      	strb	r3, [r7, #23]
  40188c:	69fb      	ldr	r3, [r7, #28]
  40188e:	613b      	str	r3, [r7, #16]
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  401890:	693b      	ldr	r3, [r7, #16]
  401892:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  401896:	f203 7307 	addw	r3, r3, #1799	; 0x707
  40189a:	025b      	lsls	r3, r3, #9
}

__always_inline static void arch_ioport_set_port_sense_mode(ioport_port_t port,
		ioport_port_mask_t mask, enum ioport_sense pin_sense)
{
	Pio *base = arch_ioport_port_to_base(port);
  40189c:	60fb      	str	r3, [r7, #12]
	 *       1       0         0    IOPORT_SENSE_FALLING
	 *       1       0         1    IOPORT_SENSE_RISING
	 *       1       1         0    IOPORT_SENSE_LEVEL_LOW
	 *       1       1         1    IOPORT_SENSE_LEVEL_HIGH
	 */
	switch(pin_sense) {
  40189e:	7dfb      	ldrb	r3, [r7, #23]
  4018a0:	3b01      	subs	r3, #1
  4018a2:	2b03      	cmp	r3, #3
  4018a4:	d82e      	bhi.n	401904 <ioport_set_pin_sense_mode+0xb0>
  4018a6:	a201      	add	r2, pc, #4	; (adr r2, 4018ac <ioport_set_pin_sense_mode+0x58>)
  4018a8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  4018ac:	004018e1 	.word	0x004018e1
  4018b0:	004018f3 	.word	0x004018f3
  4018b4:	004018bd 	.word	0x004018bd
  4018b8:	004018cf 	.word	0x004018cf
	case IOPORT_SENSE_LEVEL_LOW:
		base->PIO_LSR = mask;
  4018bc:	68fb      	ldr	r3, [r7, #12]
  4018be:	69ba      	ldr	r2, [r7, #24]
  4018c0:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
		base->PIO_FELLSR = mask;
  4018c4:	68fb      	ldr	r3, [r7, #12]
  4018c6:	69ba      	ldr	r2, [r7, #24]
  4018c8:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
  4018cc:	e01f      	b.n	40190e <ioport_set_pin_sense_mode+0xba>
		break;
	case IOPORT_SENSE_LEVEL_HIGH:
		base->PIO_LSR = mask;
  4018ce:	68fb      	ldr	r3, [r7, #12]
  4018d0:	69ba      	ldr	r2, [r7, #24]
  4018d2:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
		base->PIO_REHLSR = mask;
  4018d6:	68fb      	ldr	r3, [r7, #12]
  4018d8:	69ba      	ldr	r2, [r7, #24]
  4018da:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
  4018de:	e016      	b.n	40190e <ioport_set_pin_sense_mode+0xba>
		break;
	case IOPORT_SENSE_FALLING:
		base->PIO_ESR = mask;
  4018e0:	68fb      	ldr	r3, [r7, #12]
  4018e2:	69ba      	ldr	r2, [r7, #24]
  4018e4:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
		base->PIO_FELLSR = mask;
  4018e8:	68fb      	ldr	r3, [r7, #12]
  4018ea:	69ba      	ldr	r2, [r7, #24]
  4018ec:	f8c3 20d0 	str.w	r2, [r3, #208]	; 0xd0
  4018f0:	e00d      	b.n	40190e <ioport_set_pin_sense_mode+0xba>
		break;
	case IOPORT_SENSE_RISING:
		base->PIO_ESR = mask;
  4018f2:	68fb      	ldr	r3, [r7, #12]
  4018f4:	69ba      	ldr	r2, [r7, #24]
  4018f6:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
		base->PIO_REHLSR = mask;
  4018fa:	68fb      	ldr	r3, [r7, #12]
  4018fc:	69ba      	ldr	r2, [r7, #24]
  4018fe:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
  401902:	e004      	b.n	40190e <ioport_set_pin_sense_mode+0xba>
		break;
	default:
		base->PIO_AIMDR = mask;
  401904:	68fb      	ldr	r3, [r7, #12]
  401906:	69ba      	ldr	r2, [r7, #24]
  401908:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
	arch_ioport_set_pin_sense_mode(pin, pin_sense);
}
  40190c:	e003      	b.n	401916 <ioport_set_pin_sense_mode+0xc2>
		return;
	}
	base->PIO_AIMER = mask;
  40190e:	68fb      	ldr	r3, [r7, #12]
  401910:	69ba      	ldr	r2, [r7, #24]
  401912:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
  401916:	bf00      	nop
  401918:	3734      	adds	r7, #52	; 0x34
  40191a:	46bd      	mov	sp, r7
  40191c:	f85d 7b04 	ldr.w	r7, [sp], #4
  401920:	4770      	bx	lr
  401922:	bf00      	nop

00401924 <board_init>:
		ioport_set_pin_mode(pin, mode);\
		ioport_set_pin_sense_mode(pin, sense);\
	} while (0)

void board_init(void)
{
  401924:	b580      	push	{r7, lr}
  401926:	af00      	add	r7, sp, #0
#ifndef CONF_BOARD_KEEP_WATCHDOG_AT_INIT
	/* Disable the watchdog */
	WDT->WDT_MR = WDT_MR_WDDIS;
  401928:	4b34      	ldr	r3, [pc, #208]	; (4019fc <board_init+0xd8>)
  40192a:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  40192e:	605a      	str	r2, [r3, #4]
#endif

	/* Initialize IOPORTs */
	ioport_init();
  401930:	4b33      	ldr	r3, [pc, #204]	; (401a00 <board_init+0xdc>)
  401932:	4798      	blx	r3

	/* Configure the pins connected to LED as output and set their
	 * default initial state to high (LED off).
	 */
	ioport_set_pin_dir(LED0_GPIO, IOPORT_DIR_OUTPUT);
  401934:	2101      	movs	r1, #1
  401936:	2076      	movs	r0, #118	; 0x76
  401938:	4b32      	ldr	r3, [pc, #200]	; (401a04 <board_init+0xe0>)
  40193a:	4798      	blx	r3
	ioport_set_pin_level(LED0_GPIO, LED0_INACTIVE_LEVEL);
  40193c:	2101      	movs	r1, #1
  40193e:	2076      	movs	r0, #118	; 0x76
  401940:	4b31      	ldr	r3, [pc, #196]	; (401a08 <board_init+0xe4>)
  401942:	4798      	blx	r3

	/* Configure Push Button pins */
	ioport_set_pin_input_mode(GPIO_PUSH_BUTTON_1, GPIO_PUSH_BUTTON_1_FLAGS,
  401944:	2100      	movs	r1, #0
  401946:	2002      	movs	r0, #2
  401948:	4b2e      	ldr	r3, [pc, #184]	; (401a04 <board_init+0xe0>)
  40194a:	4798      	blx	r3
  40194c:	2188      	movs	r1, #136	; 0x88
  40194e:	2002      	movs	r0, #2
  401950:	4b2e      	ldr	r3, [pc, #184]	; (401a0c <board_init+0xe8>)
  401952:	4798      	blx	r3
  401954:	2102      	movs	r1, #2
  401956:	2002      	movs	r0, #2
  401958:	4b2d      	ldr	r3, [pc, #180]	; (401a10 <board_init+0xec>)
  40195a:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_PWM_LED0_GPIO, PIN_PWM_LED0_FLAGS);
#endif

#ifdef CONF_BOARD_CAN
	/* Configure the CAN1 TX and RX pin. */
	ioport_set_pin_peripheral_mode(PIN_CAN1_RX_IDX, PIN_CAN1_RX_FLAGS);
  40195c:	2102      	movs	r1, #2
  40195e:	204c      	movs	r0, #76	; 0x4c
  401960:	4b2a      	ldr	r3, [pc, #168]	; (401a0c <board_init+0xe8>)
  401962:	4798      	blx	r3
  401964:	204c      	movs	r0, #76	; 0x4c
  401966:	4b2b      	ldr	r3, [pc, #172]	; (401a14 <board_init+0xf0>)
  401968:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_CAN1_TX_IDX, PIN_CAN1_TX_FLAGS);
  40196a:	2102      	movs	r1, #2
  40196c:	204f      	movs	r0, #79	; 0x4f
  40196e:	4b27      	ldr	r3, [pc, #156]	; (401a0c <board_init+0xe8>)
  401970:	4798      	blx	r3
  401972:	204f      	movs	r0, #79	; 0x4f
  401974:	4b27      	ldr	r3, [pc, #156]	; (401a14 <board_init+0xf0>)
  401976:	4798      	blx	r3
	/* Configure the transiver1 RS & EN pins. */
	ioport_set_pin_dir(PIN_CAN1_TR_RS_IDX, IOPORT_DIR_OUTPUT);
  401978:	2101      	movs	r1, #1
  40197a:	2082      	movs	r0, #130	; 0x82
  40197c:	4b21      	ldr	r3, [pc, #132]	; (401a04 <board_init+0xe0>)
  40197e:	4798      	blx	r3
	ioport_set_pin_dir(PIN_CAN1_TR_EN_IDX, IOPORT_DIR_OUTPUT);
  401980:	2101      	movs	r1, #1
  401982:	2083      	movs	r0, #131	; 0x83
  401984:	4b1f      	ldr	r3, [pc, #124]	; (401a04 <board_init+0xe0>)
  401986:	4798      	blx	r3
#  endif
#endif

#if defined (CONF_BOARD_SD_MMC_HSMCI)
	/* Configure HSMCI pins */
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCCDA_GPIO, PIN_HSMCI_MCCDA_FLAGS);
  401988:	2102      	movs	r1, #2
  40198a:	201c      	movs	r0, #28
  40198c:	4b1f      	ldr	r3, [pc, #124]	; (401a0c <board_init+0xe8>)
  40198e:	4798      	blx	r3
  401990:	201c      	movs	r0, #28
  401992:	4b20      	ldr	r3, [pc, #128]	; (401a14 <board_init+0xf0>)
  401994:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCCK_GPIO, PIN_HSMCI_MCCK_FLAGS);
  401996:	2102      	movs	r1, #2
  401998:	201d      	movs	r0, #29
  40199a:	4b1c      	ldr	r3, [pc, #112]	; (401a0c <board_init+0xe8>)
  40199c:	4798      	blx	r3
  40199e:	201d      	movs	r0, #29
  4019a0:	4b1c      	ldr	r3, [pc, #112]	; (401a14 <board_init+0xf0>)
  4019a2:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCDA0_GPIO, PIN_HSMCI_MCDA0_FLAGS);
  4019a4:	2102      	movs	r1, #2
  4019a6:	201e      	movs	r0, #30
  4019a8:	4b18      	ldr	r3, [pc, #96]	; (401a0c <board_init+0xe8>)
  4019aa:	4798      	blx	r3
  4019ac:	201e      	movs	r0, #30
  4019ae:	4b19      	ldr	r3, [pc, #100]	; (401a14 <board_init+0xf0>)
  4019b0:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCDA1_GPIO, PIN_HSMCI_MCDA1_FLAGS);
  4019b2:	2102      	movs	r1, #2
  4019b4:	201f      	movs	r0, #31
  4019b6:	4b15      	ldr	r3, [pc, #84]	; (401a0c <board_init+0xe8>)
  4019b8:	4798      	blx	r3
  4019ba:	201f      	movs	r0, #31
  4019bc:	4b15      	ldr	r3, [pc, #84]	; (401a14 <board_init+0xf0>)
  4019be:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCDA2_GPIO, PIN_HSMCI_MCDA2_FLAGS);
  4019c0:	2102      	movs	r1, #2
  4019c2:	201a      	movs	r0, #26
  4019c4:	4b11      	ldr	r3, [pc, #68]	; (401a0c <board_init+0xe8>)
  4019c6:	4798      	blx	r3
  4019c8:	201a      	movs	r0, #26
  4019ca:	4b12      	ldr	r3, [pc, #72]	; (401a14 <board_init+0xf0>)
  4019cc:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(PIN_HSMCI_MCDA3_GPIO, PIN_HSMCI_MCDA3_FLAGS);
  4019ce:	2102      	movs	r1, #2
  4019d0:	201b      	movs	r0, #27
  4019d2:	4b0e      	ldr	r3, [pc, #56]	; (401a0c <board_init+0xe8>)
  4019d4:	4798      	blx	r3
  4019d6:	201b      	movs	r0, #27
  4019d8:	4b0e      	ldr	r3, [pc, #56]	; (401a14 <board_init+0xf0>)
  4019da:	4798      	blx	r3
	ioport_set_pin_dir(AT86RFX_SLP_PIN, IOPORT_DIR_OUTPUT);
	ioport_set_pin_level(AT86RFX_SLP_PIN, IOPORT_PIN_LEVEL_HIGH);
#endif  

#if (defined(CONF_BOARD_TWI0) || defined(CONF_BOARD_EDBG_TWI))
	ioport_set_pin_peripheral_mode(TWI0_DATA_GPIO, TWI0_DATA_FLAGS);
  4019dc:	2100      	movs	r1, #0
  4019de:	2003      	movs	r0, #3
  4019e0:	4b0a      	ldr	r3, [pc, #40]	; (401a0c <board_init+0xe8>)
  4019e2:	4798      	blx	r3
  4019e4:	2003      	movs	r0, #3
  4019e6:	4b0b      	ldr	r3, [pc, #44]	; (401a14 <board_init+0xf0>)
  4019e8:	4798      	blx	r3
	ioport_set_pin_peripheral_mode(TWI0_CLK_GPIO, TWI0_CLK_FLAGS);
  4019ea:	2100      	movs	r1, #0
  4019ec:	2004      	movs	r0, #4
  4019ee:	4b07      	ldr	r3, [pc, #28]	; (401a0c <board_init+0xe8>)
  4019f0:	4798      	blx	r3
  4019f2:	2004      	movs	r0, #4
  4019f4:	4b07      	ldr	r3, [pc, #28]	; (401a14 <board_init+0xf0>)
  4019f6:	4798      	blx	r3
#endif

}
  4019f8:	bf00      	nop
  4019fa:	bd80      	pop	{r7, pc}
  4019fc:	400e1850 	.word	0x400e1850
  401a00:	004015cd 	.word	0x004015cd
  401a04:	0040175f 	.word	0x0040175f
  401a08:	004017e7 	.word	0x004017e7
  401a0c:	00401643 	.word	0x00401643
  401a10:	00401855 	.word	0x00401855
  401a14:	004015f9 	.word	0x004015f9

00401a18 <rtc_set_hour_mode>:
 *
 * \param p_rtc Pointer to an RTC instance.
 * \param ul_mode 1 for 12-hour mode, 0 for 24-hour mode.
 */
void rtc_set_hour_mode(Rtc *p_rtc, uint32_t ul_mode)
{
  401a18:	b480      	push	{r7}
  401a1a:	b083      	sub	sp, #12
  401a1c:	af00      	add	r7, sp, #0
  401a1e:	6078      	str	r0, [r7, #4]
  401a20:	6039      	str	r1, [r7, #0]
	if (ul_mode) {
  401a22:	683b      	ldr	r3, [r7, #0]
  401a24:	2b00      	cmp	r3, #0
  401a26:	d006      	beq.n	401a36 <rtc_set_hour_mode+0x1e>
		p_rtc->RTC_MR |= RTC_MR_HRMOD;
  401a28:	687b      	ldr	r3, [r7, #4]
  401a2a:	685b      	ldr	r3, [r3, #4]
  401a2c:	f043 0201 	orr.w	r2, r3, #1
  401a30:	687b      	ldr	r3, [r7, #4]
  401a32:	605a      	str	r2, [r3, #4]
	} else {
		p_rtc->RTC_MR &= (~RTC_MR_HRMOD);
	}
}
  401a34:	e005      	b.n	401a42 <rtc_set_hour_mode+0x2a>
		p_rtc->RTC_MR &= (~RTC_MR_HRMOD);
  401a36:	687b      	ldr	r3, [r7, #4]
  401a38:	685b      	ldr	r3, [r3, #4]
  401a3a:	f023 0201 	bic.w	r2, r3, #1
  401a3e:	687b      	ldr	r3, [r7, #4]
  401a40:	605a      	str	r2, [r3, #4]
}
  401a42:	bf00      	nop
  401a44:	370c      	adds	r7, #12
  401a46:	46bd      	mov	sp, r7
  401a48:	f85d 7b04 	ldr.w	r7, [sp], #4
  401a4c:	4770      	bx	lr

00401a4e <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  401a4e:	b480      	push	{r7}
  401a50:	af00      	add	r7, sp, #0
	while (1) {
  401a52:	e7fe      	b.n	401a52 <Dummy_Handler+0x4>

00401a54 <cpu_irq_save>:

static volatile uint32_t cpu_irq_critical_section_counter;
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
  401a54:	b480      	push	{r7}
  401a56:	b083      	sub	sp, #12
  401a58:	af00      	add	r7, sp, #0
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
  401a5a:	f3ef 8310 	mrs	r3, PRIMASK
  401a5e:	607b      	str	r3, [r7, #4]
  return(result);
  401a60:	687b      	ldr	r3, [r7, #4]
	volatile irqflags_t flags = cpu_irq_is_enabled();
  401a62:	2b00      	cmp	r3, #0
  401a64:	bf0c      	ite	eq
  401a66:	2301      	moveq	r3, #1
  401a68:	2300      	movne	r3, #0
  401a6a:	b2db      	uxtb	r3, r3
  401a6c:	603b      	str	r3, [r7, #0]
  __ASM volatile ("cpsid i" : : : "memory");
  401a6e:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
  401a70:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
  401a74:	4b04      	ldr	r3, [pc, #16]	; (401a88 <cpu_irq_save+0x34>)
  401a76:	2200      	movs	r2, #0
  401a78:	701a      	strb	r2, [r3, #0]
	return flags;
  401a7a:	683b      	ldr	r3, [r7, #0]
}
  401a7c:	4618      	mov	r0, r3
  401a7e:	370c      	adds	r7, #12
  401a80:	46bd      	mov	sp, r7
  401a82:	f85d 7b04 	ldr.w	r7, [sp], #4
  401a86:	4770      	bx	lr
  401a88:	20000018 	.word	0x20000018

00401a8c <cpu_irq_is_enabled_flags>:

static inline bool cpu_irq_is_enabled_flags(irqflags_t flags)
{
  401a8c:	b480      	push	{r7}
  401a8e:	b083      	sub	sp, #12
  401a90:	af00      	add	r7, sp, #0
  401a92:	6078      	str	r0, [r7, #4]
	return (flags);
  401a94:	687b      	ldr	r3, [r7, #4]
  401a96:	2b00      	cmp	r3, #0
  401a98:	bf14      	ite	ne
  401a9a:	2301      	movne	r3, #1
  401a9c:	2300      	moveq	r3, #0
  401a9e:	b2db      	uxtb	r3, r3
}
  401aa0:	4618      	mov	r0, r3
  401aa2:	370c      	adds	r7, #12
  401aa4:	46bd      	mov	sp, r7
  401aa6:	f85d 7b04 	ldr.w	r7, [sp], #4
  401aaa:	4770      	bx	lr

00401aac <cpu_irq_restore>:

static inline void cpu_irq_restore(irqflags_t flags)
{
  401aac:	b580      	push	{r7, lr}
  401aae:	b082      	sub	sp, #8
  401ab0:	af00      	add	r7, sp, #0
  401ab2:	6078      	str	r0, [r7, #4]
	if (cpu_irq_is_enabled_flags(flags))
  401ab4:	6878      	ldr	r0, [r7, #4]
  401ab6:	4b07      	ldr	r3, [pc, #28]	; (401ad4 <cpu_irq_restore+0x28>)
  401ab8:	4798      	blx	r3
  401aba:	4603      	mov	r3, r0
  401abc:	2b00      	cmp	r3, #0
  401abe:	d005      	beq.n	401acc <cpu_irq_restore+0x20>
		cpu_irq_enable();
  401ac0:	4b05      	ldr	r3, [pc, #20]	; (401ad8 <cpu_irq_restore+0x2c>)
  401ac2:	2201      	movs	r2, #1
  401ac4:	701a      	strb	r2, [r3, #0]
  401ac6:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
  401aca:	b662      	cpsie	i
}
  401acc:	bf00      	nop
  401ace:	3708      	adds	r7, #8
  401ad0:	46bd      	mov	sp, r7
  401ad2:	bd80      	pop	{r7, pc}
  401ad4:	00401a8d 	.word	0x00401a8d
  401ad8:	20000018 	.word	0x20000018

00401adc <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  401adc:	b580      	push	{r7, lr}
  401ade:	b084      	sub	sp, #16
  401ae0:	af00      	add	r7, sp, #0
	uint32_t *pSrc, *pDest;

	/* Initialize the relocate segment */
	pSrc = &_etext;
  401ae2:	4b1e      	ldr	r3, [pc, #120]	; (401b5c <Reset_Handler+0x80>)
  401ae4:	60fb      	str	r3, [r7, #12]
	pDest = &_srelocate;
  401ae6:	4b1e      	ldr	r3, [pc, #120]	; (401b60 <Reset_Handler+0x84>)
  401ae8:	60bb      	str	r3, [r7, #8]

	if (pSrc != pDest) {
  401aea:	68fa      	ldr	r2, [r7, #12]
  401aec:	68bb      	ldr	r3, [r7, #8]
  401aee:	429a      	cmp	r2, r3
  401af0:	d00c      	beq.n	401b0c <Reset_Handler+0x30>
		for (; pDest < &_erelocate;) {
  401af2:	e007      	b.n	401b04 <Reset_Handler+0x28>
			*pDest++ = *pSrc++;
  401af4:	68bb      	ldr	r3, [r7, #8]
  401af6:	1d1a      	adds	r2, r3, #4
  401af8:	60ba      	str	r2, [r7, #8]
  401afa:	68fa      	ldr	r2, [r7, #12]
  401afc:	1d11      	adds	r1, r2, #4
  401afe:	60f9      	str	r1, [r7, #12]
  401b00:	6812      	ldr	r2, [r2, #0]
  401b02:	601a      	str	r2, [r3, #0]
		for (; pDest < &_erelocate;) {
  401b04:	68bb      	ldr	r3, [r7, #8]
  401b06:	4a17      	ldr	r2, [pc, #92]	; (401b64 <Reset_Handler+0x88>)
  401b08:	4293      	cmp	r3, r2
  401b0a:	d3f3      	bcc.n	401af4 <Reset_Handler+0x18>
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  401b0c:	4b16      	ldr	r3, [pc, #88]	; (401b68 <Reset_Handler+0x8c>)
  401b0e:	60bb      	str	r3, [r7, #8]
  401b10:	e004      	b.n	401b1c <Reset_Handler+0x40>
		*pDest++ = 0;
  401b12:	68bb      	ldr	r3, [r7, #8]
  401b14:	1d1a      	adds	r2, r3, #4
  401b16:	60ba      	str	r2, [r7, #8]
  401b18:	2200      	movs	r2, #0
  401b1a:	601a      	str	r2, [r3, #0]
	for (pDest = &_szero; pDest < &_ezero;) {
  401b1c:	68bb      	ldr	r3, [r7, #8]
  401b1e:	4a13      	ldr	r2, [pc, #76]	; (401b6c <Reset_Handler+0x90>)
  401b20:	4293      	cmp	r3, r2
  401b22:	d3f6      	bcc.n	401b12 <Reset_Handler+0x36>
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) & _sfixed;
  401b24:	4b12      	ldr	r3, [pc, #72]	; (401b70 <Reset_Handler+0x94>)
  401b26:	60fb      	str	r3, [r7, #12]
	SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
  401b28:	4a12      	ldr	r2, [pc, #72]	; (401b74 <Reset_Handler+0x98>)
  401b2a:	68fb      	ldr	r3, [r7, #12]
  401b2c:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
  401b30:	6093      	str	r3, [r2, #8]
 * \brief Enable FPU
 */
__always_inline static void fpu_enable(void)
{
	irqflags_t flags;
	flags = cpu_irq_save();
  401b32:	4b11      	ldr	r3, [pc, #68]	; (401b78 <Reset_Handler+0x9c>)
  401b34:	4798      	blx	r3
  401b36:	6078      	str	r0, [r7, #4]
	REG_CPACR |=  (0xFu << 20);
  401b38:	4a10      	ldr	r2, [pc, #64]	; (401b7c <Reset_Handler+0xa0>)
  401b3a:	4b10      	ldr	r3, [pc, #64]	; (401b7c <Reset_Handler+0xa0>)
  401b3c:	681b      	ldr	r3, [r3, #0]
  401b3e:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
  401b42:	6013      	str	r3, [r2, #0]
  __ASM volatile ("dsb 0xF":::"memory");
  401b44:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  401b48:	f3bf 8f6f 	isb	sy
	__DSB();
	__ISB();
	cpu_irq_restore(flags);
  401b4c:	6878      	ldr	r0, [r7, #4]
  401b4e:	4b0c      	ldr	r3, [pc, #48]	; (401b80 <Reset_Handler+0xa4>)
  401b50:	4798      	blx	r3
#if __FPU_USED
	fpu_enable();
#endif

	/* Initialize the C library */
	__libc_init_array();
  401b52:	4b0c      	ldr	r3, [pc, #48]	; (401b84 <Reset_Handler+0xa8>)
  401b54:	4798      	blx	r3

	/* Branch to main function */
	main();
  401b56:	4b0c      	ldr	r3, [pc, #48]	; (401b88 <Reset_Handler+0xac>)
  401b58:	4798      	blx	r3

	/* Infinite loop */
	while (1);
  401b5a:	e7fe      	b.n	401b5a <Reset_Handler+0x7e>
  401b5c:	004039a8 	.word	0x004039a8
  401b60:	20000000 	.word	0x20000000
  401b64:	2000044c 	.word	0x2000044c
  401b68:	20000450 	.word	0x20000450
  401b6c:	2000a7e0 	.word	0x2000a7e0
  401b70:	00400000 	.word	0x00400000
  401b74:	e000ed00 	.word	0xe000ed00
  401b78:	00401a55 	.word	0x00401a55
  401b7c:	e000ed88 	.word	0xe000ed88
  401b80:	00401aad 	.word	0x00401aad
  401b84:	00402f8d 	.word	0x00402f8d
  401b88:	00401d8d 	.word	0x00401d8d

00401b8c <SystemCoreClockUpdate>:

	SystemCoreClock = CHIP_FREQ_CPU_MAX;
}

void SystemCoreClockUpdate( void )
{
  401b8c:	b480      	push	{r7}
  401b8e:	af00      	add	r7, sp, #0
	/* Determine clock frequency according to clock register values */
	switch (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) {
  401b90:	4b52      	ldr	r3, [pc, #328]	; (401cdc <SystemCoreClockUpdate+0x150>)
  401b92:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  401b94:	f003 0303 	and.w	r3, r3, #3
  401b98:	2b01      	cmp	r3, #1
  401b9a:	d014      	beq.n	401bc6 <SystemCoreClockUpdate+0x3a>
  401b9c:	2b01      	cmp	r3, #1
  401b9e:	d302      	bcc.n	401ba6 <SystemCoreClockUpdate+0x1a>
  401ba0:	2b02      	cmp	r3, #2
  401ba2:	d038      	beq.n	401c16 <SystemCoreClockUpdate+0x8a>
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos));
		}
		break;

	default:
		break;
  401ba4:	e07a      	b.n	401c9c <SystemCoreClockUpdate+0x110>
		if ( SUPC->SUPC_SR & SUPC_SR_OSCSEL ) {
  401ba6:	4b4e      	ldr	r3, [pc, #312]	; (401ce0 <SystemCoreClockUpdate+0x154>)
  401ba8:	695b      	ldr	r3, [r3, #20]
  401baa:	f003 0380 	and.w	r3, r3, #128	; 0x80
  401bae:	2b00      	cmp	r3, #0
  401bb0:	d004      	beq.n	401bbc <SystemCoreClockUpdate+0x30>
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
  401bb2:	4b4c      	ldr	r3, [pc, #304]	; (401ce4 <SystemCoreClockUpdate+0x158>)
  401bb4:	f44f 4200 	mov.w	r2, #32768	; 0x8000
  401bb8:	601a      	str	r2, [r3, #0]
		break;
  401bba:	e06f      	b.n	401c9c <SystemCoreClockUpdate+0x110>
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
  401bbc:	4b49      	ldr	r3, [pc, #292]	; (401ce4 <SystemCoreClockUpdate+0x158>)
  401bbe:	f44f 42fa 	mov.w	r2, #32000	; 0x7d00
  401bc2:	601a      	str	r2, [r3, #0]
		break;
  401bc4:	e06a      	b.n	401c9c <SystemCoreClockUpdate+0x110>
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  401bc6:	4b45      	ldr	r3, [pc, #276]	; (401cdc <SystemCoreClockUpdate+0x150>)
  401bc8:	6a1b      	ldr	r3, [r3, #32]
  401bca:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  401bce:	2b00      	cmp	r3, #0
  401bd0:	d003      	beq.n	401bda <SystemCoreClockUpdate+0x4e>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
  401bd2:	4b44      	ldr	r3, [pc, #272]	; (401ce4 <SystemCoreClockUpdate+0x158>)
  401bd4:	4a44      	ldr	r2, [pc, #272]	; (401ce8 <SystemCoreClockUpdate+0x15c>)
  401bd6:	601a      	str	r2, [r3, #0]
		break;
  401bd8:	e060      	b.n	401c9c <SystemCoreClockUpdate+0x110>
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  401bda:	4b42      	ldr	r3, [pc, #264]	; (401ce4 <SystemCoreClockUpdate+0x158>)
  401bdc:	4a43      	ldr	r2, [pc, #268]	; (401cec <SystemCoreClockUpdate+0x160>)
  401bde:	601a      	str	r2, [r3, #0]
			switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  401be0:	4b3e      	ldr	r3, [pc, #248]	; (401cdc <SystemCoreClockUpdate+0x150>)
  401be2:	6a1b      	ldr	r3, [r3, #32]
  401be4:	f003 0370 	and.w	r3, r3, #112	; 0x70
  401be8:	2b10      	cmp	r3, #16
  401bea:	d004      	beq.n	401bf6 <SystemCoreClockUpdate+0x6a>
  401bec:	2b20      	cmp	r3, #32
  401bee:	d008      	beq.n	401c02 <SystemCoreClockUpdate+0x76>
  401bf0:	2b00      	cmp	r3, #0
  401bf2:	d00e      	beq.n	401c12 <SystemCoreClockUpdate+0x86>
				break;
  401bf4:	e00e      	b.n	401c14 <SystemCoreClockUpdate+0x88>
				SystemCoreClock *= 2U;
  401bf6:	4b3b      	ldr	r3, [pc, #236]	; (401ce4 <SystemCoreClockUpdate+0x158>)
  401bf8:	681b      	ldr	r3, [r3, #0]
  401bfa:	005b      	lsls	r3, r3, #1
  401bfc:	4a39      	ldr	r2, [pc, #228]	; (401ce4 <SystemCoreClockUpdate+0x158>)
  401bfe:	6013      	str	r3, [r2, #0]
				break;
  401c00:	e008      	b.n	401c14 <SystemCoreClockUpdate+0x88>
				SystemCoreClock *= 3U;
  401c02:	4b38      	ldr	r3, [pc, #224]	; (401ce4 <SystemCoreClockUpdate+0x158>)
  401c04:	681a      	ldr	r2, [r3, #0]
  401c06:	4613      	mov	r3, r2
  401c08:	005b      	lsls	r3, r3, #1
  401c0a:	4413      	add	r3, r2
  401c0c:	4a35      	ldr	r2, [pc, #212]	; (401ce4 <SystemCoreClockUpdate+0x158>)
  401c0e:	6013      	str	r3, [r2, #0]
				break;
  401c10:	e000      	b.n	401c14 <SystemCoreClockUpdate+0x88>
				break;
  401c12:	bf00      	nop
		break;
  401c14:	e042      	b.n	401c9c <SystemCoreClockUpdate+0x110>
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  401c16:	4b31      	ldr	r3, [pc, #196]	; (401cdc <SystemCoreClockUpdate+0x150>)
  401c18:	6a1b      	ldr	r3, [r3, #32]
  401c1a:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
  401c1e:	2b00      	cmp	r3, #0
  401c20:	d003      	beq.n	401c2a <SystemCoreClockUpdate+0x9e>
			SystemCoreClock = CHIP_FREQ_XTAL_12M ;
  401c22:	4b30      	ldr	r3, [pc, #192]	; (401ce4 <SystemCoreClockUpdate+0x158>)
  401c24:	4a30      	ldr	r2, [pc, #192]	; (401ce8 <SystemCoreClockUpdate+0x15c>)
  401c26:	601a      	str	r2, [r3, #0]
  401c28:	e01c      	b.n	401c64 <SystemCoreClockUpdate+0xd8>
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  401c2a:	4b2e      	ldr	r3, [pc, #184]	; (401ce4 <SystemCoreClockUpdate+0x158>)
  401c2c:	4a2f      	ldr	r2, [pc, #188]	; (401cec <SystemCoreClockUpdate+0x160>)
  401c2e:	601a      	str	r2, [r3, #0]
			switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  401c30:	4b2a      	ldr	r3, [pc, #168]	; (401cdc <SystemCoreClockUpdate+0x150>)
  401c32:	6a1b      	ldr	r3, [r3, #32]
  401c34:	f003 0370 	and.w	r3, r3, #112	; 0x70
  401c38:	2b10      	cmp	r3, #16
  401c3a:	d004      	beq.n	401c46 <SystemCoreClockUpdate+0xba>
  401c3c:	2b20      	cmp	r3, #32
  401c3e:	d008      	beq.n	401c52 <SystemCoreClockUpdate+0xc6>
  401c40:	2b00      	cmp	r3, #0
  401c42:	d00e      	beq.n	401c62 <SystemCoreClockUpdate+0xd6>
				break;
  401c44:	e00e      	b.n	401c64 <SystemCoreClockUpdate+0xd8>
				SystemCoreClock *= 2U;
  401c46:	4b27      	ldr	r3, [pc, #156]	; (401ce4 <SystemCoreClockUpdate+0x158>)
  401c48:	681b      	ldr	r3, [r3, #0]
  401c4a:	005b      	lsls	r3, r3, #1
  401c4c:	4a25      	ldr	r2, [pc, #148]	; (401ce4 <SystemCoreClockUpdate+0x158>)
  401c4e:	6013      	str	r3, [r2, #0]
				break;
  401c50:	e008      	b.n	401c64 <SystemCoreClockUpdate+0xd8>
				SystemCoreClock *= 3U;
  401c52:	4b24      	ldr	r3, [pc, #144]	; (401ce4 <SystemCoreClockUpdate+0x158>)
  401c54:	681a      	ldr	r2, [r3, #0]
  401c56:	4613      	mov	r3, r2
  401c58:	005b      	lsls	r3, r3, #1
  401c5a:	4413      	add	r3, r2
  401c5c:	4a21      	ldr	r2, [pc, #132]	; (401ce4 <SystemCoreClockUpdate+0x158>)
  401c5e:	6013      	str	r3, [r2, #0]
				break;
  401c60:	e000      	b.n	401c64 <SystemCoreClockUpdate+0xd8>
				break;
  401c62:	bf00      	nop
		if ((uint32_t) (PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK)
  401c64:	4b1d      	ldr	r3, [pc, #116]	; (401cdc <SystemCoreClockUpdate+0x150>)
  401c66:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  401c68:	f003 0303 	and.w	r3, r3, #3
  401c6c:	2b02      	cmp	r3, #2
  401c6e:	d114      	bne.n	401c9a <SystemCoreClockUpdate+0x10e>
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> CKGR_PLLAR_MULA_Pos) + 1U);
  401c70:	4b1a      	ldr	r3, [pc, #104]	; (401cdc <SystemCoreClockUpdate+0x150>)
  401c72:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  401c74:	0c1b      	lsrs	r3, r3, #16
  401c76:	f3c3 030a 	ubfx	r3, r3, #0, #11
  401c7a:	3301      	adds	r3, #1
  401c7c:	4a19      	ldr	r2, [pc, #100]	; (401ce4 <SystemCoreClockUpdate+0x158>)
  401c7e:	6812      	ldr	r2, [r2, #0]
  401c80:	fb02 f303 	mul.w	r3, r2, r3
  401c84:	4a17      	ldr	r2, [pc, #92]	; (401ce4 <SystemCoreClockUpdate+0x158>)
  401c86:	6013      	str	r3, [r2, #0]
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> CKGR_PLLAR_DIVA_Pos));
  401c88:	4b14      	ldr	r3, [pc, #80]	; (401cdc <SystemCoreClockUpdate+0x150>)
  401c8a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  401c8c:	b2db      	uxtb	r3, r3
  401c8e:	4a15      	ldr	r2, [pc, #84]	; (401ce4 <SystemCoreClockUpdate+0x158>)
  401c90:	6812      	ldr	r2, [r2, #0]
  401c92:	fbb2 f3f3 	udiv	r3, r2, r3
  401c96:	4a13      	ldr	r2, [pc, #76]	; (401ce4 <SystemCoreClockUpdate+0x158>)
  401c98:	6013      	str	r3, [r2, #0]
		break;
  401c9a:	bf00      	nop
	}

	if ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3) {
  401c9c:	4b0f      	ldr	r3, [pc, #60]	; (401cdc <SystemCoreClockUpdate+0x150>)
  401c9e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  401ca0:	f003 0370 	and.w	r3, r3, #112	; 0x70
  401ca4:	2b70      	cmp	r3, #112	; 0x70
  401ca6:	d108      	bne.n	401cba <SystemCoreClockUpdate+0x12e>
		SystemCoreClock /= 3U;
  401ca8:	4b0e      	ldr	r3, [pc, #56]	; (401ce4 <SystemCoreClockUpdate+0x158>)
  401caa:	681b      	ldr	r3, [r3, #0]
  401cac:	4a10      	ldr	r2, [pc, #64]	; (401cf0 <SystemCoreClockUpdate+0x164>)
  401cae:	fba2 2303 	umull	r2, r3, r2, r3
  401cb2:	085b      	lsrs	r3, r3, #1
  401cb4:	4a0b      	ldr	r2, [pc, #44]	; (401ce4 <SystemCoreClockUpdate+0x158>)
  401cb6:	6013      	str	r3, [r2, #0]
	} else {
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >>
				PMC_MCKR_PRES_Pos);
	}
}
  401cb8:	e00a      	b.n	401cd0 <SystemCoreClockUpdate+0x144>
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >>
  401cba:	4b08      	ldr	r3, [pc, #32]	; (401cdc <SystemCoreClockUpdate+0x150>)
  401cbc:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  401cbe:	091b      	lsrs	r3, r3, #4
  401cc0:	f003 0307 	and.w	r3, r3, #7
  401cc4:	4a07      	ldr	r2, [pc, #28]	; (401ce4 <SystemCoreClockUpdate+0x158>)
  401cc6:	6812      	ldr	r2, [r2, #0]
  401cc8:	fa22 f303 	lsr.w	r3, r2, r3
  401ccc:	4a05      	ldr	r2, [pc, #20]	; (401ce4 <SystemCoreClockUpdate+0x158>)
  401cce:	6013      	str	r3, [r2, #0]
}
  401cd0:	bf00      	nop
  401cd2:	46bd      	mov	sp, r7
  401cd4:	f85d 7b04 	ldr.w	r7, [sp], #4
  401cd8:	4770      	bx	lr
  401cda:	bf00      	nop
  401cdc:	400e0400 	.word	0x400e0400
  401ce0:	400e1810 	.word	0x400e1810
  401ce4:	2000001c 	.word	0x2000001c
  401ce8:	00b71b00 	.word	0x00b71b00
  401cec:	003d0900 	.word	0x003d0900
  401cf0:	aaaaaaab 	.word	0xaaaaaaab

00401cf4 <system_init_flash>:

/**
 * Initialize flash.
 */
void system_init_flash( uint32_t ul_clk )
{
  401cf4:	b480      	push	{r7}
  401cf6:	b083      	sub	sp, #12
  401cf8:	af00      	add	r7, sp, #0
  401cfa:	6078      	str	r0, [r7, #4]
	/* Set FWS for embedded Flash access according to operating frequency */
	if ( ul_clk < CHIP_FREQ_FWS_0 ) {
  401cfc:	687b      	ldr	r3, [r7, #4]
  401cfe:	4a19      	ldr	r2, [pc, #100]	; (401d64 <system_init_flash+0x70>)
  401d00:	4293      	cmp	r3, r2
  401d02:	d804      	bhi.n	401d0e <system_init_flash+0x1a>
		EFC->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  401d04:	4b18      	ldr	r3, [pc, #96]	; (401d68 <system_init_flash+0x74>)
  401d06:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
  401d0a:	601a      	str	r2, [r3, #0]
					}
				}
			}
		}
	}
}
  401d0c:	e023      	b.n	401d56 <system_init_flash+0x62>
		if (ul_clk < CHIP_FREQ_FWS_1) {
  401d0e:	687b      	ldr	r3, [r7, #4]
  401d10:	4a16      	ldr	r2, [pc, #88]	; (401d6c <system_init_flash+0x78>)
  401d12:	4293      	cmp	r3, r2
  401d14:	d803      	bhi.n	401d1e <system_init_flash+0x2a>
			EFC->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
  401d16:	4b14      	ldr	r3, [pc, #80]	; (401d68 <system_init_flash+0x74>)
  401d18:	4a15      	ldr	r2, [pc, #84]	; (401d70 <system_init_flash+0x7c>)
  401d1a:	601a      	str	r2, [r3, #0]
}
  401d1c:	e01b      	b.n	401d56 <system_init_flash+0x62>
			if (ul_clk < CHIP_FREQ_FWS_2) {
  401d1e:	687b      	ldr	r3, [r7, #4]
  401d20:	4a14      	ldr	r2, [pc, #80]	; (401d74 <system_init_flash+0x80>)
  401d22:	4293      	cmp	r3, r2
  401d24:	d803      	bhi.n	401d2e <system_init_flash+0x3a>
				EFC->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
  401d26:	4b10      	ldr	r3, [pc, #64]	; (401d68 <system_init_flash+0x74>)
  401d28:	4a13      	ldr	r2, [pc, #76]	; (401d78 <system_init_flash+0x84>)
  401d2a:	601a      	str	r2, [r3, #0]
}
  401d2c:	e013      	b.n	401d56 <system_init_flash+0x62>
				if ( ul_clk < CHIP_FREQ_FWS_3 ) {
  401d2e:	687b      	ldr	r3, [r7, #4]
  401d30:	4a12      	ldr	r2, [pc, #72]	; (401d7c <system_init_flash+0x88>)
  401d32:	4293      	cmp	r3, r2
  401d34:	d803      	bhi.n	401d3e <system_init_flash+0x4a>
					EFC->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
  401d36:	4b0c      	ldr	r3, [pc, #48]	; (401d68 <system_init_flash+0x74>)
  401d38:	4a11      	ldr	r2, [pc, #68]	; (401d80 <system_init_flash+0x8c>)
  401d3a:	601a      	str	r2, [r3, #0]
}
  401d3c:	e00b      	b.n	401d56 <system_init_flash+0x62>
					if ( ul_clk < CHIP_FREQ_FWS_4 ) {
  401d3e:	687b      	ldr	r3, [r7, #4]
  401d40:	4a10      	ldr	r2, [pc, #64]	; (401d84 <system_init_flash+0x90>)
  401d42:	4293      	cmp	r3, r2
  401d44:	d804      	bhi.n	401d50 <system_init_flash+0x5c>
						EFC->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  401d46:	4b08      	ldr	r3, [pc, #32]	; (401d68 <system_init_flash+0x74>)
  401d48:	f04f 2204 	mov.w	r2, #67109888	; 0x4000400
  401d4c:	601a      	str	r2, [r3, #0]
}
  401d4e:	e002      	b.n	401d56 <system_init_flash+0x62>
						EFC->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  401d50:	4b05      	ldr	r3, [pc, #20]	; (401d68 <system_init_flash+0x74>)
  401d52:	4a0d      	ldr	r2, [pc, #52]	; (401d88 <system_init_flash+0x94>)
  401d54:	601a      	str	r2, [r3, #0]
}
  401d56:	bf00      	nop
  401d58:	370c      	adds	r7, #12
  401d5a:	46bd      	mov	sp, r7
  401d5c:	f85d 7b04 	ldr.w	r7, [sp], #4
  401d60:	4770      	bx	lr
  401d62:	bf00      	nop
  401d64:	01312cff 	.word	0x01312cff
  401d68:	400e0a00 	.word	0x400e0a00
  401d6c:	026259ff 	.word	0x026259ff
  401d70:	04000100 	.word	0x04000100
  401d74:	039386ff 	.word	0x039386ff
  401d78:	04000200 	.word	0x04000200
  401d7c:	04c4b3ff 	.word	0x04c4b3ff
  401d80:	04000300 	.word	0x04000300
  401d84:	05f5e0ff 	.word	0x05f5e0ff
  401d88:	04000500 	.word	0x04000500

00401d8c <main>:
/* Function definitions ----------------------------------------------- */
/**
 * @brief Entry
 */
int main(void)
{
  401d8c:	b580      	push	{r7, lr}
  401d8e:	af00      	add	r7, sp, #0
  sys_init();
  401d90:	4b02      	ldr	r3, [pc, #8]	; (401d9c <main+0x10>)
  401d92:	4798      	blx	r3
  401d94:	2300      	movs	r3, #0
}
  401d96:	4618      	mov	r0, r3
  401d98:	bd80      	pop	{r7, pc}
  401d9a:	bf00      	nop
  401d9c:	00401555 	.word	0x00401555

00401da0 <osc_enable>:
{
  401da0:	b580      	push	{r7, lr}
  401da2:	b082      	sub	sp, #8
  401da4:	af00      	add	r7, sp, #0
  401da6:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  401da8:	687b      	ldr	r3, [r7, #4]
  401daa:	2b07      	cmp	r3, #7
  401dac:	d831      	bhi.n	401e12 <osc_enable+0x72>
  401dae:	a201      	add	r2, pc, #4	; (adr r2, 401db4 <osc_enable+0x14>)
  401db0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  401db4:	00401e11 	.word	0x00401e11
  401db8:	00401dd5 	.word	0x00401dd5
  401dbc:	00401ddd 	.word	0x00401ddd
  401dc0:	00401de5 	.word	0x00401de5
  401dc4:	00401ded 	.word	0x00401ded
  401dc8:	00401df5 	.word	0x00401df5
  401dcc:	00401dfd 	.word	0x00401dfd
  401dd0:	00401e07 	.word	0x00401e07
		pmc_switch_sclk_to_32kxtal(PMC_OSC_XTAL);
  401dd4:	2000      	movs	r0, #0
  401dd6:	4b11      	ldr	r3, [pc, #68]	; (401e1c <osc_enable+0x7c>)
  401dd8:	4798      	blx	r3
		break;
  401dda:	e01a      	b.n	401e12 <osc_enable+0x72>
		pmc_switch_sclk_to_32kxtal(PMC_OSC_BYPASS);
  401ddc:	2001      	movs	r0, #1
  401dde:	4b0f      	ldr	r3, [pc, #60]	; (401e1c <osc_enable+0x7c>)
  401de0:	4798      	blx	r3
		break;
  401de2:	e016      	b.n	401e12 <osc_enable+0x72>
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_4_MHz);
  401de4:	2000      	movs	r0, #0
  401de6:	4b0e      	ldr	r3, [pc, #56]	; (401e20 <osc_enable+0x80>)
  401de8:	4798      	blx	r3
		break;
  401dea:	e012      	b.n	401e12 <osc_enable+0x72>
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_8_MHz);
  401dec:	2010      	movs	r0, #16
  401dee:	4b0c      	ldr	r3, [pc, #48]	; (401e20 <osc_enable+0x80>)
  401df0:	4798      	blx	r3
		break;
  401df2:	e00e      	b.n	401e12 <osc_enable+0x72>
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_12_MHz);
  401df4:	2020      	movs	r0, #32
  401df6:	4b0a      	ldr	r3, [pc, #40]	; (401e20 <osc_enable+0x80>)
  401df8:	4798      	blx	r3
		break;
  401dfa:	e00a      	b.n	401e12 <osc_enable+0x72>
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL,
  401dfc:	213e      	movs	r1, #62	; 0x3e
  401dfe:	2000      	movs	r0, #0
  401e00:	4b08      	ldr	r3, [pc, #32]	; (401e24 <osc_enable+0x84>)
  401e02:	4798      	blx	r3
		break;
  401e04:	e005      	b.n	401e12 <osc_enable+0x72>
		pmc_switch_mainck_to_xtal(PMC_OSC_BYPASS,
  401e06:	213e      	movs	r1, #62	; 0x3e
  401e08:	2001      	movs	r0, #1
  401e0a:	4b06      	ldr	r3, [pc, #24]	; (401e24 <osc_enable+0x84>)
  401e0c:	4798      	blx	r3
		break;
  401e0e:	e000      	b.n	401e12 <osc_enable+0x72>
		break;
  401e10:	bf00      	nop
}
  401e12:	bf00      	nop
  401e14:	3708      	adds	r7, #8
  401e16:	46bd      	mov	sp, r7
  401e18:	bd80      	pop	{r7, pc}
  401e1a:	bf00      	nop
  401e1c:	00402779 	.word	0x00402779
  401e20:	004027e5 	.word	0x004027e5
  401e24:	00402855 	.word	0x00402855

00401e28 <osc_is_ready>:
{
  401e28:	b580      	push	{r7, lr}
  401e2a:	b082      	sub	sp, #8
  401e2c:	af00      	add	r7, sp, #0
  401e2e:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  401e30:	687b      	ldr	r3, [r7, #4]
  401e32:	2b07      	cmp	r3, #7
  401e34:	d826      	bhi.n	401e84 <osc_is_ready+0x5c>
  401e36:	a201      	add	r2, pc, #4	; (adr r2, 401e3c <osc_is_ready+0x14>)
  401e38:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  401e3c:	00401e5d 	.word	0x00401e5d
  401e40:	00401e61 	.word	0x00401e61
  401e44:	00401e61 	.word	0x00401e61
  401e48:	00401e73 	.word	0x00401e73
  401e4c:	00401e73 	.word	0x00401e73
  401e50:	00401e73 	.word	0x00401e73
  401e54:	00401e73 	.word	0x00401e73
  401e58:	00401e73 	.word	0x00401e73
		return 1;
  401e5c:	2301      	movs	r3, #1
  401e5e:	e012      	b.n	401e86 <osc_is_ready+0x5e>
		return pmc_osc_is_ready_32kxtal();
  401e60:	4b0b      	ldr	r3, [pc, #44]	; (401e90 <osc_is_ready+0x68>)
  401e62:	4798      	blx	r3
  401e64:	4603      	mov	r3, r0
  401e66:	2b00      	cmp	r3, #0
  401e68:	bf14      	ite	ne
  401e6a:	2301      	movne	r3, #1
  401e6c:	2300      	moveq	r3, #0
  401e6e:	b2db      	uxtb	r3, r3
  401e70:	e009      	b.n	401e86 <osc_is_ready+0x5e>
		return pmc_osc_is_ready_mainck();
  401e72:	4b08      	ldr	r3, [pc, #32]	; (401e94 <osc_is_ready+0x6c>)
  401e74:	4798      	blx	r3
  401e76:	4603      	mov	r3, r0
  401e78:	2b00      	cmp	r3, #0
  401e7a:	bf14      	ite	ne
  401e7c:	2301      	movne	r3, #1
  401e7e:	2300      	moveq	r3, #0
  401e80:	b2db      	uxtb	r3, r3
  401e82:	e000      	b.n	401e86 <osc_is_ready+0x5e>
	return 0;
  401e84:	2300      	movs	r3, #0
}
  401e86:	4618      	mov	r0, r3
  401e88:	3708      	adds	r7, #8
  401e8a:	46bd      	mov	sp, r7
  401e8c:	bd80      	pop	{r7, pc}
  401e8e:	bf00      	nop
  401e90:	004027b1 	.word	0x004027b1
  401e94:	004028cd 	.word	0x004028cd

00401e98 <osc_get_rate>:
{
  401e98:	b480      	push	{r7}
  401e9a:	b083      	sub	sp, #12
  401e9c:	af00      	add	r7, sp, #0
  401e9e:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
  401ea0:	687b      	ldr	r3, [r7, #4]
  401ea2:	2b07      	cmp	r3, #7
  401ea4:	d825      	bhi.n	401ef2 <osc_get_rate+0x5a>
  401ea6:	a201      	add	r2, pc, #4	; (adr r2, 401eac <osc_get_rate+0x14>)
  401ea8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
  401eac:	00401ecd 	.word	0x00401ecd
  401eb0:	00401ed3 	.word	0x00401ed3
  401eb4:	00401ed9 	.word	0x00401ed9
  401eb8:	00401edf 	.word	0x00401edf
  401ebc:	00401ee3 	.word	0x00401ee3
  401ec0:	00401ee7 	.word	0x00401ee7
  401ec4:	00401eeb 	.word	0x00401eeb
  401ec8:	00401eef 	.word	0x00401eef
		return OSC_SLCK_32K_RC_HZ;
  401ecc:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
  401ed0:	e010      	b.n	401ef4 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_XTAL;
  401ed2:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  401ed6:	e00d      	b.n	401ef4 <osc_get_rate+0x5c>
		return BOARD_FREQ_SLCK_BYPASS;
  401ed8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  401edc:	e00a      	b.n	401ef4 <osc_get_rate+0x5c>
		return OSC_MAINCK_4M_RC_HZ;
  401ede:	4b08      	ldr	r3, [pc, #32]	; (401f00 <osc_get_rate+0x68>)
  401ee0:	e008      	b.n	401ef4 <osc_get_rate+0x5c>
		return OSC_MAINCK_8M_RC_HZ;
  401ee2:	4b08      	ldr	r3, [pc, #32]	; (401f04 <osc_get_rate+0x6c>)
  401ee4:	e006      	b.n	401ef4 <osc_get_rate+0x5c>
		return OSC_MAINCK_12M_RC_HZ;
  401ee6:	4b08      	ldr	r3, [pc, #32]	; (401f08 <osc_get_rate+0x70>)
  401ee8:	e004      	b.n	401ef4 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_XTAL;
  401eea:	4b07      	ldr	r3, [pc, #28]	; (401f08 <osc_get_rate+0x70>)
  401eec:	e002      	b.n	401ef4 <osc_get_rate+0x5c>
		return BOARD_FREQ_MAINCK_BYPASS;
  401eee:	4b06      	ldr	r3, [pc, #24]	; (401f08 <osc_get_rate+0x70>)
  401ef0:	e000      	b.n	401ef4 <osc_get_rate+0x5c>
	return 0;
  401ef2:	2300      	movs	r3, #0
}
  401ef4:	4618      	mov	r0, r3
  401ef6:	370c      	adds	r7, #12
  401ef8:	46bd      	mov	sp, r7
  401efa:	f85d 7b04 	ldr.w	r7, [sp], #4
  401efe:	4770      	bx	lr
  401f00:	003d0900 	.word	0x003d0900
  401f04:	007a1200 	.word	0x007a1200
  401f08:	00b71b00 	.word	0x00b71b00

00401f0c <osc_wait_ready>:
 * to become stable and ready to use as a clock source.
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
  401f0c:	b580      	push	{r7, lr}
  401f0e:	b082      	sub	sp, #8
  401f10:	af00      	add	r7, sp, #0
  401f12:	4603      	mov	r3, r0
  401f14:	71fb      	strb	r3, [r7, #7]
	while (!osc_is_ready(id)) {
  401f16:	bf00      	nop
  401f18:	79fb      	ldrb	r3, [r7, #7]
  401f1a:	4618      	mov	r0, r3
  401f1c:	4b05      	ldr	r3, [pc, #20]	; (401f34 <osc_wait_ready+0x28>)
  401f1e:	4798      	blx	r3
  401f20:	4603      	mov	r3, r0
  401f22:	f083 0301 	eor.w	r3, r3, #1
  401f26:	b2db      	uxtb	r3, r3
  401f28:	2b00      	cmp	r3, #0
  401f2a:	d1f5      	bne.n	401f18 <osc_wait_ready+0xc>
		/* Do nothing */
	}
}
  401f2c:	bf00      	nop
  401f2e:	3708      	adds	r7, #8
  401f30:	46bd      	mov	sp, r7
  401f32:	bd80      	pop	{r7, pc}
  401f34:	00401e29 	.word	0x00401e29

00401f38 <pll_config_init>:
 * hardware mul+1 is hidden in this implementation. Use mul as mul effective
 * value.
 */
static inline void pll_config_init(struct pll_config *p_cfg,
		enum pll_source e_src, uint32_t ul_div, uint32_t ul_mul)
{
  401f38:	b580      	push	{r7, lr}
  401f3a:	b086      	sub	sp, #24
  401f3c:	af00      	add	r7, sp, #0
  401f3e:	60f8      	str	r0, [r7, #12]
  401f40:	607a      	str	r2, [r7, #4]
  401f42:	603b      	str	r3, [r7, #0]
  401f44:	460b      	mov	r3, r1
  401f46:	72fb      	strb	r3, [r7, #11]
	uint32_t vco_hz;

	Assert(e_src < PLL_NR_SOURCES);

	/* Calculate internal VCO frequency */
	vco_hz = osc_get_rate(e_src) / ul_div;
  401f48:	7afb      	ldrb	r3, [r7, #11]
  401f4a:	4618      	mov	r0, r3
  401f4c:	4b0d      	ldr	r3, [pc, #52]	; (401f84 <pll_config_init+0x4c>)
  401f4e:	4798      	blx	r3
  401f50:	4602      	mov	r2, r0
  401f52:	687b      	ldr	r3, [r7, #4]
  401f54:	fbb2 f3f3 	udiv	r3, r2, r3
  401f58:	617b      	str	r3, [r7, #20]
	Assert(vco_hz >= PLL_INPUT_MIN_HZ);
	Assert(vco_hz <= PLL_INPUT_MAX_HZ);

	vco_hz *= ul_mul;
  401f5a:	697b      	ldr	r3, [r7, #20]
  401f5c:	683a      	ldr	r2, [r7, #0]
  401f5e:	fb02 f303 	mul.w	r3, r2, r3
  401f62:	617b      	str	r3, [r7, #20]
	Assert(vco_hz >= PLL_OUTPUT_MIN_HZ);
	Assert(vco_hz <= PLL_OUTPUT_MAX_HZ);

	/* PMC hardware will automatically make it mul+1 */
	p_cfg->ctrl = CKGR_PLLAR_MULA(ul_mul - 1) | CKGR_PLLAR_DIVA(ul_div) | \
  401f64:	683b      	ldr	r3, [r7, #0]
  401f66:	3b01      	subs	r3, #1
  401f68:	041a      	lsls	r2, r3, #16
  401f6a:	4b07      	ldr	r3, [pc, #28]	; (401f88 <pll_config_init+0x50>)
  401f6c:	4013      	ands	r3, r2
  401f6e:	687a      	ldr	r2, [r7, #4]
  401f70:	b2d2      	uxtb	r2, r2
  401f72:	4313      	orrs	r3, r2
  401f74:	f443 527c 	orr.w	r2, r3, #16128	; 0x3f00
  401f78:	68fb      	ldr	r3, [r7, #12]
  401f7a:	601a      	str	r2, [r3, #0]
			CKGR_PLLAR_PLLACOUNT(PLL_COUNT);
}
  401f7c:	bf00      	nop
  401f7e:	3718      	adds	r7, #24
  401f80:	46bd      	mov	sp, r7
  401f82:	bd80      	pop	{r7, pc}
  401f84:	00401e99 	.word	0x00401e99
  401f88:	07ff0000 	.word	0x07ff0000

00401f8c <pll_enable>:
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
	}
}

static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
  401f8c:	b580      	push	{r7, lr}
  401f8e:	b082      	sub	sp, #8
  401f90:	af00      	add	r7, sp, #0
  401f92:	6078      	str	r0, [r7, #4]
  401f94:	6039      	str	r1, [r7, #0]
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
  401f96:	683b      	ldr	r3, [r7, #0]
  401f98:	2b00      	cmp	r3, #0
  401f9a:	d107      	bne.n	401fac <pll_enable+0x20>
		pmc_disable_pllack(); // Always stop PLL first!
  401f9c:	4b05      	ldr	r3, [pc, #20]	; (401fb4 <pll_enable+0x28>)
  401f9e:	4798      	blx	r3
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
  401fa0:	4a05      	ldr	r2, [pc, #20]	; (401fb8 <pll_enable+0x2c>)
  401fa2:	687b      	ldr	r3, [r7, #4]
  401fa4:	681b      	ldr	r3, [r3, #0]
  401fa6:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
  401faa:	6293      	str	r3, [r2, #40]	; 0x28
	}
}
  401fac:	bf00      	nop
  401fae:	3708      	adds	r7, #8
  401fb0:	46bd      	mov	sp, r7
  401fb2:	bd80      	pop	{r7, pc}
  401fb4:	004028e9 	.word	0x004028e9
  401fb8:	400e0400 	.word	0x400e0400

00401fbc <pll_is_locked>:
		pmc_disable_pllack();
	}
}

static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
  401fbc:	b580      	push	{r7, lr}
  401fbe:	b082      	sub	sp, #8
  401fc0:	af00      	add	r7, sp, #0
  401fc2:	6078      	str	r0, [r7, #4]
	Assert(ul_pll_id < NR_PLLS);

	UNUSED(ul_pll_id);
	return pmc_is_locked_pllack();
  401fc4:	4b03      	ldr	r3, [pc, #12]	; (401fd4 <pll_is_locked+0x18>)
  401fc6:	4798      	blx	r3
  401fc8:	4603      	mov	r3, r0
}
  401fca:	4618      	mov	r0, r3
  401fcc:	3708      	adds	r7, #8
  401fce:	46bd      	mov	sp, r7
  401fd0:	bd80      	pop	{r7, pc}
  401fd2:	bf00      	nop
  401fd4:	00402905 	.word	0x00402905

00401fd8 <pll_enable_source>:

static inline void pll_enable_source(enum pll_source e_src)
{
  401fd8:	b580      	push	{r7, lr}
  401fda:	b082      	sub	sp, #8
  401fdc:	af00      	add	r7, sp, #0
  401fde:	4603      	mov	r3, r0
  401fe0:	71fb      	strb	r3, [r7, #7]
	switch (e_src) {
  401fe2:	79fb      	ldrb	r3, [r7, #7]
  401fe4:	3b03      	subs	r3, #3
  401fe6:	2b04      	cmp	r3, #4
  401fe8:	d808      	bhi.n	401ffc <pll_enable_source+0x24>
	case PLL_SRC_MAINCK_4M_RC:
	case PLL_SRC_MAINCK_8M_RC:
	case PLL_SRC_MAINCK_12M_RC:
	case PLL_SRC_MAINCK_XTAL:
	case PLL_SRC_MAINCK_BYPASS:
		osc_enable(e_src);
  401fea:	79fb      	ldrb	r3, [r7, #7]
  401fec:	4618      	mov	r0, r3
  401fee:	4b06      	ldr	r3, [pc, #24]	; (402008 <pll_enable_source+0x30>)
  401ff0:	4798      	blx	r3
		osc_wait_ready(e_src);
  401ff2:	79fb      	ldrb	r3, [r7, #7]
  401ff4:	4618      	mov	r0, r3
  401ff6:	4b05      	ldr	r3, [pc, #20]	; (40200c <pll_enable_source+0x34>)
  401ff8:	4798      	blx	r3
		break;
  401ffa:	e000      	b.n	401ffe <pll_enable_source+0x26>

	default:
		Assert(false);
		break;
  401ffc:	bf00      	nop
	}
}
  401ffe:	bf00      	nop
  402000:	3708      	adds	r7, #8
  402002:	46bd      	mov	sp, r7
  402004:	bd80      	pop	{r7, pc}
  402006:	bf00      	nop
  402008:	00401da1 	.word	0x00401da1
  40200c:	00401f0d 	.word	0x00401f0d

00402010 <pll_wait_for_lock>:
 *
 * \retval STATUS_OK The PLL is now locked.
 * \retval ERR_TIMEOUT Timed out waiting for PLL to become locked.
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
  402010:	b580      	push	{r7, lr}
  402012:	b082      	sub	sp, #8
  402014:	af00      	add	r7, sp, #0
  402016:	6078      	str	r0, [r7, #4]
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  402018:	bf00      	nop
  40201a:	6878      	ldr	r0, [r7, #4]
  40201c:	4b04      	ldr	r3, [pc, #16]	; (402030 <pll_wait_for_lock+0x20>)
  40201e:	4798      	blx	r3
  402020:	4603      	mov	r3, r0
  402022:	2b00      	cmp	r3, #0
  402024:	d0f9      	beq.n	40201a <pll_wait_for_lock+0xa>
		/* Do nothing */
	}

	return 0;
  402026:	2300      	movs	r3, #0
}
  402028:	4618      	mov	r0, r3
  40202a:	3708      	adds	r7, #8
  40202c:	46bd      	mov	sp, r7
  40202e:	bd80      	pop	{r7, pc}
  402030:	00401fbd 	.word	0x00401fbd

00402034 <sysclk_get_main_hz>:
{
  402034:	b580      	push	{r7, lr}
  402036:	af00      	add	r7, sp, #0
		return pll_get_default_rate(0);
  402038:	2006      	movs	r0, #6
  40203a:	4b03      	ldr	r3, [pc, #12]	; (402048 <sysclk_get_main_hz+0x14>)
  40203c:	4798      	blx	r3
  40203e:	4603      	mov	r3, r0
  402040:	011b      	lsls	r3, r3, #4
}
  402042:	4618      	mov	r0, r3
  402044:	bd80      	pop	{r7, pc}
  402046:	bf00      	nop
  402048:	00401e99 	.word	0x00401e99

0040204c <sysclk_get_cpu_hz>:
{
  40204c:	b580      	push	{r7, lr}
  40204e:	af00      	add	r7, sp, #0
	return sysclk_get_main_hz() /
  402050:	4b02      	ldr	r3, [pc, #8]	; (40205c <sysclk_get_cpu_hz+0x10>)
  402052:	4798      	blx	r3
  402054:	4603      	mov	r3, r0
  402056:	085b      	lsrs	r3, r3, #1
}
  402058:	4618      	mov	r0, r3
  40205a:	bd80      	pop	{r7, pc}
  40205c:	00402035 	.word	0x00402035

00402060 <sysclk_init>:
	pmc_disable_udpck();
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
  402060:	b590      	push	{r4, r7, lr}
  402062:	b083      	sub	sp, #12
  402064:	af00      	add	r7, sp, #0
	/* Set flash wait state to max in case the below clock switching. */
	system_init_flash(CHIP_FREQ_CPU_MAX);
  402066:	4811      	ldr	r0, [pc, #68]	; (4020ac <sysclk_init+0x4c>)
  402068:	4b11      	ldr	r3, [pc, #68]	; (4020b0 <sysclk_init+0x50>)
  40206a:	4798      	blx	r3

#ifdef CONFIG_PLL0_SOURCE
	else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_PLLACK) {
		struct pll_config pllcfg;

		pll_enable_source(CONFIG_PLL0_SOURCE);
  40206c:	2006      	movs	r0, #6
  40206e:	4b11      	ldr	r3, [pc, #68]	; (4020b4 <sysclk_init+0x54>)
  402070:	4798      	blx	r3
		pll_config_defaults(&pllcfg, 0);
  402072:	1d38      	adds	r0, r7, #4
  402074:	2310      	movs	r3, #16
  402076:	2201      	movs	r2, #1
  402078:	2106      	movs	r1, #6
  40207a:	4c0f      	ldr	r4, [pc, #60]	; (4020b8 <sysclk_init+0x58>)
  40207c:	47a0      	blx	r4
		pll_enable(&pllcfg, 0);
  40207e:	1d3b      	adds	r3, r7, #4
  402080:	2100      	movs	r1, #0
  402082:	4618      	mov	r0, r3
  402084:	4b0d      	ldr	r3, [pc, #52]	; (4020bc <sysclk_init+0x5c>)
  402086:	4798      	blx	r3
		pll_wait_for_lock(0);
  402088:	2000      	movs	r0, #0
  40208a:	4b0d      	ldr	r3, [pc, #52]	; (4020c0 <sysclk_init+0x60>)
  40208c:	4798      	blx	r3
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  40208e:	2010      	movs	r0, #16
  402090:	4b0c      	ldr	r3, [pc, #48]	; (4020c4 <sysclk_init+0x64>)
  402092:	4798      	blx	r3
	}
#endif

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  402094:	4b0c      	ldr	r3, [pc, #48]	; (4020c8 <sysclk_init+0x68>)
  402096:	4798      	blx	r3

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  402098:	4b0c      	ldr	r3, [pc, #48]	; (4020cc <sysclk_init+0x6c>)
  40209a:	4798      	blx	r3
  40209c:	4603      	mov	r3, r0
  40209e:	4618      	mov	r0, r3
  4020a0:	4b03      	ldr	r3, [pc, #12]	; (4020b0 <sysclk_init+0x50>)
  4020a2:	4798      	blx	r3

#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
	/* Signal that the internal frequencies are setup */
	sysclk_initialized = 1;
#endif
}
  4020a4:	bf00      	nop
  4020a6:	370c      	adds	r7, #12
  4020a8:	46bd      	mov	sp, r7
  4020aa:	bd90      	pop	{r4, r7, pc}
  4020ac:	07270e00 	.word	0x07270e00
  4020b0:	00401cf5 	.word	0x00401cf5
  4020b4:	00401fd9 	.word	0x00401fd9
  4020b8:	00401f39 	.word	0x00401f39
  4020bc:	00401f8d 	.word	0x00401f8d
  4020c0:	00402011 	.word	0x00402011
  4020c4:	004026f5 	.word	0x004026f5
  4020c8:	00401b8d 	.word	0x00401b8d
  4020cc:	0040204d 	.word	0x0040204d

004020d0 <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  4020d0:	b580      	push	{r7, lr}
  4020d2:	b084      	sub	sp, #16
  4020d4:	af00      	add	r7, sp, #0
  4020d6:	6078      	str	r0, [r7, #4]
  4020d8:	6039      	str	r1, [r7, #0]
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  4020da:	6878      	ldr	r0, [r7, #4]
  4020dc:	4b2c      	ldr	r3, [pc, #176]	; (402190 <pio_handler_process+0xc0>)
  4020de:	4798      	blx	r3
  4020e0:	60f8      	str	r0, [r7, #12]
	status &= pio_get_interrupt_mask(p_pio);
  4020e2:	6878      	ldr	r0, [r7, #4]
  4020e4:	4b2b      	ldr	r3, [pc, #172]	; (402194 <pio_handler_process+0xc4>)
  4020e6:	4798      	blx	r3
  4020e8:	4602      	mov	r2, r0
  4020ea:	68fb      	ldr	r3, [r7, #12]
  4020ec:	4013      	ands	r3, r2
  4020ee:	60fb      	str	r3, [r7, #12]

	/* Check pending events */
	if (status != 0) {
  4020f0:	68fb      	ldr	r3, [r7, #12]
  4020f2:	2b00      	cmp	r3, #0
  4020f4:	d03c      	beq.n	402170 <pio_handler_process+0xa0>
		/* Find triggering source */
		i = 0;
  4020f6:	2300      	movs	r3, #0
  4020f8:	60bb      	str	r3, [r7, #8]
		while (status != 0) {
  4020fa:	e034      	b.n	402166 <pio_handler_process+0x96>
			/* Source is configured on the same controller */
			if (gs_interrupt_sources[i].id == ul_id) {
  4020fc:	4a26      	ldr	r2, [pc, #152]	; (402198 <pio_handler_process+0xc8>)
  4020fe:	68bb      	ldr	r3, [r7, #8]
  402100:	011b      	lsls	r3, r3, #4
  402102:	4413      	add	r3, r2
  402104:	681a      	ldr	r2, [r3, #0]
  402106:	683b      	ldr	r3, [r7, #0]
  402108:	429a      	cmp	r2, r3
  40210a:	d126      	bne.n	40215a <pio_handler_process+0x8a>
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
  40210c:	4a22      	ldr	r2, [pc, #136]	; (402198 <pio_handler_process+0xc8>)
  40210e:	68bb      	ldr	r3, [r7, #8]
  402110:	011b      	lsls	r3, r3, #4
  402112:	4413      	add	r3, r2
  402114:	3304      	adds	r3, #4
  402116:	681a      	ldr	r2, [r3, #0]
  402118:	68fb      	ldr	r3, [r7, #12]
  40211a:	4013      	ands	r3, r2
  40211c:	2b00      	cmp	r3, #0
  40211e:	d01c      	beq.n	40215a <pio_handler_process+0x8a>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
  402120:	4a1d      	ldr	r2, [pc, #116]	; (402198 <pio_handler_process+0xc8>)
  402122:	68bb      	ldr	r3, [r7, #8]
  402124:	011b      	lsls	r3, r3, #4
  402126:	4413      	add	r3, r2
  402128:	330c      	adds	r3, #12
  40212a:	681b      	ldr	r3, [r3, #0]
  40212c:	491a      	ldr	r1, [pc, #104]	; (402198 <pio_handler_process+0xc8>)
  40212e:	68ba      	ldr	r2, [r7, #8]
  402130:	0112      	lsls	r2, r2, #4
  402132:	440a      	add	r2, r1
  402134:	6810      	ldr	r0, [r2, #0]
  402136:	4918      	ldr	r1, [pc, #96]	; (402198 <pio_handler_process+0xc8>)
  402138:	68ba      	ldr	r2, [r7, #8]
  40213a:	0112      	lsls	r2, r2, #4
  40213c:	440a      	add	r2, r1
  40213e:	3204      	adds	r2, #4
  402140:	6812      	ldr	r2, [r2, #0]
  402142:	4611      	mov	r1, r2
  402144:	4798      	blx	r3
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
  402146:	4a14      	ldr	r2, [pc, #80]	; (402198 <pio_handler_process+0xc8>)
  402148:	68bb      	ldr	r3, [r7, #8]
  40214a:	011b      	lsls	r3, r3, #4
  40214c:	4413      	add	r3, r2
  40214e:	3304      	adds	r3, #4
  402150:	681b      	ldr	r3, [r3, #0]
  402152:	43db      	mvns	r3, r3
  402154:	68fa      	ldr	r2, [r7, #12]
  402156:	4013      	ands	r3, r2
  402158:	60fb      	str	r3, [r7, #12]
				}
			}
			i++;
  40215a:	68bb      	ldr	r3, [r7, #8]
  40215c:	3301      	adds	r3, #1
  40215e:	60bb      	str	r3, [r7, #8]
			if (i >= MAX_INTERRUPT_SOURCES) {
  402160:	68bb      	ldr	r3, [r7, #8]
  402162:	2b06      	cmp	r3, #6
  402164:	d803      	bhi.n	40216e <pio_handler_process+0x9e>
		while (status != 0) {
  402166:	68fb      	ldr	r3, [r7, #12]
  402168:	2b00      	cmp	r3, #0
  40216a:	d1c7      	bne.n	4020fc <pio_handler_process+0x2c>
  40216c:	e000      	b.n	402170 <pio_handler_process+0xa0>
				break;
  40216e:	bf00      	nop
		}
	}

	/* Check capture events */
#if (SAM3S || SAM4S || SAM4E)
	if (pio_capture_enable_flag) {
  402170:	4b0a      	ldr	r3, [pc, #40]	; (40219c <pio_handler_process+0xcc>)
  402172:	681b      	ldr	r3, [r3, #0]
  402174:	2b00      	cmp	r3, #0
  402176:	d007      	beq.n	402188 <pio_handler_process+0xb8>
		if (pio_capture_handler) {
  402178:	4b09      	ldr	r3, [pc, #36]	; (4021a0 <pio_handler_process+0xd0>)
  40217a:	681b      	ldr	r3, [r3, #0]
  40217c:	2b00      	cmp	r3, #0
  40217e:	d003      	beq.n	402188 <pio_handler_process+0xb8>
			pio_capture_handler(p_pio);
  402180:	4b07      	ldr	r3, [pc, #28]	; (4021a0 <pio_handler_process+0xd0>)
  402182:	681b      	ldr	r3, [r3, #0]
  402184:	6878      	ldr	r0, [r7, #4]
  402186:	4798      	blx	r3
		}
	}
#endif
}
  402188:	bf00      	nop
  40218a:	3710      	adds	r7, #16
  40218c:	46bd      	mov	sp, r7
  40218e:	bd80      	pop	{r7, pc}
  402190:	004026c5 	.word	0x004026c5
  402194:	004026dd 	.word	0x004026dd
  402198:	2000a734 	.word	0x2000a734
  40219c:	2000a7b8 	.word	0x2000a7b8
  4021a0:	2000a7a4 	.word	0x2000a7a4

004021a4 <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
  4021a4:	b580      	push	{r7, lr}
  4021a6:	af00      	add	r7, sp, #0
	pio_handler_process(PIOA, ID_PIOA);
  4021a8:	2109      	movs	r1, #9
  4021aa:	4802      	ldr	r0, [pc, #8]	; (4021b4 <PIOA_Handler+0x10>)
  4021ac:	4b02      	ldr	r3, [pc, #8]	; (4021b8 <PIOA_Handler+0x14>)
  4021ae:	4798      	blx	r3
}
  4021b0:	bf00      	nop
  4021b2:	bd80      	pop	{r7, pc}
  4021b4:	400e0e00 	.word	0x400e0e00
  4021b8:	004020d1 	.word	0x004020d1

004021bc <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
  4021bc:	b580      	push	{r7, lr}
  4021be:	af00      	add	r7, sp, #0
    pio_handler_process(PIOB, ID_PIOB);
  4021c0:	210a      	movs	r1, #10
  4021c2:	4802      	ldr	r0, [pc, #8]	; (4021cc <PIOB_Handler+0x10>)
  4021c4:	4b02      	ldr	r3, [pc, #8]	; (4021d0 <PIOB_Handler+0x14>)
  4021c6:	4798      	blx	r3
}
  4021c8:	bf00      	nop
  4021ca:	bd80      	pop	{r7, pc}
  4021cc:	400e1000 	.word	0x400e1000
  4021d0:	004020d1 	.word	0x004020d1

004021d4 <PIOC_Handler>:
/**
 * \brief Parallel IO Controller C interrupt handler.
 * Redefined PIOC interrupt handler for NVIC interrupt table.
 */
void PIOC_Handler(void)
{
  4021d4:	b580      	push	{r7, lr}
  4021d6:	af00      	add	r7, sp, #0
	pio_handler_process(PIOC, ID_PIOC);
  4021d8:	210b      	movs	r1, #11
  4021da:	4802      	ldr	r0, [pc, #8]	; (4021e4 <PIOC_Handler+0x10>)
  4021dc:	4b02      	ldr	r3, [pc, #8]	; (4021e8 <PIOC_Handler+0x14>)
  4021de:	4798      	blx	r3
}
  4021e0:	bf00      	nop
  4021e2:	bd80      	pop	{r7, pc}
  4021e4:	400e1200 	.word	0x400e1200
  4021e8:	004020d1 	.word	0x004020d1

004021ec <PIOD_Handler>:
/**
 * \brief Parallel IO Controller D interrupt handler.
 * Redefined PIOD interrupt handler for NVIC interrupt table.
 */
void PIOD_Handler(void)
{
  4021ec:	b580      	push	{r7, lr}
  4021ee:	af00      	add	r7, sp, #0
	pio_handler_process(PIOD, ID_PIOD);
  4021f0:	210c      	movs	r1, #12
  4021f2:	4802      	ldr	r0, [pc, #8]	; (4021fc <PIOD_Handler+0x10>)
  4021f4:	4b02      	ldr	r3, [pc, #8]	; (402200 <PIOD_Handler+0x14>)
  4021f6:	4798      	blx	r3
}
  4021f8:	bf00      	nop
  4021fa:	bd80      	pop	{r7, pc}
  4021fc:	400e1400 	.word	0x400e1400
  402200:	004020d1 	.word	0x004020d1

00402204 <PIOE_Handler>:
/**
 * \brief Parallel IO Controller E interrupt handler.
 * Redefined PIOE interrupt handler for NVIC interrupt table.
 */
void PIOE_Handler(void)
{
  402204:	b580      	push	{r7, lr}
  402206:	af00      	add	r7, sp, #0
	pio_handler_process(PIOE, ID_PIOE);
  402208:	210d      	movs	r1, #13
  40220a:	4802      	ldr	r0, [pc, #8]	; (402214 <PIOE_Handler+0x10>)
  40220c:	4b02      	ldr	r3, [pc, #8]	; (402218 <PIOE_Handler+0x14>)
  40220e:	4798      	blx	r3
}
  402210:	bf00      	nop
  402212:	bd80      	pop	{r7, pc}
  402214:	400e1600 	.word	0x400e1600
  402218:	004020d1 	.word	0x004020d1

0040221c <can_set_baudrate>:
 *
 * \retval Set the baudrate successfully or not.
 */
static uint32_t can_set_baudrate(Can *p_can, uint32_t ul_mck,
		uint32_t ul_baudrate)
{
  40221c:	b580      	push	{r7, lr}
  40221e:	b08a      	sub	sp, #40	; 0x28
  402220:	af00      	add	r7, sp, #0
  402222:	60f8      	str	r0, [r7, #12]
  402224:	60b9      	str	r1, [r7, #8]
  402226:	607a      	str	r2, [r7, #4]
	uint32_t ul_cur_mod;
	can_bit_timing_t *p_bit_time;

	/* Check whether the baudrate prescale will be greater than the max
	 * divide value. */
	if (((ul_mck + (ul_baudrate * CAN_MAX_TQ_NUM * 1000 - 1)) /
  402228:	687b      	ldr	r3, [r7, #4]
  40222a:	f246 12a8 	movw	r2, #25000	; 0x61a8
  40222e:	fb02 f203 	mul.w	r2, r2, r3
  402232:	68bb      	ldr	r3, [r7, #8]
  402234:	4413      	add	r3, r2
  402236:	1e5a      	subs	r2, r3, #1
			(ul_baudrate * CAN_MAX_TQ_NUM * 1000)) >
  402238:	687b      	ldr	r3, [r7, #4]
  40223a:	f246 11a8 	movw	r1, #25000	; 0x61a8
  40223e:	fb01 f303 	mul.w	r3, r1, r3
	if (((ul_mck + (ul_baudrate * CAN_MAX_TQ_NUM * 1000 - 1)) /
  402242:	fbb2 f3f3 	udiv	r3, r2, r3
  402246:	2b80      	cmp	r3, #128	; 0x80
  402248:	d901      	bls.n	40224e <can_set_baudrate+0x32>
			CAN_BAUDRATE_MAX_DIV) {
		return 0;
  40224a:	2300      	movs	r3, #0
  40224c:	e086      	b.n	40235c <can_set_baudrate+0x140>
	}

	/* Check whether the input MCK is too small. */
	if ((ul_mck / 2)  < ul_baudrate * CAN_MIN_TQ_NUM * 1000) {
  40224e:	68bb      	ldr	r3, [r7, #8]
  402250:	085a      	lsrs	r2, r3, #1
  402252:	687b      	ldr	r3, [r7, #4]
  402254:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
  402258:	fb01 f303 	mul.w	r3, r1, r3
  40225c:	429a      	cmp	r2, r3
  40225e:	d201      	bcs.n	402264 <can_set_baudrate+0x48>
		return 0;
  402260:	2300      	movs	r3, #0
  402262:	e07b      	b.n	40235c <can_set_baudrate+0x140>
	}

	/* Initialize it as the minimum Time Quantum. */
	uc_tq = CAN_MIN_TQ_NUM;
  402264:	2308      	movs	r3, #8
  402266:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

	/* Initialize the remainder as the max value. When the remainder is 0,
	 *get the right TQ number. */
	ul_mod = 0xffffffff;
  40226a:	f04f 33ff 	mov.w	r3, #4294967295
  40226e:	623b      	str	r3, [r7, #32]
	/* Find out the approximate Time Quantum according to the baudrate. */
	for (uint8_t i = CAN_MIN_TQ_NUM; i <= CAN_MAX_TQ_NUM; i++) {
  402270:	2308      	movs	r3, #8
  402272:	77fb      	strb	r3, [r7, #31]
  402274:	e02a      	b.n	4022cc <can_set_baudrate+0xb0>
		if ((ul_mck / (ul_baudrate * i * 1000)) <=
  402276:	7ffb      	ldrb	r3, [r7, #31]
  402278:	687a      	ldr	r2, [r7, #4]
  40227a:	fb02 f303 	mul.w	r3, r2, r3
  40227e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  402282:	fb02 f303 	mul.w	r3, r2, r3
  402286:	68ba      	ldr	r2, [r7, #8]
  402288:	fbb2 f3f3 	udiv	r3, r2, r3
  40228c:	2b80      	cmp	r3, #128	; 0x80
  40228e:	d81a      	bhi.n	4022c6 <can_set_baudrate+0xaa>
				CAN_BAUDRATE_MAX_DIV) {
			ul_cur_mod = ul_mck % (ul_baudrate * i * 1000);
  402290:	7ffb      	ldrb	r3, [r7, #31]
  402292:	687a      	ldr	r2, [r7, #4]
  402294:	fb02 f303 	mul.w	r3, r2, r3
  402298:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  40229c:	fb02 f203 	mul.w	r2, r2, r3
  4022a0:	68bb      	ldr	r3, [r7, #8]
  4022a2:	fbb3 f1f2 	udiv	r1, r3, r2
  4022a6:	fb02 f201 	mul.w	r2, r2, r1
  4022aa:	1a9b      	subs	r3, r3, r2
  4022ac:	61bb      	str	r3, [r7, #24]
			if (ul_cur_mod < ul_mod) {
  4022ae:	69ba      	ldr	r2, [r7, #24]
  4022b0:	6a3b      	ldr	r3, [r7, #32]
  4022b2:	429a      	cmp	r2, r3
  4022b4:	d207      	bcs.n	4022c6 <can_set_baudrate+0xaa>
				ul_mod = ul_cur_mod;
  4022b6:	69bb      	ldr	r3, [r7, #24]
  4022b8:	623b      	str	r3, [r7, #32]
				uc_tq = i;
  4022ba:	7ffb      	ldrb	r3, [r7, #31]
  4022bc:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
				if (!ul_mod) {
  4022c0:	6a3b      	ldr	r3, [r7, #32]
  4022c2:	2b00      	cmp	r3, #0
  4022c4:	d006      	beq.n	4022d4 <can_set_baudrate+0xb8>
	for (uint8_t i = CAN_MIN_TQ_NUM; i <= CAN_MAX_TQ_NUM; i++) {
  4022c6:	7ffb      	ldrb	r3, [r7, #31]
  4022c8:	3301      	adds	r3, #1
  4022ca:	77fb      	strb	r3, [r7, #31]
  4022cc:	7ffb      	ldrb	r3, [r7, #31]
  4022ce:	2b19      	cmp	r3, #25
  4022d0:	d9d1      	bls.n	402276 <can_set_baudrate+0x5a>
  4022d2:	e000      	b.n	4022d6 <can_set_baudrate+0xba>
					break;
  4022d4:	bf00      	nop
			}
		}
	}

	/* Calculate the baudrate prescale value. */
	uc_prescale = ul_mck / (ul_baudrate * uc_tq * 1000);
  4022d6:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  4022da:	687a      	ldr	r2, [r7, #4]
  4022dc:	fb02 f303 	mul.w	r3, r2, r3
  4022e0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  4022e4:	fb02 f303 	mul.w	r3, r2, r3
  4022e8:	68ba      	ldr	r2, [r7, #8]
  4022ea:	fbb2 f3f3 	udiv	r3, r2, r3
  4022ee:	75fb      	strb	r3, [r7, #23]
	if (uc_prescale < 2) {
  4022f0:	7dfb      	ldrb	r3, [r7, #23]
  4022f2:	2b01      	cmp	r3, #1
  4022f4:	d801      	bhi.n	4022fa <can_set_baudrate+0xde>
		return 0;
  4022f6:	2300      	movs	r3, #0
  4022f8:	e030      	b.n	40235c <can_set_baudrate+0x140>
	}

	/* Get the right CAN BIT Timing group. */
	p_bit_time = (can_bit_timing_t *)&can_bit_time[uc_tq - CAN_MIN_TQ_NUM];
  4022fa:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
  4022fe:	f1a3 0208 	sub.w	r2, r3, #8
  402302:	4613      	mov	r3, r2
  402304:	005b      	lsls	r3, r3, #1
  402306:	4413      	add	r3, r2
  402308:	005b      	lsls	r3, r3, #1
  40230a:	4a16      	ldr	r2, [pc, #88]	; (402364 <can_set_baudrate+0x148>)
  40230c:	4413      	add	r3, r2
  40230e:	613b      	str	r3, [r7, #16]

	/* Before modifying the CANBR register, disable the CAN controller. */
	can_disable(p_can);
  402310:	68f8      	ldr	r0, [r7, #12]
  402312:	4b15      	ldr	r3, [pc, #84]	; (402368 <can_set_baudrate+0x14c>)
  402314:	4798      	blx	r3

	/* Write into the CAN baudrate register. */
	p_can->CAN_BR = CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
  402316:	693b      	ldr	r3, [r7, #16]
  402318:	78db      	ldrb	r3, [r3, #3]
  40231a:	3b01      	subs	r3, #1
  40231c:	f003 0207 	and.w	r2, r3, #7
			CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
  402320:	693b      	ldr	r3, [r7, #16]
  402322:	789b      	ldrb	r3, [r3, #2]
  402324:	3b01      	subs	r3, #1
  402326:	011b      	lsls	r3, r3, #4
  402328:	f003 0370 	and.w	r3, r3, #112	; 0x70
	p_can->CAN_BR = CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
  40232c:	431a      	orrs	r2, r3
			CAN_BR_PROPAG(p_bit_time->uc_prog - 1) |
  40232e:	693b      	ldr	r3, [r7, #16]
  402330:	785b      	ldrb	r3, [r3, #1]
  402332:	3b01      	subs	r3, #1
  402334:	021b      	lsls	r3, r3, #8
  402336:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
			CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
  40233a:	431a      	orrs	r2, r3
			CAN_BR_SJW(p_bit_time->uc_sjw - 1) |
  40233c:	693b      	ldr	r3, [r7, #16]
  40233e:	791b      	ldrb	r3, [r3, #4]
  402340:	3b01      	subs	r3, #1
  402342:	031b      	lsls	r3, r3, #12
  402344:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
			CAN_BR_PROPAG(p_bit_time->uc_prog - 1) |
  402348:	431a      	orrs	r2, r3
			CAN_BR_BRP(uc_prescale - 1);
  40234a:	7dfb      	ldrb	r3, [r7, #23]
  40234c:	3b01      	subs	r3, #1
  40234e:	041b      	lsls	r3, r3, #16
  402350:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000
			CAN_BR_SJW(p_bit_time->uc_sjw - 1) |
  402354:	431a      	orrs	r2, r3
	p_can->CAN_BR = CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
  402356:	68fb      	ldr	r3, [r7, #12]
  402358:	615a      	str	r2, [r3, #20]
	return 1;
  40235a:	2301      	movs	r3, #1
}
  40235c:	4618      	mov	r0, r3
  40235e:	3728      	adds	r7, #40	; 0x28
  402360:	46bd      	mov	sp, r7
  402362:	bd80      	pop	{r7, pc}
  402364:	0040390c 	.word	0x0040390c
  402368:	00402415 	.word	0x00402415

0040236c <can_init>:
 *
 * \note PMC clock for CAN peripheral should be enabled before calling this
 *function.
 */
uint32_t can_init(Can *p_can, uint32_t ul_mck, uint32_t ul_baudrate)
{
  40236c:	b580      	push	{r7, lr}
  40236e:	b086      	sub	sp, #24
  402370:	af00      	add	r7, sp, #0
  402372:	60f8      	str	r0, [r7, #12]
  402374:	60b9      	str	r1, [r7, #8]
  402376:	607a      	str	r2, [r7, #4]
	uint32_t ul_flag;
	uint32_t ul_tick;

	/* Initialize the baudrate for CAN module. */
	ul_flag = can_set_baudrate(p_can, ul_mck, ul_baudrate);
  402378:	687a      	ldr	r2, [r7, #4]
  40237a:	68b9      	ldr	r1, [r7, #8]
  40237c:	68f8      	ldr	r0, [r7, #12]
  40237e:	4b17      	ldr	r3, [pc, #92]	; (4023dc <can_init+0x70>)
  402380:	4798      	blx	r3
  402382:	6178      	str	r0, [r7, #20]
	if (ul_flag == 0) {
  402384:	697b      	ldr	r3, [r7, #20]
  402386:	2b00      	cmp	r3, #0
  402388:	d101      	bne.n	40238e <can_init+0x22>
		return 0;
  40238a:	2300      	movs	r3, #0
  40238c:	e021      	b.n	4023d2 <can_init+0x66>
	}

	/* Reset the CAN eight message mailbox. */
	can_reset_all_mailbox(p_can);
  40238e:	68f8      	ldr	r0, [r7, #12]
  402390:	4b13      	ldr	r3, [pc, #76]	; (4023e0 <can_init+0x74>)
  402392:	4798      	blx	r3

	/* Enable the CAN controller. */
	can_enable(p_can);
  402394:	68f8      	ldr	r0, [r7, #12]
  402396:	4b13      	ldr	r3, [pc, #76]	; (4023e4 <can_init+0x78>)
  402398:	4798      	blx	r3

	/* Wait until the CAN is synchronized with the bus activity. */
	ul_flag = 0;
  40239a:	2300      	movs	r3, #0
  40239c:	617b      	str	r3, [r7, #20]
	ul_tick = 0;
  40239e:	2300      	movs	r3, #0
  4023a0:	613b      	str	r3, [r7, #16]
	while (!(ul_flag & CAN_SR_WAKEUP) && (ul_tick < CAN_TIMEOUT)) {
  4023a2:	e006      	b.n	4023b2 <can_init+0x46>
		ul_flag = can_get_status(p_can);
  4023a4:	68f8      	ldr	r0, [r7, #12]
  4023a6:	4b10      	ldr	r3, [pc, #64]	; (4023e8 <can_init+0x7c>)
  4023a8:	4798      	blx	r3
  4023aa:	6178      	str	r0, [r7, #20]
		ul_tick++;
  4023ac:	693b      	ldr	r3, [r7, #16]
  4023ae:	3301      	adds	r3, #1
  4023b0:	613b      	str	r3, [r7, #16]
	while (!(ul_flag & CAN_SR_WAKEUP) && (ul_tick < CAN_TIMEOUT)) {
  4023b2:	697b      	ldr	r3, [r7, #20]
  4023b4:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
  4023b8:	2b00      	cmp	r3, #0
  4023ba:	d103      	bne.n	4023c4 <can_init+0x58>
  4023bc:	693b      	ldr	r3, [r7, #16]
  4023be:	4a0b      	ldr	r2, [pc, #44]	; (4023ec <can_init+0x80>)
  4023c0:	4293      	cmp	r3, r2
  4023c2:	d9ef      	bls.n	4023a4 <can_init+0x38>
	}

	/* Timeout or the CAN module has been synchronized with the bus. */
	if (CAN_TIMEOUT == ul_tick) {
  4023c4:	693b      	ldr	r3, [r7, #16]
  4023c6:	4a0a      	ldr	r2, [pc, #40]	; (4023f0 <can_init+0x84>)
  4023c8:	4293      	cmp	r3, r2
  4023ca:	d101      	bne.n	4023d0 <can_init+0x64>
		return 0;
  4023cc:	2300      	movs	r3, #0
  4023ce:	e000      	b.n	4023d2 <can_init+0x66>
	} else {
		return 1;
  4023d0:	2301      	movs	r3, #1
	}
}
  4023d2:	4618      	mov	r0, r3
  4023d4:	3718      	adds	r7, #24
  4023d6:	46bd      	mov	sp, r7
  4023d8:	bd80      	pop	{r7, pc}
  4023da:	bf00      	nop
  4023dc:	0040221d 	.word	0x0040221d
  4023e0:	00402571 	.word	0x00402571
  4023e4:	004023f5 	.word	0x004023f5
  4023e8:	00402435 	.word	0x00402435
  4023ec:	0001869f 	.word	0x0001869f
  4023f0:	000186a0 	.word	0x000186a0

004023f4 <can_enable>:
 * \brief Enable CAN Controller.
 *
 * \param p_can  Pointer to a CAN peripheral instance.
 */
void can_enable(Can *p_can)
{
  4023f4:	b480      	push	{r7}
  4023f6:	b083      	sub	sp, #12
  4023f8:	af00      	add	r7, sp, #0
  4023fa:	6078      	str	r0, [r7, #4]
	p_can->CAN_MR |= CAN_MR_CANEN;
  4023fc:	687b      	ldr	r3, [r7, #4]
  4023fe:	681b      	ldr	r3, [r3, #0]
  402400:	f043 0201 	orr.w	r2, r3, #1
  402404:	687b      	ldr	r3, [r7, #4]
  402406:	601a      	str	r2, [r3, #0]
}
  402408:	bf00      	nop
  40240a:	370c      	adds	r7, #12
  40240c:	46bd      	mov	sp, r7
  40240e:	f85d 7b04 	ldr.w	r7, [sp], #4
  402412:	4770      	bx	lr

00402414 <can_disable>:
 * \brief Disable CAN Controller.
 *
 * \param p_can  Pointer to a CAN peripheral instance.
 */
void can_disable(Can *p_can)
{
  402414:	b480      	push	{r7}
  402416:	b083      	sub	sp, #12
  402418:	af00      	add	r7, sp, #0
  40241a:	6078      	str	r0, [r7, #4]
	p_can->CAN_MR &= ~CAN_MR_CANEN;
  40241c:	687b      	ldr	r3, [r7, #4]
  40241e:	681b      	ldr	r3, [r3, #0]
  402420:	f023 0201 	bic.w	r2, r3, #1
  402424:	687b      	ldr	r3, [r7, #4]
  402426:	601a      	str	r2, [r3, #0]
}
  402428:	bf00      	nop
  40242a:	370c      	adds	r7, #12
  40242c:	46bd      	mov	sp, r7
  40242e:	f85d 7b04 	ldr.w	r7, [sp], #4
  402432:	4770      	bx	lr

00402434 <can_get_status>:
 * \param p_can Pointer to a CAN peripheral instance.
 *
 * \retval CAN status.
 */
uint32_t can_get_status(Can *p_can)
{
  402434:	b480      	push	{r7}
  402436:	b083      	sub	sp, #12
  402438:	af00      	add	r7, sp, #0
  40243a:	6078      	str	r0, [r7, #4]
	return (p_can->CAN_SR);
  40243c:	687b      	ldr	r3, [r7, #4]
  40243e:	691b      	ldr	r3, [r3, #16]
}
  402440:	4618      	mov	r0, r3
  402442:	370c      	adds	r7, #12
  402444:	46bd      	mov	sp, r7
  402446:	f85d 7b04 	ldr.w	r7, [sp], #4
  40244a:	4770      	bx	lr

0040244c <can_mailbox_init>:
 *
 * \param p_can    Pointer to a CAN peripheral instance.
 * \param p_mailbox Pointer to a CAN mailbox instance.
 */
void can_mailbox_init(Can *p_can, can_mb_conf_t *p_mailbox)
{
  40244c:	b480      	push	{r7}
  40244e:	b085      	sub	sp, #20
  402450:	af00      	add	r7, sp, #0
  402452:	6078      	str	r0, [r7, #4]
  402454:	6039      	str	r1, [r7, #0]
	uint8_t uc_index;

	uc_index = (uint8_t)p_mailbox->ul_mb_idx;
  402456:	683b      	ldr	r3, [r7, #0]
  402458:	681b      	ldr	r3, [r3, #0]
  40245a:	73fb      	strb	r3, [r7, #15]
	/* Check the object type of the mailbox. If it's used to disable the
	 * mailbox, reset the whole mailbox. */
	if (!p_mailbox->uc_obj_type) {
  40245c:	683b      	ldr	r3, [r7, #0]
  40245e:	791b      	ldrb	r3, [r3, #4]
  402460:	2b00      	cmp	r3, #0
  402462:	d12f      	bne.n	4024c4 <can_mailbox_init+0x78>
		p_can->CAN_MB[uc_index].CAN_MMR = 0;
  402464:	7bfb      	ldrb	r3, [r7, #15]
  402466:	687a      	ldr	r2, [r7, #4]
  402468:	3310      	adds	r3, #16
  40246a:	015b      	lsls	r3, r3, #5
  40246c:	4413      	add	r3, r2
  40246e:	2200      	movs	r2, #0
  402470:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MAM = 0;
  402472:	7bfb      	ldrb	r3, [r7, #15]
  402474:	687a      	ldr	r2, [r7, #4]
  402476:	3310      	adds	r3, #16
  402478:	015b      	lsls	r3, r3, #5
  40247a:	4413      	add	r3, r2
  40247c:	3304      	adds	r3, #4
  40247e:	2200      	movs	r2, #0
  402480:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MID = 0;
  402482:	7bfb      	ldrb	r3, [r7, #15]
  402484:	687a      	ldr	r2, [r7, #4]
  402486:	015b      	lsls	r3, r3, #5
  402488:	4413      	add	r3, r2
  40248a:	f503 7302 	add.w	r3, r3, #520	; 0x208
  40248e:	2200      	movs	r2, #0
  402490:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MDL = 0;
  402492:	7bfb      	ldrb	r3, [r7, #15]
  402494:	687a      	ldr	r2, [r7, #4]
  402496:	015b      	lsls	r3, r3, #5
  402498:	4413      	add	r3, r2
  40249a:	f503 7305 	add.w	r3, r3, #532	; 0x214
  40249e:	2200      	movs	r2, #0
  4024a0:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MDH = 0;
  4024a2:	7bfb      	ldrb	r3, [r7, #15]
  4024a4:	687a      	ldr	r2, [r7, #4]
  4024a6:	015b      	lsls	r3, r3, #5
  4024a8:	4413      	add	r3, r2
  4024aa:	f503 7306 	add.w	r3, r3, #536	; 0x218
  4024ae:	2200      	movs	r2, #0
  4024b0:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MCR = 0;
  4024b2:	7bfb      	ldrb	r3, [r7, #15]
  4024b4:	687a      	ldr	r2, [r7, #4]
  4024b6:	015b      	lsls	r3, r3, #5
  4024b8:	4413      	add	r3, r2
  4024ba:	f503 7307 	add.w	r3, r3, #540	; 0x21c
  4024be:	2200      	movs	r2, #0
  4024c0:	601a      	str	r2, [r3, #0]
		return;
  4024c2:	e050      	b.n	402566 <can_mailbox_init+0x11a>
	}

	/* Set the priority in Transmit mode. */
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  4024c4:	7bfb      	ldrb	r3, [r7, #15]
  4024c6:	7bfa      	ldrb	r2, [r7, #15]
  4024c8:	6879      	ldr	r1, [r7, #4]
  4024ca:	3210      	adds	r2, #16
  4024cc:	0152      	lsls	r2, r2, #5
  4024ce:	440a      	add	r2, r1
  4024d0:	6812      	ldr	r2, [r2, #0]
  4024d2:	f422 2270 	bic.w	r2, r2, #983040	; 0xf0000
			~CAN_MMR_PRIOR_Msk) |
			(p_mailbox->uc_tx_prio << CAN_MMR_PRIOR_Pos);
  4024d6:	6839      	ldr	r1, [r7, #0]
  4024d8:	79c9      	ldrb	r1, [r1, #7]
  4024da:	0409      	lsls	r1, r1, #16
			~CAN_MMR_PRIOR_Msk) |
  4024dc:	430a      	orrs	r2, r1
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  4024de:	6879      	ldr	r1, [r7, #4]
  4024e0:	3310      	adds	r3, #16
  4024e2:	015b      	lsls	r3, r3, #5
  4024e4:	440b      	add	r3, r1
  4024e6:	601a      	str	r2, [r3, #0]

	/* Set the message ID and message acceptance mask for the mailbox in
	 * other modes. */
	if (p_mailbox->uc_id_ver) {
  4024e8:	683b      	ldr	r3, [r7, #0]
  4024ea:	795b      	ldrb	r3, [r3, #5]
  4024ec:	2b00      	cmp	r3, #0
  4024ee:	d016      	beq.n	40251e <can_mailbox_init+0xd2>
		p_can->CAN_MB[uc_index].CAN_MAM = p_mailbox->ul_id_msk |
  4024f0:	7bfb      	ldrb	r3, [r7, #15]
  4024f2:	683a      	ldr	r2, [r7, #0]
  4024f4:	68d2      	ldr	r2, [r2, #12]
  4024f6:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
  4024fa:	6879      	ldr	r1, [r7, #4]
  4024fc:	3310      	adds	r3, #16
  4024fe:	015b      	lsls	r3, r3, #5
  402500:	440b      	add	r3, r1
  402502:	3304      	adds	r3, #4
  402504:	601a      	str	r2, [r3, #0]
				CAN_MAM_MIDE;
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id |
  402506:	7bfb      	ldrb	r3, [r7, #15]
  402508:	683a      	ldr	r2, [r7, #0]
  40250a:	6912      	ldr	r2, [r2, #16]
  40250c:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
  402510:	6879      	ldr	r1, [r7, #4]
  402512:	015b      	lsls	r3, r3, #5
  402514:	440b      	add	r3, r1
  402516:	f503 7302 	add.w	r3, r3, #520	; 0x208
  40251a:	601a      	str	r2, [r3, #0]
  40251c:	e011      	b.n	402542 <can_mailbox_init+0xf6>
				CAN_MAM_MIDE;
	} else {
		p_can->CAN_MB[uc_index].CAN_MAM = p_mailbox->ul_id_msk;
  40251e:	7bfb      	ldrb	r3, [r7, #15]
  402520:	683a      	ldr	r2, [r7, #0]
  402522:	68d2      	ldr	r2, [r2, #12]
  402524:	6879      	ldr	r1, [r7, #4]
  402526:	3310      	adds	r3, #16
  402528:	015b      	lsls	r3, r3, #5
  40252a:	440b      	add	r3, r1
  40252c:	3304      	adds	r3, #4
  40252e:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id;
  402530:	7bfb      	ldrb	r3, [r7, #15]
  402532:	683a      	ldr	r2, [r7, #0]
  402534:	6912      	ldr	r2, [r2, #16]
  402536:	6879      	ldr	r1, [r7, #4]
  402538:	015b      	lsls	r3, r3, #5
  40253a:	440b      	add	r3, r1
  40253c:	f503 7302 	add.w	r3, r3, #520	; 0x208
  402540:	601a      	str	r2, [r3, #0]
	}

	/* Set up mailbox in one of the five different modes. */
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  402542:	7bfb      	ldrb	r3, [r7, #15]
  402544:	7bfa      	ldrb	r2, [r7, #15]
  402546:	6879      	ldr	r1, [r7, #4]
  402548:	3210      	adds	r2, #16
  40254a:	0152      	lsls	r2, r2, #5
  40254c:	440a      	add	r2, r1
  40254e:	6812      	ldr	r2, [r2, #0]
  402550:	f022 62e0 	bic.w	r2, r2, #117440512	; 0x7000000
			~CAN_MMR_MOT_Msk) |
			(p_mailbox->uc_obj_type << CAN_MMR_MOT_Pos);
  402554:	6839      	ldr	r1, [r7, #0]
  402556:	7909      	ldrb	r1, [r1, #4]
  402558:	0609      	lsls	r1, r1, #24
			~CAN_MMR_MOT_Msk) |
  40255a:	430a      	orrs	r2, r1
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
  40255c:	6879      	ldr	r1, [r7, #4]
  40255e:	3310      	adds	r3, #16
  402560:	015b      	lsls	r3, r3, #5
  402562:	440b      	add	r3, r1
  402564:	601a      	str	r2, [r3, #0]
}
  402566:	3714      	adds	r7, #20
  402568:	46bd      	mov	sp, r7
  40256a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40256e:	4770      	bx	lr

00402570 <can_reset_all_mailbox>:
 * \brief Reset the eight mailboxes.
 *
 * \param p_can Pointer to a CAN peripheral instance.
 */
void can_reset_all_mailbox(Can *p_can)
{
  402570:	b580      	push	{r7, lr}
  402572:	b08c      	sub	sp, #48	; 0x30
  402574:	af00      	add	r7, sp, #0
  402576:	6078      	str	r0, [r7, #4]
	can_mb_conf_t mb_config_t;

	/* Set the mailbox object type parameter to disable the mailbox. */
	mb_config_t.uc_obj_type = CAN_MB_DISABLE_MODE;
  402578:	2300      	movs	r3, #0
  40257a:	743b      	strb	r3, [r7, #16]

	for (uint8_t i = 0; i < CANMB_NUMBER; i++) {
  40257c:	2300      	movs	r3, #0
  40257e:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  402582:	e00d      	b.n	4025a0 <can_reset_all_mailbox+0x30>
		mb_config_t.ul_mb_idx = i;
  402584:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  402588:	60fb      	str	r3, [r7, #12]
		can_mailbox_init(p_can, &mb_config_t);
  40258a:	f107 030c 	add.w	r3, r7, #12
  40258e:	4619      	mov	r1, r3
  402590:	6878      	ldr	r0, [r7, #4]
  402592:	4b07      	ldr	r3, [pc, #28]	; (4025b0 <can_reset_all_mailbox+0x40>)
  402594:	4798      	blx	r3
	for (uint8_t i = 0; i < CANMB_NUMBER; i++) {
  402596:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  40259a:	3301      	adds	r3, #1
  40259c:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
  4025a0:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
  4025a4:	2b07      	cmp	r3, #7
  4025a6:	d9ed      	bls.n	402584 <can_reset_all_mailbox+0x14>
	}
}
  4025a8:	bf00      	nop
  4025aa:	3730      	adds	r7, #48	; 0x30
  4025ac:	46bd      	mov	sp, r7
  4025ae:	bd80      	pop	{r7, pc}
  4025b0:	0040244d 	.word	0x0040244d

004025b4 <pio_set_peripheral>:
 * \param ul_type PIO type.
 * \param ul_mask Bitmask of one or more pin(s) to configure.
 */
void pio_set_peripheral(Pio *p_pio, const pio_type_t ul_type,
		const uint32_t ul_mask)
{
  4025b4:	b480      	push	{r7}
  4025b6:	b087      	sub	sp, #28
  4025b8:	af00      	add	r7, sp, #0
  4025ba:	60f8      	str	r0, [r7, #12]
  4025bc:	60b9      	str	r1, [r7, #8]
  4025be:	607a      	str	r2, [r7, #4]
	uint32_t ul_sr;

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;
  4025c0:	68fb      	ldr	r3, [r7, #12]
  4025c2:	687a      	ldr	r2, [r7, #4]
  4025c4:	645a      	str	r2, [r3, #68]	; 0x44

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  4025c6:	68bb      	ldr	r3, [r7, #8]
  4025c8:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
  4025cc:	d04a      	beq.n	402664 <pio_set_peripheral+0xb0>
  4025ce:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
  4025d2:	d808      	bhi.n	4025e6 <pio_set_peripheral+0x32>
  4025d4:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
  4025d8:	d016      	beq.n	402608 <pio_set_peripheral+0x54>
  4025da:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  4025de:	d02c      	beq.n	40263a <pio_set_peripheral+0x86>
  4025e0:	2b00      	cmp	r3, #0
  4025e2:	d069      	beq.n	4026b8 <pio_set_peripheral+0x104>
  4025e4:	e064      	b.n	4026b0 <pio_set_peripheral+0xfc>
  4025e6:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  4025ea:	d065      	beq.n	4026b8 <pio_set_peripheral+0x104>
  4025ec:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  4025f0:	d803      	bhi.n	4025fa <pio_set_peripheral+0x46>
  4025f2:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
  4025f6:	d04a      	beq.n	40268e <pio_set_peripheral+0xda>
  4025f8:	e05a      	b.n	4026b0 <pio_set_peripheral+0xfc>
  4025fa:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
  4025fe:	d05b      	beq.n	4026b8 <pio_set_peripheral+0x104>
  402600:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  402604:	d058      	beq.n	4026b8 <pio_set_peripheral+0x104>
  402606:	e053      	b.n	4026b0 <pio_set_peripheral+0xfc>
	case PIO_PERIPH_A:
		ul_sr = p_pio->PIO_ABCDSR[0];
  402608:	68fb      	ldr	r3, [r7, #12]
  40260a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  40260c:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  40260e:	68fb      	ldr	r3, [r7, #12]
  402610:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  402612:	687b      	ldr	r3, [r7, #4]
  402614:	43d9      	mvns	r1, r3
  402616:	697b      	ldr	r3, [r7, #20]
  402618:	400b      	ands	r3, r1
  40261a:	401a      	ands	r2, r3
  40261c:	68fb      	ldr	r3, [r7, #12]
  40261e:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  402620:	68fb      	ldr	r3, [r7, #12]
  402622:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  402624:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  402626:	68fb      	ldr	r3, [r7, #12]
  402628:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  40262a:	687b      	ldr	r3, [r7, #4]
  40262c:	43d9      	mvns	r1, r3
  40262e:	697b      	ldr	r3, [r7, #20]
  402630:	400b      	ands	r3, r1
  402632:	401a      	ands	r2, r3
  402634:	68fb      	ldr	r3, [r7, #12]
  402636:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  402638:	e03a      	b.n	4026b0 <pio_set_peripheral+0xfc>
	case PIO_PERIPH_B:
		ul_sr = p_pio->PIO_ABCDSR[0];
  40263a:	68fb      	ldr	r3, [r7, #12]
  40263c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  40263e:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  402640:	687a      	ldr	r2, [r7, #4]
  402642:	697b      	ldr	r3, [r7, #20]
  402644:	431a      	orrs	r2, r3
  402646:	68fb      	ldr	r3, [r7, #12]
  402648:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  40264a:	68fb      	ldr	r3, [r7, #12]
  40264c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  40264e:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  402650:	68fb      	ldr	r3, [r7, #12]
  402652:	6f5a      	ldr	r2, [r3, #116]	; 0x74
  402654:	687b      	ldr	r3, [r7, #4]
  402656:	43d9      	mvns	r1, r3
  402658:	697b      	ldr	r3, [r7, #20]
  40265a:	400b      	ands	r3, r1
  40265c:	401a      	ands	r2, r3
  40265e:	68fb      	ldr	r3, [r7, #12]
  402660:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  402662:	e025      	b.n	4026b0 <pio_set_peripheral+0xfc>
#if (!SAMG)
	case PIO_PERIPH_C:
		ul_sr = p_pio->PIO_ABCDSR[0];
  402664:	68fb      	ldr	r3, [r7, #12]
  402666:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  402668:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  40266a:	68fb      	ldr	r3, [r7, #12]
  40266c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  40266e:	687b      	ldr	r3, [r7, #4]
  402670:	43d9      	mvns	r1, r3
  402672:	697b      	ldr	r3, [r7, #20]
  402674:	400b      	ands	r3, r1
  402676:	401a      	ands	r2, r3
  402678:	68fb      	ldr	r3, [r7, #12]
  40267a:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  40267c:	68fb      	ldr	r3, [r7, #12]
  40267e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  402680:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  402682:	687a      	ldr	r2, [r7, #4]
  402684:	697b      	ldr	r3, [r7, #20]
  402686:	431a      	orrs	r2, r3
  402688:	68fb      	ldr	r3, [r7, #12]
  40268a:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  40268c:	e010      	b.n	4026b0 <pio_set_peripheral+0xfc>
	case PIO_PERIPH_D:
		ul_sr = p_pio->PIO_ABCDSR[0];
  40268e:	68fb      	ldr	r3, [r7, #12]
  402690:	6f1b      	ldr	r3, [r3, #112]	; 0x70
  402692:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  402694:	687a      	ldr	r2, [r7, #4]
  402696:	697b      	ldr	r3, [r7, #20]
  402698:	431a      	orrs	r2, r3
  40269a:	68fb      	ldr	r3, [r7, #12]
  40269c:	671a      	str	r2, [r3, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  40269e:	68fb      	ldr	r3, [r7, #12]
  4026a0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
  4026a2:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  4026a4:	687a      	ldr	r2, [r7, #4]
  4026a6:	697b      	ldr	r3, [r7, #20]
  4026a8:	431a      	orrs	r2, r3
  4026aa:	68fb      	ldr	r3, [r7, #12]
  4026ac:	675a      	str	r2, [r3, #116]	; 0x74
		break;
  4026ae:	bf00      	nop
#else
#error "Unsupported device"
#endif

	/* Remove the pins from under the control of PIO */
	p_pio->PIO_PDR = ul_mask;
  4026b0:	68fb      	ldr	r3, [r7, #12]
  4026b2:	687a      	ldr	r2, [r7, #4]
  4026b4:	605a      	str	r2, [r3, #4]
  4026b6:	e000      	b.n	4026ba <pio_set_peripheral+0x106>
		return;
  4026b8:	bf00      	nop
}
  4026ba:	371c      	adds	r7, #28
  4026bc:	46bd      	mov	sp, r7
  4026be:	f85d 7b04 	ldr.w	r7, [sp], #4
  4026c2:	4770      	bx	lr

004026c4 <pio_get_interrupt_status>:
 * \param p_pio Pointer to a PIO instance.
 *
 * \return The interrupt status value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
  4026c4:	b480      	push	{r7}
  4026c6:	b083      	sub	sp, #12
  4026c8:	af00      	add	r7, sp, #0
  4026ca:	6078      	str	r0, [r7, #4]
	return p_pio->PIO_ISR;
  4026cc:	687b      	ldr	r3, [r7, #4]
  4026ce:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
}
  4026d0:	4618      	mov	r0, r3
  4026d2:	370c      	adds	r7, #12
  4026d4:	46bd      	mov	sp, r7
  4026d6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4026da:	4770      	bx	lr

004026dc <pio_get_interrupt_mask>:
 * \param p_pio Pointer to a PIO instance.
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
  4026dc:	b480      	push	{r7}
  4026de:	b083      	sub	sp, #12
  4026e0:	af00      	add	r7, sp, #0
  4026e2:	6078      	str	r0, [r7, #4]
	return p_pio->PIO_IMR;
  4026e4:	687b      	ldr	r3, [r7, #4]
  4026e6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
}
  4026e8:	4618      	mov	r0, r3
  4026ea:	370c      	adds	r7, #12
  4026ec:	46bd      	mov	sp, r7
  4026ee:	f85d 7b04 	ldr.w	r7, [sp], #4
  4026f2:	4770      	bx	lr

004026f4 <pmc_switch_mck_to_pllack>:
 *
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
  4026f4:	b480      	push	{r7}
  4026f6:	b085      	sub	sp, #20
  4026f8:	af00      	add	r7, sp, #0
  4026fa:	6078      	str	r0, [r7, #4]
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  4026fc:	491d      	ldr	r1, [pc, #116]	; (402774 <pmc_switch_mck_to_pllack+0x80>)
  4026fe:	4b1d      	ldr	r3, [pc, #116]	; (402774 <pmc_switch_mck_to_pllack+0x80>)
  402700:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  402702:	f023 0270 	bic.w	r2, r3, #112	; 0x70
  402706:	687b      	ldr	r3, [r7, #4]
  402708:	4313      	orrs	r3, r2
  40270a:	630b      	str	r3, [r1, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40270c:	f44f 6300 	mov.w	r3, #2048	; 0x800
  402710:	60fb      	str	r3, [r7, #12]
  402712:	e007      	b.n	402724 <pmc_switch_mck_to_pllack+0x30>
			--ul_timeout) {
		if (ul_timeout == 0) {
  402714:	68fb      	ldr	r3, [r7, #12]
  402716:	2b00      	cmp	r3, #0
  402718:	d101      	bne.n	40271e <pmc_switch_mck_to_pllack+0x2a>
			return 1;
  40271a:	2301      	movs	r3, #1
  40271c:	e023      	b.n	402766 <pmc_switch_mck_to_pllack+0x72>
			--ul_timeout) {
  40271e:	68fb      	ldr	r3, [r7, #12]
  402720:	3b01      	subs	r3, #1
  402722:	60fb      	str	r3, [r7, #12]
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  402724:	4b13      	ldr	r3, [pc, #76]	; (402774 <pmc_switch_mck_to_pllack+0x80>)
  402726:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  402728:	f003 0308 	and.w	r3, r3, #8
  40272c:	2b00      	cmp	r3, #0
  40272e:	d0f1      	beq.n	402714 <pmc_switch_mck_to_pllack+0x20>
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  402730:	4a10      	ldr	r2, [pc, #64]	; (402774 <pmc_switch_mck_to_pllack+0x80>)
  402732:	4b10      	ldr	r3, [pc, #64]	; (402774 <pmc_switch_mck_to_pllack+0x80>)
  402734:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  402736:	f023 0303 	bic.w	r3, r3, #3
  40273a:	f043 0302 	orr.w	r3, r3, #2
  40273e:	6313      	str	r3, [r2, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  402740:	f44f 6300 	mov.w	r3, #2048	; 0x800
  402744:	60fb      	str	r3, [r7, #12]
  402746:	e007      	b.n	402758 <pmc_switch_mck_to_pllack+0x64>
			--ul_timeout) {
		if (ul_timeout == 0) {
  402748:	68fb      	ldr	r3, [r7, #12]
  40274a:	2b00      	cmp	r3, #0
  40274c:	d101      	bne.n	402752 <pmc_switch_mck_to_pllack+0x5e>
			return 1;
  40274e:	2301      	movs	r3, #1
  402750:	e009      	b.n	402766 <pmc_switch_mck_to_pllack+0x72>
			--ul_timeout) {
  402752:	68fb      	ldr	r3, [r7, #12]
  402754:	3b01      	subs	r3, #1
  402756:	60fb      	str	r3, [r7, #12]
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  402758:	4b06      	ldr	r3, [pc, #24]	; (402774 <pmc_switch_mck_to_pllack+0x80>)
  40275a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  40275c:	f003 0308 	and.w	r3, r3, #8
  402760:	2b00      	cmp	r3, #0
  402762:	d0f1      	beq.n	402748 <pmc_switch_mck_to_pllack+0x54>
		}
	}

	return 0;
  402764:	2300      	movs	r3, #0
}
  402766:	4618      	mov	r0, r3
  402768:	3714      	adds	r7, #20
  40276a:	46bd      	mov	sp, r7
  40276c:	f85d 7b04 	ldr.w	r7, [sp], #4
  402770:	4770      	bx	lr
  402772:	bf00      	nop
  402774:	400e0400 	.word	0x400e0400

00402778 <pmc_switch_sclk_to_32kxtal>:
 *       VDDIO power supply.
 *
 * \param ul_bypass 0 for Xtal, 1 for bypass.
 */
void pmc_switch_sclk_to_32kxtal(uint32_t ul_bypass)
{
  402778:	b480      	push	{r7}
  40277a:	b083      	sub	sp, #12
  40277c:	af00      	add	r7, sp, #0
  40277e:	6078      	str	r0, [r7, #4]
	/* Set Bypass mode if required */
	if (ul_bypass == 1) {
  402780:	687b      	ldr	r3, [r7, #4]
  402782:	2b01      	cmp	r3, #1
  402784:	d107      	bne.n	402796 <pmc_switch_sclk_to_32kxtal+0x1e>
		SUPC->SUPC_MR |= SUPC_MR_KEY_PASSWD |
  402786:	4a08      	ldr	r2, [pc, #32]	; (4027a8 <pmc_switch_sclk_to_32kxtal+0x30>)
  402788:	4b07      	ldr	r3, [pc, #28]	; (4027a8 <pmc_switch_sclk_to_32kxtal+0x30>)
  40278a:	689b      	ldr	r3, [r3, #8]
  40278c:	f043 4325 	orr.w	r3, r3, #2768240640	; 0xa5000000
  402790:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
  402794:	6093      	str	r3, [r2, #8]
			SUPC_MR_OSCBYPASS;
	}

	SUPC->SUPC_CR = SUPC_CR_KEY_PASSWD | SUPC_CR_XTALSEL;
  402796:	4b04      	ldr	r3, [pc, #16]	; (4027a8 <pmc_switch_sclk_to_32kxtal+0x30>)
  402798:	4a04      	ldr	r2, [pc, #16]	; (4027ac <pmc_switch_sclk_to_32kxtal+0x34>)
  40279a:	601a      	str	r2, [r3, #0]
}
  40279c:	bf00      	nop
  40279e:	370c      	adds	r7, #12
  4027a0:	46bd      	mov	sp, r7
  4027a2:	f85d 7b04 	ldr.w	r7, [sp], #4
  4027a6:	4770      	bx	lr
  4027a8:	400e1810 	.word	0x400e1810
  4027ac:	a5000008 	.word	0xa5000008

004027b0 <pmc_osc_is_ready_32kxtal>:
 *
 * \retval 1 External 32k Xtal is ready.
 * \retval 0 External 32k Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_32kxtal(void)
{
  4027b0:	b480      	push	{r7}
  4027b2:	af00      	add	r7, sp, #0
	return ((SUPC->SUPC_SR & SUPC_SR_OSCSEL)
  4027b4:	4b09      	ldr	r3, [pc, #36]	; (4027dc <pmc_osc_is_ready_32kxtal+0x2c>)
  4027b6:	695b      	ldr	r3, [r3, #20]
  4027b8:	f003 0380 	and.w	r3, r3, #128	; 0x80
			&& (PMC->PMC_SR & PMC_SR_OSCSELS));
  4027bc:	2b00      	cmp	r3, #0
  4027be:	d007      	beq.n	4027d0 <pmc_osc_is_ready_32kxtal+0x20>
  4027c0:	4b07      	ldr	r3, [pc, #28]	; (4027e0 <pmc_osc_is_ready_32kxtal+0x30>)
  4027c2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4027c4:	f003 0380 	and.w	r3, r3, #128	; 0x80
  4027c8:	2b00      	cmp	r3, #0
  4027ca:	d001      	beq.n	4027d0 <pmc_osc_is_ready_32kxtal+0x20>
  4027cc:	2301      	movs	r3, #1
  4027ce:	e000      	b.n	4027d2 <pmc_osc_is_ready_32kxtal+0x22>
  4027d0:	2300      	movs	r3, #0
}
  4027d2:	4618      	mov	r0, r3
  4027d4:	46bd      	mov	sp, r7
  4027d6:	f85d 7b04 	ldr.w	r7, [sp], #4
  4027da:	4770      	bx	lr
  4027dc:	400e1810 	.word	0x400e1810
  4027e0:	400e0400 	.word	0x400e0400

004027e4 <pmc_switch_mainck_to_fastrc>:
 * \retval 0 Success.
 * \retval 1 Timeout error.
 * \retval 2 Invalid frequency.
 */
void pmc_switch_mainck_to_fastrc(uint32_t ul_moscrcf)
{
  4027e4:	b480      	push	{r7}
  4027e6:	b083      	sub	sp, #12
  4027e8:	af00      	add	r7, sp, #0
  4027ea:	6078      	str	r0, [r7, #4]
	/* Enable Fast RC oscillator but DO NOT switch to RC now */
	PMC->CKGR_MOR |= (CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCRCEN);
  4027ec:	4a18      	ldr	r2, [pc, #96]	; (402850 <pmc_switch_mainck_to_fastrc+0x6c>)
  4027ee:	4b18      	ldr	r3, [pc, #96]	; (402850 <pmc_switch_mainck_to_fastrc+0x6c>)
  4027f0:	6a1b      	ldr	r3, [r3, #32]
  4027f2:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  4027f6:	f043 0308 	orr.w	r3, r3, #8
  4027fa:	6213      	str	r3, [r2, #32]

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  4027fc:	bf00      	nop
  4027fe:	4b14      	ldr	r3, [pc, #80]	; (402850 <pmc_switch_mainck_to_fastrc+0x6c>)
  402800:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  402802:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  402806:	2b00      	cmp	r3, #0
  402808:	d0f9      	beq.n	4027fe <pmc_switch_mainck_to_fastrc+0x1a>

	/* Change Fast RC oscillator frequency */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  40280a:	4911      	ldr	r1, [pc, #68]	; (402850 <pmc_switch_mainck_to_fastrc+0x6c>)
  40280c:	4b10      	ldr	r3, [pc, #64]	; (402850 <pmc_switch_mainck_to_fastrc+0x6c>)
  40280e:	6a1b      	ldr	r3, [r3, #32]
  402810:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  402814:	f023 0370 	bic.w	r3, r3, #112	; 0x70
			CKGR_MOR_KEY_PASSWD | ul_moscrcf;
  402818:	687a      	ldr	r2, [r7, #4]
  40281a:	4313      	orrs	r3, r2
  40281c:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
  402820:	620b      	str	r3, [r1, #32]

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
  402822:	bf00      	nop
  402824:	4b0a      	ldr	r3, [pc, #40]	; (402850 <pmc_switch_mainck_to_fastrc+0x6c>)
  402826:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  402828:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  40282c:	2b00      	cmp	r3, #0
  40282e:	d0f9      	beq.n	402824 <pmc_switch_mainck_to_fastrc+0x40>

	/* Switch to Fast RC */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCSEL) |
  402830:	4a07      	ldr	r2, [pc, #28]	; (402850 <pmc_switch_mainck_to_fastrc+0x6c>)
  402832:	4b07      	ldr	r3, [pc, #28]	; (402850 <pmc_switch_mainck_to_fastrc+0x6c>)
  402834:	6a1b      	ldr	r3, [r3, #32]
  402836:	f023 739b 	bic.w	r3, r3, #20316160	; 0x1360000
  40283a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  40283e:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  402842:	6213      	str	r3, [r2, #32]
			CKGR_MOR_KEY_PASSWD;
}
  402844:	bf00      	nop
  402846:	370c      	adds	r7, #12
  402848:	46bd      	mov	sp, r7
  40284a:	f85d 7b04 	ldr.w	r7, [sp], #4
  40284e:	4770      	bx	lr
  402850:	400e0400 	.word	0x400e0400

00402854 <pmc_switch_mainck_to_xtal>:
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
  402854:	b480      	push	{r7}
  402856:	b083      	sub	sp, #12
  402858:	af00      	add	r7, sp, #0
  40285a:	6078      	str	r0, [r7, #4]
  40285c:	6039      	str	r1, [r7, #0]
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
  40285e:	687b      	ldr	r3, [r7, #4]
  402860:	2b00      	cmp	r3, #0
  402862:	d008      	beq.n	402876 <pmc_switch_mainck_to_xtal+0x22>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  402864:	4916      	ldr	r1, [pc, #88]	; (4028c0 <pmc_switch_mainck_to_xtal+0x6c>)
  402866:	4b16      	ldr	r3, [pc, #88]	; (4028c0 <pmc_switch_mainck_to_xtal+0x6c>)
  402868:	6a1b      	ldr	r3, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
  40286a:	4a16      	ldr	r2, [pc, #88]	; (4028c4 <pmc_switch_mainck_to_xtal+0x70>)
  40286c:	401a      	ands	r2, r3
  40286e:	4b16      	ldr	r3, [pc, #88]	; (4028c8 <pmc_switch_mainck_to_xtal+0x74>)
  402870:	4313      	orrs	r3, r2
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  402872:	620b      	str	r3, [r1, #32]
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));

		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
	}
}
  402874:	e01e      	b.n	4028b4 <pmc_switch_mainck_to_xtal+0x60>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  402876:	4912      	ldr	r1, [pc, #72]	; (4028c0 <pmc_switch_mainck_to_xtal+0x6c>)
  402878:	4b11      	ldr	r3, [pc, #68]	; (4028c0 <pmc_switch_mainck_to_xtal+0x6c>)
  40287a:	6a1b      	ldr	r3, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  40287c:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
  402880:	f023 0303 	bic.w	r3, r3, #3
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
  402884:	683a      	ldr	r2, [r7, #0]
  402886:	0212      	lsls	r2, r2, #8
  402888:	b292      	uxth	r2, r2
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  40288a:	4313      	orrs	r3, r2
  40288c:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
  402890:	f043 0301 	orr.w	r3, r3, #1
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  402894:	620b      	str	r3, [r1, #32]
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
  402896:	bf00      	nop
  402898:	4b09      	ldr	r3, [pc, #36]	; (4028c0 <pmc_switch_mainck_to_xtal+0x6c>)
  40289a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  40289c:	f003 0301 	and.w	r3, r3, #1
  4028a0:	2b00      	cmp	r3, #0
  4028a2:	d0f9      	beq.n	402898 <pmc_switch_mainck_to_xtal+0x44>
		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
  4028a4:	4a06      	ldr	r2, [pc, #24]	; (4028c0 <pmc_switch_mainck_to_xtal+0x6c>)
  4028a6:	4b06      	ldr	r3, [pc, #24]	; (4028c0 <pmc_switch_mainck_to_xtal+0x6c>)
  4028a8:	6a1b      	ldr	r3, [r3, #32]
  4028aa:	f043 739b 	orr.w	r3, r3, #20316160	; 0x1360000
  4028ae:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  4028b2:	6213      	str	r3, [r2, #32]
}
  4028b4:	bf00      	nop
  4028b6:	370c      	adds	r7, #12
  4028b8:	46bd      	mov	sp, r7
  4028ba:	f85d 7b04 	ldr.w	r7, [sp], #4
  4028be:	4770      	bx	lr
  4028c0:	400e0400 	.word	0x400e0400
  4028c4:	fec8fffc 	.word	0xfec8fffc
  4028c8:	01370002 	.word	0x01370002

004028cc <pmc_osc_is_ready_mainck>:
 *
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
  4028cc:	b480      	push	{r7}
  4028ce:	af00      	add	r7, sp, #0
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
  4028d0:	4b04      	ldr	r3, [pc, #16]	; (4028e4 <pmc_osc_is_ready_mainck+0x18>)
  4028d2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  4028d4:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
}
  4028d8:	4618      	mov	r0, r3
  4028da:	46bd      	mov	sp, r7
  4028dc:	f85d 7b04 	ldr.w	r7, [sp], #4
  4028e0:	4770      	bx	lr
  4028e2:	bf00      	nop
  4028e4:	400e0400 	.word	0x400e0400

004028e8 <pmc_disable_pllack>:

/**
 * \brief Disable PLLA clock.
 */
void pmc_disable_pllack(void)
{
  4028e8:	b480      	push	{r7}
  4028ea:	af00      	add	r7, sp, #0
#if (SAM4C || SAM4CM || SAM4CP || SAMG)
	PMC->CKGR_PLLAR = CKGR_PLLAR_MULA(0);
#else
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
  4028ec:	4b04      	ldr	r3, [pc, #16]	; (402900 <pmc_disable_pllack+0x18>)
  4028ee:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  4028f2:	629a      	str	r2, [r3, #40]	; 0x28
#endif
}
  4028f4:	bf00      	nop
  4028f6:	46bd      	mov	sp, r7
  4028f8:	f85d 7b04 	ldr.w	r7, [sp], #4
  4028fc:	4770      	bx	lr
  4028fe:	bf00      	nop
  402900:	400e0400 	.word	0x400e0400

00402904 <pmc_is_locked_pllack>:
 *
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
  402904:	b480      	push	{r7}
  402906:	af00      	add	r7, sp, #0
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  402908:	4b04      	ldr	r3, [pc, #16]	; (40291c <pmc_is_locked_pllack+0x18>)
  40290a:	6e9b      	ldr	r3, [r3, #104]	; 0x68
  40290c:	f003 0302 	and.w	r3, r3, #2
}
  402910:	4618      	mov	r0, r3
  402912:	46bd      	mov	sp, r7
  402914:	f85d 7b04 	ldr.w	r7, [sp], #4
  402918:	4770      	bx	lr
  40291a:	bf00      	nop
  40291c:	400e0400 	.word	0x400e0400

00402920 <pmc_enable_periph_clk>:
 *
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
  402920:	b480      	push	{r7}
  402922:	b083      	sub	sp, #12
  402924:	af00      	add	r7, sp, #0
  402926:	6078      	str	r0, [r7, #4]
	PMC->PMC_PCR = ul_id & 0x7F;
	pcr = PMC->PMC_PCR | PMC_PCR_EN | PMC_PCR_CMD;
	PMC->PMC_PCR = pcr;
	return 0;
#else
	if (ul_id > MAX_PERIPH_ID) {
  402928:	687b      	ldr	r3, [r7, #4]
  40292a:	2b2f      	cmp	r3, #47	; 0x2f
  40292c:	d901      	bls.n	402932 <pmc_enable_periph_clk+0x12>
		return 1;
  40292e:	2301      	movs	r3, #1
  402930:	e02f      	b.n	402992 <pmc_enable_periph_clk+0x72>
	}

	if (ul_id < 32) {
  402932:	687b      	ldr	r3, [r7, #4]
  402934:	2b1f      	cmp	r3, #31
  402936:	d813      	bhi.n	402960 <pmc_enable_periph_clk+0x40>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  402938:	4b19      	ldr	r3, [pc, #100]	; (4029a0 <pmc_enable_periph_clk+0x80>)
  40293a:	699a      	ldr	r2, [r3, #24]
  40293c:	2101      	movs	r1, #1
  40293e:	687b      	ldr	r3, [r7, #4]
  402940:	fa01 f303 	lsl.w	r3, r1, r3
  402944:	401a      	ands	r2, r3
  402946:	2101      	movs	r1, #1
  402948:	687b      	ldr	r3, [r7, #4]
  40294a:	fa01 f303 	lsl.w	r3, r1, r3
  40294e:	429a      	cmp	r2, r3
  402950:	d01e      	beq.n	402990 <pmc_enable_periph_clk+0x70>
			PMC->PMC_PCER0 = 1 << ul_id;
  402952:	4a13      	ldr	r2, [pc, #76]	; (4029a0 <pmc_enable_periph_clk+0x80>)
  402954:	2101      	movs	r1, #1
  402956:	687b      	ldr	r3, [r7, #4]
  402958:	fa01 f303 	lsl.w	r3, r1, r3
  40295c:	6113      	str	r3, [r2, #16]
  40295e:	e017      	b.n	402990 <pmc_enable_periph_clk+0x70>
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CM || SAM4CP || SAMG55 || SAMV71 || SAMV70 || SAME70 || SAMS70)
	} else {
		ul_id -= 32;
  402960:	687b      	ldr	r3, [r7, #4]
  402962:	3b20      	subs	r3, #32
  402964:	607b      	str	r3, [r7, #4]
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  402966:	4b0e      	ldr	r3, [pc, #56]	; (4029a0 <pmc_enable_periph_clk+0x80>)
  402968:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
  40296c:	2101      	movs	r1, #1
  40296e:	687b      	ldr	r3, [r7, #4]
  402970:	fa01 f303 	lsl.w	r3, r1, r3
  402974:	401a      	ands	r2, r3
  402976:	2101      	movs	r1, #1
  402978:	687b      	ldr	r3, [r7, #4]
  40297a:	fa01 f303 	lsl.w	r3, r1, r3
  40297e:	429a      	cmp	r2, r3
  402980:	d006      	beq.n	402990 <pmc_enable_periph_clk+0x70>
			PMC->PMC_PCER1 = 1 << ul_id;
  402982:	4a07      	ldr	r2, [pc, #28]	; (4029a0 <pmc_enable_periph_clk+0x80>)
  402984:	2101      	movs	r1, #1
  402986:	687b      	ldr	r3, [r7, #4]
  402988:	fa01 f303 	lsl.w	r3, r1, r3
  40298c:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
		}
#endif
	}

	return 0;
  402990:	2300      	movs	r3, #0
#endif /* defined(REG_PMC_PCR) && !SAMG55 */
}
  402992:	4618      	mov	r0, r3
  402994:	370c      	adds	r7, #12
  402996:	46bd      	mov	sp, r7
  402998:	f85d 7b04 	ldr.w	r7, [sp], #4
  40299c:	4770      	bx	lr
  40299e:	bf00      	nop
  4029a0:	400e0400 	.word	0x400e0400

004029a4 <twi_enable_master_mode>:
 * \brief Enable TWI master mode.
 *
 * \param p_twi Pointer to a TWI instance.
 */
void twi_enable_master_mode(Twi *p_twi)
{
  4029a4:	b480      	push	{r7}
  4029a6:	b083      	sub	sp, #12
  4029a8:	af00      	add	r7, sp, #0
  4029aa:	6078      	str	r0, [r7, #4]
	/* Set Master Disable bit and Slave Disable bit */
	p_twi->TWI_CR = TWI_CR_MSDIS;
  4029ac:	687b      	ldr	r3, [r7, #4]
  4029ae:	2208      	movs	r2, #8
  4029b0:	601a      	str	r2, [r3, #0]
	p_twi->TWI_CR = TWI_CR_SVDIS;
  4029b2:	687b      	ldr	r3, [r7, #4]
  4029b4:	2220      	movs	r2, #32
  4029b6:	601a      	str	r2, [r3, #0]

	/* Set Master Enable bit */
	p_twi->TWI_CR = TWI_CR_MSEN;
  4029b8:	687b      	ldr	r3, [r7, #4]
  4029ba:	2204      	movs	r2, #4
  4029bc:	601a      	str	r2, [r3, #0]
}
  4029be:	bf00      	nop
  4029c0:	370c      	adds	r7, #12
  4029c2:	46bd      	mov	sp, r7
  4029c4:	f85d 7b04 	ldr.w	r7, [sp], #4
  4029c8:	4770      	bx	lr
	...

004029cc <twi_master_init>:
 * \param p_opt Options for initializing the TWI module (see \ref twi_options_t).
 *
 * \return TWI_SUCCESS if initialization is complete, error code otherwise.
 */
uint32_t twi_master_init(Twi *p_twi, const twi_options_t *p_opt)
{
  4029cc:	b580      	push	{r7, lr}
  4029ce:	b084      	sub	sp, #16
  4029d0:	af00      	add	r7, sp, #0
  4029d2:	6078      	str	r0, [r7, #4]
  4029d4:	6039      	str	r1, [r7, #0]
	uint32_t status = TWI_SUCCESS;
  4029d6:	2300      	movs	r3, #0
  4029d8:	60fb      	str	r3, [r7, #12]

	/* Disable TWI interrupts */
	p_twi->TWI_IDR = ~0UL;
  4029da:	687b      	ldr	r3, [r7, #4]
  4029dc:	f04f 32ff 	mov.w	r2, #4294967295
  4029e0:	629a      	str	r2, [r3, #40]	; 0x28

	/* Dummy read in status register */
	p_twi->TWI_SR;
  4029e2:	687b      	ldr	r3, [r7, #4]
  4029e4:	6a1b      	ldr	r3, [r3, #32]

	/* Reset TWI peripheral */
	twi_reset(p_twi);
  4029e6:	6878      	ldr	r0, [r7, #4]
  4029e8:	4b0e      	ldr	r3, [pc, #56]	; (402a24 <twi_master_init+0x58>)
  4029ea:	4798      	blx	r3

	twi_enable_master_mode(p_twi);
  4029ec:	6878      	ldr	r0, [r7, #4]
  4029ee:	4b0e      	ldr	r3, [pc, #56]	; (402a28 <twi_master_init+0x5c>)
  4029f0:	4798      	blx	r3

	/* Select the speed */
	if (twi_set_speed(p_twi, p_opt->speed, p_opt->master_clk) == FAIL) {
  4029f2:	683b      	ldr	r3, [r7, #0]
  4029f4:	6859      	ldr	r1, [r3, #4]
  4029f6:	683b      	ldr	r3, [r7, #0]
  4029f8:	681b      	ldr	r3, [r3, #0]
  4029fa:	461a      	mov	r2, r3
  4029fc:	6878      	ldr	r0, [r7, #4]
  4029fe:	4b0b      	ldr	r3, [pc, #44]	; (402a2c <twi_master_init+0x60>)
  402a00:	4798      	blx	r3
  402a02:	4603      	mov	r3, r0
  402a04:	2b01      	cmp	r3, #1
  402a06:	d101      	bne.n	402a0c <twi_master_init+0x40>
		/* The desired speed setting is rejected */
		status = TWI_INVALID_ARGUMENT;
  402a08:	2301      	movs	r3, #1
  402a0a:	60fb      	str	r3, [r7, #12]
	}

	if (p_opt->smbus == 1) {
  402a0c:	683b      	ldr	r3, [r7, #0]
  402a0e:	7a5b      	ldrb	r3, [r3, #9]
  402a10:	2b01      	cmp	r3, #1
  402a12:	d102      	bne.n	402a1a <twi_master_init+0x4e>
		p_twi->TWI_CR = TWI_CR_QUICK;
  402a14:	687b      	ldr	r3, [r7, #4]
  402a16:	2240      	movs	r2, #64	; 0x40
  402a18:	601a      	str	r2, [r3, #0]
	}

	return status;
  402a1a:	68fb      	ldr	r3, [r7, #12]
}
  402a1c:	4618      	mov	r0, r3
  402a1e:	3710      	adds	r7, #16
  402a20:	46bd      	mov	sp, r7
  402a22:	bd80      	pop	{r7, pc}
  402a24:	00402c5d 	.word	0x00402c5d
  402a28:	004029a5 	.word	0x004029a5
  402a2c:	00402a31 	.word	0x00402a31

00402a30 <twi_set_speed>:
 *
 * \retval PASS New speed setting is accepted.
 * \retval FAIL New speed setting is rejected.
 */
uint32_t twi_set_speed(Twi *p_twi, uint32_t ul_speed, uint32_t ul_mck)
{
  402a30:	b480      	push	{r7}
  402a32:	b089      	sub	sp, #36	; 0x24
  402a34:	af00      	add	r7, sp, #0
  402a36:	60f8      	str	r0, [r7, #12]
  402a38:	60b9      	str	r1, [r7, #8]
  402a3a:	607a      	str	r2, [r7, #4]
	uint32_t ckdiv = 0;
  402a3c:	2300      	movs	r3, #0
  402a3e:	61fb      	str	r3, [r7, #28]
	uint32_t c_lh_div;
	uint32_t cldiv, chdiv;

	if (ul_speed > I2C_FAST_MODE_SPEED) {
  402a40:	68bb      	ldr	r3, [r7, #8]
  402a42:	4a34      	ldr	r2, [pc, #208]	; (402b14 <twi_set_speed+0xe4>)
  402a44:	4293      	cmp	r3, r2
  402a46:	d901      	bls.n	402a4c <twi_set_speed+0x1c>
		return FAIL;
  402a48:	2301      	movs	r3, #1
  402a4a:	e05d      	b.n	402b08 <twi_set_speed+0xd8>
	}

	/* Low level time not less than 1.3us of I2C Fast Mode. */
	if (ul_speed > LOW_LEVEL_TIME_LIMIT) {
  402a4c:	68bb      	ldr	r3, [r7, #8]
  402a4e:	4a32      	ldr	r2, [pc, #200]	; (402b18 <twi_set_speed+0xe8>)
  402a50:	4293      	cmp	r3, r2
  402a52:	d937      	bls.n	402ac4 <twi_set_speed+0x94>
		/* Low level of time fixed for 1.3us. */
		cldiv = ul_mck / (LOW_LEVEL_TIME_LIMIT * TWI_CLK_DIVIDER) - TWI_CLK_CALC_ARGU;
  402a54:	687b      	ldr	r3, [r7, #4]
  402a56:	4a31      	ldr	r2, [pc, #196]	; (402b1c <twi_set_speed+0xec>)
  402a58:	fba2 2303 	umull	r2, r3, r2, r3
  402a5c:	0b9b      	lsrs	r3, r3, #14
  402a5e:	3b04      	subs	r3, #4
  402a60:	617b      	str	r3, [r7, #20]
		chdiv = ul_mck / ((ul_speed + (ul_speed - LOW_LEVEL_TIME_LIMIT)) * TWI_CLK_DIVIDER) - TWI_CLK_CALC_ARGU;
  402a62:	68ba      	ldr	r2, [r7, #8]
  402a64:	4b2e      	ldr	r3, [pc, #184]	; (402b20 <twi_set_speed+0xf0>)
  402a66:	4413      	add	r3, r2
  402a68:	009b      	lsls	r3, r3, #2
  402a6a:	687a      	ldr	r2, [r7, #4]
  402a6c:	fbb2 f3f3 	udiv	r3, r2, r3
  402a70:	3b04      	subs	r3, #4
  402a72:	613b      	str	r3, [r7, #16]
		
		/* cldiv must fit in 8 bits, ckdiv must fit in 3 bits */
		while ((cldiv > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  402a74:	e005      	b.n	402a82 <twi_set_speed+0x52>
			/* Increase clock divider */
			ckdiv++;
  402a76:	69fb      	ldr	r3, [r7, #28]
  402a78:	3301      	adds	r3, #1
  402a7a:	61fb      	str	r3, [r7, #28]
			/* Divide cldiv value */
			cldiv /= TWI_CLK_DIVIDER;
  402a7c:	697b      	ldr	r3, [r7, #20]
  402a7e:	085b      	lsrs	r3, r3, #1
  402a80:	617b      	str	r3, [r7, #20]
		while ((cldiv > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  402a82:	697b      	ldr	r3, [r7, #20]
  402a84:	2bff      	cmp	r3, #255	; 0xff
  402a86:	d909      	bls.n	402a9c <twi_set_speed+0x6c>
  402a88:	69fb      	ldr	r3, [r7, #28]
  402a8a:	2b06      	cmp	r3, #6
  402a8c:	d9f3      	bls.n	402a76 <twi_set_speed+0x46>
		}
		/* chdiv must fit in 8 bits, ckdiv must fit in 3 bits */
		while ((chdiv > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  402a8e:	e005      	b.n	402a9c <twi_set_speed+0x6c>
			/* Increase clock divider */
			ckdiv++;
  402a90:	69fb      	ldr	r3, [r7, #28]
  402a92:	3301      	adds	r3, #1
  402a94:	61fb      	str	r3, [r7, #28]
			/* Divide cldiv value */
			chdiv /= TWI_CLK_DIVIDER;
  402a96:	693b      	ldr	r3, [r7, #16]
  402a98:	085b      	lsrs	r3, r3, #1
  402a9a:	613b      	str	r3, [r7, #16]
		while ((chdiv > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  402a9c:	693b      	ldr	r3, [r7, #16]
  402a9e:	2bff      	cmp	r3, #255	; 0xff
  402aa0:	d902      	bls.n	402aa8 <twi_set_speed+0x78>
  402aa2:	69fb      	ldr	r3, [r7, #28]
  402aa4:	2b06      	cmp	r3, #6
  402aa6:	d9f3      	bls.n	402a90 <twi_set_speed+0x60>
		}

		/* set clock waveform generator register */
		p_twi->TWI_CWGR =
				TWI_CWGR_CLDIV(cldiv) | TWI_CWGR_CHDIV(chdiv) |
  402aa8:	697b      	ldr	r3, [r7, #20]
  402aaa:	b2da      	uxtb	r2, r3
  402aac:	693b      	ldr	r3, [r7, #16]
  402aae:	021b      	lsls	r3, r3, #8
  402ab0:	b29b      	uxth	r3, r3
  402ab2:	431a      	orrs	r2, r3
				TWI_CWGR_CKDIV(ckdiv);		
  402ab4:	69fb      	ldr	r3, [r7, #28]
  402ab6:	041b      	lsls	r3, r3, #16
  402ab8:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
				TWI_CWGR_CLDIV(cldiv) | TWI_CWGR_CHDIV(chdiv) |
  402abc:	431a      	orrs	r2, r3
		p_twi->TWI_CWGR =
  402abe:	68fb      	ldr	r3, [r7, #12]
  402ac0:	611a      	str	r2, [r3, #16]
  402ac2:	e020      	b.n	402b06 <twi_set_speed+0xd6>
	} else {
		c_lh_div = ul_mck / (ul_speed * TWI_CLK_DIVIDER) - TWI_CLK_CALC_ARGU;
  402ac4:	68bb      	ldr	r3, [r7, #8]
  402ac6:	005b      	lsls	r3, r3, #1
  402ac8:	687a      	ldr	r2, [r7, #4]
  402aca:	fbb2 f3f3 	udiv	r3, r2, r3
  402ace:	3b04      	subs	r3, #4
  402ad0:	61bb      	str	r3, [r7, #24]

		/* cldiv must fit in 8 bits, ckdiv must fit in 3 bits */
		while ((c_lh_div > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  402ad2:	e005      	b.n	402ae0 <twi_set_speed+0xb0>
			/* Increase clock divider */
			ckdiv++;
  402ad4:	69fb      	ldr	r3, [r7, #28]
  402ad6:	3301      	adds	r3, #1
  402ad8:	61fb      	str	r3, [r7, #28]
			/* Divide cldiv value */
			c_lh_div /= TWI_CLK_DIVIDER;
  402ada:	69bb      	ldr	r3, [r7, #24]
  402adc:	085b      	lsrs	r3, r3, #1
  402ade:	61bb      	str	r3, [r7, #24]
		while ((c_lh_div > TWI_CLK_DIV_MAX) && (ckdiv < TWI_CLK_DIV_MIN)) {
  402ae0:	69bb      	ldr	r3, [r7, #24]
  402ae2:	2bff      	cmp	r3, #255	; 0xff
  402ae4:	d902      	bls.n	402aec <twi_set_speed+0xbc>
  402ae6:	69fb      	ldr	r3, [r7, #28]
  402ae8:	2b06      	cmp	r3, #6
  402aea:	d9f3      	bls.n	402ad4 <twi_set_speed+0xa4>
		}

		/* set clock waveform generator register */
		p_twi->TWI_CWGR =
				TWI_CWGR_CLDIV(c_lh_div) | TWI_CWGR_CHDIV(c_lh_div) |
  402aec:	69bb      	ldr	r3, [r7, #24]
  402aee:	b2da      	uxtb	r2, r3
  402af0:	69bb      	ldr	r3, [r7, #24]
  402af2:	021b      	lsls	r3, r3, #8
  402af4:	b29b      	uxth	r3, r3
  402af6:	431a      	orrs	r2, r3
				TWI_CWGR_CKDIV(ckdiv);
  402af8:	69fb      	ldr	r3, [r7, #28]
  402afa:	041b      	lsls	r3, r3, #16
  402afc:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
				TWI_CWGR_CLDIV(c_lh_div) | TWI_CWGR_CHDIV(c_lh_div) |
  402b00:	431a      	orrs	r2, r3
		p_twi->TWI_CWGR =
  402b02:	68fb      	ldr	r3, [r7, #12]
  402b04:	611a      	str	r2, [r3, #16]
	}

	return PASS;
  402b06:	2300      	movs	r3, #0
}
  402b08:	4618      	mov	r0, r3
  402b0a:	3724      	adds	r7, #36	; 0x24
  402b0c:	46bd      	mov	sp, r7
  402b0e:	f85d 7b04 	ldr.w	r7, [sp], #4
  402b12:	4770      	bx	lr
  402b14:	00061a80 	.word	0x00061a80
  402b18:	0005dc00 	.word	0x0005dc00
  402b1c:	057619f1 	.word	0x057619f1
  402b20:	3ffd1200 	.word	0x3ffd1200

00402b24 <twi_mk_addr>:
 * which byte is the MSB to start with.
 *
 * Please see the device datasheet for details on this.
 */
uint32_t twi_mk_addr(const uint8_t *addr, int len)
{
  402b24:	b480      	push	{r7}
  402b26:	b085      	sub	sp, #20
  402b28:	af00      	add	r7, sp, #0
  402b2a:	6078      	str	r0, [r7, #4]
  402b2c:	6039      	str	r1, [r7, #0]
	uint32_t val;

	if (len == 0)
  402b2e:	683b      	ldr	r3, [r7, #0]
  402b30:	2b00      	cmp	r3, #0
  402b32:	d101      	bne.n	402b38 <twi_mk_addr+0x14>
		return 0;
  402b34:	2300      	movs	r3, #0
  402b36:	e01d      	b.n	402b74 <twi_mk_addr+0x50>

	val = addr[0];
  402b38:	687b      	ldr	r3, [r7, #4]
  402b3a:	781b      	ldrb	r3, [r3, #0]
  402b3c:	60fb      	str	r3, [r7, #12]
	if (len > 1) {
  402b3e:	683b      	ldr	r3, [r7, #0]
  402b40:	2b01      	cmp	r3, #1
  402b42:	dd09      	ble.n	402b58 <twi_mk_addr+0x34>
		val <<= 8;
  402b44:	68fb      	ldr	r3, [r7, #12]
  402b46:	021b      	lsls	r3, r3, #8
  402b48:	60fb      	str	r3, [r7, #12]
		val |= addr[1];
  402b4a:	687b      	ldr	r3, [r7, #4]
  402b4c:	3301      	adds	r3, #1
  402b4e:	781b      	ldrb	r3, [r3, #0]
  402b50:	461a      	mov	r2, r3
  402b52:	68fb      	ldr	r3, [r7, #12]
  402b54:	4313      	orrs	r3, r2
  402b56:	60fb      	str	r3, [r7, #12]
	}
	if (len > 2) {
  402b58:	683b      	ldr	r3, [r7, #0]
  402b5a:	2b02      	cmp	r3, #2
  402b5c:	dd09      	ble.n	402b72 <twi_mk_addr+0x4e>
		val <<= 8;
  402b5e:	68fb      	ldr	r3, [r7, #12]
  402b60:	021b      	lsls	r3, r3, #8
  402b62:	60fb      	str	r3, [r7, #12]
		val |= addr[2];
  402b64:	687b      	ldr	r3, [r7, #4]
  402b66:	3302      	adds	r3, #2
  402b68:	781b      	ldrb	r3, [r3, #0]
  402b6a:	461a      	mov	r2, r3
  402b6c:	68fb      	ldr	r3, [r7, #12]
  402b6e:	4313      	orrs	r3, r2
  402b70:	60fb      	str	r3, [r7, #12]
	}
	return val;
  402b72:	68fb      	ldr	r3, [r7, #12]
}
  402b74:	4618      	mov	r0, r3
  402b76:	3714      	adds	r7, #20
  402b78:	46bd      	mov	sp, r7
  402b7a:	f85d 7b04 	ldr.w	r7, [sp], #4
  402b7e:	4770      	bx	lr

00402b80 <twi_master_write>:
 * \param p_packet Packet information and data (see \ref twi_packet_t).
 *
 * \return TWI_SUCCESS if all bytes were written, error code otherwise.
 */
uint32_t twi_master_write(Twi *p_twi, twi_packet_t *p_packet)
{
  402b80:	b580      	push	{r7, lr}
  402b82:	b086      	sub	sp, #24
  402b84:	af00      	add	r7, sp, #0
  402b86:	6078      	str	r0, [r7, #4]
  402b88:	6039      	str	r1, [r7, #0]
	uint32_t status;
	uint32_t cnt = p_packet->length;
  402b8a:	683b      	ldr	r3, [r7, #0]
  402b8c:	68db      	ldr	r3, [r3, #12]
  402b8e:	617b      	str	r3, [r7, #20]
	uint8_t *buffer = p_packet->buffer;
  402b90:	683b      	ldr	r3, [r7, #0]
  402b92:	689b      	ldr	r3, [r3, #8]
  402b94:	613b      	str	r3, [r7, #16]

	/* Check argument */
	if (cnt == 0) {
  402b96:	697b      	ldr	r3, [r7, #20]
  402b98:	2b00      	cmp	r3, #0
  402b9a:	d101      	bne.n	402ba0 <twi_master_write+0x20>
		return TWI_INVALID_ARGUMENT;
  402b9c:	2301      	movs	r3, #1
  402b9e:	e056      	b.n	402c4e <twi_master_write+0xce>
	}

	/* Set write mode, slave address and 3 internal address byte lengths */
	p_twi->TWI_MMR = 0;
  402ba0:	687b      	ldr	r3, [r7, #4]
  402ba2:	2200      	movs	r2, #0
  402ba4:	605a      	str	r2, [r3, #4]
	p_twi->TWI_MMR = TWI_MMR_DADR(p_packet->chip) |
  402ba6:	683b      	ldr	r3, [r7, #0]
  402ba8:	7c1b      	ldrb	r3, [r3, #16]
  402baa:	041b      	lsls	r3, r3, #16
  402bac:	f403 02fe 	and.w	r2, r3, #8323072	; 0x7f0000
			((p_packet->addr_length << TWI_MMR_IADRSZ_Pos) &
  402bb0:	683b      	ldr	r3, [r7, #0]
  402bb2:	685b      	ldr	r3, [r3, #4]
  402bb4:	021b      	lsls	r3, r3, #8
  402bb6:	f403 7340 	and.w	r3, r3, #768	; 0x300
	p_twi->TWI_MMR = TWI_MMR_DADR(p_packet->chip) |
  402bba:	431a      	orrs	r2, r3
  402bbc:	687b      	ldr	r3, [r7, #4]
  402bbe:	605a      	str	r2, [r3, #4]
			TWI_MMR_IADRSZ_Msk);

	/* Set internal address for remote chip */
	p_twi->TWI_IADR = 0;
  402bc0:	687b      	ldr	r3, [r7, #4]
  402bc2:	2200      	movs	r2, #0
  402bc4:	60da      	str	r2, [r3, #12]
	p_twi->TWI_IADR = twi_mk_addr(p_packet->addr, p_packet->addr_length);
  402bc6:	683a      	ldr	r2, [r7, #0]
  402bc8:	683b      	ldr	r3, [r7, #0]
  402bca:	685b      	ldr	r3, [r3, #4]
  402bcc:	4619      	mov	r1, r3
  402bce:	4610      	mov	r0, r2
  402bd0:	4b21      	ldr	r3, [pc, #132]	; (402c58 <twi_master_write+0xd8>)
  402bd2:	4798      	blx	r3
  402bd4:	4602      	mov	r2, r0
  402bd6:	687b      	ldr	r3, [r7, #4]
  402bd8:	60da      	str	r2, [r3, #12]

	/* Send all bytes */
	while (cnt > 0) {
  402bda:	e019      	b.n	402c10 <twi_master_write+0x90>
		status = p_twi->TWI_SR;
  402bdc:	687b      	ldr	r3, [r7, #4]
  402bde:	6a1b      	ldr	r3, [r3, #32]
  402be0:	60fb      	str	r3, [r7, #12]
		if (status & TWI_SR_NACK) {
  402be2:	68fb      	ldr	r3, [r7, #12]
  402be4:	f403 7380 	and.w	r3, r3, #256	; 0x100
  402be8:	2b00      	cmp	r3, #0
  402bea:	d001      	beq.n	402bf0 <twi_master_write+0x70>
			return TWI_RECEIVE_NACK;
  402bec:	2305      	movs	r3, #5
  402bee:	e02e      	b.n	402c4e <twi_master_write+0xce>
		}

		if (!(status & TWI_SR_TXRDY)) {
  402bf0:	68fb      	ldr	r3, [r7, #12]
  402bf2:	f003 0304 	and.w	r3, r3, #4
  402bf6:	2b00      	cmp	r3, #0
  402bf8:	d100      	bne.n	402bfc <twi_master_write+0x7c>
			continue;
  402bfa:	e009      	b.n	402c10 <twi_master_write+0x90>
		}
		p_twi->TWI_THR = *buffer++;
  402bfc:	693b      	ldr	r3, [r7, #16]
  402bfe:	1c5a      	adds	r2, r3, #1
  402c00:	613a      	str	r2, [r7, #16]
  402c02:	781b      	ldrb	r3, [r3, #0]
  402c04:	461a      	mov	r2, r3
  402c06:	687b      	ldr	r3, [r7, #4]
  402c08:	635a      	str	r2, [r3, #52]	; 0x34

		cnt--;
  402c0a:	697b      	ldr	r3, [r7, #20]
  402c0c:	3b01      	subs	r3, #1
  402c0e:	617b      	str	r3, [r7, #20]
	while (cnt > 0) {
  402c10:	697b      	ldr	r3, [r7, #20]
  402c12:	2b00      	cmp	r3, #0
  402c14:	d1e2      	bne.n	402bdc <twi_master_write+0x5c>
	}

	while (1) {
		status = p_twi->TWI_SR;
  402c16:	687b      	ldr	r3, [r7, #4]
  402c18:	6a1b      	ldr	r3, [r3, #32]
  402c1a:	60fb      	str	r3, [r7, #12]
		if (status & TWI_SR_NACK) {
  402c1c:	68fb      	ldr	r3, [r7, #12]
  402c1e:	f403 7380 	and.w	r3, r3, #256	; 0x100
  402c22:	2b00      	cmp	r3, #0
  402c24:	d001      	beq.n	402c2a <twi_master_write+0xaa>
			return TWI_RECEIVE_NACK;
  402c26:	2305      	movs	r3, #5
  402c28:	e011      	b.n	402c4e <twi_master_write+0xce>
		}

		if (status & TWI_SR_TXRDY) {
  402c2a:	68fb      	ldr	r3, [r7, #12]
  402c2c:	f003 0304 	and.w	r3, r3, #4
  402c30:	2b00      	cmp	r3, #0
  402c32:	d100      	bne.n	402c36 <twi_master_write+0xb6>
		status = p_twi->TWI_SR;
  402c34:	e7ef      	b.n	402c16 <twi_master_write+0x96>
			break;
  402c36:	bf00      	nop
		}
	}

	p_twi->TWI_CR = TWI_CR_STOP;
  402c38:	687b      	ldr	r3, [r7, #4]
  402c3a:	2202      	movs	r2, #2
  402c3c:	601a      	str	r2, [r3, #0]

	while (!(p_twi->TWI_SR & TWI_SR_TXCOMP)) {
  402c3e:	bf00      	nop
  402c40:	687b      	ldr	r3, [r7, #4]
  402c42:	6a1b      	ldr	r3, [r3, #32]
  402c44:	f003 0301 	and.w	r3, r3, #1
  402c48:	2b00      	cmp	r3, #0
  402c4a:	d0f9      	beq.n	402c40 <twi_master_write+0xc0>
	}

	return TWI_SUCCESS;
  402c4c:	2300      	movs	r3, #0
}
  402c4e:	4618      	mov	r0, r3
  402c50:	3718      	adds	r7, #24
  402c52:	46bd      	mov	sp, r7
  402c54:	bd80      	pop	{r7, pc}
  402c56:	bf00      	nop
  402c58:	00402b25 	.word	0x00402b25

00402c5c <twi_reset>:
 * \brief Reset TWI.
 *
 * \param p_twi Pointer to a TWI instance.
 */
void twi_reset(Twi *p_twi)
{
  402c5c:	b480      	push	{r7}
  402c5e:	b083      	sub	sp, #12
  402c60:	af00      	add	r7, sp, #0
  402c62:	6078      	str	r0, [r7, #4]
	/* Set SWRST bit to reset TWI peripheral */
	p_twi->TWI_CR = TWI_CR_SWRST;
  402c64:	687b      	ldr	r3, [r7, #4]
  402c66:	2280      	movs	r2, #128	; 0x80
  402c68:	601a      	str	r2, [r3, #0]
	p_twi->TWI_RHR;
  402c6a:	687b      	ldr	r3, [r7, #4]
  402c6c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
}
  402c6e:	bf00      	nop
  402c70:	370c      	adds	r7, #12
  402c72:	46bd      	mov	sp, r7
  402c74:	f85d 7b04 	ldr.w	r7, [sp], #4
  402c78:	4770      	bx	lr
	...

00402c7c <__aeabi_uldivmod>:
  402c7c:	b953      	cbnz	r3, 402c94 <__aeabi_uldivmod+0x18>
  402c7e:	b94a      	cbnz	r2, 402c94 <__aeabi_uldivmod+0x18>
  402c80:	2900      	cmp	r1, #0
  402c82:	bf08      	it	eq
  402c84:	2800      	cmpeq	r0, #0
  402c86:	bf1c      	itt	ne
  402c88:	f04f 31ff 	movne.w	r1, #4294967295
  402c8c:	f04f 30ff 	movne.w	r0, #4294967295
  402c90:	f000 b97a 	b.w	402f88 <__aeabi_idiv0>
  402c94:	f1ad 0c08 	sub.w	ip, sp, #8
  402c98:	e96d ce04 	strd	ip, lr, [sp, #-16]!
  402c9c:	f000 f806 	bl	402cac <__udivmoddi4>
  402ca0:	f8dd e004 	ldr.w	lr, [sp, #4]
  402ca4:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
  402ca8:	b004      	add	sp, #16
  402caa:	4770      	bx	lr

00402cac <__udivmoddi4>:
  402cac:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  402cb0:	468c      	mov	ip, r1
  402cb2:	460d      	mov	r5, r1
  402cb4:	4604      	mov	r4, r0
  402cb6:	9e08      	ldr	r6, [sp, #32]
  402cb8:	2b00      	cmp	r3, #0
  402cba:	d151      	bne.n	402d60 <__udivmoddi4+0xb4>
  402cbc:	428a      	cmp	r2, r1
  402cbe:	4617      	mov	r7, r2
  402cc0:	d96d      	bls.n	402d9e <__udivmoddi4+0xf2>
  402cc2:	fab2 fe82 	clz	lr, r2
  402cc6:	f1be 0f00 	cmp.w	lr, #0
  402cca:	d00b      	beq.n	402ce4 <__udivmoddi4+0x38>
  402ccc:	f1ce 0c20 	rsb	ip, lr, #32
  402cd0:	fa01 f50e 	lsl.w	r5, r1, lr
  402cd4:	fa20 fc0c 	lsr.w	ip, r0, ip
  402cd8:	fa02 f70e 	lsl.w	r7, r2, lr
  402cdc:	ea4c 0c05 	orr.w	ip, ip, r5
  402ce0:	fa00 f40e 	lsl.w	r4, r0, lr
  402ce4:	ea4f 4a17 	mov.w	sl, r7, lsr #16
  402ce8:	0c25      	lsrs	r5, r4, #16
  402cea:	fbbc f8fa 	udiv	r8, ip, sl
  402cee:	fa1f f987 	uxth.w	r9, r7
  402cf2:	fb0a cc18 	mls	ip, sl, r8, ip
  402cf6:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
  402cfa:	fb08 f309 	mul.w	r3, r8, r9
  402cfe:	42ab      	cmp	r3, r5
  402d00:	d90a      	bls.n	402d18 <__udivmoddi4+0x6c>
  402d02:	19ed      	adds	r5, r5, r7
  402d04:	f108 32ff 	add.w	r2, r8, #4294967295
  402d08:	f080 8123 	bcs.w	402f52 <__udivmoddi4+0x2a6>
  402d0c:	42ab      	cmp	r3, r5
  402d0e:	f240 8120 	bls.w	402f52 <__udivmoddi4+0x2a6>
  402d12:	f1a8 0802 	sub.w	r8, r8, #2
  402d16:	443d      	add	r5, r7
  402d18:	1aed      	subs	r5, r5, r3
  402d1a:	b2a4      	uxth	r4, r4
  402d1c:	fbb5 f0fa 	udiv	r0, r5, sl
  402d20:	fb0a 5510 	mls	r5, sl, r0, r5
  402d24:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
  402d28:	fb00 f909 	mul.w	r9, r0, r9
  402d2c:	45a1      	cmp	r9, r4
  402d2e:	d909      	bls.n	402d44 <__udivmoddi4+0x98>
  402d30:	19e4      	adds	r4, r4, r7
  402d32:	f100 33ff 	add.w	r3, r0, #4294967295
  402d36:	f080 810a 	bcs.w	402f4e <__udivmoddi4+0x2a2>
  402d3a:	45a1      	cmp	r9, r4
  402d3c:	f240 8107 	bls.w	402f4e <__udivmoddi4+0x2a2>
  402d40:	3802      	subs	r0, #2
  402d42:	443c      	add	r4, r7
  402d44:	eba4 0409 	sub.w	r4, r4, r9
  402d48:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
  402d4c:	2100      	movs	r1, #0
  402d4e:	2e00      	cmp	r6, #0
  402d50:	d061      	beq.n	402e16 <__udivmoddi4+0x16a>
  402d52:	fa24 f40e 	lsr.w	r4, r4, lr
  402d56:	2300      	movs	r3, #0
  402d58:	6034      	str	r4, [r6, #0]
  402d5a:	6073      	str	r3, [r6, #4]
  402d5c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  402d60:	428b      	cmp	r3, r1
  402d62:	d907      	bls.n	402d74 <__udivmoddi4+0xc8>
  402d64:	2e00      	cmp	r6, #0
  402d66:	d054      	beq.n	402e12 <__udivmoddi4+0x166>
  402d68:	2100      	movs	r1, #0
  402d6a:	e886 0021 	stmia.w	r6, {r0, r5}
  402d6e:	4608      	mov	r0, r1
  402d70:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  402d74:	fab3 f183 	clz	r1, r3
  402d78:	2900      	cmp	r1, #0
  402d7a:	f040 808e 	bne.w	402e9a <__udivmoddi4+0x1ee>
  402d7e:	42ab      	cmp	r3, r5
  402d80:	d302      	bcc.n	402d88 <__udivmoddi4+0xdc>
  402d82:	4282      	cmp	r2, r0
  402d84:	f200 80fa 	bhi.w	402f7c <__udivmoddi4+0x2d0>
  402d88:	1a84      	subs	r4, r0, r2
  402d8a:	eb65 0503 	sbc.w	r5, r5, r3
  402d8e:	2001      	movs	r0, #1
  402d90:	46ac      	mov	ip, r5
  402d92:	2e00      	cmp	r6, #0
  402d94:	d03f      	beq.n	402e16 <__udivmoddi4+0x16a>
  402d96:	e886 1010 	stmia.w	r6, {r4, ip}
  402d9a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  402d9e:	b912      	cbnz	r2, 402da6 <__udivmoddi4+0xfa>
  402da0:	2701      	movs	r7, #1
  402da2:	fbb7 f7f2 	udiv	r7, r7, r2
  402da6:	fab7 fe87 	clz	lr, r7
  402daa:	f1be 0f00 	cmp.w	lr, #0
  402dae:	d134      	bne.n	402e1a <__udivmoddi4+0x16e>
  402db0:	1beb      	subs	r3, r5, r7
  402db2:	0c3a      	lsrs	r2, r7, #16
  402db4:	fa1f fc87 	uxth.w	ip, r7
  402db8:	2101      	movs	r1, #1
  402dba:	fbb3 f8f2 	udiv	r8, r3, r2
  402dbe:	0c25      	lsrs	r5, r4, #16
  402dc0:	fb02 3318 	mls	r3, r2, r8, r3
  402dc4:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
  402dc8:	fb0c f308 	mul.w	r3, ip, r8
  402dcc:	42ab      	cmp	r3, r5
  402dce:	d907      	bls.n	402de0 <__udivmoddi4+0x134>
  402dd0:	19ed      	adds	r5, r5, r7
  402dd2:	f108 30ff 	add.w	r0, r8, #4294967295
  402dd6:	d202      	bcs.n	402dde <__udivmoddi4+0x132>
  402dd8:	42ab      	cmp	r3, r5
  402dda:	f200 80d1 	bhi.w	402f80 <__udivmoddi4+0x2d4>
  402dde:	4680      	mov	r8, r0
  402de0:	1aed      	subs	r5, r5, r3
  402de2:	b2a3      	uxth	r3, r4
  402de4:	fbb5 f0f2 	udiv	r0, r5, r2
  402de8:	fb02 5510 	mls	r5, r2, r0, r5
  402dec:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
  402df0:	fb0c fc00 	mul.w	ip, ip, r0
  402df4:	45a4      	cmp	ip, r4
  402df6:	d907      	bls.n	402e08 <__udivmoddi4+0x15c>
  402df8:	19e4      	adds	r4, r4, r7
  402dfa:	f100 33ff 	add.w	r3, r0, #4294967295
  402dfe:	d202      	bcs.n	402e06 <__udivmoddi4+0x15a>
  402e00:	45a4      	cmp	ip, r4
  402e02:	f200 80b8 	bhi.w	402f76 <__udivmoddi4+0x2ca>
  402e06:	4618      	mov	r0, r3
  402e08:	eba4 040c 	sub.w	r4, r4, ip
  402e0c:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
  402e10:	e79d      	b.n	402d4e <__udivmoddi4+0xa2>
  402e12:	4631      	mov	r1, r6
  402e14:	4630      	mov	r0, r6
  402e16:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  402e1a:	f1ce 0420 	rsb	r4, lr, #32
  402e1e:	fa05 f30e 	lsl.w	r3, r5, lr
  402e22:	fa07 f70e 	lsl.w	r7, r7, lr
  402e26:	fa20 f804 	lsr.w	r8, r0, r4
  402e2a:	0c3a      	lsrs	r2, r7, #16
  402e2c:	fa25 f404 	lsr.w	r4, r5, r4
  402e30:	ea48 0803 	orr.w	r8, r8, r3
  402e34:	fbb4 f1f2 	udiv	r1, r4, r2
  402e38:	ea4f 4518 	mov.w	r5, r8, lsr #16
  402e3c:	fb02 4411 	mls	r4, r2, r1, r4
  402e40:	fa1f fc87 	uxth.w	ip, r7
  402e44:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
  402e48:	fb01 f30c 	mul.w	r3, r1, ip
  402e4c:	42ab      	cmp	r3, r5
  402e4e:	fa00 f40e 	lsl.w	r4, r0, lr
  402e52:	d909      	bls.n	402e68 <__udivmoddi4+0x1bc>
  402e54:	19ed      	adds	r5, r5, r7
  402e56:	f101 30ff 	add.w	r0, r1, #4294967295
  402e5a:	f080 808a 	bcs.w	402f72 <__udivmoddi4+0x2c6>
  402e5e:	42ab      	cmp	r3, r5
  402e60:	f240 8087 	bls.w	402f72 <__udivmoddi4+0x2c6>
  402e64:	3902      	subs	r1, #2
  402e66:	443d      	add	r5, r7
  402e68:	1aeb      	subs	r3, r5, r3
  402e6a:	fa1f f588 	uxth.w	r5, r8
  402e6e:	fbb3 f0f2 	udiv	r0, r3, r2
  402e72:	fb02 3310 	mls	r3, r2, r0, r3
  402e76:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
  402e7a:	fb00 f30c 	mul.w	r3, r0, ip
  402e7e:	42ab      	cmp	r3, r5
  402e80:	d907      	bls.n	402e92 <__udivmoddi4+0x1e6>
  402e82:	19ed      	adds	r5, r5, r7
  402e84:	f100 38ff 	add.w	r8, r0, #4294967295
  402e88:	d26f      	bcs.n	402f6a <__udivmoddi4+0x2be>
  402e8a:	42ab      	cmp	r3, r5
  402e8c:	d96d      	bls.n	402f6a <__udivmoddi4+0x2be>
  402e8e:	3802      	subs	r0, #2
  402e90:	443d      	add	r5, r7
  402e92:	1aeb      	subs	r3, r5, r3
  402e94:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
  402e98:	e78f      	b.n	402dba <__udivmoddi4+0x10e>
  402e9a:	f1c1 0720 	rsb	r7, r1, #32
  402e9e:	fa22 f807 	lsr.w	r8, r2, r7
  402ea2:	408b      	lsls	r3, r1
  402ea4:	fa05 f401 	lsl.w	r4, r5, r1
  402ea8:	ea48 0303 	orr.w	r3, r8, r3
  402eac:	fa20 fe07 	lsr.w	lr, r0, r7
  402eb0:	ea4f 4c13 	mov.w	ip, r3, lsr #16
  402eb4:	40fd      	lsrs	r5, r7
  402eb6:	ea4e 0e04 	orr.w	lr, lr, r4
  402eba:	fbb5 f9fc 	udiv	r9, r5, ip
  402ebe:	ea4f 441e 	mov.w	r4, lr, lsr #16
  402ec2:	fb0c 5519 	mls	r5, ip, r9, r5
  402ec6:	fa1f f883 	uxth.w	r8, r3
  402eca:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
  402ece:	fb09 f408 	mul.w	r4, r9, r8
  402ed2:	42ac      	cmp	r4, r5
  402ed4:	fa02 f201 	lsl.w	r2, r2, r1
  402ed8:	fa00 fa01 	lsl.w	sl, r0, r1
  402edc:	d908      	bls.n	402ef0 <__udivmoddi4+0x244>
  402ede:	18ed      	adds	r5, r5, r3
  402ee0:	f109 30ff 	add.w	r0, r9, #4294967295
  402ee4:	d243      	bcs.n	402f6e <__udivmoddi4+0x2c2>
  402ee6:	42ac      	cmp	r4, r5
  402ee8:	d941      	bls.n	402f6e <__udivmoddi4+0x2c2>
  402eea:	f1a9 0902 	sub.w	r9, r9, #2
  402eee:	441d      	add	r5, r3
  402ef0:	1b2d      	subs	r5, r5, r4
  402ef2:	fa1f fe8e 	uxth.w	lr, lr
  402ef6:	fbb5 f0fc 	udiv	r0, r5, ip
  402efa:	fb0c 5510 	mls	r5, ip, r0, r5
  402efe:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
  402f02:	fb00 f808 	mul.w	r8, r0, r8
  402f06:	45a0      	cmp	r8, r4
  402f08:	d907      	bls.n	402f1a <__udivmoddi4+0x26e>
  402f0a:	18e4      	adds	r4, r4, r3
  402f0c:	f100 35ff 	add.w	r5, r0, #4294967295
  402f10:	d229      	bcs.n	402f66 <__udivmoddi4+0x2ba>
  402f12:	45a0      	cmp	r8, r4
  402f14:	d927      	bls.n	402f66 <__udivmoddi4+0x2ba>
  402f16:	3802      	subs	r0, #2
  402f18:	441c      	add	r4, r3
  402f1a:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
  402f1e:	eba4 0408 	sub.w	r4, r4, r8
  402f22:	fba0 8902 	umull	r8, r9, r0, r2
  402f26:	454c      	cmp	r4, r9
  402f28:	46c6      	mov	lr, r8
  402f2a:	464d      	mov	r5, r9
  402f2c:	d315      	bcc.n	402f5a <__udivmoddi4+0x2ae>
  402f2e:	d012      	beq.n	402f56 <__udivmoddi4+0x2aa>
  402f30:	b156      	cbz	r6, 402f48 <__udivmoddi4+0x29c>
  402f32:	ebba 030e 	subs.w	r3, sl, lr
  402f36:	eb64 0405 	sbc.w	r4, r4, r5
  402f3a:	fa04 f707 	lsl.w	r7, r4, r7
  402f3e:	40cb      	lsrs	r3, r1
  402f40:	431f      	orrs	r7, r3
  402f42:	40cc      	lsrs	r4, r1
  402f44:	6037      	str	r7, [r6, #0]
  402f46:	6074      	str	r4, [r6, #4]
  402f48:	2100      	movs	r1, #0
  402f4a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  402f4e:	4618      	mov	r0, r3
  402f50:	e6f8      	b.n	402d44 <__udivmoddi4+0x98>
  402f52:	4690      	mov	r8, r2
  402f54:	e6e0      	b.n	402d18 <__udivmoddi4+0x6c>
  402f56:	45c2      	cmp	sl, r8
  402f58:	d2ea      	bcs.n	402f30 <__udivmoddi4+0x284>
  402f5a:	ebb8 0e02 	subs.w	lr, r8, r2
  402f5e:	eb69 0503 	sbc.w	r5, r9, r3
  402f62:	3801      	subs	r0, #1
  402f64:	e7e4      	b.n	402f30 <__udivmoddi4+0x284>
  402f66:	4628      	mov	r0, r5
  402f68:	e7d7      	b.n	402f1a <__udivmoddi4+0x26e>
  402f6a:	4640      	mov	r0, r8
  402f6c:	e791      	b.n	402e92 <__udivmoddi4+0x1e6>
  402f6e:	4681      	mov	r9, r0
  402f70:	e7be      	b.n	402ef0 <__udivmoddi4+0x244>
  402f72:	4601      	mov	r1, r0
  402f74:	e778      	b.n	402e68 <__udivmoddi4+0x1bc>
  402f76:	3802      	subs	r0, #2
  402f78:	443c      	add	r4, r7
  402f7a:	e745      	b.n	402e08 <__udivmoddi4+0x15c>
  402f7c:	4608      	mov	r0, r1
  402f7e:	e708      	b.n	402d92 <__udivmoddi4+0xe6>
  402f80:	f1a8 0802 	sub.w	r8, r8, #2
  402f84:	443d      	add	r5, r7
  402f86:	e72b      	b.n	402de0 <__udivmoddi4+0x134>

00402f88 <__aeabi_idiv0>:
  402f88:	4770      	bx	lr
  402f8a:	bf00      	nop

00402f8c <__libc_init_array>:
  402f8c:	b570      	push	{r4, r5, r6, lr}
  402f8e:	4e0f      	ldr	r6, [pc, #60]	; (402fcc <__libc_init_array+0x40>)
  402f90:	4d0f      	ldr	r5, [pc, #60]	; (402fd0 <__libc_init_array+0x44>)
  402f92:	1b76      	subs	r6, r6, r5
  402f94:	10b6      	asrs	r6, r6, #2
  402f96:	bf18      	it	ne
  402f98:	2400      	movne	r4, #0
  402f9a:	d005      	beq.n	402fa8 <__libc_init_array+0x1c>
  402f9c:	3401      	adds	r4, #1
  402f9e:	f855 3b04 	ldr.w	r3, [r5], #4
  402fa2:	4798      	blx	r3
  402fa4:	42a6      	cmp	r6, r4
  402fa6:	d1f9      	bne.n	402f9c <__libc_init_array+0x10>
  402fa8:	4e0a      	ldr	r6, [pc, #40]	; (402fd4 <__libc_init_array+0x48>)
  402faa:	4d0b      	ldr	r5, [pc, #44]	; (402fd8 <__libc_init_array+0x4c>)
  402fac:	1b76      	subs	r6, r6, r5
  402fae:	f000 fce5 	bl	40397c <_init>
  402fb2:	10b6      	asrs	r6, r6, #2
  402fb4:	bf18      	it	ne
  402fb6:	2400      	movne	r4, #0
  402fb8:	d006      	beq.n	402fc8 <__libc_init_array+0x3c>
  402fba:	3401      	adds	r4, #1
  402fbc:	f855 3b04 	ldr.w	r3, [r5], #4
  402fc0:	4798      	blx	r3
  402fc2:	42a6      	cmp	r6, r4
  402fc4:	d1f9      	bne.n	402fba <__libc_init_array+0x2e>
  402fc6:	bd70      	pop	{r4, r5, r6, pc}
  402fc8:	bd70      	pop	{r4, r5, r6, pc}
  402fca:	bf00      	nop
  402fcc:	00403988 	.word	0x00403988
  402fd0:	00403988 	.word	0x00403988
  402fd4:	00403990 	.word	0x00403990
  402fd8:	00403988 	.word	0x00403988

00402fdc <register_fini>:
  402fdc:	4b02      	ldr	r3, [pc, #8]	; (402fe8 <register_fini+0xc>)
  402fde:	b113      	cbz	r3, 402fe6 <register_fini+0xa>
  402fe0:	4802      	ldr	r0, [pc, #8]	; (402fec <register_fini+0x10>)
  402fe2:	f000 b805 	b.w	402ff0 <atexit>
  402fe6:	4770      	bx	lr
  402fe8:	00000000 	.word	0x00000000
  402fec:	00402ffd 	.word	0x00402ffd

00402ff0 <atexit>:
  402ff0:	2300      	movs	r3, #0
  402ff2:	4601      	mov	r1, r0
  402ff4:	461a      	mov	r2, r3
  402ff6:	4618      	mov	r0, r3
  402ff8:	f000 b81e 	b.w	403038 <__register_exitproc>

00402ffc <__libc_fini_array>:
  402ffc:	b538      	push	{r3, r4, r5, lr}
  402ffe:	4c0a      	ldr	r4, [pc, #40]	; (403028 <__libc_fini_array+0x2c>)
  403000:	4d0a      	ldr	r5, [pc, #40]	; (40302c <__libc_fini_array+0x30>)
  403002:	1b64      	subs	r4, r4, r5
  403004:	10a4      	asrs	r4, r4, #2
  403006:	d00a      	beq.n	40301e <__libc_fini_array+0x22>
  403008:	f104 4380 	add.w	r3, r4, #1073741824	; 0x40000000
  40300c:	3b01      	subs	r3, #1
  40300e:	eb05 0583 	add.w	r5, r5, r3, lsl #2
  403012:	3c01      	subs	r4, #1
  403014:	f855 3904 	ldr.w	r3, [r5], #-4
  403018:	4798      	blx	r3
  40301a:	2c00      	cmp	r4, #0
  40301c:	d1f9      	bne.n	403012 <__libc_fini_array+0x16>
  40301e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  403022:	f000 bcb5 	b.w	403990 <_fini>
  403026:	bf00      	nop
  403028:	004039a0 	.word	0x004039a0
  40302c:	0040399c 	.word	0x0040399c

00403030 <__retarget_lock_acquire_recursive>:
  403030:	4770      	bx	lr
  403032:	bf00      	nop

00403034 <__retarget_lock_release_recursive>:
  403034:	4770      	bx	lr
  403036:	bf00      	nop

00403038 <__register_exitproc>:
  403038:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  40303c:	4d2c      	ldr	r5, [pc, #176]	; (4030f0 <__register_exitproc+0xb8>)
  40303e:	4606      	mov	r6, r0
  403040:	6828      	ldr	r0, [r5, #0]
  403042:	4698      	mov	r8, r3
  403044:	460f      	mov	r7, r1
  403046:	4691      	mov	r9, r2
  403048:	f7ff fff2 	bl	403030 <__retarget_lock_acquire_recursive>
  40304c:	4b29      	ldr	r3, [pc, #164]	; (4030f4 <__register_exitproc+0xbc>)
  40304e:	681c      	ldr	r4, [r3, #0]
  403050:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
  403054:	2b00      	cmp	r3, #0
  403056:	d03e      	beq.n	4030d6 <__register_exitproc+0x9e>
  403058:	685a      	ldr	r2, [r3, #4]
  40305a:	2a1f      	cmp	r2, #31
  40305c:	dc1c      	bgt.n	403098 <__register_exitproc+0x60>
  40305e:	f102 0e01 	add.w	lr, r2, #1
  403062:	b176      	cbz	r6, 403082 <__register_exitproc+0x4a>
  403064:	eb03 0182 	add.w	r1, r3, r2, lsl #2
  403068:	2401      	movs	r4, #1
  40306a:	f8c1 9088 	str.w	r9, [r1, #136]	; 0x88
  40306e:	f8d3 0188 	ldr.w	r0, [r3, #392]	; 0x188
  403072:	4094      	lsls	r4, r2
  403074:	4320      	orrs	r0, r4
  403076:	2e02      	cmp	r6, #2
  403078:	f8c3 0188 	str.w	r0, [r3, #392]	; 0x188
  40307c:	f8c1 8108 	str.w	r8, [r1, #264]	; 0x108
  403080:	d023      	beq.n	4030ca <__register_exitproc+0x92>
  403082:	3202      	adds	r2, #2
  403084:	f8c3 e004 	str.w	lr, [r3, #4]
  403088:	6828      	ldr	r0, [r5, #0]
  40308a:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
  40308e:	f7ff ffd1 	bl	403034 <__retarget_lock_release_recursive>
  403092:	2000      	movs	r0, #0
  403094:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  403098:	4b17      	ldr	r3, [pc, #92]	; (4030f8 <__register_exitproc+0xc0>)
  40309a:	b30b      	cbz	r3, 4030e0 <__register_exitproc+0xa8>
  40309c:	f44f 70c8 	mov.w	r0, #400	; 0x190
  4030a0:	f3af 8000 	nop.w
  4030a4:	4603      	mov	r3, r0
  4030a6:	b1d8      	cbz	r0, 4030e0 <__register_exitproc+0xa8>
  4030a8:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
  4030ac:	6002      	str	r2, [r0, #0]
  4030ae:	2100      	movs	r1, #0
  4030b0:	6041      	str	r1, [r0, #4]
  4030b2:	460a      	mov	r2, r1
  4030b4:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
  4030b8:	f04f 0e01 	mov.w	lr, #1
  4030bc:	f8c0 1188 	str.w	r1, [r0, #392]	; 0x188
  4030c0:	f8c0 118c 	str.w	r1, [r0, #396]	; 0x18c
  4030c4:	2e00      	cmp	r6, #0
  4030c6:	d0dc      	beq.n	403082 <__register_exitproc+0x4a>
  4030c8:	e7cc      	b.n	403064 <__register_exitproc+0x2c>
  4030ca:	f8d3 118c 	ldr.w	r1, [r3, #396]	; 0x18c
  4030ce:	430c      	orrs	r4, r1
  4030d0:	f8c3 418c 	str.w	r4, [r3, #396]	; 0x18c
  4030d4:	e7d5      	b.n	403082 <__register_exitproc+0x4a>
  4030d6:	f504 73a6 	add.w	r3, r4, #332	; 0x14c
  4030da:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
  4030de:	e7bb      	b.n	403058 <__register_exitproc+0x20>
  4030e0:	6828      	ldr	r0, [r5, #0]
  4030e2:	f7ff ffa7 	bl	403034 <__retarget_lock_release_recursive>
  4030e6:	f04f 30ff 	mov.w	r0, #4294967295
  4030ea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  4030ee:	bf00      	nop
  4030f0:	20000448 	.word	0x20000448
  4030f4:	00403978 	.word	0x00403978
  4030f8:	00000000 	.word	0x00000000

004030fc <IO_SENSOR>:
	...
  40310c:	00000001 400e1000 0000000a 00004000     .......@.....@..
  40311c:	0000002e 00000001 400e1000 0000000a     ...........@....
  40312c:	00002000 0000002d 00000001 400e1400     . ..-..........@
  40313c:	0000000c 00000001 00000060 00000001     ........`.......
  40314c:	400e1400 0000000c 80000000 0000007f     ...@............
  40315c:	00000001 400e1600 0000000d 00000008     .......@........
  40316c:	00000083 00000001 400e1600 0000000d     ...........@....
  40317c:	00000001 00000080 00000001 400e1600     ...............@
  40318c:	0000000d 00000002 00000081 00000001     ................
  40319c:	400e1600 0000000d 00000004 00000082     ...@............
  4031ac:	00000001 400e1200 0000000b 08000000     .......@........
  4031bc:	0000005b 00000001 400e1200 0000000b     [..........@....
  4031cc:	00000001 00000040 00000001 400e1200     ....@..........@
  4031dc:	0000000b 04000000 0000005a 00000001     ........Z.......
  4031ec:	400e1200 0000000b 80000000 0000005f     ...@........_...
  4031fc:	00000001 400e1200 0000000b 40000000     .......@.......@
  40320c:	0000005e 00000001 400e1200 0000000b     ^..........@....
  40321c:	20000000 0000005d 00000001 400e1200     ... ]..........@
  40322c:	0000000b 00002000 0000004d 00000001     ..... ..M.......
  40323c:	400e1000 0000000a 00000001 00000020     ...@........ ...
  40324c:	00000001 400e1000 0000000a 00000002     .......@........
  40325c:	00000021 00000001 400e0e00 00000009     !..........@....
  40326c:	00100000 00000014 00000001 400e0e00     ...............@
  40327c:	00000009 00020000 00000011 00000001     ................
  40328c:	400e1600 0000000d 00000010 00000084     ...@............
  40329c:	00000001 400e0e00 00000009 00080000     .......@........
  4032ac:	00000013 00000001 400e1600 0000000d     ...........@....
  4032bc:	00000020 00000085 00000001 400e1000      ..............@
  4032cc:	0000000a 00000004 00000022 00000001     ........".......
  4032dc:	400e0e00 00000009 00040000 00000012     ...@............
  4032ec:	00000001 400e0e00 00000009 00200000     .......@...... .
  4032fc:	00000015 00000001 400e1000 0000000a     ...........@....
  40330c:	00000008 00000023 00000001 400e1400     ....#..........@
  40331c:	0000000c 04000000 0000007a 00000001     ........z.......
  40332c:	400e1400 0000000c 40000000 0000007e     ...@.......@~...
  40333c:	00000001 400e0e00 00000009 00800000     .......@........
  40334c:	00000017 00000001 400e0e00 00000009     ...........@....
  40335c:	00004000 0000000e 00000001 400e1400     .@.............@
  40336c:	0000000c 00200000 00000075 00000001     ...... .u.......
  40337c:	400e1400 0000000c 02000000 00000079     ...@........y...
  40338c:	00000001 400e0e00 00000009 00010000     .......@........
  40339c:	00000010 00000001 400e1400 0000000c     ...........@....
  4033ac:	00100000 00000074 00000001 400e0e00     ....t..........@
  4033bc:	00000009 00008000 0000000f 00000001     ................
  4033cc:	400e1200 0000000b 00000080 00000047     ...@........G...
  4033dc:	00000001 400e1400 0000000c 08000000     .......@........
  4033ec:	0000007b 00000001 400e0e00 00000009     {..........@....
  4033fc:	00400000 00000016 00000001 400e1200     ..@............@
  40340c:	0000000b 00000002 00000041 00000001     ........A.......
  40341c:	400e1200 0000000b 00000004 00000042     ...@........B...
  40342c:	00000001 400e1200 0000000b 00000008     .......@........
  40343c:	00000043 00000001 400e1200 0000000b     C..........@....
  40344c:	00000010 00000044 00000001 400e0e00     ....D..........@
  40345c:	00000009 00002000 0000000d 00000001     ..... ..........
  40346c:	400e1200 0000000b 00000020 00000045     ...@.... ...E...
  40347c:	00000001 400e1200 0000000b 00000040     .......@....@...
  40348c:	00000046 00000001 400e1400 0000000c     F..........@....
  40349c:	01000000 00000078 00000001 400e0e00     ....x..........@
  4034ac:	00000009 01000000 00000018 00000001     ................
  4034bc:	400e1400 0000000c 00800000 00000077     ...@........w...
  4034cc:	00000001 400e0e00 00000009 02000000     .......@........
  4034dc:	00000019 00000001 400e1400 0000000c     ...........@....
  4034ec:	00400000 00000076 00000001 400e1400     ..@.v..........@
  4034fc:	0000000c 00080000 00000073 00000001     ........s.......
  40350c:	400e0e00 00000009 00001000 0000000c     ...@............
  40351c:	00000001 400e1400 0000000c 00040000     .......@........
  40352c:	00000072 00000001 400e0e00 00000009     r..........@....
  40353c:	00000800 0000000b 00000001 400e1400     ...............@
  40354c:	0000000c 00002000 0000006d 00000001     ..... ..m.......
  40355c:	400e1200 0000000b 00000200 00000049     ...@........I...
  40356c:	00000001 400e1400 0000000c 00004000     .......@.....@..
  40357c:	0000006e 00000001 400e1400 0000000c     n..........@....
  40358c:	10000000 0000007c 00000001 400e1200     ....|..........@
  40359c:	0000000b 10000000 0000005c 00000001     ........\.......
  4035ac:	400e1000 0000000a 00000040 00000026     ...@....@...&...
  4035bc:	00000001 400e0e00 00000009 00000020     .......@.... ...
  4035cc:	00000005 00000001 400e1400 0000000c     ...........@....
  4035dc:	00020000 00000071 00000001 400e1400     ....q..........@
  4035ec:	0000000c 00010000 00000070 00000001     ........p.......
  4035fc:	400e1200 0000000b 00000100 00000048     ...@........H...
  40360c:	00000001 400e1400 0000000c 00001000     .......@........
  40361c:	0000006c 00000001 400e1200 0000000b     l..........@....
  40362c:	00000800 0000004b 00000001 400e0e00     ....K..........@
  40363c:	00000009 00000004 00000002 00000001     ................
  40364c:	400e1000 0000000a 00001000 0000002c     ...@........,...
  40365c:	00000001 400e1200 0000000b 00004000     .......@.....@..
  40366c:	0000004e 00000001 400e1400 0000000c     N..........@....
  40367c:	00000080 00000067 00000001 400e1000     ....g..........@
  40368c:	0000000a 00000080 00000027 00000001     ........'.......
  40369c:	400e1200 0000000b 00000400 0000004a     ...@........J...
  4036ac:	00000001 400e1400 0000000c 00000800     .......@........
  4036bc:	0000006b 00000001 400e0e00 00000009     k..........@....
  4036cc:	00000002 00000001 00000001 400e1200     ...............@
  4036dc:	0000000b 00010000 00000050 00000001     ........P.......
  4036ec:	400e1400 0000000c 00000400 0000006a     ...@........j...
  4036fc:	00000001 400e0e00 00000009 00000001     .......@........
  40370c:	00000000 00000001 400e1200 0000000b     ...........@....
  40371c:	00020000 00000051 00000001 400e1200     ....Q..........@
  40372c:	0000000b 00080000 00000053 00000001     ........S.......
  40373c:	400e1000 0000000a 00000010 00000024     ...@........$...
  40374c:	00000001 400e1400 0000000c 00008000     .......@........
  40375c:	0000006f 00000001 400e1400 0000000c     o..........@....
  40376c:	20000000 0000007d 00000001 400e1000     ... }..........@
  40377c:	0000000a 00000020 00000025 00000001     .... ...%.......
  40378c:	400e1400 0000000c 00000200 00000069     ...@........i...
  40379c:	00000001 400e1200 0000000b 00040000     .......@........
  4037ac:	00000052 00000001 400e1400 0000000c     R..........@....
  4037bc:	00000100 00000068 00000001 400e0e00     ....h..........@
  4037cc:	00000009 00000040 00000006 00000001     ....@...........
  4037dc:	400e1200 0000000b 00100000 00000054     ...@........T...
  4037ec:	00000001 400e1200 0000000b 00400000     .......@......@.
  4037fc:	00000056 00000001 400e1400 0000000c     V..........@....
  40380c:	00000040 00000066 00000001 400e1200     @...f..........@
  40381c:	0000000b 00200000 00000055 00000001     ...... .U.......
  40382c:	400e1200 0000000b 01000000 00000058     ...@........X...
  40383c:	00000001 400e1400 0000000c 00000020     .......@.... ...
  40384c:	00000065 00000001 400e1400 0000000c     e..........@....
  40385c:	00000010 00000064 00000001 400e1200     ....d..........@
  40386c:	0000000b 00800000 00000057 00000001     ........W.......
  40387c:	400e1400 0000000c 00000004 00000062     ...@........b...
  40388c:	00000001 400e1400 0000000c 00000008     .......@........
  40389c:	00000063 00000001 400e1400 0000000c     c..........@....
  4038ac:	00000002 00000061 00000001 400e1200     ....a..........@
  4038bc:	0000000b 02000000 00000059 00000000     ........Y.......

004038cc <SSD1311_CFG_SCRIPT>:
  4038cc:	08020000 71022a02 72020003 79020003     .....*.q...r...y
  4038dc:	7f028102 6002d502 7802d902 1002da02     .......`...x....
  4038ec:	4002db02 0302dc02 78027804 06020902     ...@.....x.x....
  4038fc:	01022802 06020202 05040c02 00000101     .(..............

0040390c <can_bit_time>:
  40390c:	02020308 02094b03 43020303 0303030a     .....K.....C....
  40391c:	040b4603 48040303 0404030c 040d4304     .F.....H.....C..
  40392c:	4d040404 0504040e 040f4004 43040505     ...M.....@.....C
  40393c:	05050510 06114504 47040505 06060512     .....E.....G....
  40394c:	06134304 44040606 06060714 08154604     .C.....D.....F..
  40395c:	47040606 07070716 08174404 46040708     ...G.....D.....F
  40396c:	08080718 08194304 44040808              .....C.....D

00403978 <_global_impure_ptr>:
  403978:	20000020                                 .. 

0040397c <_init>:
  40397c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40397e:	bf00      	nop
  403980:	bcf8      	pop	{r3, r4, r5, r6, r7}
  403982:	bc08      	pop	{r3}
  403984:	469e      	mov	lr, r3
  403986:	4770      	bx	lr

00403988 <__init_array_start>:
  403988:	00402fdd 	.word	0x00402fdd

0040398c <__frame_dummy_init_array_entry>:
  40398c:	0040011d                                ..@.

00403990 <_fini>:
  403990:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  403992:	bf00      	nop
  403994:	bcf8      	pop	{r3, r4, r5, r6, r7}
  403996:	bc08      	pop	{r3}
  403998:	469e      	mov	lr, r3
  40399a:	4770      	bx	lr

0040399c <__fini_array_start>:
  40399c:	004000f9 	.word	0x004000f9

Disassembly of section .relocate:

20000000 <portable_delay_cycles>:
RAMFUNC
void portable_delay_cycles(unsigned long n)
{
	UNUSED(n);

	__asm (
20000000:	f3bf 8f5f 	dmb	sy
20000004:	3801      	subs	r0, #1
20000006:	d1fb      	bne.n	20000000 <portable_delay_cycles>
20000008:	4770      	bx	lr
	...

2000000c <uxCriticalNesting>:
2000000c:	aaaa aaaa                                   ....

20000010 <xFreeBytesRemaining>:
20000010:	a000 0000                                   ....

20000014 <xNextTaskUnblockTime>:
20000014:	ffff ffff                                   ....

20000018 <g_interrupt_enabled>:
20000018:	0001 0000                                   ....

2000001c <SystemCoreClock>:
2000001c:	0900 003d                                   ..=.

20000020 <impure_data>:
20000020:	0000 0000 030c 2000 0374 2000 03dc 2000     ....... t.. ... 
	...
200000c8:	0001 0000 0000 0000 330e abcd 1234 e66d     .........3..4.m.
200000d8:	deec 0005 000b 0000 0000 0000 0000 0000     ................
	...

20000448 <__atexit_recursive_mutex>:
20000448:	a7bc 2000                                   ... 
